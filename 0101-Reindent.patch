From 85704145ee1a83fccc1be59ca30d690d756acaad Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Tue, 20 May 2014 14:40:51 -0400
Subject: [PATCH 101/119] Reindent

I don't like the GNU coding style and I'm not sure why I chose it.
This commit changes things over to use 8 space tabs and 'if () {'
style braces.
---
 src/client/ply-boot-client.c                       | 1085 ++++---
 src/client/ply-boot-client.h                       |  224 +-
 src/client/plymouth.c                              | 1940 ++++++------
 src/libply-splash-core/ply-boot-splash-plugin.h    |   96 +-
 src/libply-splash-core/ply-boot-splash.c           |  881 +++---
 src/libply-splash-core/ply-boot-splash.h           |   18 +-
 src/libply-splash-core/ply-device-manager.c        | 1109 ++++---
 src/libply-splash-core/ply-device-manager.h        |   22 +-
 src/libply-splash-core/ply-keyboard.c              |  693 +++--
 src/libply-splash-core/ply-keyboard.h              |   54 +-
 src/libply-splash-core/ply-pixel-buffer.c          |  945 +++---
 src/libply-splash-core/ply-pixel-buffer.h          |   10 +-
 src/libply-splash-core/ply-pixel-display.c         |  119 +-
 src/libply-splash-core/ply-pixel-display.h         |   22 +-
 src/libply-splash-core/ply-renderer-plugin.h       |   48 +-
 src/libply-splash-core/ply-renderer.c              |  391 ++-
 src/libply-splash-core/ply-renderer.h              |   28 +-
 src/libply-splash-core/ply-seat.c                  |  381 ++-
 src/libply-splash-core/ply-seat.h                  |    6 +-
 src/libply-splash-core/ply-terminal.c              | 1174 ++++----
 src/libply-splash-core/ply-terminal.h              |   56 +-
 src/libply-splash-core/ply-text-display.c          |  189 +-
 src/libply-splash-core/ply-text-display.h          |   34 +-
 src/libply-splash-core/ply-text-progress-bar.c     |  300 +-
 src/libply-splash-core/ply-text-progress-bar.h     |   10 +-
 src/libply-splash-core/ply-text-step-bar.c         |  139 +-
 src/libply-splash-core/ply-text-step-bar.h         |    4 +-
 src/libply-splash-graphics/ply-animation.c         |  463 ++-
 src/libply-splash-graphics/ply-animation.h         |    8 +-
 src/libply-splash-graphics/ply-entry.c             |  306 +-
 src/libply-splash-graphics/ply-entry.h             |    6 +-
 src/libply-splash-graphics/ply-image.c             |  275 +-
 src/libply-splash-graphics/ply-image.h             |   15 +-
 src/libply-splash-graphics/ply-label-plugin.h      |   58 +-
 src/libply-splash-graphics/ply-label.c             |  322 +-
 src/libply-splash-graphics/ply-label.h             |   25 +-
 .../ply-progress-animation.c                       |  599 ++--
 .../ply-progress-animation.h                       |   12 +-
 src/libply-splash-graphics/ply-progress-bar.c      |  119 +-
 src/libply-splash-graphics/ply-throbber.c          |  414 ++-
 src/libply-splash-graphics/ply-throbber.h          |    2 +-
 src/libply/ply-array.c                             |  130 +-
 src/libply/ply-array.h                             |   10 +-
 src/libply/ply-bitarray.c                          |   13 +-
 src/libply/ply-bitarray.h                          |    4 +-
 src/libply/ply-buffer.c                            |  221 +-
 src/libply/ply-buffer.h                            |   11 +-
 src/libply/ply-command-parser.c                    | 1126 ++++---
 src/libply/ply-command-parser.h                    |   43 +-
 src/libply/ply-event-loop.c                        | 1520 +++++-----
 src/libply/ply-event-loop.h                        |   67 +-
 src/libply/ply-hashtable.c                         |  286 +-
 src/libply/ply-hashtable.h                         |   22 +-
 src/libply/ply-key-file.c                          |  426 ++-
 src/libply/ply-key-file.h                          |    8 +-
 src/libply/ply-list.c                              |  349 ++-
 src/libply/ply-list.h                              |   11 +-
 src/libply/ply-logger.c                            |  603 ++--
 src/libply/ply-logger.h                            |   95 +-
 src/libply/ply-progress.c                          |  437 ++-
 src/libply/ply-progress.h                          |   24 +-
 src/libply/ply-rectangle.c                         |  377 ++-
 src/libply/ply-rectangle.h                         |  107 +-
 src/libply/ply-region.c                            |  727 +++--
 src/libply/ply-terminal-session.c                  |  725 +++--
 src/libply/ply-terminal-session.h                  |   44 +-
 src/libply/ply-trigger.c                           |  153 +-
 src/libply/ply-trigger.h                           |   18 +-
 src/libply/ply-utils.c                             | 1146 ++++----
 src/libply/ply-utils.h                             |   42 +-
 src/main.c                                         | 3093 +++++++++-----------
 src/plugins/controls/label/plugin.c                |  457 ++-
 src/plugins/renderers/drm/plugin.c                 | 1535 +++++-----
 src/plugins/renderers/drm/ply-renderer-driver.h    |   41 +-
 .../renderers/drm/ply-renderer-generic-driver.c    |  370 ++-
 src/plugins/renderers/frame-buffer/plugin.c        |  888 +++---
 src/plugins/renderers/x11/plugin.c                 |  659 ++---
 src/plugins/splash/details/plugin.c                |  408 ++-
 src/plugins/splash/fade-throbber/plugin.c          | 1258 ++++----
 src/plugins/splash/script/plugin.c                 |  546 ++--
 src/plugins/splash/script/script-debug.c           |   48 +-
 src/plugins/splash/script/script-debug.h           |    6 +-
 src/plugins/splash/script/script-execute.c         | 1052 ++++---
 src/plugins/splash/script/script-execute.h         |    8 +-
 src/plugins/splash/script/script-lib-image.c       |  424 ++-
 src/plugins/splash/script/script-lib-image.h       |    6 +-
 src/plugins/splash/script/script-lib-math.c        |  129 +-
 src/plugins/splash/script/script-lib-math.h        |    2 +-
 src/plugins/splash/script/script-lib-plymouth.c    |  453 +--
 src/plugins/splash/script/script-lib-plymouth.h    |   34 +-
 src/plugins/splash/script/script-lib-sprite.c      | 1243 ++++----
 src/plugins/splash/script/script-lib-sprite.h      |   50 +-
 src/plugins/splash/script/script-lib-string.c      |  128 +-
 src/plugins/splash/script/script-lib-string.h      |    2 +-
 src/plugins/splash/script/script-object.c          |  671 +++--
 src/plugins/splash/script/script-object.h          |   40 +-
 src/plugins/splash/script/script-parse.c           | 1582 +++++-----
 src/plugins/splash/script/script-scan.c            |  609 ++--
 src/plugins/splash/script/script-scan.h            |   88 +-
 src/plugins/splash/script/script.c                 |  136 +-
 src/plugins/splash/script/script.h                 |  299 +-
 src/plugins/splash/space-flares/plugin.c           | 2526 ++++++++--------
 src/plugins/splash/text/plugin.c                   |  714 +++--
 src/plugins/splash/throbgress/plugin.c             | 1050 ++++---
 src/plugins/splash/tribar/plugin.c                 |  714 +++--
 src/plugins/splash/two-step/plugin.c               | 1877 ++++++------
 src/ply-boot-server.c                              | 1201 ++++----
 src/ply-boot-server.h                              |  152 +-
 src/upstart-bridge/ply-upstart-monitor.c           | 1634 +++++------
 src/upstart-bridge/ply-upstart-monitor.h           |   52 +-
 src/upstart-bridge/plymouth-upstart-bridge.c       |  304 +-
 src/viewer/plymouth-log-viewer.c                   |  491 ++--
 112 files changed, 23464 insertions(+), 24863 deletions(-)

diff --git a/src/client/ply-boot-client.c b/src/client/ply-boot-client.c
index 3480676..9cd129b 100644
--- a/src/client/ply-boot-client.c
+++ b/src/client/ply-boot-client.c
@@ -38,27 +38,27 @@
 
 struct _ply_boot_client
 {
-  ply_event_loop_t *loop;
-  ply_fd_watch_t *daemon_can_take_request_watch;
-  ply_fd_watch_t *daemon_has_reply_watch;
-  ply_list_t *requests_to_send;
-  ply_list_t *requests_waiting_for_replies;
-  int socket_fd;
+        ply_event_loop_t                    *loop;
+        ply_fd_watch_t                      *daemon_can_take_request_watch;
+        ply_fd_watch_t                      *daemon_has_reply_watch;
+        ply_list_t                          *requests_to_send;
+        ply_list_t                          *requests_waiting_for_replies;
+        int                                  socket_fd;
 
-  ply_boot_client_disconnect_handler_t disconnect_handler;
-  void *disconnect_handler_user_data;
+        ply_boot_client_disconnect_handler_t disconnect_handler;
+        void                                *disconnect_handler_user_data;
 
-  uint32_t is_connected : 1;
+        uint32_t                             is_connected : 1;
 };
 
 typedef struct
 {
-  ply_boot_client_t *client;
-  char *command;
-  char *argument;
-  ply_boot_client_response_handler_t handler;
-  ply_boot_client_response_handler_t failed_handler;
-  void *user_data;
+        ply_boot_client_t                 *client;
+        char                              *command;
+        char                              *argument;
+        ply_boot_client_response_handler_t handler;
+        ply_boot_client_response_handler_t failed_handler;
+        void                              *user_data;
 } ply_boot_client_request_t;
 
 static void ply_boot_client_cancel_request (ply_boot_client_t         *client,
@@ -67,320 +67,297 @@ static void ply_boot_client_cancel_request (ply_boot_client_t         *client,
 ply_boot_client_t *
 ply_boot_client_new (void)
 {
-  ply_boot_client_t *client;
+        ply_boot_client_t *client;
 
-  client = calloc (1, sizeof (ply_boot_client_t));
-  client->daemon_can_take_request_watch = NULL;
-  client->daemon_has_reply_watch = NULL;
-  client->requests_to_send = ply_list_new ();
-  client->requests_waiting_for_replies = ply_list_new ();
-  client->loop = NULL;
-  client->is_connected = false;
-  client->disconnect_handler = NULL;
-  client->disconnect_handler_user_data = NULL;
+        client = calloc (1, sizeof(ply_boot_client_t));
+        client->daemon_can_take_request_watch = NULL;
+        client->daemon_has_reply_watch = NULL;
+        client->requests_to_send = ply_list_new ();
+        client->requests_waiting_for_replies = ply_list_new ();
+        client->loop = NULL;
+        client->is_connected = false;
+        client->disconnect_handler = NULL;
+        client->disconnect_handler_user_data = NULL;
 
-  return client;
+        return client;
 }
 
 static void
 ply_boot_client_cancel_unsent_requests (ply_boot_client_t *client)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (ply_list_get_length (client->requests_to_send) == 0)
-      return;
+        if (ply_list_get_length (client->requests_to_send) == 0)
+                return;
 
-  node = ply_list_get_first_node (client->requests_to_send);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_boot_client_request_t *request;
+        node = ply_list_get_first_node (client->requests_to_send);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_boot_client_request_t *request;
 
-      request = (ply_boot_client_request_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (client->requests_to_send, node);
+                request = (ply_boot_client_request_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (client->requests_to_send, node);
 
-      ply_boot_client_cancel_request (client, request);
-      ply_list_remove_node (client->requests_to_send, node);
+                ply_boot_client_cancel_request (client, request);
+                ply_list_remove_node (client->requests_to_send, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  if (client->daemon_can_take_request_watch != NULL)
-    {
-      assert (client->loop != NULL);
+        if (client->daemon_can_take_request_watch != NULL) {
+                assert (client->loop != NULL);
 
-      ply_event_loop_stop_watching_fd (client->loop, 
-                                       client->daemon_can_take_request_watch);
-      client->daemon_can_take_request_watch = NULL;
-    }
+                ply_event_loop_stop_watching_fd (client->loop,
+                                                 client->daemon_can_take_request_watch);
+                client->daemon_can_take_request_watch = NULL;
+        }
 }
 
 static void
 ply_boot_client_cancel_requests_waiting_for_replies (ply_boot_client_t *client)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (ply_list_get_length (client->requests_waiting_for_replies) == 0)
-      return;
+        if (ply_list_get_length (client->requests_waiting_for_replies) == 0)
+                return;
 
-  node = ply_list_get_first_node (client->requests_waiting_for_replies);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_boot_client_request_t *request;
+        node = ply_list_get_first_node (client->requests_waiting_for_replies);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_boot_client_request_t *request;
 
-      request = (ply_boot_client_request_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (client->requests_waiting_for_replies, node);
+                request = (ply_boot_client_request_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (client->requests_waiting_for_replies, node);
 
-      ply_boot_client_cancel_request (client, request);
-      ply_list_remove_node (client->requests_waiting_for_replies, node);
+                ply_boot_client_cancel_request (client, request);
+                ply_list_remove_node (client->requests_waiting_for_replies, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  if (client->daemon_has_reply_watch != NULL)
-    {
-      assert (client->loop != NULL);
+        if (client->daemon_has_reply_watch != NULL) {
+                assert (client->loop != NULL);
 
-      ply_event_loop_stop_watching_fd (client->loop, 
-                                       client->daemon_has_reply_watch);
-      client->daemon_has_reply_watch = NULL;
-    }
+                ply_event_loop_stop_watching_fd (client->loop,
+                                                 client->daemon_has_reply_watch);
+                client->daemon_has_reply_watch = NULL;
+        }
 }
 
 static void
 ply_boot_client_cancel_requests (ply_boot_client_t *client)
 {
-  ply_boot_client_cancel_unsent_requests (client);
-  ply_boot_client_cancel_requests_waiting_for_replies (client);
+        ply_boot_client_cancel_unsent_requests (client);
+        ply_boot_client_cancel_requests_waiting_for_replies (client);
 }
 
 void
 ply_boot_client_free (ply_boot_client_t *client)
 {
-  if (client == NULL)
-    return;
+        if (client == NULL)
+                return;
 
-  ply_boot_client_cancel_requests (client);
+        ply_boot_client_cancel_requests (client);
 
-  ply_list_free (client->requests_to_send);
-  ply_list_free (client->requests_waiting_for_replies);
+        ply_list_free (client->requests_to_send);
+        ply_list_free (client->requests_waiting_for_replies);
 
-  free (client);
+        free (client);
 }
 
 bool
-ply_boot_client_connect (ply_boot_client_t *client,
-                         ply_boot_client_disconnect_handler_t  disconnect_handler,
-                         void                                 *user_data)
-{
-  assert (client != NULL);
-  assert (!client->is_connected);
-  assert (client->disconnect_handler == NULL);
-  assert (client->disconnect_handler_user_data == NULL);
-
-  client->socket_fd =
-      ply_connect_to_unix_socket (PLY_BOOT_PROTOCOL_TRIMMED_ABSTRACT_SOCKET_PATH,
-                                  PLY_UNIX_SOCKET_TYPE_TRIMMED_ABSTRACT);
-
-  if (client->socket_fd < 0)
-    {
-      ply_trace ("could not connect to " PLY_BOOT_PROTOCOL_TRIMMED_ABSTRACT_SOCKET_PATH ": %m");
-      ply_trace ("trying old fallback path " PLY_BOOT_PROTOCOL_OLD_ABSTRACT_SOCKET_PATH);
-
-      client->socket_fd =
-          ply_connect_to_unix_socket (PLY_BOOT_PROTOCOL_OLD_ABSTRACT_SOCKET_PATH,
-                                      PLY_UNIX_SOCKET_TYPE_ABSTRACT);
-      if (client->socket_fd < 0)
-        {
-          ply_trace ("could not connect to " PLY_BOOT_PROTOCOL_OLD_ABSTRACT_SOCKET_PATH ": %m");
-          return false;
+ply_boot_client_connect (ply_boot_client_t                   *client,
+                         ply_boot_client_disconnect_handler_t disconnect_handler,
+                         void                                *user_data)
+{
+        assert (client != NULL);
+        assert (!client->is_connected);
+        assert (client->disconnect_handler == NULL);
+        assert (client->disconnect_handler_user_data == NULL);
+
+        client->socket_fd =
+                ply_connect_to_unix_socket (PLY_BOOT_PROTOCOL_TRIMMED_ABSTRACT_SOCKET_PATH,
+                                            PLY_UNIX_SOCKET_TYPE_TRIMMED_ABSTRACT);
+
+        if (client->socket_fd < 0) {
+                ply_trace ("could not connect to " PLY_BOOT_PROTOCOL_TRIMMED_ABSTRACT_SOCKET_PATH ": %m");
+                ply_trace ("trying old fallback path " PLY_BOOT_PROTOCOL_OLD_ABSTRACT_SOCKET_PATH);
+
+                client->socket_fd =
+                        ply_connect_to_unix_socket (PLY_BOOT_PROTOCOL_OLD_ABSTRACT_SOCKET_PATH,
+                                                    PLY_UNIX_SOCKET_TYPE_ABSTRACT);
+                if (client->socket_fd < 0) {
+                        ply_trace ("could not connect to " PLY_BOOT_PROTOCOL_OLD_ABSTRACT_SOCKET_PATH ": %m");
+                        return false;
+                }
         }
-    }
 
-  client->disconnect_handler = disconnect_handler;
-  client->disconnect_handler_user_data = user_data;
+        client->disconnect_handler = disconnect_handler;
+        client->disconnect_handler_user_data = user_data;
 
-  client->is_connected = true;
-  return true;
+        client->is_connected = true;
+        return true;
 }
 
 static ply_boot_client_request_t *
-ply_boot_client_request_new (ply_boot_client_t                  *client,
-                             const char                         *request_command,
-                             const char                         *request_argument,
-                             ply_boot_client_response_handler_t  handler,
-                             ply_boot_client_response_handler_t  failed_handler,
-                             void                               *user_data)
+ply_boot_client_request_new (ply_boot_client_t                 *client,
+                             const char                        *request_command,
+                             const char                        *request_argument,
+                             ply_boot_client_response_handler_t handler,
+                             ply_boot_client_response_handler_t failed_handler,
+                             void                              *user_data)
 {
-  ply_boot_client_request_t *request;
+        ply_boot_client_request_t *request;
 
-  assert (client != NULL);
-  assert (request_command != NULL);
+        assert (client != NULL);
+        assert (request_command != NULL);
 
-  request = calloc (1, sizeof (ply_boot_client_request_t));
-  request->client = client;
-  request->command = strdup (request_command);
-  if (request_argument != NULL)
-    request->argument = strdup (request_argument);
-  request->handler = handler;
-  request->failed_handler = failed_handler;
-  request->user_data = user_data;
+        request = calloc (1, sizeof(ply_boot_client_request_t));
+        request->client = client;
+        request->command = strdup (request_command);
+        if (request_argument != NULL)
+                request->argument = strdup (request_argument);
+        request->handler = handler;
+        request->failed_handler = failed_handler;
+        request->user_data = user_data;
 
-  return request;
+        return request;
 }
 
 static void
 ply_boot_client_request_free (ply_boot_client_request_t *request)
 {
-  if (request == NULL)
-    return;
-  free (request->command);
-  if (request->argument != NULL)
-    free (request->argument);
-  free (request);
+        if (request == NULL)
+                return;
+        free (request->command);
+        if (request->argument != NULL)
+                free (request->argument);
+        free (request);
 }
 
 static void
 ply_boot_client_cancel_request (ply_boot_client_t         *client,
                                 ply_boot_client_request_t *request)
 {
-  if (request->failed_handler != NULL)
-    request->failed_handler (request->user_data, request->client);
+        if (request->failed_handler != NULL)
+                request->failed_handler (request->user_data, request->client);
 
-  ply_boot_client_request_free (request);
+        ply_boot_client_request_free (request);
 }
 
 static void
 ply_boot_client_process_incoming_replies (ply_boot_client_t *client)
 {
-  ply_list_node_t *request_node;
-  ply_boot_client_request_t *request;
-  bool processed_reply;
-  uint8_t byte[2] = "";
-  uint32_t size;
-
-  assert (client != NULL);
-
-  processed_reply = false;
-  if (ply_list_get_length (client->requests_waiting_for_replies) == 0)
-    {
-      ply_error ("received unexpected response from boot status daemon");
-      return;
-    }
-
-  request_node = ply_list_get_first_node (client->requests_waiting_for_replies);
-  assert (request_node != NULL);
-
-  request = (ply_boot_client_request_t *) ply_list_node_get_data (request_node);
-  assert (request != NULL);
-
-  if (!ply_read (client->socket_fd, byte, sizeof (uint8_t)))
-    goto out;
-
-  if (memcmp (byte, PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK, sizeof (uint8_t)) == 0)
-    {
-      if (request->handler != NULL)
-        request->handler (request->user_data, client);
-    }
-  else if (memcmp (byte, PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ANSWER, sizeof (uint8_t)) == 0)
-    {
-      char *answer;
-
-      if (!ply_read_uint32 (client->socket_fd, &size))
-        goto out;
-      
-      answer = malloc ((size+1) * sizeof(char));
-      if (size > 0)
-        {
-          if (!ply_read (client->socket_fd, answer, size))
-            {
-              free (answer);
-              goto out;
-            }
-        }
+        ply_list_node_t *request_node;
+        ply_boot_client_request_t *request;
+        bool processed_reply;
+        uint8_t byte[2] = "";
+        uint32_t size;
 
-      answer[size] = '\0';
-      if (request->handler != NULL)
-        ((ply_boot_client_answer_handler_t) request->handler) (request->user_data, answer, client);
-      free(answer);
-    }
-  else if (memcmp (byte, PLY_BOOT_PROTOCOL_RESPONSE_TYPE_MULTIPLE_ANSWERS, sizeof (uint8_t)) == 0)
-    {
-      ply_array_t *array;
-      char **answers;
-      char *answer;
-      char *p;
-      char *q;
-      uint8_t i;
-
-      array = NULL;
-      answers = NULL;
-
-      if (!ply_read_uint32 (client->socket_fd, &size))
-        goto out;
-
-      assert (size > 0);
-
-      answer = malloc (size);
-
-      if (!ply_read (client->socket_fd, answer, size))
-        {
-          free (answer);
-          goto out;
-        }
+        assert (client != NULL);
 
-      array = ply_array_new (PLY_ARRAY_ELEMENT_TYPE_POINTER);
-
-      p = answer;
-      q = p;
-      for (i = 0; i < size; i++, q++)
-        {
-          if (*q == '\0')
-            {
-              ply_array_add_pointer_element (array, strdup (p));
-              p = q + 1;
-            }
+        processed_reply = false;
+        if (ply_list_get_length (client->requests_waiting_for_replies) == 0) {
+                ply_error ("received unexpected response from boot status daemon");
+                return;
         }
-      free (answer);
-
-      answers = (char **) ply_array_steal_pointer_elements (array);
-      ply_array_free (array);
-
-      if (request->handler != NULL)
-        ((ply_boot_client_multiple_answers_handler_t) request->handler) (request->user_data, (const char * const *) answers, client);
 
-      ply_free_string_array (answers);
-    }
-  else if (memcmp (byte, PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NO_ANSWER, sizeof (uint8_t)) == 0)
-    {
-      if (request->handler != NULL)
-        ((ply_boot_client_answer_handler_t) request->handler) (request->user_data, NULL, client);
-    }
-  else
-    goto out;
+        request_node = ply_list_get_first_node (client->requests_waiting_for_replies);
+        assert (request_node != NULL);
+
+        request = (ply_boot_client_request_t *) ply_list_node_get_data (request_node);
+        assert (request != NULL);
+
+        if (!ply_read (client->socket_fd, byte, sizeof(uint8_t)))
+                goto out;
+
+        if (memcmp (byte, PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK, sizeof(uint8_t)) == 0) {
+                if (request->handler != NULL)
+                        request->handler (request->user_data, client);
+        } else if (memcmp (byte, PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ANSWER, sizeof(uint8_t)) == 0) {
+                char *answer;
+
+                if (!ply_read_uint32 (client->socket_fd, &size))
+                        goto out;
+
+                answer = malloc ((size + 1) * sizeof(char));
+                if (size > 0) {
+                        if (!ply_read (client->socket_fd, answer, size)) {
+                                free (answer);
+                                goto out;
+                        }
+                }
+
+                answer[size] = '\0';
+                if (request->handler != NULL)
+                        ((ply_boot_client_answer_handler_t) request->handler)(request->user_data, answer, client);
+                free (answer);
+        } else if (memcmp (byte, PLY_BOOT_PROTOCOL_RESPONSE_TYPE_MULTIPLE_ANSWERS, sizeof(uint8_t)) == 0) {
+                ply_array_t *array;
+                char **answers;
+                char *answer;
+                char *p;
+                char *q;
+                uint8_t i;
+
+                array = NULL;
+                answers = NULL;
+
+                if (!ply_read_uint32 (client->socket_fd, &size))
+                        goto out;
+
+                assert (size > 0);
+
+                answer = malloc (size);
+
+                if (!ply_read (client->socket_fd, answer, size)) {
+                        free (answer);
+                        goto out;
+                }
+
+                array = ply_array_new (PLY_ARRAY_ELEMENT_TYPE_POINTER);
+
+                p = answer;
+                q = p;
+                for (i = 0; i < size; i++, q++) {
+                        if (*q == '\0') {
+                                ply_array_add_pointer_element (array, strdup (p));
+                                p = q + 1;
+                        }
+                }
+                free (answer);
+
+                answers = (char **) ply_array_steal_pointer_elements (array);
+                ply_array_free (array);
+
+                if (request->handler != NULL)
+                        ((ply_boot_client_multiple_answers_handler_t) request->handler)(request->user_data, (const char *const *) answers, client);
+
+                ply_free_string_array (answers);
+        } else if (memcmp (byte, PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NO_ANSWER, sizeof(uint8_t)) == 0) {
+                if (request->handler != NULL)
+                        ((ply_boot_client_answer_handler_t) request->handler)(request->user_data, NULL, client);
+        } else {
+                goto out;
+        }
 
-  processed_reply = true;
+        processed_reply = true;
 
 out:
-  if (!processed_reply)
-    {
-      if (request->failed_handler != NULL)
-        request->failed_handler (request->user_data, client);
-    }
-
-  ply_list_remove_node (client->requests_waiting_for_replies, request_node);
-
-  if (ply_list_get_length (client->requests_waiting_for_replies) == 0)
-    {
-      if (client->daemon_has_reply_watch != NULL)
-        {
-          assert (client->loop != NULL);
-          ply_event_loop_stop_watching_fd (client->loop,
-                                           client->daemon_has_reply_watch);
-          client->daemon_has_reply_watch = NULL;
+        if (!processed_reply)
+                if (request->failed_handler != NULL)
+                        request->failed_handler (request->user_data, client);
+
+        ply_list_remove_node (client->requests_waiting_for_replies, request_node);
+
+        if (ply_list_get_length (client->requests_waiting_for_replies) == 0) {
+                if (client->daemon_has_reply_watch != NULL) {
+                        assert (client->loop != NULL);
+                        ply_event_loop_stop_watching_fd (client->loop,
+                                                         client->daemon_has_reply_watch);
+                        client->daemon_has_reply_watch = NULL;
+                }
         }
-    }
 }
 
 static char *
@@ -388,485 +365,471 @@ ply_boot_client_get_request_string (ply_boot_client_t         *client,
                                     ply_boot_client_request_t *request,
                                     size_t                    *request_size)
 {
-  char *request_string;
+        char *request_string;
 
-  assert (client != NULL);
-  assert (request != NULL);
-  assert (request_size != NULL);
+        assert (client != NULL);
+        assert (request != NULL);
+        assert (request_size != NULL);
 
-  assert (request->command != NULL);
+        assert (request->command != NULL);
 
-  if (request->argument == NULL)
-    {
-      request_string = strdup (request->command);
-      *request_size = strlen (request_string) + 1;
-      return request_string;
-    }
+        if (request->argument == NULL) {
+                request_string = strdup (request->command);
+                *request_size = strlen (request_string) + 1;
+                return request_string;
+        }
 
-  assert (strlen (request->argument) <= UCHAR_MAX);
+        assert (strlen (request->argument) <= UCHAR_MAX);
 
-  request_string = NULL;
-  asprintf (&request_string, "%s\002%c%s", request->command, 
-            (char) (strlen (request->argument) + 1), request->argument);
-  *request_size = strlen (request_string) + 1;
+        request_string = NULL;
+        asprintf (&request_string, "%s\002%c%s", request->command,
+                  (char) (strlen (request->argument) + 1), request->argument);
+        *request_size = strlen (request_string) + 1;
 
-  return request_string;
+        return request_string;
 }
 
 static bool
 ply_boot_client_send_request (ply_boot_client_t         *client,
                               ply_boot_client_request_t *request)
 {
-  char *request_string;
-  size_t request_size;
-
-  assert (client != NULL);
-  assert (request != NULL);
-
-  request_string = ply_boot_client_get_request_string (client, request,
-                                                       &request_size);
-  if (!ply_write (client->socket_fd, request_string, request_size))
-    {
-      free (request_string);
-      ply_boot_client_cancel_request (client, request);
-      return false;
-    }
-  free (request_string);
-
-  if (client->daemon_has_reply_watch == NULL)
-    {
-      assert (ply_list_get_length (client->requests_waiting_for_replies) == 0);
-      client->daemon_has_reply_watch = 
-          ply_event_loop_watch_fd (client->loop, client->socket_fd,
-                                   PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                                   (ply_event_handler_t)
-                                   ply_boot_client_process_incoming_replies,
-                                   NULL, client);
-    }
-  return true;
+        char *request_string;
+        size_t request_size;
+
+        assert (client != NULL);
+        assert (request != NULL);
+
+        request_string = ply_boot_client_get_request_string (client, request,
+                                                             &request_size);
+        if (!ply_write (client->socket_fd, request_string, request_size)) {
+                free (request_string);
+                ply_boot_client_cancel_request (client, request);
+                return false;
+        }
+        free (request_string);
+
+        if (client->daemon_has_reply_watch == NULL) {
+                assert (ply_list_get_length (client->requests_waiting_for_replies) == 0);
+                client->daemon_has_reply_watch =
+                        ply_event_loop_watch_fd (client->loop, client->socket_fd,
+                                                 PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                                 (ply_event_handler_t)
+                                                 ply_boot_client_process_incoming_replies,
+                                                 NULL, client);
+        }
+        return true;
 }
 
 static void
 ply_boot_client_process_pending_requests (ply_boot_client_t *client)
 {
-  ply_list_node_t *request_node;
-  ply_boot_client_request_t *request;
+        ply_list_node_t *request_node;
+        ply_boot_client_request_t *request;
 
-  assert (ply_list_get_length (client->requests_to_send) != 0);
-  assert (client->daemon_can_take_request_watch != NULL);
+        assert (ply_list_get_length (client->requests_to_send) != 0);
+        assert (client->daemon_can_take_request_watch != NULL);
 
-  request_node = ply_list_get_first_node (client->requests_to_send);
-  assert (request_node != NULL);
+        request_node = ply_list_get_first_node (client->requests_to_send);
+        assert (request_node != NULL);
 
-  request = (ply_boot_client_request_t *) ply_list_node_get_data (request_node);
-  assert (request != NULL);
+        request = (ply_boot_client_request_t *) ply_list_node_get_data (request_node);
+        assert (request != NULL);
 
-  ply_list_remove_node (client->requests_to_send, request_node);
+        ply_list_remove_node (client->requests_to_send, request_node);
 
-  if (ply_boot_client_send_request (client, request))
-    ply_list_append_data (client->requests_waiting_for_replies, request);
+        if (ply_boot_client_send_request (client, request))
+                ply_list_append_data (client->requests_waiting_for_replies, request);
 
-  if (ply_list_get_length (client->requests_to_send) == 0)
-    {
-      if (client->daemon_has_reply_watch != NULL)
-        {
-          assert (client->loop != NULL);
+        if (ply_list_get_length (client->requests_to_send) == 0) {
+                if (client->daemon_has_reply_watch != NULL) {
+                        assert (client->loop != NULL);
 
-          ply_event_loop_stop_watching_fd (client->loop,
-                                           client->daemon_can_take_request_watch);
-          client->daemon_can_take_request_watch = NULL;
+                        ply_event_loop_stop_watching_fd (client->loop,
+                                                         client->daemon_can_take_request_watch);
+                        client->daemon_can_take_request_watch = NULL;
+                }
         }
-    }
 }
 
 static void
-ply_boot_client_queue_request (ply_boot_client_t                  *client,
-                               const char                         *request_command,
-                               const char                         *request_argument,
-                               ply_boot_client_response_handler_t  handler,
-                               ply_boot_client_response_handler_t  failed_handler,
-                               void                               *user_data)
-{
-  assert (client != NULL);
-  assert (client->loop != NULL);
-  assert (request_command != NULL);
-  assert (request_argument == NULL || strlen (request_argument) <= UCHAR_MAX);
-
-  if (client->daemon_can_take_request_watch == NULL &&
-      client->socket_fd >= 0)
-    {
-      assert (ply_list_get_length (client->requests_to_send) == 0);
-      client->daemon_can_take_request_watch = 
-          ply_event_loop_watch_fd (client->loop, client->socket_fd,
-                                   PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA,
-                                   (ply_event_handler_t)
-                                   ply_boot_client_process_pending_requests,
-                                   NULL, client);
-    }
-
-  if (!client->is_connected)
-    {
-      if (failed_handler != NULL)
-        {
-          failed_handler (user_data, client);
+ply_boot_client_queue_request (ply_boot_client_t                 *client,
+                               const char                        *request_command,
+                               const char                        *request_argument,
+                               ply_boot_client_response_handler_t handler,
+                               ply_boot_client_response_handler_t failed_handler,
+                               void                              *user_data)
+{
+        assert (client != NULL);
+        assert (client->loop != NULL);
+        assert (request_command != NULL);
+        assert (request_argument == NULL || strlen (request_argument) <= UCHAR_MAX);
+
+        if (client->daemon_can_take_request_watch == NULL &&
+            client->socket_fd >= 0) {
+                assert (ply_list_get_length (client->requests_to_send) == 0);
+                client->daemon_can_take_request_watch =
+                        ply_event_loop_watch_fd (client->loop, client->socket_fd,
+                                                 PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA,
+                                                 (ply_event_handler_t)
+                                                 ply_boot_client_process_pending_requests,
+                                                 NULL, client);
         }
-    }
-  else
-    {
-      ply_boot_client_request_t *request;
 
-      request = ply_boot_client_request_new (client, request_command,
-                                             request_argument,
-                                             handler, failed_handler, user_data);
-      ply_list_append_data (client->requests_to_send, request);
-    }
+        if (!client->is_connected) {
+                if (failed_handler != NULL)
+                        failed_handler (user_data, client);
+        } else {
+                ply_boot_client_request_t *request;
+
+                request = ply_boot_client_request_new (client, request_command,
+                                                       request_argument,
+                                                       handler, failed_handler, user_data);
+                ply_list_append_data (client->requests_to_send, request);
+        }
 }
 
 void
-ply_boot_client_ping_daemon (ply_boot_client_t                  *client,
-                             ply_boot_client_response_handler_t  handler,
-                             ply_boot_client_response_handler_t  failed_handler,
-                             void                               *user_data)
+ply_boot_client_ping_daemon (ply_boot_client_t                 *client,
+                             ply_boot_client_response_handler_t handler,
+                             ply_boot_client_response_handler_t failed_handler,
+                             void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PING,
-                                 NULL, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PING,
+                                       NULL, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_update_daemon (ply_boot_client_t                  *client,
-                               const char                         *status,
-                               ply_boot_client_response_handler_t  handler,
-                               ply_boot_client_response_handler_t  failed_handler,
-                               void                               *user_data)
+ply_boot_client_update_daemon (ply_boot_client_t                 *client,
+                               const char                        *status,
+                               ply_boot_client_response_handler_t handler,
+                               ply_boot_client_response_handler_t failed_handler,
+                               void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_UPDATE,
-                                 status, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_UPDATE,
+                                       status, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_change_mode (ply_boot_client_t                  *client,
-                             const char                         *new_mode,
-                             ply_boot_client_response_handler_t  handler,
-                             ply_boot_client_response_handler_t  failed_handler,
-                             void                               *user_data)
+ply_boot_client_change_mode (ply_boot_client_t                 *client,
+                             const char                        *new_mode,
+                             ply_boot_client_response_handler_t handler,
+                             ply_boot_client_response_handler_t failed_handler,
+                             void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_CHANGE_MODE,
-                                 new_mode, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_CHANGE_MODE,
+                                       new_mode, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_system_update (ply_boot_client_t                  *client,
-                               const char                         *progress,
-                               ply_boot_client_response_handler_t  handler,
-                               ply_boot_client_response_handler_t  failed_handler,
-                               void                               *user_data)
+ply_boot_client_system_update (ply_boot_client_t                 *client,
+                               const char                        *progress,
+                               ply_boot_client_response_handler_t handler,
+                               ply_boot_client_response_handler_t failed_handler,
+                               void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SYSTEM_UPDATE,
-                                 progress, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SYSTEM_UPDATE,
+                                       progress, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_to_change_root (ply_boot_client_t                  *client,
-                                            const char                         *root_dir,
-                                            ply_boot_client_response_handler_t  handler,
-                                            ply_boot_client_response_handler_t  failed_handler,
-                                            void                               *user_data)
+ply_boot_client_tell_daemon_to_change_root (ply_boot_client_t                 *client,
+                                            const char                        *root_dir,
+                                            ply_boot_client_response_handler_t handler,
+                                            ply_boot_client_response_handler_t failed_handler,
+                                            void                              *user_data)
 {
-  assert (client != NULL);
-  assert (root_dir != NULL);
+        assert (client != NULL);
+        assert (root_dir != NULL);
 
-  ply_boot_client_queue_request(client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_NEWROOT,
-                                root_dir, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_NEWROOT,
+                                       root_dir, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_to_display_message (ply_boot_client_t                  *client,
-                                                const char                         *message,
-                                                ply_boot_client_response_handler_t  handler,
-                                                ply_boot_client_response_handler_t  failed_handler,
-                                                void                               *user_data)
+ply_boot_client_tell_daemon_to_display_message (ply_boot_client_t                 *client,
+                                                const char                        *message,
+                                                ply_boot_client_response_handler_t handler,
+                                                ply_boot_client_response_handler_t failed_handler,
+                                                void                              *user_data)
 {
-  assert (client != NULL);
-  assert (message != NULL);
+        assert (client != NULL);
+        assert (message != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SHOW_MESSAGE,
-                                 message, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SHOW_MESSAGE,
+                                       message, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_to_hide_message (ply_boot_client_t                  *client,
-                                             const char                         *message,
-                                             ply_boot_client_response_handler_t  handler,
-                                             ply_boot_client_response_handler_t  failed_handler,
-                                             void                               *user_data)
+ply_boot_client_tell_daemon_to_hide_message (ply_boot_client_t                 *client,
+                                             const char                        *message,
+                                             ply_boot_client_response_handler_t handler,
+                                             ply_boot_client_response_handler_t failed_handler,
+                                             void                              *user_data)
 {
-  assert (client != NULL);
-  assert (message != NULL);
+        assert (client != NULL);
+        assert (message != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HIDE_MESSAGE,
-                                 message, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HIDE_MESSAGE,
+                                       message, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_system_is_initialized (ply_boot_client_t                  *client,
-                                                   ply_boot_client_response_handler_t  handler,
-                                                   ply_boot_client_response_handler_t  failed_handler,
-                                                   void                               *user_data)
+ply_boot_client_tell_daemon_system_is_initialized (ply_boot_client_t                 *client,
+                                                   ply_boot_client_response_handler_t handler,
+                                                   ply_boot_client_response_handler_t failed_handler,
+                                                   void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client,
-                                 PLY_BOOT_PROTOCOL_REQUEST_TYPE_SYSTEM_INITIALIZED,
-                                 NULL, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client,
+                                       PLY_BOOT_PROTOCOL_REQUEST_TYPE_SYSTEM_INITIALIZED,
+                                       NULL, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_ask_daemon_for_password (ply_boot_client_t                  *client,
+ply_boot_client_ask_daemon_for_password (ply_boot_client_t                 *client,
 
-                                         const char *prompt,
-                                         ply_boot_client_answer_handler_t    handler,
-                                         ply_boot_client_response_handler_t  failed_handler,
-                                         void                               *user_data)
+                                         const char                        *prompt,
+                                         ply_boot_client_answer_handler_t   handler,
+                                         ply_boot_client_response_handler_t failed_handler,
+                                         void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PASSWORD,
-                                 prompt, (ply_boot_client_response_handler_t)
-                                 handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PASSWORD,
+                                       prompt, (ply_boot_client_response_handler_t)
+                                       handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_ask_daemon_for_cached_passwords (ply_boot_client_t                  *client,
-                                                 ply_boot_client_multiple_answers_handler_t    handler,
-                                                 ply_boot_client_response_handler_t  failed_handler,
-                                                 void                               *user_data)
+ply_boot_client_ask_daemon_for_cached_passwords (ply_boot_client_t                         *client,
+                                                 ply_boot_client_multiple_answers_handler_t handler,
+                                                 ply_boot_client_response_handler_t         failed_handler,
+                                                 void                                      *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_CACHED_PASSWORD,
-                                 NULL, (ply_boot_client_response_handler_t)
-                                 handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_CACHED_PASSWORD,
+                                       NULL, (ply_boot_client_response_handler_t)
+                                       handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_ask_daemon_question     (ply_boot_client_t                    *client,
-                                         const char                            *prompt,
-                                         ply_boot_client_answer_handler_t       handler,
-                                         ply_boot_client_response_handler_t     failed_handler,
-                                         void                                  *user_data)
+ply_boot_client_ask_daemon_question (ply_boot_client_t                 *client,
+                                     const char                        *prompt,
+                                     ply_boot_client_answer_handler_t   handler,
+                                     ply_boot_client_response_handler_t failed_handler,
+                                     void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_QUESTION,
-                                 prompt, (ply_boot_client_response_handler_t)
-                                 handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_QUESTION,
+                                       prompt, (ply_boot_client_response_handler_t)
+                                       handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_ask_daemon_to_watch_for_keystroke (ply_boot_client_t           *client,
-                                         const char                            *keys,
-                                         ply_boot_client_answer_handler_t       handler,
-                                         ply_boot_client_response_handler_t     failed_handler,
-                                         void                                  *user_data)
+ply_boot_client_ask_daemon_to_watch_for_keystroke (ply_boot_client_t                 *client,
+                                                   const char                        *keys,
+                                                   ply_boot_client_answer_handler_t   handler,
+                                                   ply_boot_client_response_handler_t failed_handler,
+                                                   void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_KEYSTROKE,
-                                 keys, (ply_boot_client_response_handler_t)
-                                 handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_KEYSTROKE,
+                                       keys, (ply_boot_client_response_handler_t)
+                                       handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_ask_daemon_to_ignore_keystroke (ply_boot_client_t                  *client,
-                                         const char                                *keys,
-                                         ply_boot_client_answer_handler_t           handler,
-                                         ply_boot_client_response_handler_t         failed_handler,
-                                         void                                      *user_data)
+ply_boot_client_ask_daemon_to_ignore_keystroke (ply_boot_client_t                 *client,
+                                                const char                        *keys,
+                                                ply_boot_client_answer_handler_t   handler,
+                                                ply_boot_client_response_handler_t failed_handler,
+                                                void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_KEYSTROKE_REMOVE,
-                                 keys, (ply_boot_client_response_handler_t)
-                                 handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_KEYSTROKE_REMOVE,
+                                       keys, (ply_boot_client_response_handler_t)
+                                       handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_to_show_splash (ply_boot_client_t                  *client,
-                                            ply_boot_client_response_handler_t  handler,
-                                            ply_boot_client_response_handler_t  failed_handler,
-                                            void                               *user_data)
+ply_boot_client_tell_daemon_to_show_splash (ply_boot_client_t                 *client,
+                                            ply_boot_client_response_handler_t handler,
+                                            ply_boot_client_response_handler_t failed_handler,
+                                            void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SHOW_SPLASH,
-                                 NULL, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SHOW_SPLASH,
+                                       NULL, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_to_hide_splash (ply_boot_client_t                  *client,
-                                            ply_boot_client_response_handler_t  handler,
-                                            ply_boot_client_response_handler_t  failed_handler,
-                                            void                               *user_data)
+ply_boot_client_tell_daemon_to_hide_splash (ply_boot_client_t                 *client,
+                                            ply_boot_client_response_handler_t handler,
+                                            ply_boot_client_response_handler_t failed_handler,
+                                            void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HIDE_SPLASH,
-                                 NULL, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HIDE_SPLASH,
+                                       NULL, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_to_deactivate (ply_boot_client_t                  *client,
-                                           ply_boot_client_response_handler_t  handler,
-                                           ply_boot_client_response_handler_t  failed_handler,
-                                           void                               *user_data)
+ply_boot_client_tell_daemon_to_deactivate (ply_boot_client_t                 *client,
+                                           ply_boot_client_response_handler_t handler,
+                                           ply_boot_client_response_handler_t failed_handler,
+                                           void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_DEACTIVATE,
-                                 NULL, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_DEACTIVATE,
+                                       NULL, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_to_reactivate (ply_boot_client_t                  *client,
-                                           ply_boot_client_response_handler_t  handler,
-                                           ply_boot_client_response_handler_t  failed_handler,
-                                           void                               *user_data)
+ply_boot_client_tell_daemon_to_reactivate (ply_boot_client_t                 *client,
+                                           ply_boot_client_response_handler_t handler,
+                                           ply_boot_client_response_handler_t failed_handler,
+                                           void                              *user_data)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_REACTIVATE,
-                                 NULL, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_REACTIVATE,
+                                       NULL, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_to_quit (ply_boot_client_t                  *client,
-                                     bool                                retain_splash,
-                                     ply_boot_client_response_handler_t  handler,
-                                     ply_boot_client_response_handler_t  failed_handler,
-                                     void                               *user_data)
+ply_boot_client_tell_daemon_to_quit (ply_boot_client_t                 *client,
+                                     bool                               retain_splash,
+                                     ply_boot_client_response_handler_t handler,
+                                     ply_boot_client_response_handler_t failed_handler,
+                                     void                              *user_data)
 {
-  char arg[2] = "";
+        char arg[2] = "";
 
-  assert (client != NULL);
+        assert (client != NULL);
 
-  arg[0] = (char) (retain_splash != false);
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_QUIT,
-                                 arg, handler, failed_handler, user_data);
+        arg[0] = (char) (retain_splash != false);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_QUIT,
+                                       arg, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_to_progress_pause (ply_boot_client_t                  *client,
-                                               ply_boot_client_response_handler_t  handler,
-                                               ply_boot_client_response_handler_t  failed_handler,
-                                               void                               *user_data)
+ply_boot_client_tell_daemon_to_progress_pause (ply_boot_client_t                 *client,
+                                               ply_boot_client_response_handler_t handler,
+                                               ply_boot_client_response_handler_t failed_handler,
+                                               void                              *user_data)
 {
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PROGRESS_PAUSE,
-                                 NULL, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PROGRESS_PAUSE,
+                                       NULL, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_to_progress_unpause (ply_boot_client_t                  *client,
-                                                 ply_boot_client_response_handler_t  handler,
-                                                 ply_boot_client_response_handler_t  failed_handler,
-                                                 void                               *user_data)
+ply_boot_client_tell_daemon_to_progress_unpause (ply_boot_client_t                 *client,
+                                                 ply_boot_client_response_handler_t handler,
+                                                 ply_boot_client_response_handler_t failed_handler,
+                                                 void                              *user_data)
 {
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PROGRESS_UNPAUSE,
-                                 NULL, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PROGRESS_UNPAUSE,
+                                       NULL, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_ask_daemon_has_active_vt (ply_boot_client_t                  *client,
-                                          ply_boot_client_response_handler_t  handler,
-                                          ply_boot_client_response_handler_t  failed_handler,
-                                          void                               *user_data)
+ply_boot_client_ask_daemon_has_active_vt (ply_boot_client_t                 *client,
+                                          ply_boot_client_response_handler_t handler,
+                                          ply_boot_client_response_handler_t failed_handler,
+                                          void                              *user_data)
 {
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HAS_ACTIVE_VT,
-                                 NULL, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HAS_ACTIVE_VT,
+                                       NULL, handler, failed_handler, user_data);
 }
 
 void
-ply_boot_client_tell_daemon_about_error (ply_boot_client_t                  *client,
-                                         ply_boot_client_response_handler_t  handler,
-                                         ply_boot_client_response_handler_t  failed_handler,
-                                         void                               *user_data)
+ply_boot_client_tell_daemon_about_error (ply_boot_client_t                 *client,
+                                         ply_boot_client_response_handler_t handler,
+                                         ply_boot_client_response_handler_t failed_handler,
+                                         void                              *user_data)
 {
-  ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_ERROR,
-                                 NULL, handler, failed_handler, user_data);
+        ply_boot_client_queue_request (client, PLY_BOOT_PROTOCOL_REQUEST_TYPE_ERROR,
+                                       NULL, handler, failed_handler, user_data);
 }
 
 void
 ply_boot_client_flush (ply_boot_client_t *client)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  while (ply_list_get_length (client->requests_to_send) > 0)
-    {
-      ply_event_loop_process_pending_events (client->loop);
-    }
+        while (ply_list_get_length (client->requests_to_send) > 0) {
+                ply_event_loop_process_pending_events (client->loop);
+        }
 }
 
 void
 ply_boot_client_disconnect (ply_boot_client_t *client)
 {
-  assert (client != NULL);
+        assert (client != NULL);
 
-  close (client->socket_fd);
-  client->socket_fd = -1;
-  client->is_connected = false;
+        close (client->socket_fd);
+        client->socket_fd = -1;
+        client->is_connected = false;
 }
 
 static void
 ply_boot_client_detach_from_event_loop (ply_boot_client_t *client)
 {
-  assert (client != NULL);
-  ply_trace ("detaching from event loop");
-  client->loop = NULL;
-  client->daemon_can_take_request_watch = NULL;
-  client->daemon_has_reply_watch = NULL;
+        assert (client != NULL);
+        ply_trace ("detaching from event loop");
+        client->loop = NULL;
+        client->daemon_can_take_request_watch = NULL;
+        client->daemon_has_reply_watch = NULL;
 }
 
 static void
 ply_boot_client_on_hangup (ply_boot_client_t *client)
 {
-  assert (client != NULL);
-  ply_boot_client_cancel_requests (client);
+        assert (client != NULL);
+        ply_boot_client_cancel_requests (client);
 
-  if (client->disconnect_handler != NULL)
-    client->disconnect_handler (client->disconnect_handler_user_data,
-                                client);
+        if (client->disconnect_handler != NULL)
+                client->disconnect_handler (client->disconnect_handler_user_data,
+                                            client);
 }
 
 void
 ply_boot_client_attach_to_event_loop (ply_boot_client_t *client,
                                       ply_event_loop_t  *loop)
 {
-  assert (client != NULL);
-  assert (loop != NULL);
-  assert (client->loop == NULL);
+        assert (client != NULL);
+        assert (loop != NULL);
+        assert (client->loop == NULL);
 
-  client->loop = loop;
+        client->loop = loop;
 
-  if (client->socket_fd >= 0)
-    {
-      ply_event_loop_watch_fd (client->loop, client->socket_fd,
-                               PLY_EVENT_LOOP_FD_STATUS_NONE,
-                               NULL,
-                               (ply_event_handler_t) ply_boot_client_on_hangup,
-                               client);
-    }
-
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t) 
-                                 ply_boot_client_detach_from_event_loop,
-                                 client); 
+        if (client->socket_fd >= 0) {
+                ply_event_loop_watch_fd (client->loop, client->socket_fd,
+                                         PLY_EVENT_LOOP_FD_STATUS_NONE,
+                                         NULL,
+                                         (ply_event_handler_t) ply_boot_client_on_hangup,
+                                         client);
+        }
 
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       ply_boot_client_detach_from_event_loop,
+                                       client);
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/client/ply-boot-client.h b/src/client/ply-boot-client.h
index 24939f7..3ccf9b3 100644
--- a/src/client/ply-boot-client.h
+++ b/src/client/ply-boot-client.h
@@ -30,128 +30,128 @@
 #include "ply-event-loop.h"
 
 typedef struct _ply_boot_client ply_boot_client_t;
-typedef void (* ply_boot_client_response_handler_t) (void              *user_data,
-                                                     ply_boot_client_t *client);
-typedef void (* ply_boot_client_answer_handler_t) (void              *user_data,
-                                                   const char        *answer,
-                                                   ply_boot_client_t *client);
+typedef void (*ply_boot_client_response_handler_t) (void              *user_data,
+                                                    ply_boot_client_t *client);
+typedef void (*ply_boot_client_answer_handler_t) (void              *user_data,
+                                                  const char        *answer,
+                                                  ply_boot_client_t *client);
 
-typedef void (* ply_boot_client_multiple_answers_handler_t) (void    *user_data,
-                                                             const char * const *answers,
-                                                             ply_boot_client_t *client);
-typedef void (* ply_boot_client_disconnect_handler_t) (void              *user_data,
-                                                       ply_boot_client_t *client);
+typedef void (*ply_boot_client_multiple_answers_handler_t) (void              *user_data,
+                                                            const char *const *answers,
+                                                            ply_boot_client_t *client);
+typedef void (*ply_boot_client_disconnect_handler_t) (void              *user_data,
+                                                      ply_boot_client_t *client);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_boot_client_t *ply_boot_client_new (void);
 
 void ply_boot_client_free (ply_boot_client_t *client);
-bool ply_boot_client_connect (ply_boot_client_t                    *client,
-                              ply_boot_client_disconnect_handler_t  disconnect_handler,
-                              void                                 *user_data);
-void ply_boot_client_ping_daemon (ply_boot_client_t                  *client,
-                                  ply_boot_client_response_handler_t  handler,
-                                  ply_boot_client_response_handler_t  failed_handler,
-                                  void                               *user_data);
-void ply_boot_client_update_daemon (ply_boot_client_t                  *client,
-                                    const char                         *new_status,
-                                    ply_boot_client_response_handler_t  handler,
-                                    ply_boot_client_response_handler_t  failed_handler,
-                                    void                               *user_data);
-void ply_boot_client_change_mode (ply_boot_client_t                  *client,
-                                  const char                         *new_mode,
-                                  ply_boot_client_response_handler_t  handler,
-                                  ply_boot_client_response_handler_t  failed_handler,
-                                  void                               *user_data);
-void ply_boot_client_system_update (ply_boot_client_t                  *client,
-                                    const char                         *progress,
-                                    ply_boot_client_response_handler_t  handler,
-                                    ply_boot_client_response_handler_t  failed_handler,
-                                    void                               *user_data);
-void ply_boot_client_tell_daemon_to_change_root (ply_boot_client_t                  *client,
-                                                 const char                         *chroot_dir,
-                                                 ply_boot_client_response_handler_t  handler,
-                                                 ply_boot_client_response_handler_t  failed_handler,
-                                                 void                               *user_data);
-void ply_boot_client_tell_daemon_to_display_message (ply_boot_client_t                  *client,
-                                                     const char                         *message,
-                                                     ply_boot_client_response_handler_t  handler,
-                                                     ply_boot_client_response_handler_t  failed_handler,
-                                                     void                               *user_data);
-void ply_boot_client_tell_daemon_to_hide_message (ply_boot_client_t                  *client,
-                                                  const char                         *message,
-                                                  ply_boot_client_response_handler_t  handler,
-                                                  ply_boot_client_response_handler_t  failed_handler,
-                                                  void                               *user_data);
-void ply_boot_client_ask_daemon_for_password (ply_boot_client_t                  *client,
-                                              const char                         *prompt,
-                                              ply_boot_client_answer_handler_t    handler,
-                                              ply_boot_client_response_handler_t  failed_handler,
-                                              void                               *user_data);
-void ply_boot_client_ask_daemon_for_cached_passwords (ply_boot_client_t                  *client,
-                                                      ply_boot_client_multiple_answers_handler_t    handler,
-                                                      ply_boot_client_response_handler_t  failed_handler,
-                                                      void                               *user_data);
-void ply_boot_client_ask_daemon_question     (ply_boot_client_t                    *client,
-                                              const char                           *prompt,
-                                              ply_boot_client_answer_handler_t      handler,
-                                              ply_boot_client_response_handler_t    failed_handler,
-                                              void                                 *user_data);
-void ply_boot_client_ask_daemon_to_watch_for_keystroke (ply_boot_client_t          *client,
-                                         const char                                *keys,
-                                         ply_boot_client_answer_handler_t           handler,
-                                         ply_boot_client_response_handler_t         failed_handler,
-                                         void                                      *user_data);
-void ply_boot_client_ask_daemon_to_ignore_keystroke (ply_boot_client_t             *client,
-                                         const char                                *keys,
-                                         ply_boot_client_answer_handler_t           handler,
-                                         ply_boot_client_response_handler_t         failed_handler,
-                                         void                                      *user_data);
-void ply_boot_client_tell_daemon_system_is_initialized (ply_boot_client_t                  *client,
-                                                        ply_boot_client_response_handler_t  handler,
-                                                        ply_boot_client_response_handler_t  failed_handler,
-                                                        void                               *user_data);
-void ply_boot_client_tell_daemon_to_show_splash (ply_boot_client_t                  *client,
-                                                 ply_boot_client_response_handler_t  handler,
-                                                 ply_boot_client_response_handler_t  failed_handler,
-                                                 void                               *user_data);
-void ply_boot_client_tell_daemon_to_hide_splash (ply_boot_client_t                  *client,
-                                                 ply_boot_client_response_handler_t  handler,
-                                                 ply_boot_client_response_handler_t  failed_handler,
-                                                 void                               *user_data);
-void ply_boot_client_tell_daemon_to_deactivate (ply_boot_client_t                  *client,
-                                                ply_boot_client_response_handler_t  handler,
-                                                ply_boot_client_response_handler_t  failed_handler,
-                                                void                               *user_data);
-void ply_boot_client_tell_daemon_to_reactivate (ply_boot_client_t                  *client,
-                                                ply_boot_client_response_handler_t  handler,
-                                                ply_boot_client_response_handler_t  failed_handler,
-                                                void                               *user_data);
-void ply_boot_client_tell_daemon_to_quit (ply_boot_client_t                  *client,
-                                          bool                                retain_splash,
-                                          ply_boot_client_response_handler_t  handler,
-                                          ply_boot_client_response_handler_t  failed_handler,
-                                          void                               *user_data);
-void ply_boot_client_tell_daemon_to_progress_pause (ply_boot_client_t                  *client,
-                                                    ply_boot_client_response_handler_t  handler,
-                                                    ply_boot_client_response_handler_t  failed_handler,
-                                                    void                               *user_data);
-void ply_boot_client_tell_daemon_to_progress_unpause (ply_boot_client_t                  *client,
-                                                      ply_boot_client_response_handler_t  handler,
-                                                      ply_boot_client_response_handler_t  failed_handler,
-                                                      void                               *user_data);
-void ply_boot_client_ask_daemon_has_active_vt (ply_boot_client_t                  *client,
-                                               ply_boot_client_response_handler_t  handler,
-                                               ply_boot_client_response_handler_t  failed_handler,
-                                               void                               *user_data);
+bool ply_boot_client_connect (ply_boot_client_t                   *client,
+                              ply_boot_client_disconnect_handler_t disconnect_handler,
+                              void                                *user_data);
+void ply_boot_client_ping_daemon (ply_boot_client_t                 *client,
+                                  ply_boot_client_response_handler_t handler,
+                                  ply_boot_client_response_handler_t failed_handler,
+                                  void                              *user_data);
+void ply_boot_client_update_daemon (ply_boot_client_t                 *client,
+                                    const char                        *new_status,
+                                    ply_boot_client_response_handler_t handler,
+                                    ply_boot_client_response_handler_t failed_handler,
+                                    void                              *user_data);
+void ply_boot_client_change_mode (ply_boot_client_t                 *client,
+                                  const char                        *new_mode,
+                                  ply_boot_client_response_handler_t handler,
+                                  ply_boot_client_response_handler_t failed_handler,
+                                  void                              *user_data);
+void ply_boot_client_system_update (ply_boot_client_t                 *client,
+                                    const char                        *progress,
+                                    ply_boot_client_response_handler_t handler,
+                                    ply_boot_client_response_handler_t failed_handler,
+                                    void                              *user_data);
+void ply_boot_client_tell_daemon_to_change_root (ply_boot_client_t                 *client,
+                                                 const char                        *chroot_dir,
+                                                 ply_boot_client_response_handler_t handler,
+                                                 ply_boot_client_response_handler_t failed_handler,
+                                                 void                              *user_data);
+void ply_boot_client_tell_daemon_to_display_message (ply_boot_client_t                 *client,
+                                                     const char                        *message,
+                                                     ply_boot_client_response_handler_t handler,
+                                                     ply_boot_client_response_handler_t failed_handler,
+                                                     void                              *user_data);
+void ply_boot_client_tell_daemon_to_hide_message (ply_boot_client_t                 *client,
+                                                  const char                        *message,
+                                                  ply_boot_client_response_handler_t handler,
+                                                  ply_boot_client_response_handler_t failed_handler,
+                                                  void                              *user_data);
+void ply_boot_client_ask_daemon_for_password (ply_boot_client_t                 *client,
+                                              const char                        *prompt,
+                                              ply_boot_client_answer_handler_t   handler,
+                                              ply_boot_client_response_handler_t failed_handler,
+                                              void                              *user_data);
+void ply_boot_client_ask_daemon_for_cached_passwords (ply_boot_client_t                         *client,
+                                                      ply_boot_client_multiple_answers_handler_t handler,
+                                                      ply_boot_client_response_handler_t         failed_handler,
+                                                      void                                      *user_data);
+void ply_boot_client_ask_daemon_question (ply_boot_client_t                 *client,
+                                          const char                        *prompt,
+                                          ply_boot_client_answer_handler_t   handler,
+                                          ply_boot_client_response_handler_t failed_handler,
+                                          void                              *user_data);
+void ply_boot_client_ask_daemon_to_watch_for_keystroke (ply_boot_client_t                 *client,
+                                                        const char                        *keys,
+                                                        ply_boot_client_answer_handler_t   handler,
+                                                        ply_boot_client_response_handler_t failed_handler,
+                                                        void                              *user_data);
+void ply_boot_client_ask_daemon_to_ignore_keystroke (ply_boot_client_t                 *client,
+                                                     const char                        *keys,
+                                                     ply_boot_client_answer_handler_t   handler,
+                                                     ply_boot_client_response_handler_t failed_handler,
+                                                     void                              *user_data);
+void ply_boot_client_tell_daemon_system_is_initialized (ply_boot_client_t                 *client,
+                                                        ply_boot_client_response_handler_t handler,
+                                                        ply_boot_client_response_handler_t failed_handler,
+                                                        void                              *user_data);
+void ply_boot_client_tell_daemon_to_show_splash (ply_boot_client_t                 *client,
+                                                 ply_boot_client_response_handler_t handler,
+                                                 ply_boot_client_response_handler_t failed_handler,
+                                                 void                              *user_data);
+void ply_boot_client_tell_daemon_to_hide_splash (ply_boot_client_t                 *client,
+                                                 ply_boot_client_response_handler_t handler,
+                                                 ply_boot_client_response_handler_t failed_handler,
+                                                 void                              *user_data);
+void ply_boot_client_tell_daemon_to_deactivate (ply_boot_client_t                 *client,
+                                                ply_boot_client_response_handler_t handler,
+                                                ply_boot_client_response_handler_t failed_handler,
+                                                void                              *user_data);
+void ply_boot_client_tell_daemon_to_reactivate (ply_boot_client_t                 *client,
+                                                ply_boot_client_response_handler_t handler,
+                                                ply_boot_client_response_handler_t failed_handler,
+                                                void                              *user_data);
+void ply_boot_client_tell_daemon_to_quit (ply_boot_client_t                 *client,
+                                          bool                               retain_splash,
+                                          ply_boot_client_response_handler_t handler,
+                                          ply_boot_client_response_handler_t failed_handler,
+                                          void                              *user_data);
+void ply_boot_client_tell_daemon_to_progress_pause (ply_boot_client_t                 *client,
+                                                    ply_boot_client_response_handler_t handler,
+                                                    ply_boot_client_response_handler_t failed_handler,
+                                                    void                              *user_data);
+void ply_boot_client_tell_daemon_to_progress_unpause (ply_boot_client_t                 *client,
+                                                      ply_boot_client_response_handler_t handler,
+                                                      ply_boot_client_response_handler_t failed_handler,
+                                                      void                              *user_data);
+void ply_boot_client_ask_daemon_has_active_vt (ply_boot_client_t                 *client,
+                                               ply_boot_client_response_handler_t handler,
+                                               ply_boot_client_response_handler_t failed_handler,
+                                               void                              *user_data);
 void ply_boot_client_flush (ply_boot_client_t *client);
 void ply_boot_client_disconnect (ply_boot_client_t *client);
 void ply_boot_client_attach_to_event_loop (ply_boot_client_t *client,
                                            ply_event_loop_t  *loop);
-void ply_boot_client_tell_daemon_about_error (ply_boot_client_t                  *client,
-                                              ply_boot_client_response_handler_t  handler,
-                                              ply_boot_client_response_handler_t  failed_handler,
-                                              void                               *user_data);
+void ply_boot_client_tell_daemon_about_error (ply_boot_client_t                 *client,
+                                              ply_boot_client_response_handler_t handler,
+                                              ply_boot_client_response_handler_t failed_handler,
+                                              void                              *user_data);
 
 #endif
 
diff --git a/src/client/plymouth.c b/src/client/plymouth.c
index b22e90c..bf02bce 100644
--- a/src/client/plymouth.c
+++ b/src/client/plymouth.c
@@ -42,320 +42,293 @@
 #define PLY_MAX_COMMAND_LINE_SIZE 512
 #endif
 
-#define KEY_CTRL_C ('\100' ^'C')
+#define KEY_CTRL_C ('\100' ^ 'C')
 
 typedef struct
 {
-  ply_event_loop_t     *loop;
-  ply_boot_client_t    *client;
-  ply_command_parser_t *command_parser;
-  char kernel_command_line[PLY_MAX_COMMAND_LINE_SIZE];
+        ply_event_loop_t     *loop;
+        ply_boot_client_t    *client;
+        ply_command_parser_t *command_parser;
+        char                  kernel_command_line[PLY_MAX_COMMAND_LINE_SIZE];
 } state_t;
 
 typedef struct
 {
-  state_t *state;
-  char    *command;
-  char    *prompt;
-  int      number_of_tries_left;
-  uint32_t pause : 1;
+        state_t *state;
+        char    *command;
+        char    *prompt;
+        int      number_of_tries_left;
+        uint32_t pause : 1;
 } password_answer_state_t;
 
 typedef struct
 {
-  state_t *state;
-  char    *command;
-  char    *prompt;
-  uint32_t pause : 1;
+        state_t *state;
+        char    *command;
+        char    *prompt;
+        uint32_t pause : 1;
 } question_answer_state_t;
 
 typedef struct
 {
-  state_t *state;
-  char    *command;
-  char    *keys;
+        state_t *state;
+        char    *command;
+        char    *keys;
 } key_answer_state_t;
 
 static char **
 split_string (const char *command,
               const char  delimiter)
 {
-  const char *p, *q;
-  int i, number_of_delimiters;
-  char **args;
-
-  number_of_delimiters = 0;
-  for (p = command; *p != '\0'; p++)
-    {
-      if (*p == delimiter &&
-          *(p + 1) != delimiter)
-      number_of_delimiters++;
-    }
-
-  /* there is one more arg that delimiters between args
-   * and a trailing NULL arg
-   */
-  args = calloc (number_of_delimiters + 2, sizeof (char *));
-  q = command;
-  i = 0;
-  for (p = command; *p != '\0'; p++)
-    {
-      if (*p == delimiter)
-        {
-          args[i++] = strndup (q, p - q);
-
-          while (*p == delimiter)
-              p++;
-
-          q = p;
+        const char *p, *q;
+        int i, number_of_delimiters;
+        char **args;
+
+        number_of_delimiters = 0;
+        for (p = command; *p != '\0'; p++) {
+                if (*p == delimiter &&
+                    *(p + 1) != delimiter)
+                        number_of_delimiters++;
         }
 
-      assert (*q != delimiter);
-      assert (i <= number_of_delimiters);
-    }
+        /* there is one more arg that delimiters between args
+         * and a trailing NULL arg
+         */
+        args = calloc (number_of_delimiters + 2, sizeof(char *));
+        q = command;
+        i = 0;
+        for (p = command; *p != '\0'; p++) {
+                if (*p == delimiter) {
+                        args[i++] = strndup (q, p - q);
+
+                        while (*p == delimiter) {
+                                p++;
+                        }
+
+                        q = p;
+                }
+
+                assert (*q != delimiter);
+                assert (i <= number_of_delimiters);
+        }
 
-  args[i++] = strndup (q, p - q);
+        args[i++] = strndup (q, p - q);
 
-  return args;
+        return args;
 }
 
 static bool
-answer_via_command (char           *command,
-                    const char     *answer,
-                    int            *exit_status)
+answer_via_command (char       *command,
+                    const char *answer,
+                    int        *exit_status)
 {
-  bool gave_answer;
-  pid_t pid;
-  int command_input_sender_fd, command_input_receiver_fd;
+        bool gave_answer;
+        pid_t pid;
+        int command_input_sender_fd, command_input_receiver_fd;
 
 
-  ply_trace ("running command '%s'", command);
+        ply_trace ("running command '%s'", command);
 
-  /* answer may be NULL which means,
-   * "The daemon can't ask the user questions,
-   *   do all the prompting from the client"
-   */
+        /* answer may be NULL which means,
+         * "The daemon can't ask the user questions,
+         *   do all the prompting from the client"
+         */
 
-  gave_answer = false;
-  if (answer != NULL &&
-    !ply_open_unidirectional_pipe (&command_input_sender_fd,
-                                   &command_input_receiver_fd))
-    return false;
+        gave_answer = false;
+        if (answer != NULL &&
+            !ply_open_unidirectional_pipe (&command_input_sender_fd,
+                                           &command_input_receiver_fd))
+                return false;
 
-  pid = fork (); 
+        pid = fork ();
 
-  if (pid < 0)
-    return false;
+        if (pid < 0)
+                return false;
 
-  if (pid == 0)
-    {
-      char **args;
-      args = split_string (command, ' ');
-      if (answer != NULL)
-        {
-          close (command_input_sender_fd);
-          dup2 (command_input_receiver_fd, STDIN_FILENO);
-        }
+        if (pid == 0) {
+                char **args;
+                args = split_string (command, ' ');
+                if (answer != NULL) {
+                        close (command_input_sender_fd);
+                        dup2 (command_input_receiver_fd, STDIN_FILENO);
+                }
 
-      execvp (args[0], args); 
-      ply_trace ("could not run command: %m");
-      _exit (127);
-    }
+                execvp (args[0], args);
+                ply_trace ("could not run command: %m");
+                _exit (127);
+        }
 
-  if (answer != NULL)
-    {
-      close (command_input_receiver_fd);
+        if (answer != NULL) {
+                close (command_input_receiver_fd);
 
-      if (write (command_input_sender_fd, answer, strlen (answer)) < 0)
-        goto out;
-    }
+                if (write (command_input_sender_fd, answer, strlen (answer)) < 0)
+                        goto out;
+        }
 
-  gave_answer = true;
+        gave_answer = true;
 out:
-  if (answer != NULL)
-    close (command_input_sender_fd);
-  waitpid (pid, exit_status, 0); 
+        if (answer != NULL)
+                close (command_input_sender_fd);
+        waitpid (pid, exit_status, 0);
 
-  return gave_answer;
+        return gave_answer;
 }
 
 static void
 on_failure (state_t *state)
 {
-  ply_event_loop_exit (state->loop, 1);
+        ply_event_loop_exit (state->loop, 1);
 }
 
 static void
 on_success (state_t *state)
 {
-  ply_event_loop_exit (state->loop, 0);
+        ply_event_loop_exit (state->loop, 0);
 }
 
 static void
 on_password_answer_failure (password_answer_state_t *answer_state,
                             ply_boot_client_t       *client)
 {
-  ply_trace ("password answer failure");
-
-  /* plymouthd isn't running for some reason.  If there is a command
-   * to run, we'll run it anyway, because it might be important for
-   * boot up to continue (to decrypt the root partition or whatever)
-   */
-  if (answer_state->command != NULL)
-    {
-      int exit_status;
-      bool command_started;
-
-      ply_trace ("daemon not available, running command on our own");
-
-      exit_status = 127;
-      command_started = false;
-      while (answer_state->number_of_tries_left > 0)
-        {
-          command_started = answer_via_command (answer_state->command, NULL,
-                                                &exit_status);
-
-          if (command_started && WIFEXITED (exit_status) &&
-              WEXITSTATUS (exit_status) == 0)
-            {
-              ply_trace ("command was successful");
-              break;
-            }
-
-          ply_trace ("command failed");
-          answer_state->number_of_tries_left--;
-        }
+        ply_trace ("password answer failure");
+
+        /* plymouthd isn't running for some reason.  If there is a command
+         * to run, we'll run it anyway, because it might be important for
+         * boot up to continue (to decrypt the root partition or whatever)
+         */
+        if (answer_state->command != NULL) {
+                int exit_status;
+                bool command_started;
+
+                ply_trace ("daemon not available, running command on our own");
+
+                exit_status = 127;
+                command_started = false;
+                while (answer_state->number_of_tries_left > 0) {
+                        command_started = answer_via_command (answer_state->command, NULL,
+                                                              &exit_status);
+
+                        if (command_started && WIFEXITED (exit_status) &&
+                            WEXITSTATUS (exit_status) == 0) {
+                                ply_trace ("command was successful");
+                                break;
+                        }
+
+                        ply_trace ("command failed");
+                        answer_state->number_of_tries_left--;
+                }
 
-      if (command_started && WIFSIGNALED (exit_status))
-        {
-          ply_trace ("command died with signal %s", strsignal (WTERMSIG (exit_status)));
-          raise (WTERMSIG (exit_status));
-        }
-      else
-        {
-          ply_event_loop_exit (answer_state->state->loop,
-                               WEXITSTATUS (exit_status));
+                if (command_started && WIFSIGNALED (exit_status)) {
+                        ply_trace ("command died with signal %s", strsignal (WTERMSIG (exit_status)));
+                        raise (WTERMSIG (exit_status));
+                } else {
+                        ply_event_loop_exit (answer_state->state->loop,
+                                             WEXITSTATUS (exit_status));
+                }
+        } else {
+                ply_event_loop_exit (answer_state->state->loop, 1);
         }
-    }
-  else
-    {
-      ply_event_loop_exit (answer_state->state->loop, 1);
-    }
 }
 
 static void
-on_password_answer (password_answer_state_t   *answer_state,
-                    const char                *answer,
-                    ply_boot_client_t         *client)
+on_password_answer (password_answer_state_t *answer_state,
+                    const char              *answer,
+                    ply_boot_client_t       *client)
 {
-  int exit_status;
-
-  exit_status = 127;
-  if (answer != NULL && answer[0] != KEY_CTRL_C)  /* a CTRL-C answer means the user canceled */
-    {
-      if (answer_state->command != NULL)
-        {
-          bool command_started = false;
-
-          command_started = answer_via_command (answer_state->command, answer,
-                                                &exit_status);
-
-          if (command_started && (!WIFEXITED (exit_status) ||
-              WEXITSTATUS (exit_status) != 0))
-            {
-              answer_state->number_of_tries_left--;
-
-              if (answer_state->number_of_tries_left > 0)
-                {
-                  ply_boot_client_ask_daemon_for_password (answer_state->state->client,
-                                                           answer_state->prompt,
-                                                           (ply_boot_client_answer_handler_t)
-                                                           on_password_answer,
-                                                           (ply_boot_client_response_handler_t)
-                                                           on_password_answer_failure,
-                                                           answer_state);
-                  return;
+        int exit_status;
+
+        exit_status = 127;
+        if (answer != NULL && answer[0] != KEY_CTRL_C) { /* a CTRL-C answer means the user canceled */
+                if (answer_state->command != NULL) {
+                        bool command_started = false;
+
+                        command_started = answer_via_command (answer_state->command, answer,
+                                                              &exit_status);
+
+                        if (command_started && (!WIFEXITED (exit_status) ||
+                                                WEXITSTATUS (exit_status) != 0)) {
+                                answer_state->number_of_tries_left--;
+
+                                if (answer_state->number_of_tries_left > 0) {
+                                        ply_boot_client_ask_daemon_for_password (answer_state->state->client,
+                                                                                 answer_state->prompt,
+                                                                                 (ply_boot_client_answer_handler_t)
+                                                                                 on_password_answer,
+                                                                                 (ply_boot_client_response_handler_t)
+                                                                                 on_password_answer_failure,
+                                                                                 answer_state);
+                                        return;
+                                }
+                        }
+                } else {
+                        write (STDOUT_FILENO, answer, strlen (answer));
+                        exit_status = 0;
                 }
-            }
+        } else if (answer == NULL) {
+                on_password_answer_failure (answer_state, answer_state->state->client);
         }
-      else
-        {
-          write (STDOUT_FILENO, answer, strlen (answer));
-          exit_status = 0;
+
+        if (WIFSIGNALED (exit_status))
+                raise (WTERMSIG (exit_status));
+
+        if (answer_state->pause) {
+                ply_boot_client_tell_daemon_to_progress_unpause (client,
+                                                                 (ply_boot_client_response_handler_t)
+                                                                 (WEXITSTATUS (exit_status) ? on_failure : on_success),
+                                                                 (ply_boot_client_response_handler_t)
+                                                                 on_failure,
+                                                                 answer_state->state);
+        } else {
+                ply_event_loop_exit (answer_state->state->loop, WEXITSTATUS (exit_status));
         }
-    }
-  else if (answer == NULL)
-    {
-      on_password_answer_failure (answer_state, answer_state->state->client);
-    }
-
-  if (WIFSIGNALED (exit_status))
-    raise (WTERMSIG (exit_status));
-  
-  if (answer_state->pause)
-    {
-      ply_boot_client_tell_daemon_to_progress_unpause (client,
-                                                       (ply_boot_client_response_handler_t)
-                                                       (WEXITSTATUS (exit_status) ? on_failure : on_success),
-                                                       (ply_boot_client_response_handler_t)
-                                                       on_failure,
-                                                       answer_state->state);
-    }
-  else
-    ply_event_loop_exit (answer_state->state->loop, WEXITSTATUS (exit_status));
 }
 
 static void
 on_question_answer_failure (question_answer_state_t *answer_state,
                             ply_boot_client_t       *client)
 {
-  ply_event_loop_exit (answer_state->state->loop, 1);
+        ply_event_loop_exit (answer_state->state->loop, 1);
 }
 
 static void
-on_question_answer (question_answer_state_t   *answer_state,
-                   const char                 *answer,
-                   ply_boot_client_t          *client)
+on_question_answer (question_answer_state_t *answer_state,
+                    const char              *answer,
+                    ply_boot_client_t       *client)
 {
-  if (answer != NULL)
-    {
-      if (answer_state->command != NULL)
-        {
-          answer_via_command (answer_state->command, answer, NULL);
-        }
-      else
-        {
-          write (STDOUT_FILENO, answer, strlen (answer));
+        if (answer != NULL) {
+                if (answer_state->command != NULL)
+                        answer_via_command (answer_state->command, answer, NULL);
+                else
+                        write (STDOUT_FILENO, answer, strlen (answer));
+                if (answer_state->pause) {
+                        ply_boot_client_tell_daemon_to_progress_unpause (client,
+                                                                         (ply_boot_client_response_handler_t)
+                                                                         on_success,
+                                                                         (ply_boot_client_response_handler_t)
+                                                                         on_failure,
+                                                                         answer_state->state);
+                } else {
+                        ply_event_loop_exit (answer_state->state->loop, 0);
+                }
+        } else {
+                if (answer_state->pause) {
+                        ply_boot_client_tell_daemon_to_progress_unpause (client,
+                                                                         (ply_boot_client_response_handler_t)
+                                                                         on_failure,
+                                                                         (ply_boot_client_response_handler_t)
+                                                                         on_failure,
+                                                                         answer_state->state);
+                } else {
+                        ply_event_loop_exit (answer_state->state->loop, 1);
+                }
         }
-      if (answer_state->pause)
-        ply_boot_client_tell_daemon_to_progress_unpause (client,
-                                                         (ply_boot_client_response_handler_t)
-                                                         on_success,
-                                                         (ply_boot_client_response_handler_t)
-                                                         on_failure,
-                                                         answer_state->state);
-      else
-        ply_event_loop_exit (answer_state->state->loop, 0);
-    }
-  else
-    {
-      if (answer_state->pause)
-        ply_boot_client_tell_daemon_to_progress_unpause (client,
-                                                         (ply_boot_client_response_handler_t)
-                                                         on_failure,
-                                                         (ply_boot_client_response_handler_t)
-                                                         on_failure,
-                                                         answer_state->state);
-      else
-        ply_event_loop_exit (answer_state->state->loop, 1);
-    }
 }
 
 static void
 on_key_answer_failure (key_answer_state_t *answer_state,
                        ply_boot_client_t  *client)
 {
-  ply_event_loop_exit (answer_state->state->loop, 1);
+        ply_event_loop_exit (answer_state->state->loop, 1);
 }
 
 static void
@@ -363,182 +336,164 @@ on_key_answer (key_answer_state_t *answer_state,
                const char         *answer,
                ply_boot_client_t  *client)
 {
+        if (answer == NULL) {
+                ply_event_loop_exit (answer_state->state->loop, 1);
+                return;
+        }
+
+        if (answer_state->command != NULL)
+                answer_via_command (answer_state->command, answer, NULL);
+        else
+        if (answer != NULL)
+                write (STDOUT_FILENO, answer, strlen (answer));
 
-  if (answer == NULL)
-    {
-      ply_event_loop_exit (answer_state->state->loop, 1);
-      return;
-    }
-
-  if (answer_state->command != NULL)
-    {
-      answer_via_command (answer_state->command, answer, NULL);
-    }
-  else
-    {
-      if (answer != NULL)
-        write (STDOUT_FILENO, answer, strlen (answer));
-    }
-
-  ply_event_loop_exit (answer_state->state->loop, 0);
+        ply_event_loop_exit (answer_state->state->loop, 0);
 }
 
 static void
-on_multiple_password_answers (password_answer_state_t     *answer_state,
-                              const char * const          *answers)
+on_multiple_password_answers (password_answer_state_t *answer_state,
+                              const char *const       *answers)
 {
-  bool need_to_ask_user;
-  int i;
-  int exit_status;
-
-  assert (answer_state->command != NULL);
-
-  ply_trace ("on multiple password answers");
-
-  need_to_ask_user = true;
-
-  if (answers != NULL)
-    {
-      ply_trace ("daemon has a few candidate passwords for us to try");
-      for (i = 0; answers[i] != NULL; i++)
-        {
-          bool command_started;
-          exit_status = 127;
-          command_started = answer_via_command (answer_state->command, answers[i],
-                                                &exit_status);
-          if (command_started && WIFEXITED (exit_status) &&
-              WEXITSTATUS (exit_status) == 0)
-            {
-              need_to_ask_user = false;
-              break;
-            }
+        bool need_to_ask_user;
+        int i;
+        int exit_status;
+
+        assert (answer_state->command != NULL);
+
+        ply_trace ("on multiple password answers");
+
+        need_to_ask_user = true;
+
+        if (answers != NULL) {
+                ply_trace ("daemon has a few candidate passwords for us to try");
+                for (i = 0; answers[i] != NULL; i++) {
+                        bool command_started;
+                        exit_status = 127;
+                        command_started = answer_via_command (answer_state->command, answers[i],
+                                                              &exit_status);
+                        if (command_started && WIFEXITED (exit_status) &&
+                            WEXITSTATUS (exit_status) == 0) {
+                                need_to_ask_user = false;
+                                break;
+                        }
+                }
+        } else {
+                ply_trace ("daemon has no candidate passwords for us to try");
         }
-    }
-  else
-    {
-      ply_trace ("daemon has no candidate passwords for us to try");
-    }
-
-  if (need_to_ask_user)
-    {
-      ply_boot_client_ask_daemon_for_password (answer_state->state->client,
-                                               answer_state->prompt,
-                                               (ply_boot_client_answer_handler_t)
-                                               on_password_answer,
-                                               (ply_boot_client_response_handler_t)
-                                               on_password_answer_failure, answer_state);
-      return;
-    }
 
-  ply_event_loop_exit (answer_state->state->loop, 0);
+        if (need_to_ask_user) {
+                ply_boot_client_ask_daemon_for_password (answer_state->state->client,
+                                                         answer_state->prompt,
+                                                         (ply_boot_client_answer_handler_t)
+                                                         on_password_answer,
+                                                         (ply_boot_client_response_handler_t)
+                                                         on_password_answer_failure, answer_state);
+                return;
+        }
+
+        ply_event_loop_exit (answer_state->state->loop, 0);
 }
 
 static void
 on_disconnect (state_t *state)
 {
-  bool wait;
-  int status = 0;
-
-  wait = false;
-  ply_command_parser_get_options (state->command_parser,
-                                   "wait", &wait,
-                                   NULL
-                                  );
-
-  if (! wait) {
-      ply_error ("error: unexpectedly disconnected from boot status daemon");
-      status = 2;
-  }
-
-  ply_trace ("disconnect");
-  ply_event_loop_exit (state->loop, status);
+        bool wait;
+        int status = 0;
+
+        wait = false;
+        ply_command_parser_get_options (state->command_parser,
+                                        "wait", &wait,
+                                        NULL
+                                        );
+
+        if (!wait) {
+                ply_error ("error: unexpectedly disconnected from boot status daemon");
+                status = 2;
+        }
+
+        ply_trace ("disconnect");
+        ply_event_loop_exit (state->loop, status);
 }
 
 static void
 on_password_request_execute (password_answer_state_t *password_answer_state,
                              ply_boot_client_t       *client)
 {
-  ply_trace ("executing password request (command %s)",
-             password_answer_state->command);
-
-  if (password_answer_state->command != NULL)
-    {
-      ply_boot_client_ask_daemon_for_cached_passwords (client,
-                                                       (ply_boot_client_multiple_answers_handler_t)
-                                                       on_multiple_password_answers,
-                                                       (ply_boot_client_response_handler_t)
-                                                       on_password_answer_failure, password_answer_state);
-    }
-  else
-    {
-      ply_boot_client_ask_daemon_for_password (client,
-                                               password_answer_state->prompt,
-                                               (ply_boot_client_answer_handler_t)
-                                               on_password_answer,
-                                               (ply_boot_client_response_handler_t)
-                                               on_password_answer_failure, password_answer_state);
-    }
+        ply_trace ("executing password request (command %s)",
+                   password_answer_state->command);
+
+        if (password_answer_state->command != NULL) {
+                ply_boot_client_ask_daemon_for_cached_passwords (client,
+                                                                 (ply_boot_client_multiple_answers_handler_t)
+                                                                 on_multiple_password_answers,
+                                                                 (ply_boot_client_response_handler_t)
+                                                                 on_password_answer_failure, password_answer_state);
+        } else {
+                ply_boot_client_ask_daemon_for_password (client,
+                                                         password_answer_state->prompt,
+                                                         (ply_boot_client_answer_handler_t)
+                                                         on_password_answer,
+                                                         (ply_boot_client_response_handler_t)
+                                                         on_password_answer_failure, password_answer_state);
+        }
 }
 
 static void
 on_password_request (state_t    *state,
                      const char *command)
 {
-  char *prompt;
-  char *program;
-  int number_of_tries;
-  bool dont_pause;
-  password_answer_state_t *password_answer_state;
-
-  prompt = NULL;
-  program = NULL;
-  number_of_tries = 0;
-  dont_pause = false;
-
-  ply_trace ("Password request");
-  ply_command_parser_get_command_options (state->command_parser,
-                                          command,
-                                          "command", &program,
-                                          "prompt", &prompt,
-                                          "number-of-tries", &number_of_tries,
-                                          "dont-pause-progress", &dont_pause,
-                                          NULL);
-
-  if (number_of_tries <= 0)
-    number_of_tries = INT_MAX;
-
-  password_answer_state = calloc (1, sizeof (password_answer_state_t));
-  password_answer_state->state = state;
-  password_answer_state->command = program;
-  password_answer_state->prompt = prompt;
-  password_answer_state->number_of_tries_left = number_of_tries;
-  password_answer_state->pause = !dont_pause;
-  if (password_answer_state->pause)
-    {
-      ply_boot_client_tell_daemon_to_progress_pause (state->client,
-                                                     (ply_boot_client_response_handler_t)
-                                                     on_password_request_execute,
-                                                     (ply_boot_client_response_handler_t)
-                                                     on_password_answer_failure,
-                                                     password_answer_state);
-    }
-  else
-    {
-      on_password_request_execute (password_answer_state, state->client);
-    }
+        char *prompt;
+        char *program;
+        int number_of_tries;
+        bool dont_pause;
+        password_answer_state_t *password_answer_state;
+
+        prompt = NULL;
+        program = NULL;
+        number_of_tries = 0;
+        dont_pause = false;
+
+        ply_trace ("Password request");
+        ply_command_parser_get_command_options (state->command_parser,
+                                                command,
+                                                "command", &program,
+                                                "prompt", &prompt,
+                                                "number-of-tries", &number_of_tries,
+                                                "dont-pause-progress", &dont_pause,
+                                                NULL);
+
+        if (number_of_tries <= 0)
+                number_of_tries = INT_MAX;
+
+        password_answer_state = calloc (1, sizeof(password_answer_state_t));
+        password_answer_state->state = state;
+        password_answer_state->command = program;
+        password_answer_state->prompt = prompt;
+        password_answer_state->number_of_tries_left = number_of_tries;
+        password_answer_state->pause = !dont_pause;
+        if (password_answer_state->pause) {
+                ply_boot_client_tell_daemon_to_progress_pause (state->client,
+                                                               (ply_boot_client_response_handler_t)
+                                                               on_password_request_execute,
+                                                               (ply_boot_client_response_handler_t)
+                                                               on_password_answer_failure,
+                                                               password_answer_state);
+        } else {
+                on_password_request_execute (password_answer_state, state->client);
+        }
 }
 
 static void
 on_question_request_execute (question_answer_state_t *question_answer_state,
                              ply_boot_client_t       *client)
 {
-  ply_boot_client_ask_daemon_question (client,
-                                       question_answer_state->prompt,
-                                       (ply_boot_client_answer_handler_t)
-                                       on_question_answer,
-                                       (ply_boot_client_response_handler_t)
-                                       on_question_answer_failure,
-                                       question_answer_state);
+        ply_boot_client_ask_daemon_question (client,
+                                             question_answer_state->prompt,
+                                             (ply_boot_client_answer_handler_t)
+                                             on_question_answer,
+                                             (ply_boot_client_response_handler_t)
+                                             on_question_answer_failure,
+                                             question_answer_state);
 }
 
 
@@ -546,147 +501,142 @@ static void
 on_question_request (state_t    *state,
                      const char *command)
 {
-  char *prompt;
-  char *program;
-  bool dont_pause;
-  question_answer_state_t *question_answer_state;
-
-  prompt = NULL;
-  program = NULL;
-  dont_pause = false;
-  
-  ply_command_parser_get_command_options (state->command_parser,
-                                          command,
-                                          "command", &program,
-                                          "prompt", &prompt,
-                                          "dont-pause-progress", &dont_pause,
-                                          NULL);
-
-  question_answer_state = calloc (1, sizeof (question_answer_state_t));
-  question_answer_state->state = state;
-  question_answer_state->command = program;
-  question_answer_state->prompt = prompt;
-  question_answer_state->pause = !dont_pause;
-  if (question_answer_state->pause)
-    {
-      ply_boot_client_tell_daemon_to_progress_pause (state->client,
-                                                     (ply_boot_client_response_handler_t)
-                                                     on_question_request_execute,
-                                                     (ply_boot_client_response_handler_t)
-                                                     on_question_answer_failure,
-                                                     question_answer_state);
-    }
-  else
-    {
-      on_question_request_execute (question_answer_state, state->client);
-    }
+        char *prompt;
+        char *program;
+        bool dont_pause;
+        question_answer_state_t *question_answer_state;
+
+        prompt = NULL;
+        program = NULL;
+        dont_pause = false;
+
+        ply_command_parser_get_command_options (state->command_parser,
+                                                command,
+                                                "command", &program,
+                                                "prompt", &prompt,
+                                                "dont-pause-progress", &dont_pause,
+                                                NULL);
+
+        question_answer_state = calloc (1, sizeof(question_answer_state_t));
+        question_answer_state->state = state;
+        question_answer_state->command = program;
+        question_answer_state->prompt = prompt;
+        question_answer_state->pause = !dont_pause;
+        if (question_answer_state->pause) {
+                ply_boot_client_tell_daemon_to_progress_pause (state->client,
+                                                               (ply_boot_client_response_handler_t)
+                                                               on_question_request_execute,
+                                                               (ply_boot_client_response_handler_t)
+                                                               on_question_answer_failure,
+                                                               question_answer_state);
+        } else {
+                on_question_request_execute (question_answer_state, state->client);
+        }
 }
 
 static void
 on_display_message_request (state_t    *state,
                             const char *command)
 {
-  char *text;
-
-  text = NULL;
-  ply_command_parser_get_command_options (state->command_parser,
-                                          command,
-                                          "text", &text,
-                                          NULL);
-  if (text != NULL)
-    {
-      ply_boot_client_tell_daemon_to_display_message (state->client,
-                                                      text,
-                                                      (ply_boot_client_response_handler_t)
-                                                      on_success,
-                                                      (ply_boot_client_response_handler_t)
-                                                      on_failure, state);
-      free (text);
-    }
+        char *text;
+
+        text = NULL;
+        ply_command_parser_get_command_options (state->command_parser,
+                                                command,
+                                                "text", &text,
+                                                NULL);
+        if (text != NULL) {
+                ply_boot_client_tell_daemon_to_display_message (state->client,
+                                                                text,
+                                                                (ply_boot_client_response_handler_t)
+                                                                on_success,
+                                                                (ply_boot_client_response_handler_t)
+                                                                on_failure, state);
+                free (text);
+        }
 }
 
 static void
 on_hide_message_request (state_t    *state,
                          const char *command)
 {
-  char *text;
-
-  text = NULL;
-  ply_command_parser_get_command_options (state->command_parser,
-                                          command,
-                                          "text", &text,
-                                          NULL);
-  if (text != NULL)
-    {
-      ply_boot_client_tell_daemon_to_hide_message (state->client,
-                                                   text,
-                                                   (ply_boot_client_response_handler_t)
-                                                   on_success,
-                                                   (ply_boot_client_response_handler_t)
-                                                   on_failure, state);
-      free (text);
-    }
+        char *text;
+
+        text = NULL;
+        ply_command_parser_get_command_options (state->command_parser,
+                                                command,
+                                                "text", &text,
+                                                NULL);
+        if (text != NULL) {
+                ply_boot_client_tell_daemon_to_hide_message (state->client,
+                                                             text,
+                                                             (ply_boot_client_response_handler_t)
+                                                             on_success,
+                                                             (ply_boot_client_response_handler_t)
+                                                             on_failure, state);
+                free (text);
+        }
 }
 
 static void
 on_keystroke_request (state_t    *state,
-                     const char *command)
+                      const char *command)
 {
-  char *keys;
-  char *program;
-
-  keys = NULL;
-  program = NULL;
-  
-  ply_command_parser_get_command_options (state->command_parser,
-                                          command,
-                                          "command", &program,
-                                          "keys", &keys,
-                                          NULL);
-  key_answer_state_t *key_answer_state;
-  key_answer_state = calloc (1, sizeof (key_answer_state_t));
-  key_answer_state->state = state;
-  key_answer_state->keys = keys;
-  key_answer_state->command = program;
-  ply_boot_client_ask_daemon_to_watch_for_keystroke (state->client,
-                                                     keys,
-                                                     (ply_boot_client_answer_handler_t)
-                                                     on_key_answer,
-                                                     (ply_boot_client_response_handler_t)
-                                                     on_key_answer_failure,
-                                                     key_answer_state);
+        char *keys;
+        char *program;
+
+        keys = NULL;
+        program = NULL;
+
+        ply_command_parser_get_command_options (state->command_parser,
+                                                command,
+                                                "command", &program,
+                                                "keys", &keys,
+                                                NULL);
+        key_answer_state_t *key_answer_state;
+        key_answer_state = calloc (1, sizeof(key_answer_state_t));
+        key_answer_state->state = state;
+        key_answer_state->keys = keys;
+        key_answer_state->command = program;
+        ply_boot_client_ask_daemon_to_watch_for_keystroke (state->client,
+                                                           keys,
+                                                           (ply_boot_client_answer_handler_t)
+                                                           on_key_answer,
+                                                           (ply_boot_client_response_handler_t)
+                                                           on_key_answer_failure,
+                                                           key_answer_state);
 }
 
 static void
 on_keystroke_ignore (state_t    *state,
                      const char *command)
 {
-  char *keys;
-
-  keys = NULL;
-  
-  ply_command_parser_get_command_options (state->command_parser,
-                                          command,
-                                          "keys", &keys,
-                                          NULL);
-
-  ply_boot_client_ask_daemon_to_ignore_keystroke (state->client,
-                                                  keys,
-                                                  (ply_boot_client_answer_handler_t)
-                                                  on_success,
-                                                  (ply_boot_client_response_handler_t)
-                                                  on_failure, state);
+        char *keys;
+
+        keys = NULL;
+
+        ply_command_parser_get_command_options (state->command_parser,
+                                                command,
+                                                "keys", &keys,
+                                                NULL);
+
+        ply_boot_client_ask_daemon_to_ignore_keystroke (state->client,
+                                                        keys,
+                                                        (ply_boot_client_answer_handler_t)
+                                                        on_success,
+                                                        (ply_boot_client_response_handler_t)
+                                                        on_failure, state);
 }
 
 static void
 on_progress_pause_request (state_t    *state,
                            const char *command)
 {
-  ply_boot_client_tell_daemon_to_progress_pause (state->client,
-                                                (ply_boot_client_response_handler_t)
-                                                on_success,
-                                                (ply_boot_client_response_handler_t)
-                                                on_failure, state);
+        ply_boot_client_tell_daemon_to_progress_pause (state->client,
+                                                       (ply_boot_client_response_handler_t)
+                                                       on_success,
+                                                       (ply_boot_client_response_handler_t)
+                                                       on_failure, state);
 }
 
 
@@ -694,613 +644,581 @@ static void
 on_progress_unpause_request (state_t    *state,
                              const char *command)
 {
-  ply_boot_client_tell_daemon_to_progress_unpause (state->client,
-                                                  (ply_boot_client_response_handler_t)
-                                                  on_success,
-                                                  (ply_boot_client_response_handler_t)
-                                                  on_failure, state);
+        ply_boot_client_tell_daemon_to_progress_unpause (state->client,
+                                                         (ply_boot_client_response_handler_t)
+                                                         on_success,
+                                                         (ply_boot_client_response_handler_t)
+                                                         on_failure, state);
 }
 
 static void
 on_report_error_request (state_t    *state,
                          const char *command)
 {
-  ply_boot_client_tell_daemon_about_error (state->client,
-                                           (ply_boot_client_response_handler_t)
-                                           on_success,
-                                           (ply_boot_client_response_handler_t)
-                                           on_failure, state);
-
+        ply_boot_client_tell_daemon_about_error (state->client,
+                                                 (ply_boot_client_response_handler_t)
+                                                 on_success,
+                                                 (ply_boot_client_response_handler_t)
+                                                 on_failure, state);
 }
 
 static void
 on_deactivate_request (state_t    *state,
                        const char *command)
 {
-  ply_boot_client_tell_daemon_to_deactivate (state->client,
-                                             (ply_boot_client_response_handler_t)
-                                             on_success,
-                                             (ply_boot_client_response_handler_t)
-                                             on_failure, state);
+        ply_boot_client_tell_daemon_to_deactivate (state->client,
+                                                   (ply_boot_client_response_handler_t)
+                                                   on_success,
+                                                   (ply_boot_client_response_handler_t)
+                                                   on_failure, state);
 }
 
 static void
 on_reactivate_request (state_t    *state,
                        const char *command)
 {
-  ply_boot_client_tell_daemon_to_reactivate (state->client,
-                                             (ply_boot_client_response_handler_t)
-                                             on_success,
-                                             (ply_boot_client_response_handler_t)
-                                             on_failure, state);
+        ply_boot_client_tell_daemon_to_reactivate (state->client,
+                                                   (ply_boot_client_response_handler_t)
+                                                   on_success,
+                                                   (ply_boot_client_response_handler_t)
+                                                   on_failure, state);
 }
 
 static void
 on_quit_request (state_t    *state,
                  const char *command)
 {
-  bool should_retain_splash;
-
-  should_retain_splash = false;
-  ply_command_parser_get_command_options (state->command_parser,
-                                          command,
-                                          "retain-splash", &should_retain_splash,
-                                          NULL);
-
-  ply_boot_client_tell_daemon_to_quit (state->client,
-                                       should_retain_splash,
-                                       (ply_boot_client_response_handler_t)
-                                       on_success,
-                                       (ply_boot_client_response_handler_t)
-                                       on_failure, state);
+        bool should_retain_splash;
+
+        should_retain_splash = false;
+        ply_command_parser_get_command_options (state->command_parser,
+                                                command,
+                                                "retain-splash", &should_retain_splash,
+                                                NULL);
+
+        ply_boot_client_tell_daemon_to_quit (state->client,
+                                             should_retain_splash,
+                                             (ply_boot_client_response_handler_t)
+                                             on_success,
+                                             (ply_boot_client_response_handler_t)
+                                             on_failure, state);
 }
 
 static bool
 get_kernel_command_line (state_t *state)
 {
-  int fd;
-
-  ply_trace ("opening /proc/cmdline");
-  fd = open ("/proc/cmdline", O_RDONLY);
-
-  if (fd < 0)
-    {
-      ply_trace ("couldn't open it: %m");
-      return false;
-    }
-
-  ply_trace ("reading kernel command line");
-  if (read (fd, state->kernel_command_line, sizeof (state->kernel_command_line)) < 0)
-    {
-      ply_trace ("couldn't read it: %m");
-      close (fd);
-      return false;
-    }
-
-  ply_trace ("Kernel command line is: '%s'", state->kernel_command_line);
-  close (fd);
-  return true;
+        int fd;
+
+        ply_trace ("opening /proc/cmdline");
+        fd = open ("/proc/cmdline", O_RDONLY);
+
+        if (fd < 0) {
+                ply_trace ("couldn't open it: %m");
+                return false;
+        }
+
+        ply_trace ("reading kernel command line");
+        if (read (fd, state->kernel_command_line, sizeof(state->kernel_command_line)) < 0) {
+                ply_trace ("couldn't read it: %m");
+                close (fd);
+                return false;
+        }
+
+        ply_trace ("Kernel command line is: '%s'", state->kernel_command_line);
+        close (fd);
+        return true;
 }
 
 static void
 on_update_root_fs_request (state_t    *state,
                            const char *command)
 {
+        char *root_dir;
+        bool is_read_write;
+
+        root_dir = NULL;
+        is_read_write = false;
+        ply_command_parser_get_command_options (state->command_parser,
+                                                command,
+                                                "new-root-dir", &root_dir,
+                                                "read-write", &is_read_write,
+                                                NULL);
+
+        if (root_dir != NULL) {
+                ply_boot_client_tell_daemon_to_change_root (state->client, root_dir,
+                                                            (ply_boot_client_response_handler_t)
+                                                            on_success,
+                                                            (ply_boot_client_response_handler_t)
+                                                            on_failure, state);
+        }
 
-  char *root_dir;
-  bool is_read_write;
-
-  root_dir = NULL;
-  is_read_write = false;
-  ply_command_parser_get_command_options (state->command_parser,
-                                          command,
-                                          "new-root-dir", &root_dir,
-                                          "read-write", &is_read_write,
-                                          NULL);
-
-  if (root_dir != NULL)
-    {
-      ply_boot_client_tell_daemon_to_change_root (state->client, root_dir,
-                                                  (ply_boot_client_response_handler_t)
-                                                  on_success,
-                                                  (ply_boot_client_response_handler_t)
-                                                  on_failure, state);
-
-    }
-
-  if (is_read_write)
-    {
-      ply_boot_client_tell_daemon_system_is_initialized (state->client,
-                                                         (ply_boot_client_response_handler_t)
-                                                         on_success,
-                                                         (ply_boot_client_response_handler_t)
-                                                         on_failure, state);
-    }
+        if (is_read_write) {
+                ply_boot_client_tell_daemon_system_is_initialized (state->client,
+                                                                   (ply_boot_client_response_handler_t)
+                                                                   on_success,
+                                                                   (ply_boot_client_response_handler_t)
+                                                                   on_failure, state);
+        }
 }
 
 static void
 on_show_splash_request (state_t    *state,
                         const char *command)
 {
-    ply_boot_client_tell_daemon_to_show_splash (state->client,
-                                               (ply_boot_client_response_handler_t)
-                                               on_success,
-                                               (ply_boot_client_response_handler_t)
-                                               on_failure, state);
+        ply_boot_client_tell_daemon_to_show_splash (state->client,
+                                                    (ply_boot_client_response_handler_t)
+                                                    on_success,
+                                                    (ply_boot_client_response_handler_t)
+                                                    on_failure, state);
 }
 
 static void
 on_hide_splash_request (state_t    *state,
                         const char *command)
 {
-    ply_boot_client_tell_daemon_to_hide_splash (state->client,
-                                               (ply_boot_client_response_handler_t)
-                                               on_success,
-                                               (ply_boot_client_response_handler_t)
-                                               on_failure, state);
+        ply_boot_client_tell_daemon_to_hide_splash (state->client,
+                                                    (ply_boot_client_response_handler_t)
+                                                    on_success,
+                                                    (ply_boot_client_response_handler_t)
+                                                    on_failure, state);
 }
 
 static void
 on_update_request (state_t    *state,
                    const char *command)
 {
-  char *status;
-
-  status = NULL;
-  ply_command_parser_get_command_options (state->command_parser,
-                                          command,
-                                          "status", &status,
-                                          NULL);
-
-  if (status != NULL)
-    {
-      ply_boot_client_update_daemon (state->client, status,
-                                     (ply_boot_client_response_handler_t)
-                                     on_success,
-                                     (ply_boot_client_response_handler_t)
-                                     on_failure, state);
-
-    }
+        char *status;
+
+        status = NULL;
+        ply_command_parser_get_command_options (state->command_parser,
+                                                command,
+                                                "status", &status,
+                                                NULL);
+
+        if (status != NULL) {
+                ply_boot_client_update_daemon (state->client, status,
+                                               (ply_boot_client_response_handler_t)
+                                               on_success,
+                                               (ply_boot_client_response_handler_t)
+                                               on_failure, state);
+        }
 }
 
 static void
 on_change_mode_request (state_t    *state,
                         const char *command)
 {
-  bool boot_up;
-  bool shutdown;
-  bool updates;
-
-  boot_up = false;
-  shutdown = false;
-  updates = false;
-  ply_command_parser_get_command_options (state->command_parser,
-                                          command,
-                                          "boot-up", &boot_up,
-                                          "shutdown", &shutdown,
-                                          "updates", &updates,
-                                          NULL);
-
-  if (boot_up)
-    {
-      ply_boot_client_change_mode (state->client, "boot-up",
-                                   (ply_boot_client_response_handler_t)
-                                   on_success,
-                                   (ply_boot_client_response_handler_t)
-                                   on_failure, state);
-
-    }
-  else if (shutdown)
-    {
-      ply_boot_client_change_mode (state->client, "shutdown",
-                                   (ply_boot_client_response_handler_t)
-                                   on_success,
-                                   (ply_boot_client_response_handler_t)
-                                   on_failure, state);
-
-    }
-  else if (updates)
-    {
-      ply_boot_client_change_mode (state->client, "updates",
-                                   (ply_boot_client_response_handler_t)
-                                   on_success,
-                                   (ply_boot_client_response_handler_t)
-                                   on_failure, state);
-
-    }
+        bool boot_up;
+        bool shutdown;
+        bool updates;
+
+        boot_up = false;
+        shutdown = false;
+        updates = false;
+        ply_command_parser_get_command_options (state->command_parser,
+                                                command,
+                                                "boot-up", &boot_up,
+                                                "shutdown", &shutdown,
+                                                "updates", &updates,
+                                                NULL);
+
+        if (boot_up) {
+                ply_boot_client_change_mode (state->client, "boot-up",
+                                             (ply_boot_client_response_handler_t)
+                                             on_success,
+                                             (ply_boot_client_response_handler_t)
+                                             on_failure, state);
+        } else if (shutdown) {
+                ply_boot_client_change_mode (state->client, "shutdown",
+                                             (ply_boot_client_response_handler_t)
+                                             on_success,
+                                             (ply_boot_client_response_handler_t)
+                                             on_failure, state);
+        } else if (updates) {
+                ply_boot_client_change_mode (state->client, "updates",
+                                             (ply_boot_client_response_handler_t)
+                                             on_success,
+                                             (ply_boot_client_response_handler_t)
+                                             on_failure, state);
+        }
 }
 
 static void
 on_system_update_request (state_t    *state,
                           const char *command)
 {
-  int progress;
-
-  progress = 0;
-  ply_command_parser_get_command_options (state->command_parser,
-                                          command,
-                                          "progress", &progress,
-                                          NULL);
-
-  if (progress >= 0 && progress <= 100)
-    {
-      char *progress_string = NULL;
-
-      asprintf (&progress_string, "%d", progress);
-
-      ply_boot_client_system_update (state->client,
-                                     progress_string,
-                                     (ply_boot_client_response_handler_t)
-                                     on_success,
-                                     (ply_boot_client_response_handler_t)
-                                     on_failure, state);
-      free (progress_string);
-    }
-  else
-    {
-      ply_error ("couldn't set invalid percentage: %i", progress);
-      ply_event_loop_exit (state->loop, 1);
-    }
+        int progress;
+
+        progress = 0;
+        ply_command_parser_get_command_options (state->command_parser,
+                                                command,
+                                                "progress", &progress,
+                                                NULL);
+
+        if (progress >= 0 && progress <= 100) {
+                char *progress_string = NULL;
+
+                asprintf (&progress_string, "%d", progress);
+
+                ply_boot_client_system_update (state->client,
+                                               progress_string,
+                                               (ply_boot_client_response_handler_t)
+                                               on_success,
+                                               (ply_boot_client_response_handler_t)
+                                               on_failure, state);
+                free (progress_string);
+        } else {
+                ply_error ("couldn't set invalid percentage: %i", progress);
+                ply_event_loop_exit (state->loop, 1);
+        }
 }
 
 int
 main (int    argc,
       char **argv)
 {
-  state_t state = { 0 };
-  bool should_help, should_quit, should_ping, should_check_for_active_vt, should_sysinit, should_ask_for_password, should_show_splash, should_hide_splash, should_wait, should_be_verbose, report_error, should_get_plugin_path;
-  bool is_connected;
-  char *status, *chroot_dir, *ignore_keystroke;
-  int exit_code;
-
-  exit_code = 0;
-
-  signal (SIGPIPE, SIG_IGN);
-
-  state.loop = ply_event_loop_new ();
-  state.client = ply_boot_client_new ();
-  state.command_parser = ply_command_parser_new ("plymouth", "Splash control client");
-
-  ply_command_parser_add_options (state.command_parser,
-                                  "help", "This help message", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "debug", "Enable verbose debug logging", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "get-splash-plugin-path", "Get directory where splash plugins are installed", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "newroot", "Tell boot daemon that new root filesystem is mounted", PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "quit", "Tell boot daemon to quit", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "ping", "Check of boot daemon is running", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "has-active-vt", "Check if boot daemon has an active vt", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "sysinit", "Tell boot daemon root filesystem is mounted read-write", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "show-splash", "Show splash screen", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "hide-splash", "Hide splash screen", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "ask-for-password", "Ask user for password", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "ignore-keystroke", "Remove sensitivity to a keystroke", PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "update", "Tell boot daemon an update about boot progress", PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "details", "Tell boot daemon there were errors during boot", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "wait", "Wait for boot daemon to quit", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "change-mode", "Change the operation mode",
-                                  (ply_command_handler_t)
-                                  on_change_mode_request, &state,
-                                  "boot-up", "Starting the system up",
-                                  PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "shutdown", "Shutting the system down",
-                                  PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "updates", "Applying updates",
-                                  PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "system-update", "Tell the daemon about updates progress",
-                                  (ply_command_handler_t)
-                                  on_system_update_request, &state,
-                                  "progress", "The percentage progress of the updates",
-                                  PLY_COMMAND_OPTION_TYPE_INTEGER,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "update", "Tell daemon about boot status changes",
-                                  (ply_command_handler_t)
-                                  on_update_request, &state,
-                                  "status", "Tell daemon the current boot status",
-                                  PLY_COMMAND_OPTION_TYPE_STRING,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "update-root-fs", "Tell daemon about root filesystem changes",
-                                  (ply_command_handler_t)
-                                  on_update_root_fs_request, &state,
-                                  "new-root-dir", "Root filesystem is about to change",
-                                  PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "read-write", "Root filesystem is no longer read-only",
-                                  PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "show-splash", "Tell daemon to show splash screen",
-                                  (ply_command_handler_t)
-                                  on_show_splash_request, &state,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "hide-splash", "Tell daemon to hide splash screen",
-                                  (ply_command_handler_t)
-                                  on_hide_splash_request, &state,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "ask-for-password", "Ask user for password",
-                                  (ply_command_handler_t)
-                                  on_password_request, &state,
-                                  "command", "Command to send password to via standard input",
-                                  PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "prompt", "Message to display when asking for password",
-                                  PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "number-of-tries", "Number of times to ask before giving up (requires --command)",
-                                  PLY_COMMAND_OPTION_TYPE_INTEGER,
-                                  "dont-pause-progress", "Don't pause boot progress bar while asking",
-                                  PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "ask-question", "Ask user a question",
-                                  (ply_command_handler_t)
-                                  on_question_request, &state,
-                                  "command", "Command to send the answer to via standard input",
-                                  PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "prompt", "Message to display when asking the question",
-                                  PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "dont-pause-progress", "Don't pause boot progress bar while asking",
-                                  PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "display-message", "Display a message",
-                                  (ply_command_handler_t)
-                                  on_display_message_request, &state,
-                                  "text", "The message text",
-                                  PLY_COMMAND_OPTION_TYPE_STRING,
-                                  NULL);
-  ply_command_parser_add_command_alias (state.command_parser,
-                                        "display-message",
-                                        "message");
-  ply_command_parser_add_command (state.command_parser,
-                                  "hide-message", "Hide a message",
-                                  (ply_command_handler_t)
-                                  on_hide_message_request, &state,
-                                  "text", "The message text",
-                                  PLY_COMMAND_OPTION_TYPE_STRING,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "watch-keystroke", "Become sensitive to a keystroke",
-                                  (ply_command_handler_t)
-                                  on_keystroke_request, &state,
-                                  "command", "Command to send keystroke to via standard input",
-                                  PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "keys", "Keys to become sensitive to",
-                                  PLY_COMMAND_OPTION_TYPE_STRING,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "ignore-keystroke", "Remove sensitivity to a keystroke",
-                                  (ply_command_handler_t)
-                                  on_keystroke_ignore, &state,
-                                  "keys", "Keys to remove sensitivity to",
-                                  PLY_COMMAND_OPTION_TYPE_STRING,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "pause-progress", "Pause boot progress bar",
-                                  (ply_command_handler_t)
-                                  on_progress_pause_request, &state,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "unpause-progress", "Unpause boot progress bar",
-                                  (ply_command_handler_t)
-                                  on_progress_unpause_request, &state,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "report-error", "Tell boot daemon there were errors during boot",
-                                  (ply_command_handler_t)
-                                  on_report_error_request, &state,
-                                  NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "deactivate", "Tell boot daemon to deactivate",
-                                  (ply_command_handler_t)
-                                  on_deactivate_request, &state, NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "reactivate", "Tell boot daemon to reactivate",
-                                  (ply_command_handler_t)
-                                  on_reactivate_request, &state, NULL);
-
-  ply_command_parser_add_command (state.command_parser,
-                                  "quit", "Tell boot daemon to quit",
-                                  (ply_command_handler_t)
-                                  on_quit_request, &state,
-                                  "retain-splash", "Don't explicitly hide boot splash on exit",
-                                  PLY_COMMAND_OPTION_TYPE_FLAG, NULL);
-
-  if (!ply_command_parser_parse_arguments (state.command_parser, state.loop, argv, argc))
-    {
-      char *help_string;
-
-      help_string = ply_command_parser_get_help_string (state.command_parser);
-
-      ply_error ("%s", help_string);
-
-      free (help_string);
-      return 1;
-    }
-
-  ply_command_parser_get_options (state.command_parser,
-                                  "help", &should_help,
-                                  "debug", &should_be_verbose,
-                                  "get-splash-plugin-path", &should_get_plugin_path,
-                                  "newroot", &chroot_dir,
-                                  "quit", &should_quit,
-                                  "ping", &should_ping,
-                                  "has-active-vt", &should_check_for_active_vt,
-                                  "sysinit", &should_sysinit,
-                                  "show-splash", &should_show_splash,
-                                  "hide-splash", &should_hide_splash,
-                                  "ask-for-password", &should_ask_for_password,
-                                  "ignore-keystroke", &ignore_keystroke,
-                                  "update", &status,
-                                  "wait", &should_wait,
-                                  "details", &report_error,
-                                  NULL);
-
-  if (should_help || argc < 2)
-    {
-      char *help_string;
-
-      help_string = ply_command_parser_get_help_string (state.command_parser);
-
-      if (argc < 2)
-        fprintf (stderr, "%s", help_string);
-      else
-        printf ("%s", help_string);
-
-      free (help_string);
-      return 0;
-    }
-
-  if (get_kernel_command_line (&state))
-    {
-      if ((strstr (state.kernel_command_line, "plymouth.debug") != NULL ||
-           strstr (state.kernel_command_line, "plymouth:debug") != NULL)
-          && !ply_is_tracing ())
-        ply_toggle_tracing ();
-    }
-
-  if (should_be_verbose && !ply_is_tracing ())
-    ply_toggle_tracing ();
-
-  if (should_get_plugin_path)
-    {
-      printf ("%s\n", PLYMOUTH_PLUGIN_PATH);
-      return 0;
-    }
-
-  is_connected = ply_boot_client_connect (state.client,
-                                          (ply_boot_client_disconnect_handler_t)
-                                          on_disconnect, &state);
-  if (!is_connected)
-    {
-      ply_trace ("daemon not running");
-
-      if (should_ping)
-        {
-          ply_trace ("ping failed");
-          return 1;
+        state_t state = { 0 };
+        bool should_help, should_quit, should_ping, should_check_for_active_vt, should_sysinit, should_ask_for_password, should_show_splash, should_hide_splash, should_wait, should_be_verbose, report_error, should_get_plugin_path;
+        bool is_connected;
+        char *status, *chroot_dir, *ignore_keystroke;
+        int exit_code;
+
+        exit_code = 0;
+
+        signal (SIGPIPE, SIG_IGN);
+
+        state.loop = ply_event_loop_new ();
+        state.client = ply_boot_client_new ();
+        state.command_parser = ply_command_parser_new ("plymouth", "Splash control client");
+
+        ply_command_parser_add_options (state.command_parser,
+                                        "help", "This help message", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "debug", "Enable verbose debug logging", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "get-splash-plugin-path", "Get directory where splash plugins are installed", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "newroot", "Tell boot daemon that new root filesystem is mounted", PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "quit", "Tell boot daemon to quit", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "ping", "Check of boot daemon is running", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "has-active-vt", "Check if boot daemon has an active vt", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "sysinit", "Tell boot daemon root filesystem is mounted read-write", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "show-splash", "Show splash screen", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "hide-splash", "Hide splash screen", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "ask-for-password", "Ask user for password", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "ignore-keystroke", "Remove sensitivity to a keystroke", PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "update", "Tell boot daemon an update about boot progress", PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "details", "Tell boot daemon there were errors during boot", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "wait", "Wait for boot daemon to quit", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "change-mode", "Change the operation mode",
+                                        (ply_command_handler_t)
+                                        on_change_mode_request, &state,
+                                        "boot-up", "Starting the system up",
+                                        PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "shutdown", "Shutting the system down",
+                                        PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "updates", "Applying updates",
+                                        PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "system-update", "Tell the daemon about updates progress",
+                                        (ply_command_handler_t)
+                                        on_system_update_request, &state,
+                                        "progress", "The percentage progress of the updates",
+                                        PLY_COMMAND_OPTION_TYPE_INTEGER,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "update", "Tell daemon about boot status changes",
+                                        (ply_command_handler_t)
+                                        on_update_request, &state,
+                                        "status", "Tell daemon the current boot status",
+                                        PLY_COMMAND_OPTION_TYPE_STRING,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "update-root-fs", "Tell daemon about root filesystem changes",
+                                        (ply_command_handler_t)
+                                        on_update_root_fs_request, &state,
+                                        "new-root-dir", "Root filesystem is about to change",
+                                        PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "read-write", "Root filesystem is no longer read-only",
+                                        PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "show-splash", "Tell daemon to show splash screen",
+                                        (ply_command_handler_t)
+                                        on_show_splash_request, &state,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "hide-splash", "Tell daemon to hide splash screen",
+                                        (ply_command_handler_t)
+                                        on_hide_splash_request, &state,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "ask-for-password", "Ask user for password",
+                                        (ply_command_handler_t)
+                                        on_password_request, &state,
+                                        "command", "Command to send password to via standard input",
+                                        PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "prompt", "Message to display when asking for password",
+                                        PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "number-of-tries", "Number of times to ask before giving up (requires --command)",
+                                        PLY_COMMAND_OPTION_TYPE_INTEGER,
+                                        "dont-pause-progress", "Don't pause boot progress bar while asking",
+                                        PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "ask-question", "Ask user a question",
+                                        (ply_command_handler_t)
+                                        on_question_request, &state,
+                                        "command", "Command to send the answer to via standard input",
+                                        PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "prompt", "Message to display when asking the question",
+                                        PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "dont-pause-progress", "Don't pause boot progress bar while asking",
+                                        PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "display-message", "Display a message",
+                                        (ply_command_handler_t)
+                                        on_display_message_request, &state,
+                                        "text", "The message text",
+                                        PLY_COMMAND_OPTION_TYPE_STRING,
+                                        NULL);
+        ply_command_parser_add_command_alias (state.command_parser,
+                                              "display-message",
+                                              "message");
+        ply_command_parser_add_command (state.command_parser,
+                                        "hide-message", "Hide a message",
+                                        (ply_command_handler_t)
+                                        on_hide_message_request, &state,
+                                        "text", "The message text",
+                                        PLY_COMMAND_OPTION_TYPE_STRING,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "watch-keystroke", "Become sensitive to a keystroke",
+                                        (ply_command_handler_t)
+                                        on_keystroke_request, &state,
+                                        "command", "Command to send keystroke to via standard input",
+                                        PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "keys", "Keys to become sensitive to",
+                                        PLY_COMMAND_OPTION_TYPE_STRING,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "ignore-keystroke", "Remove sensitivity to a keystroke",
+                                        (ply_command_handler_t)
+                                        on_keystroke_ignore, &state,
+                                        "keys", "Keys to remove sensitivity to",
+                                        PLY_COMMAND_OPTION_TYPE_STRING,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "pause-progress", "Pause boot progress bar",
+                                        (ply_command_handler_t)
+                                        on_progress_pause_request, &state,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "unpause-progress", "Unpause boot progress bar",
+                                        (ply_command_handler_t)
+                                        on_progress_unpause_request, &state,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "report-error", "Tell boot daemon there were errors during boot",
+                                        (ply_command_handler_t)
+                                        on_report_error_request, &state,
+                                        NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "deactivate", "Tell boot daemon to deactivate",
+                                        (ply_command_handler_t)
+                                        on_deactivate_request, &state, NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "reactivate", "Tell boot daemon to reactivate",
+                                        (ply_command_handler_t)
+                                        on_reactivate_request, &state, NULL);
+
+        ply_command_parser_add_command (state.command_parser,
+                                        "quit", "Tell boot daemon to quit",
+                                        (ply_command_handler_t)
+                                        on_quit_request, &state,
+                                        "retain-splash", "Don't explicitly hide boot splash on exit",
+                                        PLY_COMMAND_OPTION_TYPE_FLAG, NULL);
+
+        if (!ply_command_parser_parse_arguments (state.command_parser, state.loop, argv, argc)) {
+                char *help_string;
+
+                help_string = ply_command_parser_get_help_string (state.command_parser);
+
+                ply_error ("%s", help_string);
+
+                free (help_string);
+                return 1;
         }
-      if (should_check_for_active_vt)
-        {
-          ply_trace ("has active vt? failed");
-          return 1;
+
+        ply_command_parser_get_options (state.command_parser,
+                                        "help", &should_help,
+                                        "debug", &should_be_verbose,
+                                        "get-splash-plugin-path", &should_get_plugin_path,
+                                        "newroot", &chroot_dir,
+                                        "quit", &should_quit,
+                                        "ping", &should_ping,
+                                        "has-active-vt", &should_check_for_active_vt,
+                                        "sysinit", &should_sysinit,
+                                        "show-splash", &should_show_splash,
+                                        "hide-splash", &should_hide_splash,
+                                        "ask-for-password", &should_ask_for_password,
+                                        "ignore-keystroke", &ignore_keystroke,
+                                        "update", &status,
+                                        "wait", &should_wait,
+                                        "details", &report_error,
+                                        NULL);
+
+        if (should_help || argc < 2) {
+                char *help_string;
+
+                help_string = ply_command_parser_get_help_string (state.command_parser);
+
+                if (argc < 2)
+                        fprintf (stderr, "%s", help_string);
+                else
+                        printf ("%s", help_string);
+
+                free (help_string);
+                return 0;
         }
-      if (should_wait)
-        {
-          ply_trace("no need to wait");
-          return 0;
+
+        if (get_kernel_command_line (&state)) {
+                if ((strstr (state.kernel_command_line, "plymouth.debug") != NULL ||
+                     strstr (state.kernel_command_line, "plymouth:debug") != NULL)
+                    && !ply_is_tracing ())
+                        ply_toggle_tracing ();
         }
-    }
 
-  ply_boot_client_attach_to_event_loop (state.client, state.loop);
+        if (should_be_verbose && !ply_is_tracing ())
+                ply_toggle_tracing ();
 
-  if (should_show_splash)
-    ply_boot_client_tell_daemon_to_show_splash (state.client,
-                                               (ply_boot_client_response_handler_t)
-                                               on_success,
-                                               (ply_boot_client_response_handler_t)
-                                               on_failure, &state);
-  else if (should_hide_splash)
-    ply_boot_client_tell_daemon_to_hide_splash (state.client,
-                                               (ply_boot_client_response_handler_t)
-                                               on_success,
-                                               (ply_boot_client_response_handler_t)
-                                               on_failure, &state);
-  else if (should_quit)
-    ply_boot_client_tell_daemon_to_quit (state.client,
-                                         false,
-                                         (ply_boot_client_response_handler_t)
-                                         on_success,
-                                         (ply_boot_client_response_handler_t)
-                                         on_failure, &state);
-  else if (should_ping)
-    ply_boot_client_ping_daemon (state.client,
-                                 (ply_boot_client_response_handler_t)
-                                 on_success, 
-                                 (ply_boot_client_response_handler_t)
-                                 on_failure, &state);
-  else if (should_check_for_active_vt)
-    ply_boot_client_ask_daemon_has_active_vt (state.client,
-                                              (ply_boot_client_response_handler_t)
-                                              on_success,
-                                              (ply_boot_client_response_handler_t)
-                                              on_failure, &state);
-  else if (status != NULL)
-    ply_boot_client_update_daemon (state.client, status,
-                                   (ply_boot_client_response_handler_t)
-                                   on_success, 
-                                   (ply_boot_client_response_handler_t)
-                                   on_failure, &state);
-  else if (should_ask_for_password)
-    {
-      password_answer_state_t answer_state = { 0 };
-
-      answer_state.state = &state;
-      answer_state.number_of_tries_left = 1;
-      ply_boot_client_ask_daemon_for_password (state.client,
-                                               NULL,
-                                               (ply_boot_client_answer_handler_t)
-                                               on_password_answer,
-                                               (ply_boot_client_response_handler_t)
-                                               on_password_answer_failure, &answer_state);
-    }
-  else if (ignore_keystroke)
-    {
-      ply_boot_client_ask_daemon_to_ignore_keystroke (state.client,
-                                           ignore_keystroke,
-                                           (ply_boot_client_answer_handler_t)
-                                           on_success,
-                                           (ply_boot_client_response_handler_t)
-                                           on_failure, &state);
-    }
-  else if (should_sysinit)
-    ply_boot_client_tell_daemon_system_is_initialized (state.client,
-                                   (ply_boot_client_response_handler_t)
-                                   on_success, 
-                                   (ply_boot_client_response_handler_t)
-                                   on_failure, &state);
-  else if (chroot_dir)
-    ply_boot_client_tell_daemon_to_change_root (state.client, chroot_dir,
-                                   (ply_boot_client_response_handler_t)
-                                   on_success,
-                                   (ply_boot_client_response_handler_t)
-                                   on_failure, &state);
-
-  else if (should_wait)
-    {} // Do nothing
-  else if (report_error)
-    ply_boot_client_tell_daemon_about_error (state.client,
+        if (should_get_plugin_path) {
+                printf ("%s\n", PLYMOUTH_PLUGIN_PATH);
+                return 0;
+        }
+
+        is_connected = ply_boot_client_connect (state.client,
+                                                (ply_boot_client_disconnect_handler_t)
+                                                on_disconnect, &state);
+        if (!is_connected) {
+                ply_trace ("daemon not running");
+
+                if (should_ping) {
+                        ply_trace ("ping failed");
+                        return 1;
+                }
+                if (should_check_for_active_vt) {
+                        ply_trace ("has active vt? failed");
+                        return 1;
+                }
+                if (should_wait) {
+                        ply_trace ("no need to wait");
+                        return 0;
+                }
+        }
+
+        ply_boot_client_attach_to_event_loop (state.client, state.loop);
+
+        if (should_show_splash) {
+                ply_boot_client_tell_daemon_to_show_splash (state.client,
+                                                            (ply_boot_client_response_handler_t)
+                                                            on_success,
+                                                            (ply_boot_client_response_handler_t)
+                                                            on_failure, &state);
+        } else if (should_hide_splash) {
+                ply_boot_client_tell_daemon_to_hide_splash (state.client,
+                                                            (ply_boot_client_response_handler_t)
+                                                            on_success,
+                                                            (ply_boot_client_response_handler_t)
+                                                            on_failure, &state);
+        } else if (should_quit) {
+                ply_boot_client_tell_daemon_to_quit (state.client,
+                                                     false,
+                                                     (ply_boot_client_response_handler_t)
+                                                     on_success,
+                                                     (ply_boot_client_response_handler_t)
+                                                     on_failure, &state);
+        } else if (should_ping) {
+                ply_boot_client_ping_daemon (state.client,
                                              (ply_boot_client_response_handler_t)
                                              on_success,
                                              (ply_boot_client_response_handler_t)
                                              on_failure, &state);
+        } else if (should_check_for_active_vt) {
+                ply_boot_client_ask_daemon_has_active_vt (state.client,
+                                                          (ply_boot_client_response_handler_t)
+                                                          on_success,
+                                                          (ply_boot_client_response_handler_t)
+                                                          on_failure, &state);
+        } else if (status != NULL) {
+                ply_boot_client_update_daemon (state.client, status,
+                                               (ply_boot_client_response_handler_t)
+                                               on_success,
+                                               (ply_boot_client_response_handler_t)
+                                               on_failure, &state);
+        } else if (should_ask_for_password) {
+                password_answer_state_t answer_state = { 0 };
+
+                answer_state.state = &state;
+                answer_state.number_of_tries_left = 1;
+                ply_boot_client_ask_daemon_for_password (state.client,
+                                                         NULL,
+                                                         (ply_boot_client_answer_handler_t)
+                                                         on_password_answer,
+                                                         (ply_boot_client_response_handler_t)
+                                                         on_password_answer_failure, &answer_state);
+        } else if (ignore_keystroke) {
+                ply_boot_client_ask_daemon_to_ignore_keystroke (state.client,
+                                                                ignore_keystroke,
+                                                                (ply_boot_client_answer_handler_t)
+                                                                on_success,
+                                                                (ply_boot_client_response_handler_t)
+                                                                on_failure, &state);
+        } else if (should_sysinit) {
+                ply_boot_client_tell_daemon_system_is_initialized (state.client,
+                                                                   (ply_boot_client_response_handler_t)
+                                                                   on_success,
+                                                                   (ply_boot_client_response_handler_t)
+                                                                   on_failure, &state);
+        } else if (chroot_dir) {
+                ply_boot_client_tell_daemon_to_change_root (state.client, chroot_dir,
+                                                            (ply_boot_client_response_handler_t)
+                                                            on_success,
+                                                            (ply_boot_client_response_handler_t)
+                                                            on_failure, &state);
+        } else if (should_wait) {
+        } // Do nothing
+        else if (report_error) {
+                ply_boot_client_tell_daemon_about_error (state.client,
+                                                         (ply_boot_client_response_handler_t)
+                                                         on_success,
+                                                         (ply_boot_client_response_handler_t)
+                                                         on_failure, &state);
+        }
 
-  exit_code = ply_event_loop_run (state.loop);
+        exit_code = ply_event_loop_run (state.loop);
 
-  ply_boot_client_free (state.client);
+        ply_boot_client_free (state.client);
 
-  ply_event_loop_free (state.loop);
+        ply_event_loop_free (state.loop);
 
-  return exit_code;
+        return exit_code;
 }
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-core/ply-boot-splash-plugin.h b/src/libply-splash-core/ply-boot-splash-plugin.h
index 2d73d66..710047e 100644
--- a/src/libply-splash-core/ply-boot-splash-plugin.h
+++ b/src/libply-splash-core/ply-boot-splash-plugin.h
@@ -36,61 +36,61 @@
 
 typedef enum
 {
-  PLY_BOOT_SPLASH_MODE_BOOT_UP,
-  PLY_BOOT_SPLASH_MODE_SHUTDOWN,
-  PLY_BOOT_SPLASH_MODE_UPDATES,
-  PLY_BOOT_SPLASH_MODE_INVALID
+        PLY_BOOT_SPLASH_MODE_BOOT_UP,
+        PLY_BOOT_SPLASH_MODE_SHUTDOWN,
+        PLY_BOOT_SPLASH_MODE_UPDATES,
+        PLY_BOOT_SPLASH_MODE_INVALID
 } ply_boot_splash_mode_t;
 
 typedef struct _ply_boot_splash_plugin ply_boot_splash_plugin_t;
 
 typedef struct
 {
-  ply_boot_splash_plugin_t * (* create_plugin) (ply_key_file_t *key_file);
-  void (* destroy_plugin) (ply_boot_splash_plugin_t *plugin);
+        ply_boot_splash_plugin_t * (*create_plugin)(ply_key_file_t * key_file);
+        void (*destroy_plugin)(ply_boot_splash_plugin_t *plugin);
 
-  void (* set_keyboard) (ply_boot_splash_plugin_t *plugin,
-                         ply_keyboard_t           *keyboard);
-  void (* unset_keyboard) (ply_boot_splash_plugin_t *plugin,
-                           ply_keyboard_t           *keyboard);
-  void (* add_pixel_display) (ply_boot_splash_plugin_t *plugin,
-                              ply_pixel_display_t      *display);
-  void (* remove_pixel_display) (ply_boot_splash_plugin_t *plugin,
-                                 ply_pixel_display_t      *display);
-  void (* add_text_display) (ply_boot_splash_plugin_t *plugin,
-                             ply_text_display_t       *display);
-  void (* remove_text_display) (ply_boot_splash_plugin_t *plugin,
-                                ply_text_display_t       *display);
-  bool (* show_splash_screen) (ply_boot_splash_plugin_t *plugin,
-                               ply_event_loop_t         *loop,
-                               ply_buffer_t             *boot_buffer,
-                               ply_boot_splash_mode_t    mode);
-  void (* system_update) (ply_boot_splash_plugin_t *plugin,
-                          int                       progress);
-  void (* update_status) (ply_boot_splash_plugin_t *plugin,
-                          const char               *status);
-  void (* on_boot_output) (ply_boot_splash_plugin_t *plugin,
-                           const char               *output,
-                           size_t                    size);
-  void (* on_boot_progress) (ply_boot_splash_plugin_t *plugin,
-                             double                    duration,
-                             double                    percent_done);
-  void (* on_root_mounted) (ply_boot_splash_plugin_t *plugin);
-  void (* hide_splash_screen) (ply_boot_splash_plugin_t *plugin,
-                               ply_event_loop_t         *loop);
-  void (* display_message) (ply_boot_splash_plugin_t *plugin,
-                            const char               *message);
-  void (* hide_message) (ply_boot_splash_plugin_t *plugin,
-                         const char               *message);
-  void (* display_normal) (ply_boot_splash_plugin_t *plugin);
-  void (* display_password) (ply_boot_splash_plugin_t *plugin,
-                             const char               *prompt,
-                             int                       bullets);
-  void (* display_question) (ply_boot_splash_plugin_t *plugin,
-                             const char               *prompt,
-                             const char               *entry_text);
-  void (* become_idle) (ply_boot_splash_plugin_t       *plugin,
-                        ply_trigger_t                  *idle_trigger);
+        void (*set_keyboard)(ply_boot_splash_plugin_t *plugin,
+                             ply_keyboard_t           *keyboard);
+        void (*unset_keyboard)(ply_boot_splash_plugin_t *plugin,
+                               ply_keyboard_t           *keyboard);
+        void (*add_pixel_display)(ply_boot_splash_plugin_t *plugin,
+                                  ply_pixel_display_t      *display);
+        void (*remove_pixel_display)(ply_boot_splash_plugin_t *plugin,
+                                     ply_pixel_display_t      *display);
+        void (*add_text_display)(ply_boot_splash_plugin_t *plugin,
+                                 ply_text_display_t       *display);
+        void (*remove_text_display)(ply_boot_splash_plugin_t *plugin,
+                                    ply_text_display_t       *display);
+        bool (*show_splash_screen)(ply_boot_splash_plugin_t *plugin,
+                                   ply_event_loop_t         *loop,
+                                   ply_buffer_t             *boot_buffer,
+                                   ply_boot_splash_mode_t    mode);
+        void (*system_update)(ply_boot_splash_plugin_t *plugin,
+                              int                       progress);
+        void (*update_status)(ply_boot_splash_plugin_t *plugin,
+                              const char               *status);
+        void (*on_boot_output)(ply_boot_splash_plugin_t *plugin,
+                               const char               *output,
+                               size_t                    size);
+        void (*on_boot_progress)(ply_boot_splash_plugin_t *plugin,
+                                 double                    duration,
+                                 double                    percent_done);
+        void (*on_root_mounted)(ply_boot_splash_plugin_t *plugin);
+        void (*hide_splash_screen)(ply_boot_splash_plugin_t *plugin,
+                                   ply_event_loop_t         *loop);
+        void (*display_message)(ply_boot_splash_plugin_t *plugin,
+                                const char               *message);
+        void (*hide_message)(ply_boot_splash_plugin_t *plugin,
+                             const char               *message);
+        void (*display_normal)(ply_boot_splash_plugin_t *plugin);
+        void (*display_password)(ply_boot_splash_plugin_t *plugin,
+                                 const char               *prompt,
+                                 int                       bullets);
+        void (*display_question)(ply_boot_splash_plugin_t *plugin,
+                                 const char               *prompt,
+                                 const char               *entry_text);
+        void (*become_idle)(ply_boot_splash_plugin_t *plugin,
+                            ply_trigger_t            *idle_trigger);
 } ply_boot_splash_plugin_interface_t;
 
 #endif /* PLY_BOOT_SPLASH_PLUGIN_H */
diff --git a/src/libply-splash-core/ply-boot-splash.c b/src/libply-splash-core/ply-boot-splash.c
index 160ce45..310d4d5 100644
--- a/src/libply-splash-core/ply-boot-splash.c
+++ b/src/libply-splash-core/ply-boot-splash.c
@@ -50,517 +50,493 @@
 
 struct _ply_boot_splash
 {
-  ply_event_loop_t *loop;
-  ply_module_handle_t *module_handle;
-  const ply_boot_splash_plugin_interface_t *plugin_interface;
-  ply_boot_splash_plugin_t *plugin;
-  ply_boot_splash_mode_t mode;
-  ply_buffer_t *boot_buffer;
-  ply_trigger_t *idle_trigger;
-  ply_list_t *seats;
-
-  char *theme_path;
-  char *plugin_dir;
-  char *status;
-
-  ply_progress_t *progress;
-  ply_boot_splash_on_idle_handler_t idle_handler;
-  void *idle_handler_user_data;
-
-  uint32_t is_loaded : 1;
-  uint32_t should_force_text_mode : 1;
+        ply_event_loop_t                         *loop;
+        ply_module_handle_t                      *module_handle;
+        const ply_boot_splash_plugin_interface_t *plugin_interface;
+        ply_boot_splash_plugin_t                 *plugin;
+        ply_boot_splash_mode_t                    mode;
+        ply_buffer_t                             *boot_buffer;
+        ply_trigger_t                            *idle_trigger;
+        ply_list_t                               *seats;
+
+        char                                     *theme_path;
+        char                                     *plugin_dir;
+        char                                     *status;
+
+        ply_progress_t                           *progress;
+        ply_boot_splash_on_idle_handler_t         idle_handler;
+        void                                     *idle_handler_user_data;
+
+        uint32_t                                  is_loaded : 1;
+        uint32_t                                  should_force_text_mode : 1;
 };
 
 typedef const ply_boot_splash_plugin_interface_t *
-        (* get_plugin_interface_function_t) (void);
+(*get_plugin_interface_function_t) (void);
 
 static void ply_boot_splash_update_progress (ply_boot_splash_t *splash);
 static void ply_boot_splash_detach_from_event_loop (ply_boot_splash_t *splash);
 
 ply_boot_splash_t *
-ply_boot_splash_new (const char     *theme_path,
-                     const char     *plugin_dir,
-                     ply_buffer_t   *boot_buffer)
+ply_boot_splash_new (const char   *theme_path,
+                     const char   *plugin_dir,
+                     ply_buffer_t *boot_buffer)
 {
-  ply_boot_splash_t *splash;
+        ply_boot_splash_t *splash;
 
-  assert (theme_path != NULL);
+        assert (theme_path != NULL);
 
-  splash = calloc (1, sizeof (ply_boot_splash_t));
-  splash->loop = NULL;
-  splash->theme_path = strdup (theme_path);
-  splash->plugin_dir = strdup (plugin_dir);
-  splash->module_handle = NULL;
-  splash->mode = PLY_BOOT_SPLASH_MODE_INVALID;
+        splash = calloc (1, sizeof(ply_boot_splash_t));
+        splash->loop = NULL;
+        splash->theme_path = strdup (theme_path);
+        splash->plugin_dir = strdup (plugin_dir);
+        splash->module_handle = NULL;
+        splash->mode = PLY_BOOT_SPLASH_MODE_INVALID;
 
-  splash->boot_buffer = boot_buffer;
-  splash->seats = ply_list_new ();
+        splash->boot_buffer = boot_buffer;
+        splash->seats = ply_list_new ();
 
-  return splash;
+        return splash;
 }
 
 static void
 detach_from_seat (ply_boot_splash_t *splash,
                   ply_seat_t        *seat)
 {
-  ply_keyboard_t *keyboard;
-  ply_list_t *displays;
-  ply_list_node_t *node, *next_node;
-
-  ply_trace ("removing keyboard");
-  if (splash->plugin_interface->unset_keyboard != NULL)
-    {
-      keyboard = ply_seat_get_keyboard (seat);
-      splash->plugin_interface->unset_keyboard (splash->plugin, keyboard);
-    }
+        ply_keyboard_t *keyboard;
+        ply_list_t *displays;
+        ply_list_node_t *node, *next_node;
+
+        ply_trace ("removing keyboard");
+        if (splash->plugin_interface->unset_keyboard != NULL) {
+                keyboard = ply_seat_get_keyboard (seat);
+                splash->plugin_interface->unset_keyboard (splash->plugin, keyboard);
+        }
 
-  ply_trace ("removing pixel displays");
-  displays = ply_seat_get_pixel_displays (seat);
+        ply_trace ("removing pixel displays");
+        displays = ply_seat_get_pixel_displays (seat);
 
-  node = ply_list_get_first_node (displays);
-  while (node != NULL)
-    {
-      ply_pixel_display_t *display;
-      ply_list_node_t *next_node;
-      unsigned long width, height;
+        node = ply_list_get_first_node (displays);
+        while (node != NULL) {
+                ply_pixel_display_t *display;
+                ply_list_node_t *next_node;
+                unsigned long width, height;
 
-      display = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (displays, node);
+                display = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (displays, node);
 
-      width = ply_pixel_display_get_width (display);
-      height = ply_pixel_display_get_height (display);
+                width = ply_pixel_display_get_width (display);
+                height = ply_pixel_display_get_height (display);
 
-      ply_trace ("Removing %lux%lu pixel display", width, height);
+                ply_trace ("Removing %lux%lu pixel display", width, height);
 
-      if (splash->plugin_interface->remove_pixel_display != NULL)
-        splash->plugin_interface->remove_pixel_display (splash->plugin, display);
+                if (splash->plugin_interface->remove_pixel_display != NULL)
+                        splash->plugin_interface->remove_pixel_display (splash->plugin, display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  ply_trace ("removing text displays");
-  displays = ply_seat_get_text_displays (seat);
+        ply_trace ("removing text displays");
+        displays = ply_seat_get_text_displays (seat);
 
-  node = ply_list_get_first_node (displays);
-  while (node != NULL)
-    {
-      ply_text_display_t *display;
-      int number_of_columns, number_of_rows;
+        node = ply_list_get_first_node (displays);
+        while (node != NULL) {
+                ply_text_display_t *display;
+                int number_of_columns, number_of_rows;
 
-      display = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (displays, node);
+                display = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (displays, node);
 
-      number_of_columns = ply_text_display_get_number_of_columns (display);
-      number_of_rows = ply_text_display_get_number_of_rows (display);
+                number_of_columns = ply_text_display_get_number_of_columns (display);
+                number_of_rows = ply_text_display_get_number_of_rows (display);
 
-      ply_trace ("Removing %dx%d text display", number_of_columns, number_of_rows);
+                ply_trace ("Removing %dx%d text display", number_of_columns, number_of_rows);
 
-      if (splash->plugin_interface->remove_text_display != NULL)
-        splash->plugin_interface->remove_text_display (splash->plugin, display);
+                if (splash->plugin_interface->remove_text_display != NULL)
+                        splash->plugin_interface->remove_text_display (splash->plugin, display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 attach_to_seat (ply_boot_splash_t *splash,
                 ply_seat_t        *seat)
 {
-  ply_keyboard_t *keyboard;
-  ply_list_t *displays;
-  ply_list_node_t *node, *next_node;
+        ply_keyboard_t *keyboard;
+        ply_list_t *displays;
+        ply_list_node_t *node, *next_node;
 
-  if (splash->plugin_interface->set_keyboard != NULL)
-    {
-      keyboard = ply_seat_get_keyboard (seat);
-      splash->plugin_interface->set_keyboard (splash->plugin, keyboard);
-    }
+        if (splash->plugin_interface->set_keyboard != NULL) {
+                keyboard = ply_seat_get_keyboard (seat);
+                splash->plugin_interface->set_keyboard (splash->plugin, keyboard);
+        }
 
-  if (splash->plugin_interface->add_pixel_display != NULL)
-    {
-      displays = ply_seat_get_pixel_displays (seat);
+        if (splash->plugin_interface->add_pixel_display != NULL) {
+                displays = ply_seat_get_pixel_displays (seat);
 
-      ply_trace ("adding pixel displays");
-      node = ply_list_get_first_node (displays);
-      while (node != NULL)
-        {
-          ply_pixel_display_t *display;
-          ply_list_node_t *next_node;
-          unsigned long width, height;
+                ply_trace ("adding pixel displays");
+                node = ply_list_get_first_node (displays);
+                while (node != NULL) {
+                        ply_pixel_display_t *display;
+                        ply_list_node_t *next_node;
+                        unsigned long width, height;
 
-          display = ply_list_node_get_data (node);
-          next_node = ply_list_get_next_node (displays, node);
+                        display = ply_list_node_get_data (node);
+                        next_node = ply_list_get_next_node (displays, node);
 
-          width = ply_pixel_display_get_width (display);
-          height = ply_pixel_display_get_height (display);
+                        width = ply_pixel_display_get_width (display);
+                        height = ply_pixel_display_get_height (display);
 
-          ply_trace ("Adding %lux%lu pixel display", width, height);
+                        ply_trace ("Adding %lux%lu pixel display", width, height);
 
-          splash->plugin_interface->add_pixel_display (splash->plugin, display);
+                        splash->plugin_interface->add_pixel_display (splash->plugin, display);
 
-          node = next_node;
+                        node = next_node;
+                }
         }
-    }
 
-  if (splash->plugin_interface->add_text_display != NULL)
-    {
-      displays = ply_seat_get_text_displays (seat);
+        if (splash->plugin_interface->add_text_display != NULL) {
+                displays = ply_seat_get_text_displays (seat);
 
-      ply_trace ("adding text displays");
-      node = ply_list_get_first_node (displays);
-      while (node != NULL)
-        {
-          ply_text_display_t *display;
-          int number_of_columns, number_of_rows;
+                ply_trace ("adding text displays");
+                node = ply_list_get_first_node (displays);
+                while (node != NULL) {
+                        ply_text_display_t *display;
+                        int number_of_columns, number_of_rows;
 
-          display = ply_list_node_get_data (node);
-          next_node = ply_list_get_next_node (displays, node);
+                        display = ply_list_node_get_data (node);
+                        next_node = ply_list_get_next_node (displays, node);
 
-          number_of_columns = ply_text_display_get_number_of_columns (display);
-          number_of_rows = ply_text_display_get_number_of_rows (display);
+                        number_of_columns = ply_text_display_get_number_of_columns (display);
+                        number_of_rows = ply_text_display_get_number_of_rows (display);
 
-          ply_trace ("Adding %dx%d text display", number_of_columns, number_of_rows);
+                        ply_trace ("Adding %dx%d text display", number_of_columns, number_of_rows);
 
-          splash->plugin_interface->add_text_display (splash->plugin, display);
+                        splash->plugin_interface->add_text_display (splash->plugin, display);
 
-          node = next_node;
+                        node = next_node;
+                }
         }
-    }
 }
 
 void
 ply_boot_splash_attach_to_seat (ply_boot_splash_t *splash,
                                 ply_seat_t        *seat)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_find_node (splash->seats, seat);
+        node = ply_list_find_node (splash->seats, seat);
 
-  if (node != NULL)
-    return;
+        if (node != NULL)
+                return;
 
-  ply_list_append_data (splash->seats, seat);
-  attach_to_seat (splash, seat);
+        ply_list_append_data (splash->seats, seat);
+        attach_to_seat (splash, seat);
 }
 
 void
 ply_boot_splash_detach_from_seat (ply_boot_splash_t *splash,
                                   ply_seat_t        *seat)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_find_node (splash->seats, seat);
+        node = ply_list_find_node (splash->seats, seat);
 
-  if (node == NULL)
-    return;
+        if (node == NULL)
+                return;
 
-  ply_list_remove_data (splash->seats, seat);
-  detach_from_seat (splash, seat);
+        ply_list_remove_data (splash->seats, seat);
+        detach_from_seat (splash, seat);
 }
 
 bool
 ply_boot_splash_load (ply_boot_splash_t *splash)
 {
-  ply_key_file_t *key_file;
-  char *module_name;
-  char *module_path;
+        ply_key_file_t *key_file;
+        char *module_name;
+        char *module_path;
 
-  assert (splash != NULL);
+        assert (splash != NULL);
 
-  get_plugin_interface_function_t get_boot_splash_plugin_interface;
+        get_plugin_interface_function_t get_boot_splash_plugin_interface;
 
-  key_file = ply_key_file_new (splash->theme_path);
+        key_file = ply_key_file_new (splash->theme_path);
 
-  if (!ply_key_file_load (key_file))
-    return false;
+        if (!ply_key_file_load (key_file))
+                return false;
 
-  module_name = ply_key_file_get_value (key_file, "Plymouth Theme", "ModuleName");
+        module_name = ply_key_file_get_value (key_file, "Plymouth Theme", "ModuleName");
 
-  asprintf (&module_path, "%s%s.so",
-            splash->plugin_dir, module_name);
-  free (module_name);
+        asprintf (&module_path, "%s%s.so",
+                  splash->plugin_dir, module_name);
+        free (module_name);
 
-  splash->module_handle = ply_open_module (module_path);
+        splash->module_handle = ply_open_module (module_path);
 
-  free (module_path);
+        free (module_path);
 
-  if (splash->module_handle == NULL)
-    {
-      ply_key_file_free (key_file);
-      return false;
-    }
-
-  get_boot_splash_plugin_interface = (get_plugin_interface_function_t)
-      ply_module_look_up_function (splash->module_handle,
-                                   "ply_boot_splash_plugin_get_interface");
+        if (splash->module_handle == NULL) {
+                ply_key_file_free (key_file);
+                return false;
+        }
 
-  if (get_boot_splash_plugin_interface == NULL)
-    {
-      ply_save_errno ();
-      ply_close_module (splash->module_handle);
-      splash->module_handle = NULL;
-      ply_key_file_free (key_file);
-      ply_restore_errno ();
-      return false;
-    }
+        get_boot_splash_plugin_interface = (get_plugin_interface_function_t)
+                                           ply_module_look_up_function (splash->module_handle,
+                                                                        "ply_boot_splash_plugin_get_interface");
+
+        if (get_boot_splash_plugin_interface == NULL) {
+                ply_save_errno ();
+                ply_close_module (splash->module_handle);
+                splash->module_handle = NULL;
+                ply_key_file_free (key_file);
+                ply_restore_errno ();
+                return false;
+        }
 
-  splash->plugin_interface = get_boot_splash_plugin_interface ();
+        splash->plugin_interface = get_boot_splash_plugin_interface ();
 
-  if (splash->plugin_interface == NULL)
-    {
-      ply_save_errno ();
-      ply_close_module (splash->module_handle);
-      splash->module_handle = NULL;
-      ply_key_file_free (key_file);
-      ply_restore_errno ();
-      return false;
-    }
+        if (splash->plugin_interface == NULL) {
+                ply_save_errno ();
+                ply_close_module (splash->module_handle);
+                splash->module_handle = NULL;
+                ply_key_file_free (key_file);
+                ply_restore_errno ();
+                return false;
+        }
 
-  splash->plugin = splash->plugin_interface->create_plugin (key_file);
+        splash->plugin = splash->plugin_interface->create_plugin (key_file);
 
-  ply_key_file_free (key_file);
+        ply_key_file_free (key_file);
 
-  assert (splash->plugin != NULL);
+        assert (splash->plugin != NULL);
 
-  splash->is_loaded = true;
+        splash->is_loaded = true;
 
-  return true;
+        return true;
 }
 
 bool
 ply_boot_splash_load_built_in (ply_boot_splash_t *splash)
 {
-  get_plugin_interface_function_t get_boot_splash_plugin_interface;
+        get_plugin_interface_function_t get_boot_splash_plugin_interface;
 
-  assert (splash != NULL);
+        assert (splash != NULL);
 
-  splash->module_handle = ply_open_built_in_module ();
+        splash->module_handle = ply_open_built_in_module ();
 
-  if (splash->module_handle == NULL)
-    return false;
+        if (splash->module_handle == NULL)
+                return false;
 
-  get_boot_splash_plugin_interface = (get_plugin_interface_function_t)
-      ply_module_look_up_function (splash->module_handle,
-                                   "ply_boot_splash_plugin_get_interface");
+        get_boot_splash_plugin_interface = (get_plugin_interface_function_t)
+                                           ply_module_look_up_function (splash->module_handle,
+                                                                        "ply_boot_splash_plugin_get_interface");
 
-  if (get_boot_splash_plugin_interface == NULL)
-    {
-      ply_save_errno ();
-      ply_close_module (splash->module_handle);
-      splash->module_handle = NULL;
-      ply_restore_errno ();
-      return false;
-    }
+        if (get_boot_splash_plugin_interface == NULL) {
+                ply_save_errno ();
+                ply_close_module (splash->module_handle);
+                splash->module_handle = NULL;
+                ply_restore_errno ();
+                return false;
+        }
 
-  splash->plugin_interface = get_boot_splash_plugin_interface ();
+        splash->plugin_interface = get_boot_splash_plugin_interface ();
 
-  if (splash->plugin_interface == NULL)
-    {
-      ply_save_errno ();
-      ply_close_module (splash->module_handle);
-      splash->module_handle = NULL;
-      ply_restore_errno ();
-      return false;
-    }
+        if (splash->plugin_interface == NULL) {
+                ply_save_errno ();
+                ply_close_module (splash->module_handle);
+                splash->module_handle = NULL;
+                ply_restore_errno ();
+                return false;
+        }
 
-  splash->plugin = splash->plugin_interface->create_plugin (NULL);
+        splash->plugin = splash->plugin_interface->create_plugin (NULL);
 
-  assert (splash->plugin != NULL);
+        assert (splash->plugin != NULL);
 
-  splash->is_loaded = true;
+        splash->is_loaded = true;
 
-  return true;
+        return true;
 }
 
 void
 ply_boot_splash_unload (ply_boot_splash_t *splash)
 {
-  assert (splash != NULL);
-  assert (splash->plugin != NULL);
-  assert (splash->plugin_interface != NULL);
-  assert (splash->module_handle != NULL);
+        assert (splash != NULL);
+        assert (splash->plugin != NULL);
+        assert (splash->plugin_interface != NULL);
+        assert (splash->module_handle != NULL);
 
-  splash->plugin_interface->destroy_plugin (splash->plugin);
-  splash->plugin = NULL;
+        splash->plugin_interface->destroy_plugin (splash->plugin);
+        splash->plugin = NULL;
 
-  ply_close_module (splash->module_handle);
-  splash->plugin_interface = NULL;
-  splash->module_handle = NULL;
+        ply_close_module (splash->module_handle);
+        splash->plugin_interface = NULL;
+        splash->module_handle = NULL;
 
-  splash->is_loaded = false;
+        splash->is_loaded = false;
 }
 
 static void
 detach_from_seats (ply_boot_splash_t *splash)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("detaching from seats");
+        ply_trace ("detaching from seats");
 
-  node = ply_list_get_first_node (splash->seats);
-  while (node != NULL)
-    {
-      ply_seat_t *seat;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (splash->seats);
+        while (node != NULL) {
+                ply_seat_t *seat;
+                ply_list_node_t *next_node;
 
-      seat = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (splash->seats, node);
+                seat = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (splash->seats, node);
 
-      detach_from_seat (splash, seat);
+                detach_from_seat (splash, seat);
 
-      ply_list_remove_node (splash->seats, node);
+                ply_list_remove_node (splash->seats, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 void
 ply_boot_splash_free (ply_boot_splash_t *splash)
 {
-  ply_trace ("freeing splash");
-  if (splash == NULL)
-    return;
-
-  if (splash->loop != NULL)
-    {
-      if (splash->plugin_interface->on_boot_progress != NULL)
-        {
-          ply_event_loop_stop_watching_for_timeout (splash->loop,
-                                                    (ply_event_loop_timeout_handler_t)
-                                                    ply_boot_splash_update_progress, splash);
+        ply_trace ("freeing splash");
+        if (splash == NULL)
+                return;
+
+        if (splash->loop != NULL) {
+                if (splash->plugin_interface->on_boot_progress != NULL) {
+                        ply_event_loop_stop_watching_for_timeout (splash->loop,
+                                                                  (ply_event_loop_timeout_handler_t)
+                                                                  ply_boot_splash_update_progress, splash);
+                }
+
+                ply_event_loop_stop_watching_for_exit (splash->loop, (ply_event_loop_exit_handler_t)
+                                                       ply_boot_splash_detach_from_event_loop,
+                                                       splash);
         }
 
-      ply_event_loop_stop_watching_for_exit (splash->loop, (ply_event_loop_exit_handler_t)
-                                             ply_boot_splash_detach_from_event_loop,
-                                             splash);
-    }
-
-  detach_from_seats (splash);
-  ply_list_free (splash->seats);
+        detach_from_seats (splash);
+        ply_list_free (splash->seats);
 
-  if (splash->module_handle != NULL)
-    ply_boot_splash_unload (splash);
+        if (splash->module_handle != NULL)
+                ply_boot_splash_unload (splash);
 
-  if (splash->idle_trigger != NULL)
-    ply_trigger_free (splash->idle_trigger);
+        if (splash->idle_trigger != NULL)
+                ply_trigger_free (splash->idle_trigger);
 
-  free (splash->theme_path);
-  free (splash->plugin_dir);
-  free (splash);
+        free (splash->theme_path);
+        free (splash->plugin_dir);
+        free (splash);
 }
 
 static void
 ply_boot_splash_update_progress (ply_boot_splash_t *splash)
 {
-  double percentage=0.0;
-  double time=0.0;
-
-  assert (splash != NULL);
-
-  if (splash->progress)
-    {
-      percentage = ply_progress_get_percentage(splash->progress);
-      time = ply_progress_get_time(splash->progress);
-    }
-
-  if (splash->plugin_interface->on_boot_progress != NULL)
-    splash->plugin_interface->on_boot_progress (splash->plugin,
-                                                time,
-                                                percentage);
-
-  ply_event_loop_watch_for_timeout (splash->loop,
-                                   1.0 / UPDATES_PER_SECOND,
-                                   (ply_event_loop_timeout_handler_t)
-                                   ply_boot_splash_update_progress, splash);
+        double percentage = 0.0;
+        double time = 0.0;
+
+        assert (splash != NULL);
+
+        if (splash->progress) {
+                percentage = ply_progress_get_percentage (splash->progress);
+                time = ply_progress_get_time (splash->progress);
+        }
+
+        if (splash->plugin_interface->on_boot_progress != NULL)
+                splash->plugin_interface->on_boot_progress (splash->plugin,
+                                                            time,
+                                                            percentage);
+
+        ply_event_loop_watch_for_timeout (splash->loop,
+                                          1.0 / UPDATES_PER_SECOND,
+                                          (ply_event_loop_timeout_handler_t)
+                                          ply_boot_splash_update_progress, splash);
 }
 
 void
 ply_boot_splash_attach_progress (ply_boot_splash_t *splash,
-                                      ply_progress_t    *progress)
+                                 ply_progress_t    *progress)
 {
-  assert (splash != NULL);
-  assert (progress != NULL);
-  assert (splash->progress == NULL);
-  splash->progress = progress;
+        assert (splash != NULL);
+        assert (progress != NULL);
+        assert (splash->progress == NULL);
+        splash->progress = progress;
 }
 
 
 bool
-ply_boot_splash_show (ply_boot_splash_t *splash,
+ply_boot_splash_show (ply_boot_splash_t     *splash,
                       ply_boot_splash_mode_t mode)
 {
-  assert (splash != NULL);
-  assert (mode != PLY_BOOT_SPLASH_MODE_INVALID);
-  assert (splash->module_handle != NULL);
-  assert (splash->loop != NULL);
-  assert (splash->plugin_interface != NULL);
-  assert (splash->plugin != NULL);
-  assert (splash->plugin_interface->show_splash_screen != NULL);
-
-  if (splash->mode == mode)
-    {
-      ply_trace ("already set same splash screen mode");
-      return true;
-    }
-  else if (splash->mode != PLY_BOOT_SPLASH_MODE_INVALID)
-    {
-      splash->plugin_interface->hide_splash_screen (splash->plugin,
-                                                    splash->loop);
-    }
-
-  ply_trace ("showing splash screen");
-  if (!splash->plugin_interface->show_splash_screen (splash->plugin,
-                                                     splash->loop,
-                                                     splash->boot_buffer,
-                                                     mode))
-    {
-
-      ply_save_errno ();
-      ply_trace ("can't show splash: %m");
-      ply_restore_errno ();
-      return false;
-    }
-
-  if (splash->plugin_interface->on_boot_progress != NULL)
-    {
-      ply_boot_splash_update_progress (splash);
-    }
-
-  splash->mode = mode;
-  return true;
+        assert (splash != NULL);
+        assert (mode != PLY_BOOT_SPLASH_MODE_INVALID);
+        assert (splash->module_handle != NULL);
+        assert (splash->loop != NULL);
+        assert (splash->plugin_interface != NULL);
+        assert (splash->plugin != NULL);
+        assert (splash->plugin_interface->show_splash_screen != NULL);
+
+        if (splash->mode == mode) {
+                ply_trace ("already set same splash screen mode");
+                return true;
+        } else if (splash->mode != PLY_BOOT_SPLASH_MODE_INVALID) {
+                splash->plugin_interface->hide_splash_screen (splash->plugin,
+                                                              splash->loop);
+        }
+
+        ply_trace ("showing splash screen");
+        if (!splash->plugin_interface->show_splash_screen (splash->plugin,
+                                                           splash->loop,
+                                                           splash->boot_buffer,
+                                                           mode)) {
+                ply_save_errno ();
+                ply_trace ("can't show splash: %m");
+                ply_restore_errno ();
+                return false;
+        }
+
+        if (splash->plugin_interface->on_boot_progress != NULL)
+                ply_boot_splash_update_progress (splash);
+
+        splash->mode = mode;
+        return true;
 }
 
 bool
 ply_boot_splash_system_update (ply_boot_splash_t *splash,
                                int                progress)
 {
-  assert (splash != NULL);
-  assert (splash->module_handle != NULL);
-  assert (splash->loop != NULL);
-  assert (splash->plugin_interface != NULL);
-  assert (splash->plugin != NULL);
-
-  if (splash->plugin_interface->system_update == NULL)
-    return false;
-
-  ply_trace ("updating system %i%%", progress);
-  splash->plugin_interface->system_update (splash->plugin,
-                                           progress);
-  return true;
+        assert (splash != NULL);
+        assert (splash->module_handle != NULL);
+        assert (splash->loop != NULL);
+        assert (splash->plugin_interface != NULL);
+        assert (splash->plugin != NULL);
+
+        if (splash->plugin_interface->system_update == NULL)
+                return false;
+
+        ply_trace ("updating system %i%%", progress);
+        splash->plugin_interface->system_update (splash->plugin,
+                                                 progress);
+        return true;
 }
 
 void
 ply_boot_splash_update_status (ply_boot_splash_t *splash,
                                const char        *status)
 {
-  assert (splash != NULL);
-  assert (status != NULL);
-  assert (splash->plugin_interface != NULL);
-  assert (splash->plugin != NULL);
-  assert (splash->plugin_interface->update_status != NULL);
-  assert (splash->mode != PLY_BOOT_SPLASH_MODE_INVALID);
-
-  splash->plugin_interface->update_status (splash->plugin, status);
+        assert (splash != NULL);
+        assert (status != NULL);
+        assert (splash->plugin_interface != NULL);
+        assert (splash->plugin != NULL);
+        assert (splash->plugin_interface->update_status != NULL);
+        assert (splash->mode != PLY_BOOT_SPLASH_MODE_INVALID);
+
+        splash->plugin_interface->update_status (splash->plugin, status);
 }
 
 void
@@ -568,107 +544,105 @@ ply_boot_splash_update_output (ply_boot_splash_t *splash,
                                const char        *output,
                                size_t             size)
 {
-  assert (splash != NULL);
-  assert (output != NULL);
+        assert (splash != NULL);
+        assert (output != NULL);
 
-  if (splash->plugin_interface->on_boot_output != NULL)
-    splash->plugin_interface->on_boot_output (splash->plugin, output, size);
+        if (splash->plugin_interface->on_boot_output != NULL)
+                splash->plugin_interface->on_boot_output (splash->plugin, output, size);
 }
 
 void
 ply_boot_splash_root_mounted (ply_boot_splash_t *splash)
 {
-  assert (splash != NULL);
+        assert (splash != NULL);
 
-  if (splash->plugin_interface->on_root_mounted != NULL)
-    splash->plugin_interface->on_root_mounted (splash->plugin);
+        if (splash->plugin_interface->on_root_mounted != NULL)
+                splash->plugin_interface->on_root_mounted (splash->plugin);
 }
 
 static void
 ply_boot_splash_detach_from_event_loop (ply_boot_splash_t *splash)
 {
-  assert (splash != NULL);
-  splash->loop = NULL;
+        assert (splash != NULL);
+        splash->loop = NULL;
 }
 
 void
 ply_boot_splash_hide (ply_boot_splash_t *splash)
 {
-  assert (splash != NULL);
-  assert (splash->plugin_interface != NULL);
-  assert (splash->plugin != NULL);
-  assert (splash->plugin_interface->hide_splash_screen != NULL);
-
-  splash->plugin_interface->hide_splash_screen (splash->plugin,
-                                                splash->loop);
-
-  splash->mode = PLY_BOOT_SPLASH_MODE_INVALID;
-
-  if (splash->loop != NULL)
-    {
-      if (splash->plugin_interface->on_boot_progress != NULL)
-        {
-          ply_event_loop_stop_watching_for_timeout (splash->loop,
-                                                    (ply_event_loop_timeout_handler_t)
-                                                    ply_boot_splash_update_progress, splash);
+        assert (splash != NULL);
+        assert (splash->plugin_interface != NULL);
+        assert (splash->plugin != NULL);
+        assert (splash->plugin_interface->hide_splash_screen != NULL);
+
+        splash->plugin_interface->hide_splash_screen (splash->plugin,
+                                                      splash->loop);
+
+        splash->mode = PLY_BOOT_SPLASH_MODE_INVALID;
+
+        if (splash->loop != NULL) {
+                if (splash->plugin_interface->on_boot_progress != NULL) {
+                        ply_event_loop_stop_watching_for_timeout (splash->loop,
+                                                                  (ply_event_loop_timeout_handler_t)
+                                                                  ply_boot_splash_update_progress, splash);
+                }
+
+                ply_event_loop_stop_watching_for_exit (splash->loop, (ply_event_loop_exit_handler_t)
+                                                       ply_boot_splash_detach_from_event_loop,
+                                                       splash);
         }
-
-      ply_event_loop_stop_watching_for_exit (splash->loop, (ply_event_loop_exit_handler_t)
-                                             ply_boot_splash_detach_from_event_loop,
-                                             splash);
-    }
 }
 
-void ply_boot_splash_display_message (ply_boot_splash_t             *splash,
-                                      const char                    *message)
+void ply_boot_splash_display_message (ply_boot_splash_t *splash,
+                                      const char        *message)
 {
-  assert (splash != NULL);
-  assert (splash->plugin_interface != NULL);
-  assert (splash->plugin != NULL);
+        assert (splash != NULL);
+        assert (splash->plugin_interface != NULL);
+        assert (splash->plugin != NULL);
 
-  if (splash->plugin_interface->display_message != NULL)
-    splash->plugin_interface->display_message (splash->plugin, message);
+        if (splash->plugin_interface->display_message != NULL)
+                splash->plugin_interface->display_message (splash->plugin, message);
 }
 
-void ply_boot_splash_hide_message (ply_boot_splash_t             *splash,
-                                      const char                 *message)
+void ply_boot_splash_hide_message (ply_boot_splash_t *splash,
+                                   const char        *message)
 {
-  assert (splash != NULL);
-  assert (splash->plugin_interface != NULL);
-  assert (splash->plugin != NULL);
-  if (splash->plugin_interface->hide_message != NULL)
-    splash->plugin_interface->hide_message (splash->plugin, message);
+        assert (splash != NULL);
+        assert (splash->plugin_interface != NULL);
+        assert (splash->plugin != NULL);
+        if (splash->plugin_interface->hide_message != NULL)
+                splash->plugin_interface->hide_message (splash->plugin, message);
 }
 
-void ply_boot_splash_display_normal  (ply_boot_splash_t              *splash)
+void ply_boot_splash_display_normal (ply_boot_splash_t *splash)
 {
-  assert (splash != NULL);
-  assert (splash->plugin_interface != NULL);
-  assert (splash->plugin != NULL);
-  if (splash->plugin_interface->display_normal != NULL)
-    splash->plugin_interface->display_normal (splash->plugin);
+        assert (splash != NULL);
+        assert (splash->plugin_interface != NULL);
+        assert (splash->plugin != NULL);
+        if (splash->plugin_interface->display_normal != NULL)
+                splash->plugin_interface->display_normal (splash->plugin);
 }
 
-void ply_boot_splash_display_password (ply_boot_splash_t             *splash,
-                                       const char                    *prompt,
-                                       int                            bullets)
+void ply_boot_splash_display_password (ply_boot_splash_t *splash,
+                                       const char        *prompt,
+                                       int                bullets)
 {
-  assert (splash != NULL);
-  assert (splash->plugin_interface != NULL);
-  assert (splash->plugin != NULL);
-  if (splash->plugin_interface->display_password != NULL)
-    splash->plugin_interface->display_password (splash->plugin, prompt, bullets);
+        assert (splash != NULL);
+        assert (splash->plugin_interface != NULL);
+        assert (splash->plugin != NULL);
+        if (splash->plugin_interface->display_password != NULL)
+                splash->plugin_interface->display_password (splash->plugin, prompt, bullets);
 }
 
-void ply_boot_splash_display_question (ply_boot_splash_t             *splash,
-                                       const char                    *prompt,
-                                       const char                    *entry_text)
+void ply_boot_splash_display_question (ply_boot_splash_t *splash,
+                                       const char        *prompt,
+                                       const char        *entry_text)
 {
-  assert (splash != NULL);
-  assert (splash->plugin_interface != NULL);
-  assert (splash->plugin != NULL);
-  if (splash->plugin_interface->display_question != NULL)
-    splash->plugin_interface->display_question (splash->plugin, prompt, entry_text);
+        assert (splash != NULL);
+        assert (splash->plugin_interface != NULL);
+        assert (splash->plugin != NULL);
+        if (splash->plugin_interface->display_question != NULL)
+                splash->plugin_interface->display_question (splash->plugin, prompt, entry_text);
 }
 
 
@@ -677,63 +651,60 @@ void
 ply_boot_splash_attach_to_event_loop (ply_boot_splash_t *splash,
                                       ply_event_loop_t  *loop)
 {
-  assert (splash != NULL);
-  assert (loop != NULL);
-  assert (splash->loop == NULL);
+        assert (splash != NULL);
+        assert (loop != NULL);
+        assert (splash->loop == NULL);
 
-  splash->loop = loop;
+        splash->loop = loop;
 
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t) 
-                                 ply_boot_splash_detach_from_event_loop,
-                                 splash); 
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       ply_boot_splash_detach_from_event_loop,
+                                       splash);
 }
 
 static void
 on_idle (ply_boot_splash_t *splash)
 {
-
-  ply_trace ("splash now idle");
-  ply_event_loop_watch_for_timeout (splash->loop, 0.01,
-                                    (ply_event_loop_timeout_handler_t)
-                                    splash->idle_handler,
-                                    splash->idle_handler_user_data);
-  splash->idle_handler = NULL;
-  splash->idle_handler_user_data = NULL;
+        ply_trace ("splash now idle");
+        ply_event_loop_watch_for_timeout (splash->loop, 0.01,
+                                          (ply_event_loop_timeout_handler_t)
+                                          splash->idle_handler,
+                                          splash->idle_handler_user_data);
+        splash->idle_handler = NULL;
+        splash->idle_handler_user_data = NULL;
 }
 
 void
-ply_boot_splash_become_idle (ply_boot_splash_t                  *splash,
-                             ply_boot_splash_on_idle_handler_t  idle_handler,
-                             void                              *user_data)
+ply_boot_splash_become_idle (ply_boot_splash_t                *splash,
+                             ply_boot_splash_on_idle_handler_t idle_handler,
+                             void                             *user_data)
 {
-  assert (splash->idle_trigger == NULL);
-
-  if (splash->progress != NULL)
-    {
-      ply_progress_set_percentage (splash->progress, 1.0);
-      ply_boot_splash_update_progress (splash);
-    }
-
-  ply_trace ("telling splash to become idle");
-  if (splash->plugin_interface->become_idle == NULL)
-    {
-      ply_event_loop_watch_for_timeout (splash->loop, 0.01,
-                                        (ply_event_loop_timeout_handler_t)
-                                        idle_handler,
-                                        user_data);
-
-      return;
-    }
-
-  splash->idle_handler = idle_handler;
-  splash->idle_handler_user_data = user_data;
-
-  splash->idle_trigger = ply_trigger_new (&splash->idle_trigger);
-  ply_trigger_add_handler (splash->idle_trigger,
-                           (ply_trigger_handler_t) on_idle,
-                           splash);
-
-  splash->plugin_interface->become_idle (splash->plugin, splash->idle_trigger);
+        assert (splash->idle_trigger == NULL);
+
+        if (splash->progress != NULL) {
+                ply_progress_set_percentage (splash->progress, 1.0);
+                ply_boot_splash_update_progress (splash);
+        }
+
+        ply_trace ("telling splash to become idle");
+        if (splash->plugin_interface->become_idle == NULL) {
+                ply_event_loop_watch_for_timeout (splash->loop, 0.01,
+                                                  (ply_event_loop_timeout_handler_t)
+                                                  idle_handler,
+                                                  user_data);
+
+                return;
+        }
+
+        splash->idle_handler = idle_handler;
+        splash->idle_handler_user_data = user_data;
+
+        splash->idle_trigger = ply_trigger_new (&splash->idle_trigger);
+        ply_trigger_add_handler (splash->idle_trigger,
+                                 (ply_trigger_handler_t) on_idle,
+                                 splash);
+
+        splash->plugin_interface->become_idle (splash->plugin, splash->idle_trigger);
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-core/ply-boot-splash.h b/src/libply-splash-core/ply-boot-splash.h
index 335039b..0ad6f22 100644
--- a/src/libply-splash-core/ply-boot-splash.h
+++ b/src/libply-splash-core/ply-boot-splash.h
@@ -40,12 +40,12 @@
 typedef struct _ply_boot_splash ply_boot_splash_t;
 typedef struct _ply_seat ply_seat_t;
 
-typedef void (* ply_boot_splash_on_idle_handler_t) (void *user_data);
+typedef void (*ply_boot_splash_on_idle_handler_t) (void *user_data);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
-ply_boot_splash_t *ply_boot_splash_new (const char   *  theme_path,
-                                        const char   *  plugin_dir,
-                                        ply_buffer_t *  boot_buffer);
+ply_boot_splash_t *ply_boot_splash_new (const char   *theme_path,
+                                        const char   *plugin_dir,
+                                        ply_buffer_t *boot_buffer);
 
 bool ply_boot_splash_load (ply_boot_splash_t *splash);
 bool ply_boot_splash_load_built_in (ply_boot_splash_t *splash);
@@ -55,7 +55,7 @@ void ply_boot_splash_attach_to_seat (ply_boot_splash_t *splash,
 void ply_boot_splash_detach_from_seat (ply_boot_splash_t *splash,
                                        ply_seat_t        *seat);
 void ply_boot_splash_free (ply_boot_splash_t *splash);
-bool ply_boot_splash_show (ply_boot_splash_t *splash,
+bool ply_boot_splash_show (ply_boot_splash_t     *splash,
                            ply_boot_splash_mode_t mode);
 bool ply_boot_splash_system_update (ply_boot_splash_t *splash,
                                     int                progress);
@@ -70,7 +70,7 @@ void ply_boot_splash_display_message (ply_boot_splash_t *splash,
 void ply_boot_splash_hide_message (ply_boot_splash_t *splash,
                                    const char        *message);
 void ply_boot_splash_hide (ply_boot_splash_t *splash);
-void ply_boot_splash_display_normal  (ply_boot_splash_t *splash);
+void ply_boot_splash_display_normal (ply_boot_splash_t *splash);
 void ply_boot_splash_display_password (ply_boot_splash_t *splash,
                                        const char        *prompt,
                                        int                bullets);
@@ -81,9 +81,9 @@ void ply_boot_splash_attach_to_event_loop (ply_boot_splash_t *splash,
                                            ply_event_loop_t  *loop);
 void ply_boot_splash_attach_progress (ply_boot_splash_t *splash,
                                       ply_progress_t    *progress);
-void ply_boot_splash_become_idle (ply_boot_splash_t                 *splash,
-                                  ply_boot_splash_on_idle_handler_t  idle_handler,
-                                  void                              *user_data);
+void ply_boot_splash_become_idle (ply_boot_splash_t                *splash,
+                                  ply_boot_splash_on_idle_handler_t idle_handler,
+                                  void                             *user_data);
 
 
 #endif
diff --git a/src/libply-splash-core/ply-device-manager.c b/src/libply-splash-core/ply-device-manager.c
index dbc203d..e904708 100644
--- a/src/libply-splash-core/ply-device-manager.c
+++ b/src/libply-splash-core/ply-device-manager.c
@@ -47,392 +47,362 @@ static void create_seat_for_terminal_and_renderer_type (ply_device_manager_t *ma
                                                         ply_renderer_type_t   renderer_type);
 struct _ply_device_manager
 {
-  ply_device_manager_flags_t  flags;
-  ply_event_loop_t           *loop;
-  ply_hashtable_t            *terminals;
-  ply_terminal_t             *local_console_terminal;
-  ply_seat_t                 *local_console_seat;
-  ply_list_t                 *seats;
-  struct udev                *udev_context;
-  struct udev_queue          *udev_queue;
-  int                         udev_queue_fd;
-  ply_fd_watch_t             *udev_queue_fd_watch;
-  struct udev_monitor        *udev_monitor;
-
-  ply_seat_added_handler_t    seat_added_handler;
-  ply_seat_removed_handler_t  seat_removed_handler;
-  void                       *seat_event_handler_data;
+        ply_device_manager_flags_t flags;
+        ply_event_loop_t          *loop;
+        ply_hashtable_t           *terminals;
+        ply_terminal_t            *local_console_terminal;
+        ply_seat_t                *local_console_seat;
+        ply_list_t                *seats;
+        struct udev               *udev_context;
+        struct udev_queue         *udev_queue;
+        int                        udev_queue_fd;
+        ply_fd_watch_t            *udev_queue_fd_watch;
+        struct udev_monitor       *udev_monitor;
+
+        ply_seat_added_handler_t   seat_added_handler;
+        ply_seat_removed_handler_t seat_removed_handler;
+        void                      *seat_event_handler_data;
 };
 
 static void
 detach_from_event_loop (ply_device_manager_t *manager)
 {
-  assert (manager != NULL);
+        assert (manager != NULL);
 
-  manager->loop = NULL;
+        manager->loop = NULL;
 }
 
 static void
 attach_to_event_loop (ply_device_manager_t *manager,
                       ply_event_loop_t     *loop)
 {
-  assert (manager != NULL);
-  assert (loop != NULL);
-  assert (manager->loop == NULL);
+        assert (manager != NULL);
+        assert (loop != NULL);
+        assert (manager->loop == NULL);
 
-  manager->loop = loop;
+        manager->loop = loop;
 
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
-                                 detach_from_event_loop,
-                                 manager);
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       detach_from_event_loop,
+                                       manager);
 }
 
 static bool
 device_is_for_local_console (ply_device_manager_t *manager,
                              struct udev_device   *device)
 {
-  const char *device_path;
-  struct udev_device *bus_device;
-  char *bus_device_path;
-  const char *boot_vga;
-  bool for_local_console;
+        const char *device_path;
+        struct udev_device *bus_device;
+        char *bus_device_path;
+        const char *boot_vga;
+        bool for_local_console;
 
-  /* Look at the associated bus device to see if this card is the
-   * card the kernel is using for its console. */
-  device_path = udev_device_get_syspath (device);
-  asprintf (&bus_device_path, "%s/device", device_path);
-  bus_device = udev_device_new_from_syspath (manager->udev_context, bus_device_path);
+        /* Look at the associated bus device to see if this card is the
+         * card the kernel is using for its console. */
+        device_path = udev_device_get_syspath (device);
+        asprintf (&bus_device_path, "%s/device", device_path);
+        bus_device = udev_device_new_from_syspath (manager->udev_context, bus_device_path);
 
-  boot_vga = udev_device_get_sysattr_value (bus_device, "boot_vga");
-  free (bus_device_path);
+        boot_vga = udev_device_get_sysattr_value (bus_device, "boot_vga");
+        free (bus_device_path);
 
-  if (boot_vga != NULL && strcmp (boot_vga, "1") == 0)
-    for_local_console = true;
-  else
-    for_local_console = false;
+        if (boot_vga != NULL && strcmp (boot_vga, "1") == 0)
+                for_local_console = true;
+        else
+                for_local_console = false;
 
-  return for_local_console;
+        return for_local_console;
 }
 
 static bool
 fb_device_has_drm_device (ply_device_manager_t *manager,
                           struct udev_device   *fb_device)
 {
-  struct udev_enumerate *card_matches;
-  struct udev_list_entry *card_entry;
-  const char *id_path;
-  bool has_drm_device = false;
-
-  /* We want to see if the framebuffer is associated with a DRM-capable
-   * graphics card, if it is, we'll use the DRM device */
-  card_matches = udev_enumerate_new (manager->udev_context);
-  udev_enumerate_add_match_is_initialized(card_matches);
-  udev_enumerate_add_match_parent (card_matches, udev_device_get_parent (fb_device));
-  udev_enumerate_add_match_subsystem (card_matches, "drm");
-  id_path = udev_device_get_property_value (fb_device, "ID_PATH");
-  udev_enumerate_add_match_property (card_matches, "ID_PATH", id_path);
-
-  ply_trace ("trying to find associated drm node for fb device (path: %s)", id_path);
-
-  udev_enumerate_scan_devices (card_matches);
-
-  /* there should only ever be at most one match so we don't iterate through
-   * the list, but just look at the first entry */
-  card_entry = udev_enumerate_get_list_entry (card_matches);
-
-  if (card_entry != NULL)
-    {
-      struct udev_device *card_device = NULL;
-      const char *card_node;
-      const char *card_path;
-
-      card_path = udev_list_entry_get_name (card_entry);
-      card_device = udev_device_new_from_syspath (manager->udev_context, card_path);
-      card_node = udev_device_get_devnode (card_device);
-      if (card_node != NULL)
-        has_drm_device = true;
-      else
-        ply_trace ("no card node!");
-
-      udev_device_unref (card_device);
-    }
-  else
-    {
-      ply_trace ("no card entry!");
-    }
-
-  udev_enumerate_unref (card_matches);
-  return has_drm_device;
+        struct udev_enumerate *card_matches;
+        struct udev_list_entry *card_entry;
+        const char *id_path;
+        bool has_drm_device = false;
+
+        /* We want to see if the framebuffer is associated with a DRM-capable
+         * graphics card, if it is, we'll use the DRM device */
+        card_matches = udev_enumerate_new (manager->udev_context);
+        udev_enumerate_add_match_is_initialized (card_matches);
+        udev_enumerate_add_match_parent (card_matches, udev_device_get_parent (fb_device));
+        udev_enumerate_add_match_subsystem (card_matches, "drm");
+        id_path = udev_device_get_property_value (fb_device, "ID_PATH");
+        udev_enumerate_add_match_property (card_matches, "ID_PATH", id_path);
+
+        ply_trace ("trying to find associated drm node for fb device (path: %s)", id_path);
+
+        udev_enumerate_scan_devices (card_matches);
+
+        /* there should only ever be at most one match so we don't iterate through
+         * the list, but just look at the first entry */
+        card_entry = udev_enumerate_get_list_entry (card_matches);
+
+        if (card_entry != NULL) {
+                struct udev_device *card_device = NULL;
+                const char *card_node;
+                const char *card_path;
+
+                card_path = udev_list_entry_get_name (card_entry);
+                card_device = udev_device_new_from_syspath (manager->udev_context, card_path);
+                card_node = udev_device_get_devnode (card_device);
+                if (card_node != NULL)
+                        has_drm_device = true;
+                else
+                        ply_trace ("no card node!");
+
+                udev_device_unref (card_device);
+        } else {
+                ply_trace ("no card entry!");
+        }
+
+        udev_enumerate_unref (card_matches);
+        return has_drm_device;
 }
 
 static void
 create_seat_for_udev_device (ply_device_manager_t *manager,
                              struct udev_device   *device)
 {
-  bool for_local_console;
-  const char *device_path;
-  ply_terminal_t *terminal = NULL;
+        bool for_local_console;
+        const char *device_path;
+        ply_terminal_t *terminal = NULL;
 
-  for_local_console = device_is_for_local_console (manager, device);
+        for_local_console = device_is_for_local_console (manager, device);
 
-  ply_trace ("device is for local console: %s", for_local_console? "yes" : "no");
+        ply_trace ("device is for local console: %s", for_local_console ? "yes" : "no");
 
-  if (for_local_console)
-    terminal = manager->local_console_terminal;
+        if (for_local_console)
+                terminal = manager->local_console_terminal;
 
-  device_path = udev_device_get_devnode (device);
+        device_path = udev_device_get_devnode (device);
 
-  if (device_path != NULL)
-    {
-      const char *subsystem;
-      ply_renderer_type_t renderer_type = PLY_RENDERER_TYPE_NONE;
+        if (device_path != NULL) {
+                const char *subsystem;
+                ply_renderer_type_t renderer_type = PLY_RENDERER_TYPE_NONE;
 
-      subsystem = udev_device_get_subsystem (device);
-      ply_trace ("device subsystem is %s", subsystem);
+                subsystem = udev_device_get_subsystem (device);
+                ply_trace ("device subsystem is %s", subsystem);
 
-      if (subsystem != NULL && strcmp (subsystem, SUBSYSTEM_DRM) == 0)
-        {
-          ply_trace ("found DRM device %s", device_path);
-          renderer_type = PLY_RENDERER_TYPE_DRM;
-        }
-      else if (strcmp (subsystem, SUBSYSTEM_FRAME_BUFFER) == 0)
-        {
-          ply_trace ("found frame buffer device %s", device_path);
-          if (!fb_device_has_drm_device (manager, device))
-            {
-              renderer_type = PLY_RENDERER_TYPE_FRAME_BUFFER;
-            }
-          else
-            {
-              ply_trace ("ignoring, since there's a DRM device associated with it");
-            }
-        }
+                if (subsystem != NULL && strcmp (subsystem, SUBSYSTEM_DRM) == 0) {
+                        ply_trace ("found DRM device %s", device_path);
+                        renderer_type = PLY_RENDERER_TYPE_DRM;
+                } else if (strcmp (subsystem, SUBSYSTEM_FRAME_BUFFER) == 0) {
+                        ply_trace ("found frame buffer device %s", device_path);
+                        if (!fb_device_has_drm_device (manager, device))
+                                renderer_type = PLY_RENDERER_TYPE_FRAME_BUFFER;
+                        else
+                                ply_trace ("ignoring, since there's a DRM device associated with it");
+                }
 
-      if (renderer_type != PLY_RENDERER_TYPE_NONE)
-        create_seat_for_terminal_and_renderer_type (manager,
-                                                    device_path,
-                                                    terminal,
-                                                    renderer_type);
-    }
+                if (renderer_type != PLY_RENDERER_TYPE_NONE) {
+                        create_seat_for_terminal_and_renderer_type (manager,
+                                                                    device_path,
+                                                                    terminal,
+                                                                    renderer_type);
+                }
+        }
 }
 
 static void
 free_seat_from_device_path (ply_device_manager_t *manager,
                             const char           *device_path)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (manager->seats);
-  while (node != NULL)
-    {
-      ply_seat_t *seat;
-      ply_renderer_t *renderer;
-      ply_list_node_t *next_node;
-      const char *renderer_device_path;
+        node = ply_list_get_first_node (manager->seats);
+        while (node != NULL) {
+                ply_seat_t *seat;
+                ply_renderer_t *renderer;
+                ply_list_node_t *next_node;
+                const char *renderer_device_path;
 
-      seat = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (manager->seats, node);
-      renderer = ply_seat_get_renderer (seat);
+                seat = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (manager->seats, node);
+                renderer = ply_seat_get_renderer (seat);
 
-      if (renderer != NULL)
-        {
-          renderer_device_path = ply_renderer_get_device_name (renderer);
+                if (renderer != NULL) {
+                        renderer_device_path = ply_renderer_get_device_name (renderer);
 
-          if (renderer_device_path != NULL)
-            {
-              if (strcmp (device_path, renderer_device_path) == 0)
-                {
-                  ply_trace ("removing seat associated with %s", device_path);
+                        if (renderer_device_path != NULL) {
+                                if (strcmp (device_path, renderer_device_path) == 0) {
+                                        ply_trace ("removing seat associated with %s", device_path);
 
-                  if (manager->seat_removed_handler != NULL)
-                    manager->seat_removed_handler (manager->seat_event_handler_data, seat);
+                                        if (manager->seat_removed_handler != NULL)
+                                                manager->seat_removed_handler (manager->seat_event_handler_data, seat);
 
-                  ply_seat_free (seat);
-                  ply_list_remove_node (manager->seats, node);
-                  break;
+                                        ply_seat_free (seat);
+                                        ply_list_remove_node (manager->seats, node);
+                                        break;
+                                }
+                        }
                 }
-            }
-        }
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 free_seat_for_udev_device (ply_device_manager_t *manager,
                            struct udev_device   *device)
 {
-  const char *device_path;
+        const char *device_path;
 
-  device_path = udev_device_get_devnode (device);
+        device_path = udev_device_get_devnode (device);
 
-  if (device_path != NULL)
-    free_seat_from_device_path (manager, device_path);
+        if (device_path != NULL)
+                free_seat_from_device_path (manager, device_path);
 }
 
 static bool
 create_seats_for_subsystem (ply_device_manager_t *manager,
                             const char           *subsystem)
 {
-  struct udev_enumerate *matches;
-  struct udev_list_entry *entry;
-  bool found_device = false;
+        struct udev_enumerate *matches;
+        struct udev_list_entry *entry;
+        bool found_device = false;
 
-  ply_trace ("creating seats for %s devices",
-             strcmp (subsystem, SUBSYSTEM_FRAME_BUFFER) == 0?
-             "frame buffer":
-             subsystem);
+        ply_trace ("creating seats for %s devices",
+                   strcmp (subsystem, SUBSYSTEM_FRAME_BUFFER) == 0 ?
+                   "frame buffer" :
+                   subsystem);
 
-  matches = udev_enumerate_new (manager->udev_context);
-  udev_enumerate_add_match_subsystem (matches, subsystem);
-  udev_enumerate_scan_devices (matches);
+        matches = udev_enumerate_new (manager->udev_context);
+        udev_enumerate_add_match_subsystem (matches, subsystem);
+        udev_enumerate_scan_devices (matches);
 
-  udev_list_entry_foreach (entry, udev_enumerate_get_list_entry (matches))
-    {
-      struct udev_device *device = NULL;
-      const char *path;
+        udev_list_entry_foreach (entry, udev_enumerate_get_list_entry (matches)){
+                struct udev_device *device = NULL;
+                const char *path;
 
-      path = udev_list_entry_get_name (entry);
+                path = udev_list_entry_get_name (entry);
 
-      if (path == NULL)
-        {
-          ply_trace ("path was null!");
-          continue;
-        }
+                if (path == NULL) {
+                        ply_trace ("path was null!");
+                        continue;
+                }
 
-      ply_trace ("found device %s", path);
-
-      device = udev_device_new_from_syspath (manager->udev_context, path);
-
-      /* if device isn't fully initialized, we'll get an add event later
-       */
-      if (udev_device_get_is_initialized (device))
-        {
-          ply_trace ("device is initialized");
-
-          /* We only care about devices assigned to a (any) seat. Floating
-           * devices should be ignored.
-           */
-          if (udev_device_has_tag (device, "seat"))
-            {
-              const char *node;
-              node = udev_device_get_devnode (device);
-              if (node != NULL)
-                {
-                  ply_trace ("found node %s", node);
-                  found_device = true;
-                  create_seat_for_udev_device (manager, device);
+                ply_trace ("found device %s", path);
+
+                device = udev_device_new_from_syspath (manager->udev_context, path);
+
+                /* if device isn't fully initialized, we'll get an add event later
+                 */
+                if (udev_device_get_is_initialized (device)) {
+                        ply_trace ("device is initialized");
+
+                        /* We only care about devices assigned to a (any) seat. Floating
+                         * devices should be ignored.
+                         */
+                        if (udev_device_has_tag (device, "seat")) {
+                                const char *node;
+                                node = udev_device_get_devnode (device);
+                                if (node != NULL) {
+                                        ply_trace ("found node %s", node);
+                                        found_device = true;
+                                        create_seat_for_udev_device (manager, device);
+                                }
+                        } else {
+                                ply_trace ("device doesn't have a seat tag");
+                        }
+                } else {
+                        ply_trace ("it's not initialized");
                 }
-            }
-          else
-            {
-              ply_trace ("device doesn't have a seat tag");
-            }
-        }
-      else
-        {
-          ply_trace ("it's not initialized");
-        }
 
-      udev_device_unref (device);
-    }
+                udev_device_unref (device);
+        }
 
-  udev_enumerate_unref (matches);
+        udev_enumerate_unref (matches);
 
-  return found_device;
+        return found_device;
 }
 
 static void
 on_udev_event (ply_device_manager_t *manager)
 {
-  struct udev_device *device;
-  const char *action;
+        struct udev_device *device;
+        const char *action;
 
-  device = udev_monitor_receive_device (manager->udev_monitor);
-  if (device == NULL)
-    return;
+        device = udev_monitor_receive_device (manager->udev_monitor);
+        if (device == NULL)
+                return;
 
-  action = udev_device_get_action (device);
+        action = udev_device_get_action (device);
 
-  ply_trace ("got %s event for device %s", action, udev_device_get_sysname (device));
+        ply_trace ("got %s event for device %s", action, udev_device_get_sysname (device));
 
-  if (action == NULL)
-    return;
+        if (action == NULL)
+                return;
 
-  if (strcmp (action, "add") == 0)
-    {
-      const char *subsystem;
-      bool coldplug_complete = manager->udev_queue_fd_watch == NULL;
+        if (strcmp (action, "add") == 0) {
+                const char *subsystem;
+                bool coldplug_complete = manager->udev_queue_fd_watch == NULL;
 
-      subsystem = udev_device_get_subsystem (device);
+                subsystem = udev_device_get_subsystem (device);
 
-      if (strcmp (subsystem, SUBSYSTEM_DRM) == 0 ||
-          coldplug_complete)
-        {
-          create_seat_for_udev_device (manager, device);
+                if (strcmp (subsystem, SUBSYSTEM_DRM) == 0 ||
+                    coldplug_complete)
+                        create_seat_for_udev_device (manager, device);
+                else
+                        ply_trace ("ignoring since we only handle subsystem %s devices after coldplug completes", subsystem);
+        } else if (strcmp (action, "remove") == 0) {
+                free_seat_for_udev_device (manager, device);
         }
-      else
-        {
-          ply_trace ("ignoring since we only handle subsystem %s devices after coldplug completes", subsystem);
-        }
-    }
-  else if (strcmp (action, "remove") == 0)
-    {
-      free_seat_for_udev_device (manager, device);
-    }
 
-  udev_device_unref (device);
+        udev_device_unref (device);
 }
 
 static void
 watch_for_udev_events (ply_device_manager_t *manager)
 {
-  int fd;
-  assert (manager != NULL);
-  assert (manager->udev_monitor == NULL);
+        int fd;
+
+        assert (manager != NULL);
+        assert (manager->udev_monitor == NULL);
 
-  ply_trace ("watching for udev graphics device add and remove events");
+        ply_trace ("watching for udev graphics device add and remove events");
 
-  manager->udev_monitor = udev_monitor_new_from_netlink (manager->udev_context, "udev");
+        manager->udev_monitor = udev_monitor_new_from_netlink (manager->udev_context, "udev");
 
-  udev_monitor_filter_add_match_subsystem_devtype (manager->udev_monitor, SUBSYSTEM_DRM, NULL);
-  udev_monitor_filter_add_match_subsystem_devtype (manager->udev_monitor, SUBSYSTEM_FRAME_BUFFER, NULL);
-  udev_monitor_filter_add_match_tag (manager->udev_monitor, "seat");
-  udev_monitor_enable_receiving (manager->udev_monitor);
+        udev_monitor_filter_add_match_subsystem_devtype (manager->udev_monitor, SUBSYSTEM_DRM, NULL);
+        udev_monitor_filter_add_match_subsystem_devtype (manager->udev_monitor, SUBSYSTEM_FRAME_BUFFER, NULL);
+        udev_monitor_filter_add_match_tag (manager->udev_monitor, "seat");
+        udev_monitor_enable_receiving (manager->udev_monitor);
 
-  fd = udev_monitor_get_fd (manager->udev_monitor);
-  ply_event_loop_watch_fd (manager->loop,
-                           fd,
-                           PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                           (ply_event_handler_t)
-                           on_udev_event,
-                           NULL,
-                           manager);
+        fd = udev_monitor_get_fd (manager->udev_monitor);
+        ply_event_loop_watch_fd (manager->loop,
+                                 fd,
+                                 PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                 (ply_event_handler_t)
+                                 on_udev_event,
+                                 NULL,
+                                 manager);
 }
 
 static void
 free_seats (ply_device_manager_t *manager)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("removing seats");
-  node = ply_list_get_first_node (manager->seats);
-  while (node != NULL)
-    {
-      ply_seat_t *seat;
-      ply_list_node_t *next_node;
+        ply_trace ("removing seats");
+        node = ply_list_get_first_node (manager->seats);
+        while (node != NULL) {
+                ply_seat_t *seat;
+                ply_list_node_t *next_node;
 
-      seat = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (manager->seats, node);
+                seat = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (manager->seats, node);
 
-      if (manager->seat_removed_handler != NULL)
-        manager->seat_removed_handler (manager->seat_event_handler_data, seat);
+                if (manager->seat_removed_handler != NULL)
+                        manager->seat_removed_handler (manager->seat_event_handler_data, seat);
 
-      ply_seat_free (seat);
-      ply_list_remove_node (manager->seats, node);
+                ply_seat_free (seat);
+                ply_list_remove_node (manager->seats, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
@@ -440,183 +410,176 @@ free_terminal (char                 *device,
                ply_terminal_t       *terminal,
                ply_device_manager_t *manager)
 {
-  ply_hashtable_remove (manager->terminals, device);
+        ply_hashtable_remove (manager->terminals, device);
 
-  ply_terminal_close (terminal);
-  ply_terminal_free (terminal);
+        ply_terminal_close (terminal);
+        ply_terminal_free (terminal);
 }
 
 static void
 free_terminals (ply_device_manager_t *manager)
 {
-  ply_hashtable_foreach (manager->terminals,
-                         (ply_hashtable_foreach_func_t *)
-                         free_terminal,
-                         manager);
+        ply_hashtable_foreach (manager->terminals,
+                               (ply_hashtable_foreach_func_t *)
+                               free_terminal,
+                               manager);
 }
 
 static ply_terminal_t *
 get_terminal (ply_device_manager_t *manager,
               const char           *device_name)
 {
-  char *full_name = NULL;
-  ply_terminal_t *terminal;
+        char *full_name = NULL;
+        ply_terminal_t *terminal;
 
-  if (strncmp (device_name, "/dev/", strlen ("/dev/")) == 0)
-    full_name = strdup (device_name);
-  else
-    asprintf (&full_name, "/dev/%s", device_name);
+        if (strncmp (device_name, "/dev/", strlen ("/dev/")) == 0)
+                full_name = strdup (device_name);
+        else
+                asprintf (&full_name, "/dev/%s", device_name);
 
-  if (strcmp (full_name, "/dev/tty0") == 0 ||
-      strcmp (full_name, "/dev/tty") == 0 ||
-      strcmp (full_name, ply_terminal_get_name (manager->local_console_terminal)) == 0)
-    {
-      terminal = manager->local_console_terminal;
-      goto done;
-    }
+        if (strcmp (full_name, "/dev/tty0") == 0 ||
+            strcmp (full_name, "/dev/tty") == 0 ||
+            strcmp (full_name, ply_terminal_get_name (manager->local_console_terminal)) == 0) {
+                terminal = manager->local_console_terminal;
+                goto done;
+        }
 
-  terminal = ply_hashtable_lookup (manager->terminals, full_name);
+        terminal = ply_hashtable_lookup (manager->terminals, full_name);
 
-  if (terminal == NULL)
-    {
-      terminal = ply_terminal_new (full_name);
+        if (terminal == NULL) {
+                terminal = ply_terminal_new (full_name);
 
-      ply_hashtable_insert (manager->terminals,
-                            (void *) ply_terminal_get_name (terminal),
-                            terminal);
-    }
+                ply_hashtable_insert (manager->terminals,
+                                      (void *) ply_terminal_get_name (terminal),
+                                      terminal);
+        }
 
 done:
-  free (full_name);
-  return terminal;
+        free (full_name);
+        return terminal;
 }
 
 ply_device_manager_t *
-ply_device_manager_new (const char                 *default_tty,
-                        ply_device_manager_flags_t  flags)
+ply_device_manager_new (const char                *default_tty,
+                        ply_device_manager_flags_t flags)
 {
-  ply_device_manager_t *manager;
+        ply_device_manager_t *manager;
 
-  manager = calloc (1, sizeof (ply_device_manager_t));
-  manager->loop = NULL;
-  manager->terminals = ply_hashtable_new (ply_hashtable_string_hash, ply_hashtable_string_compare);
-  manager->local_console_terminal = ply_terminal_new (default_tty);
-  ply_hashtable_insert (manager->terminals,
-                        (void *) ply_terminal_get_name (manager->local_console_terminal),
-                        manager->local_console_terminal);
-  manager->seats = ply_list_new ();
-  manager->flags = flags;
+        manager = calloc (1, sizeof(ply_device_manager_t));
+        manager->loop = NULL;
+        manager->terminals = ply_hashtable_new (ply_hashtable_string_hash, ply_hashtable_string_compare);
+        manager->local_console_terminal = ply_terminal_new (default_tty);
+        ply_hashtable_insert (manager->terminals,
+                              (void *) ply_terminal_get_name (manager->local_console_terminal),
+                              manager->local_console_terminal);
+        manager->seats = ply_list_new ();
+        manager->flags = flags;
 
-  if (!(flags & PLY_DEVICE_MANAGER_FLAGS_IGNORE_UDEV))
-    manager->udev_context = udev_new ();
+        if (!(flags & PLY_DEVICE_MANAGER_FLAGS_IGNORE_UDEV))
+                manager->udev_context = udev_new ();
 
-  attach_to_event_loop (manager, ply_event_loop_get_default ());
+        attach_to_event_loop (manager, ply_event_loop_get_default ());
 
-  return manager;
+        return manager;
 }
 
 void
 ply_device_manager_free (ply_device_manager_t *manager)
 {
-  ply_trace ("freeing device manager");
+        ply_trace ("freeing device manager");
 
-  if (manager == NULL)
-    return;
+        if (manager == NULL)
+                return;
 
-  ply_event_loop_stop_watching_for_exit (manager->loop,
-                                         (ply_event_loop_exit_handler_t)
-                                         detach_from_event_loop,
-                                         manager);
-  free_seats (manager);
-  ply_list_free (manager->seats);
+        ply_event_loop_stop_watching_for_exit (manager->loop,
+                                               (ply_event_loop_exit_handler_t)
+                                               detach_from_event_loop,
+                                               manager);
+        free_seats (manager);
+        ply_list_free (manager->seats);
 
-  free_terminals (manager);
-  ply_hashtable_free (manager->terminals);
+        free_terminals (manager);
+        ply_hashtable_free (manager->terminals);
 
-  if (manager->udev_monitor != NULL)
-    udev_monitor_unref (manager->udev_monitor);
+        if (manager->udev_monitor != NULL)
+                udev_monitor_unref (manager->udev_monitor);
 
-  if (manager->udev_context != NULL)
-    udev_unref (manager->udev_context);
+        if (manager->udev_context != NULL)
+                udev_unref (manager->udev_context);
 
-  free (manager);
+        free (manager);
 }
 
 static bool
 add_consoles_from_file (ply_device_manager_t *manager,
                         const char           *path)
 {
-  int fd;
-  char contents[512] = "";
-  ssize_t contents_length;
-  bool has_serial_consoles;
-  const char *remaining_file_contents;
-
-  ply_trace ("opening %s", path);
-  fd = open (path, O_RDONLY);
-
-  if (fd < 0)
-    {
-      ply_trace ("couldn't open it: %m");
-      return false;
-    }
-
-  ply_trace ("reading file");
-  contents_length = read (fd, contents, sizeof (contents) - 1);
-
-  if (contents_length <= 0)
-    {
-      ply_trace ("couldn't read it: %m");
-      close (fd);
-      return false;
-    }
-  close (fd);
-
-  remaining_file_contents = contents;
-  has_serial_consoles = false;
-
-  while (remaining_file_contents < contents + contents_length)
-    {
-      char *console;
-      size_t console_length;
-      const char *console_device;
-      ply_terminal_t *terminal;
-
-      /* Advance past any leading whitespace */
-      remaining_file_contents += strspn (remaining_file_contents, " \n\t\v");
-
-      if (*remaining_file_contents == '\0')
-        {
-          /* There's nothing left after the whitespace, we're done */
-          break;
+        int fd;
+        char contents[512] = "";
+        ssize_t contents_length;
+        bool has_serial_consoles;
+        const char *remaining_file_contents;
+
+        ply_trace ("opening %s", path);
+        fd = open (path, O_RDONLY);
+
+        if (fd < 0) {
+                ply_trace ("couldn't open it: %m");
+                return false;
         }
 
-      /* Find trailing whitespace and NUL terminate.  If strcspn
-       * doesn't find whitespace, it gives us the length of the string
-       * until the next NUL byte, which we'll just overwrite with
-       * another NUL byte anyway. */
-      console_length = strcspn (remaining_file_contents, " \n\t\v");
-      console = strndup (remaining_file_contents, console_length);
+        ply_trace ("reading file");
+        contents_length = read (fd, contents, sizeof(contents) - 1);
 
-      terminal = get_terminal (manager, console);
-      console_device = ply_terminal_get_name (terminal);
+        if (contents_length <= 0) {
+                ply_trace ("couldn't read it: %m");
+                close (fd);
+                return false;
+        }
+        close (fd);
 
-      free (console);
+        remaining_file_contents = contents;
+        has_serial_consoles = false;
 
-      ply_trace ("console %s found!", console_device);
+        while (remaining_file_contents < contents + contents_length) {
+                char *console;
+                size_t console_length;
+                const char *console_device;
+                ply_terminal_t *terminal;
 
-      if (terminal != manager->local_console_terminal)
-        has_serial_consoles = true;
+                /* Advance past any leading whitespace */
+                remaining_file_contents += strspn (remaining_file_contents, " \n\t\v");
 
-      /* Move past the parsed console string, and the whitespace we
-       * may have found above.  If we found a NUL above and not whitespace,
-       * then we're going to jump past the end of the buffer and the loop
-       * will terminate
-       */
-      remaining_file_contents += console_length + 1;
-    }
+                if (*remaining_file_contents == '\0')
+                        /* There's nothing left after the whitespace, we're done */
+                        break;
 
-  return has_serial_consoles;
+                /* Find trailing whitespace and NUL terminate.  If strcspn
+                 * doesn't find whitespace, it gives us the length of the string
+                 * until the next NUL byte, which we'll just overwrite with
+                 * another NUL byte anyway. */
+                console_length = strcspn (remaining_file_contents, " \n\t\v");
+                console = strndup (remaining_file_contents, console_length);
+
+                terminal = get_terminal (manager, console);
+                console_device = ply_terminal_get_name (terminal);
+
+                free (console);
+
+                ply_trace ("console %s found!", console_device);
+
+                if (terminal != manager->local_console_terminal)
+                        has_serial_consoles = true;
+
+                /* Move past the parsed console string, and the whitespace we
+                 * may have found above.  If we found a NUL above and not whitespace,
+                 * then we're going to jump past the end of the buffer and the loop
+                 * will terminate
+                 */
+                remaining_file_contents += console_length + 1;
+        }
+
+        return has_serial_consoles;
 }
 
 static void
@@ -625,36 +588,34 @@ create_seat_for_terminal_and_renderer_type (ply_device_manager_t *manager,
                                             ply_terminal_t       *terminal,
                                             ply_renderer_type_t   renderer_type)
 {
-  ply_seat_t *seat;
-  bool is_local_terminal = false;
+        ply_seat_t *seat;
+        bool is_local_terminal = false;
 
-  if (terminal != NULL && manager->local_console_terminal == terminal)
-    is_local_terminal = true;
+        if (terminal != NULL && manager->local_console_terminal == terminal)
+                is_local_terminal = true;
 
-  if (is_local_terminal && manager->local_console_seat != NULL)
-    {
-      ply_trace ("trying to create seat for local console when one already exists");
-      return;
-    }
+        if (is_local_terminal && manager->local_console_seat != NULL) {
+                ply_trace ("trying to create seat for local console when one already exists");
+                return;
+        }
 
-  ply_trace ("creating seat for %s (renderer type: %u) (terminal: %s)",
-             device_path? : "", renderer_type, terminal? ply_terminal_get_name (terminal): "none");
-  seat = ply_seat_new (terminal);
+        ply_trace ("creating seat for %s (renderer type: %u) (terminal: %s)",
+                   device_path ? : "", renderer_type, terminal ? ply_terminal_get_name (terminal) : "none");
+        seat = ply_seat_new (terminal);
 
-  if (!ply_seat_open (seat, renderer_type, device_path))
-    {
-      ply_trace ("could not create seat");
-      ply_seat_free (seat);
-      return;
-    }
+        if (!ply_seat_open (seat, renderer_type, device_path)) {
+                ply_trace ("could not create seat");
+                ply_seat_free (seat);
+                return;
+        }
 
-  ply_list_append_data (manager->seats, seat);
+        ply_list_append_data (manager->seats, seat);
 
-  if (is_local_terminal)
-    manager->local_console_seat = seat;
+        if (is_local_terminal)
+                manager->local_console_seat = seat;
 
-  if (manager->seat_added_handler != NULL)
-    manager->seat_added_handler (manager->seat_event_handler_data, seat);
+        if (manager->seat_added_handler != NULL)
+                manager->seat_added_handler (manager->seat_event_handler_data, seat);
 }
 
 static void
@@ -662,274 +623,260 @@ create_seat_for_terminal (const char           *device_path,
                           ply_terminal_t       *terminal,
                           ply_device_manager_t *manager)
 {
-  create_seat_for_terminal_and_renderer_type (manager,
-                                              device_path,
-                                              terminal,
-                                              PLY_RENDERER_TYPE_NONE);
+        create_seat_for_terminal_and_renderer_type (manager,
+                                                    device_path,
+                                                    terminal,
+                                                    PLY_RENDERER_TYPE_NONE);
 }
 static bool
 create_seats_from_terminals (ply_device_manager_t *manager)
 {
-  bool has_serial_consoles;
+        bool has_serial_consoles;
 
-  ply_trace ("checking for consoles");
+        ply_trace ("checking for consoles");
 
-  if (manager->flags & PLY_DEVICE_MANAGER_FLAGS_IGNORE_SERIAL_CONSOLES)
-    {
-      has_serial_consoles = false;
-      ply_trace ("ignoring all consoles but default console because explicitly told to.");
-    }
-  else
-    {
-      has_serial_consoles = add_consoles_from_file (manager, "/sys/class/tty/console/active");
-    }
+        if (manager->flags & PLY_DEVICE_MANAGER_FLAGS_IGNORE_SERIAL_CONSOLES) {
+                has_serial_consoles = false;
+                ply_trace ("ignoring all consoles but default console because explicitly told to.");
+        } else {
+                has_serial_consoles = add_consoles_from_file (manager, "/sys/class/tty/console/active");
+        }
 
-  if (has_serial_consoles)
-    {
-      ply_trace ("serial consoles detected, managing them with details forced");
-      ply_hashtable_foreach (manager->terminals,
-                             (ply_hashtable_foreach_func_t *)
-                             create_seat_for_terminal,
-                             manager);
-      return true;
-    }
+        if (has_serial_consoles) {
+                ply_trace ("serial consoles detected, managing them with details forced");
+                ply_hashtable_foreach (manager->terminals,
+                                       (ply_hashtable_foreach_func_t *)
+                                       create_seat_for_terminal,
+                                       manager);
+                return true;
+        }
 
-  return false;
+        return false;
 }
 
 static void
 create_seats_from_udev (ply_device_manager_t *manager)
 {
-  bool found_drm_device, found_fb_device;
+        bool found_drm_device, found_fb_device;
 
-  ply_trace ("Looking for devices from udev");
+        ply_trace ("Looking for devices from udev");
 
-  found_drm_device = create_seats_for_subsystem (manager, SUBSYSTEM_DRM);
-  found_fb_device = create_seats_for_subsystem (manager, SUBSYSTEM_FRAME_BUFFER);
+        found_drm_device = create_seats_for_subsystem (manager, SUBSYSTEM_DRM);
+        found_fb_device = create_seats_for_subsystem (manager, SUBSYSTEM_FRAME_BUFFER);
 
-  if (found_drm_device || found_fb_device)
-    return;
+        if (found_drm_device || found_fb_device)
+                return;
 
-  ply_trace ("Creating non-graphical seat, since there's no suitable graphics hardware");
-  create_seat_for_terminal_and_renderer_type (manager,
-                                              ply_terminal_get_name (manager->local_console_terminal),
-                                              manager->local_console_terminal,
-                                              PLY_RENDERER_TYPE_NONE);
+        ply_trace ("Creating non-graphical seat, since there's no suitable graphics hardware");
+        create_seat_for_terminal_and_renderer_type (manager,
+                                                    ply_terminal_get_name (manager->local_console_terminal),
+                                                    manager->local_console_terminal,
+                                                    PLY_RENDERER_TYPE_NONE);
 }
 
 static void
 create_fallback_seat (ply_device_manager_t *manager)
 {
-  create_seat_for_terminal_and_renderer_type (manager,
-                                              ply_terminal_get_name (manager->local_console_terminal),
-                                              manager->local_console_terminal,
-                                              PLY_RENDERER_TYPE_AUTO);
+        create_seat_for_terminal_and_renderer_type (manager,
+                                                    ply_terminal_get_name (manager->local_console_terminal),
+                                                    manager->local_console_terminal,
+                                                    PLY_RENDERER_TYPE_AUTO);
 }
 
 static void
 on_udev_queue_changed (ply_device_manager_t *manager)
 {
+        if (!udev_queue_get_queue_is_empty (manager->udev_queue))
+                return;
 
-  if (!udev_queue_get_queue_is_empty (manager->udev_queue))
-    return;
-
-  ply_trace ("udev coldplug complete");
-  ply_event_loop_stop_watching_fd (manager->loop, manager->udev_queue_fd_watch);
-  manager->udev_queue_fd_watch = NULL;
-  udev_queue_unref (manager->udev_queue);
+        ply_trace ("udev coldplug complete");
+        ply_event_loop_stop_watching_fd (manager->loop, manager->udev_queue_fd_watch);
+        manager->udev_queue_fd_watch = NULL;
+        udev_queue_unref (manager->udev_queue);
 
-  close (manager->udev_queue_fd);
-  manager->udev_queue_fd = -1;
+        close (manager->udev_queue_fd);
+        manager->udev_queue_fd = -1;
 
-  manager->udev_queue = NULL;
+        manager->udev_queue = NULL;
 
-  create_seats_from_udev (manager);
+        create_seats_from_udev (manager);
 }
 
 static void
 watch_for_coldplug_completion (ply_device_manager_t *manager)
 {
-  int fd;
-  int result;
+        int fd;
+        int result;
 
-  manager->udev_queue = udev_queue_new (manager->udev_context);
+        manager->udev_queue = udev_queue_new (manager->udev_context);
 
-  if (udev_queue_get_queue_is_empty (manager->udev_queue))
-    {
-      ply_trace ("udev coldplug completed already ");
-      create_seats_from_udev (manager);
-      return;
-    }
-
-  fd = inotify_init1 (IN_CLOEXEC);
-  result = inotify_add_watch (fd, "/run/udev", IN_MOVED_TO);
+        if (udev_queue_get_queue_is_empty (manager->udev_queue)) {
+                ply_trace ("udev coldplug completed already ");
+                create_seats_from_udev (manager);
+                return;
+        }
 
-  if (result < 0)
-    {
-      ply_trace ("could not watch for udev to show up: %m");
-      close (fd);
+        fd = inotify_init1 (IN_CLOEXEC);
+        result = inotify_add_watch (fd, "/run/udev", IN_MOVED_TO);
 
-      create_fallback_seat (manager);
-      return;
-    }
+        if (result < 0) {
+                ply_trace ("could not watch for udev to show up: %m");
+                close (fd);
 
-  manager->udev_queue_fd = fd;
+                create_fallback_seat (manager);
+                return;
+        }
 
-  manager->udev_queue_fd_watch = ply_event_loop_watch_fd (manager->loop,
-                                                          fd,
-                                                          PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                                                          (ply_event_handler_t)
-                                                          on_udev_queue_changed,
-                                                          NULL,
-                                                          manager);
+        manager->udev_queue_fd = fd;
 
+        manager->udev_queue_fd_watch = ply_event_loop_watch_fd (manager->loop,
+                                                                fd,
+                                                                PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                                                (ply_event_handler_t)
+                                                                on_udev_queue_changed,
+                                                                NULL,
+                                                                manager);
 }
 
 void
-ply_device_manager_watch_seats (ply_device_manager_t       *manager,
-                                ply_seat_added_handler_t    seat_added_handler,
-                                ply_seat_removed_handler_t  seat_removed_handler,
-                                void                       *data)
+ply_device_manager_watch_seats (ply_device_manager_t      *manager,
+                                ply_seat_added_handler_t   seat_added_handler,
+                                ply_seat_removed_handler_t seat_removed_handler,
+                                void                      *data)
 {
-  bool done_with_initial_seat_setup;
+        bool done_with_initial_seat_setup;
 
-  manager->seat_added_handler = seat_added_handler;
-  manager->seat_removed_handler = seat_removed_handler;
-  manager->seat_event_handler_data = data;
+        manager->seat_added_handler = seat_added_handler;
+        manager->seat_removed_handler = seat_removed_handler;
+        manager->seat_event_handler_data = data;
 
-  /* Try to create seats for each serial device right away, if possible
-   */
-  done_with_initial_seat_setup = create_seats_from_terminals (manager);
+        /* Try to create seats for each serial device right away, if possible
+         */
+        done_with_initial_seat_setup = create_seats_from_terminals (manager);
 
-  if (done_with_initial_seat_setup)
-    return;
+        if (done_with_initial_seat_setup)
+                return;
 
-  if ((manager->flags & PLY_DEVICE_MANAGER_FLAGS_IGNORE_UDEV))
-    {
-      ply_trace ("udev support disabled, creating fallback seat");
-      create_fallback_seat (manager);
-      return;
-    }
+        if ((manager->flags & PLY_DEVICE_MANAGER_FLAGS_IGNORE_UDEV)) {
+                ply_trace ("udev support disabled, creating fallback seat");
+                create_fallback_seat (manager);
+                return;
+        }
 
-  watch_for_udev_events (manager);
-  watch_for_coldplug_completion (manager);
+        watch_for_udev_events (manager);
+        watch_for_coldplug_completion (manager);
 }
 
 bool
 ply_device_manager_has_open_seats (ply_device_manager_t *manager)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (manager->seats);
-  while (node != NULL)
-    {
-      ply_seat_t *seat;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (manager->seats);
+        while (node != NULL) {
+                ply_seat_t *seat;
+                ply_list_node_t *next_node;
 
-      seat = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (manager->seats, node);
+                seat = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (manager->seats, node);
 
-      if (ply_seat_is_open (seat))
-        return true;
+                if (ply_seat_is_open (seat))
+                        return true;
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  return false;
+        return false;
 }
 
 ply_list_t *
 ply_device_manager_get_seats (ply_device_manager_t *manager)
 {
-  return manager->seats;
+        return manager->seats;
 }
 
 ply_terminal_t *
 ply_device_manager_get_default_terminal (ply_device_manager_t *manager)
 {
-  return manager->local_console_terminal;
+        return manager->local_console_terminal;
 }
 
 void
 ply_device_manager_activate_renderers (ply_device_manager_t *manager)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("activating renderers");
-  node = ply_list_get_first_node (manager->seats);
-  while (node != NULL)
-    {
-      ply_seat_t *seat;
-      ply_list_node_t *next_node;
+        ply_trace ("activating renderers");
+        node = ply_list_get_first_node (manager->seats);
+        while (node != NULL) {
+                ply_seat_t *seat;
+                ply_list_node_t *next_node;
 
-      seat = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (manager->seats, node);
+                seat = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (manager->seats, node);
 
-      ply_seat_activate_renderer (seat);
+                ply_seat_activate_renderer (seat);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 void
 ply_device_manager_deactivate_renderers (ply_device_manager_t *manager)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("deactivating renderers");
-  node = ply_list_get_first_node (manager->seats);
-  while (node != NULL)
-    {
-      ply_seat_t *seat;
-      ply_list_node_t *next_node;
+        ply_trace ("deactivating renderers");
+        node = ply_list_get_first_node (manager->seats);
+        while (node != NULL) {
+                ply_seat_t *seat;
+                ply_list_node_t *next_node;
 
-      seat = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (manager->seats, node);
+                seat = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (manager->seats, node);
 
-      ply_seat_deactivate_renderer (seat);
+                ply_seat_deactivate_renderer (seat);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 void
 ply_device_manager_activate_keyboards (ply_device_manager_t *manager)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("activating keyboards");
-  node = ply_list_get_first_node (manager->seats);
-  while (node != NULL)
-    {
-      ply_seat_t *seat;
-      ply_list_node_t *next_node;
+        ply_trace ("activating keyboards");
+        node = ply_list_get_first_node (manager->seats);
+        while (node != NULL) {
+                ply_seat_t *seat;
+                ply_list_node_t *next_node;
 
-      seat = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (manager->seats, node);
+                seat = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (manager->seats, node);
 
-      ply_seat_activate_keyboard (seat);
+                ply_seat_activate_keyboard (seat);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 void
 ply_device_manager_deactivate_keyboards (ply_device_manager_t *manager)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("deactivating keyboards");
-  node = ply_list_get_first_node (manager->seats);
-  while (node != NULL)
-    {
-      ply_seat_t *seat;
-      ply_list_node_t *next_node;
+        ply_trace ("deactivating keyboards");
+        node = ply_list_get_first_node (manager->seats);
+        while (node != NULL) {
+                ply_seat_t *seat;
+                ply_list_node_t *next_node;
 
-      seat = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (manager->seats, node);
+                seat = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (manager->seats, node);
 
-      ply_seat_deactivate_keyboard (seat);
+                ply_seat_deactivate_keyboard (seat);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
diff --git a/src/libply-splash-core/ply-device-manager.h b/src/libply-splash-core/ply-device-manager.h
index d9c58e8..c3e6487 100644
--- a/src/libply-splash-core/ply-device-manager.h
+++ b/src/libply-splash-core/ply-device-manager.h
@@ -25,22 +25,24 @@
 
 typedef enum
 {
-  PLY_DEVICE_MANAGER_FLAGS_NONE                   = 0,
-  PLY_DEVICE_MANAGER_FLAGS_IGNORE_SERIAL_CONSOLES = 1 << 0,
-  PLY_DEVICE_MANAGER_FLAGS_IGNORE_UDEV            = 1 << 1
+        PLY_DEVICE_MANAGER_FLAGS_NONE = 0,
+        PLY_DEVICE_MANAGER_FLAGS_IGNORE_SERIAL_CONSOLES = 1 << 0,
+                PLY_DEVICE_MANAGER_FLAGS_IGNORE_UDEV = 1 << 1
 } ply_device_manager_flags_t;
 
 typedef struct _ply_device_manager ply_device_manager_t;
-typedef void (* ply_seat_added_handler_t) (void *, ply_seat_t *);
-typedef void (* ply_seat_removed_handler_t) (void *, ply_seat_t *);
+typedef void (*ply_seat_added_handler_t) (void       *,
+                                          ply_seat_t *);
+typedef void (*ply_seat_removed_handler_t) (void       *,
+                                            ply_seat_t *);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
-ply_device_manager_t *ply_device_manager_new (const char                 *default_tty,
-                                              ply_device_manager_flags_t  flags);
-void ply_device_manager_watch_seats (ply_device_manager_t *manager,
-                                     ply_seat_added_handler_t seat_added_handler,
+ply_device_manager_t *ply_device_manager_new (const char                *default_tty,
+                                              ply_device_manager_flags_t flags);
+void ply_device_manager_watch_seats (ply_device_manager_t      *manager,
+                                     ply_seat_added_handler_t   seat_added_handler,
                                      ply_seat_removed_handler_t seat_removed_handler,
-                                     void *data);
+                                     void                      *data);
 bool ply_device_manager_has_open_seats (ply_device_manager_t *manager);
 ply_list_t *ply_device_manager_get_seats (ply_device_manager_t *manager);
 void ply_device_manager_free (ply_device_manager_t *manager);
diff --git a/src/libply-splash-core/ply-keyboard.c b/src/libply-splash-core/ply-keyboard.c
index 624f906..ccf08e8 100644
--- a/src/libply-splash-core/ply-keyboard.c
+++ b/src/libply-splash-core/ply-keyboard.c
@@ -41,57 +41,58 @@
 #include "ply-terminal.h"
 #include "ply-utils.h"
 
-#define KEY_CTRL_U ('\100' ^'U')
-#define KEY_CTRL_W ('\100' ^'W')
-#define KEY_CTRL_V ('\100' ^'V')
-#define KEY_ESCAPE ('\100' ^'[')
+#define KEY_CTRL_U ('\100' ^ 'U')
+#define KEY_CTRL_W ('\100' ^ 'W')
+#define KEY_CTRL_V ('\100' ^ 'V')
+#define KEY_ESCAPE ('\100' ^ '[')
 #define KEY_RETURN '\n'
 #define KEY_BACKSPACE '\177'
 
-typedef void (* ply_keyboard_handler_t) (void *);
+typedef void (*ply_keyboard_handler_t) (void *);
 
 typedef struct
 {
-  ply_keyboard_handler_t function;
-  void *user_data;
+        ply_keyboard_handler_t function;
+        void                  *user_data;
 } ply_keyboard_closure_t;
 
 typedef enum
 {
-  PLY_KEYBOARD_PROVIDER_TYPE_TERMINAL,
-  PLY_KEYBOARD_PROVIDER_TYPE_RENDERER
+        PLY_KEYBOARD_PROVIDER_TYPE_TERMINAL,
+        PLY_KEYBOARD_PROVIDER_TYPE_RENDERER
 } ply_keyboard_provider_type_t;
 
 typedef struct
 {
-  ply_terminal_t *terminal;
-  ply_buffer_t   *key_buffer;
+        ply_terminal_t *terminal;
+        ply_buffer_t   *key_buffer;
 } ply_keyboard_terminal_provider_t;
 
 typedef struct
 {
-  ply_renderer_t              *renderer;
-  ply_renderer_input_source_t *input_source;
+        ply_renderer_t              *renderer;
+        ply_renderer_input_source_t *input_source;
 } ply_keyboard_renderer_provider_t;
 
-typedef  union {
-  ply_keyboard_renderer_provider_t *if_renderer;
-  ply_keyboard_terminal_provider_t *if_terminal;
+typedef  union
+{
+        ply_keyboard_renderer_provider_t *if_renderer;
+        ply_keyboard_terminal_provider_t *if_terminal;
 } ply_keyboard_provider_t;
 
 struct _ply_keyboard
 {
-  ply_event_loop_t *loop;
+        ply_event_loop_t            *loop;
 
-  ply_keyboard_provider_type_t provider_type;
-  ply_keyboard_provider_t provider;
+        ply_keyboard_provider_type_t provider_type;
+        ply_keyboard_provider_t      provider;
 
-  ply_buffer_t     *line_buffer;
+        ply_buffer_t                *line_buffer;
 
-  ply_list_t *keyboard_input_handler_list;
-  ply_list_t *backspace_handler_list;
-  ply_list_t *escape_handler_list;
-  ply_list_t *enter_handler_list;
+        ply_list_t                  *keyboard_input_handler_list;
+        ply_list_t                  *backspace_handler_list;
+        ply_list_t                  *escape_handler_list;
+        ply_list_t                  *enter_handler_list;
 };
 
 static bool ply_keyboard_watch_for_terminal_input (ply_keyboard_t *keyboard);
@@ -99,495 +100,473 @@ static bool ply_keyboard_watch_for_terminal_input (ply_keyboard_t *keyboard);
 ply_keyboard_t *
 ply_keyboard_new_for_terminal (ply_terminal_t *terminal)
 {
-  ply_keyboard_t *keyboard;
-
-  keyboard = calloc (1, sizeof (ply_keyboard_t));
-  keyboard->line_buffer = ply_buffer_new ();
-  keyboard->keyboard_input_handler_list = ply_list_new ();
-  keyboard->backspace_handler_list = ply_list_new ();
-  keyboard->escape_handler_list = ply_list_new ();
-  keyboard->enter_handler_list = ply_list_new ();
-  keyboard->provider_type = PLY_KEYBOARD_PROVIDER_TYPE_TERMINAL;
-  keyboard->provider.if_terminal = calloc (1, sizeof (ply_keyboard_terminal_provider_t));
-  keyboard->provider.if_terminal->terminal = terminal;
-  keyboard->provider.if_terminal->key_buffer = ply_buffer_new ();
-
-  keyboard->loop = ply_event_loop_get_default ();
-
-  return keyboard;
+        ply_keyboard_t *keyboard;
+
+        keyboard = calloc (1, sizeof(ply_keyboard_t));
+        keyboard->line_buffer = ply_buffer_new ();
+        keyboard->keyboard_input_handler_list = ply_list_new ();
+        keyboard->backspace_handler_list = ply_list_new ();
+        keyboard->escape_handler_list = ply_list_new ();
+        keyboard->enter_handler_list = ply_list_new ();
+        keyboard->provider_type = PLY_KEYBOARD_PROVIDER_TYPE_TERMINAL;
+        keyboard->provider.if_terminal = calloc (1, sizeof(ply_keyboard_terminal_provider_t));
+        keyboard->provider.if_terminal->terminal = terminal;
+        keyboard->provider.if_terminal->key_buffer = ply_buffer_new ();
+
+        keyboard->loop = ply_event_loop_get_default ();
+
+        return keyboard;
 }
 
 ply_keyboard_t *
 ply_keyboard_new_for_renderer (ply_renderer_t *renderer)
 {
-  ply_keyboard_t *keyboard;
-  ply_renderer_input_source_t *input_source;
+        ply_keyboard_t *keyboard;
+        ply_renderer_input_source_t *input_source;
 
-  keyboard = calloc (1, sizeof (ply_keyboard_t));
-  keyboard->line_buffer = ply_buffer_new ();
-  keyboard->keyboard_input_handler_list = ply_list_new ();
-  keyboard->backspace_handler_list = ply_list_new ();
-  keyboard->escape_handler_list = ply_list_new ();
-  keyboard->enter_handler_list = ply_list_new ();
-  keyboard->provider_type = PLY_KEYBOARD_PROVIDER_TYPE_RENDERER;
-  keyboard->provider.if_renderer = calloc (1, sizeof (ply_keyboard_renderer_provider_t));
-  keyboard->provider.if_renderer->renderer = renderer;
+        keyboard = calloc (1, sizeof(ply_keyboard_t));
+        keyboard->line_buffer = ply_buffer_new ();
+        keyboard->keyboard_input_handler_list = ply_list_new ();
+        keyboard->backspace_handler_list = ply_list_new ();
+        keyboard->escape_handler_list = ply_list_new ();
+        keyboard->enter_handler_list = ply_list_new ();
+        keyboard->provider_type = PLY_KEYBOARD_PROVIDER_TYPE_RENDERER;
+        keyboard->provider.if_renderer = calloc (1, sizeof(ply_keyboard_renderer_provider_t));
+        keyboard->provider.if_renderer->renderer = renderer;
 
-  input_source = ply_renderer_get_input_source (renderer);
+        input_source = ply_renderer_get_input_source (renderer);
 
-  keyboard->provider.if_renderer->input_source = input_source;
+        keyboard->provider.if_renderer->input_source = input_source;
 
-  keyboard->loop = ply_event_loop_get_default ();
+        keyboard->loop = ply_event_loop_get_default ();
 
-  return keyboard;
+        return keyboard;
 }
 
 static void
 process_backspace (ply_keyboard_t *keyboard)
 {
-  size_t bytes_to_remove;
-  ssize_t previous_character_size;
-  const char *bytes;
-  size_t size;
-  ply_list_node_t *node;
-
-  bytes = ply_buffer_get_bytes (keyboard->line_buffer);
-  size = ply_buffer_get_size (keyboard->line_buffer);
-
-  bytes_to_remove = MIN (size, PLY_UTF8_CHARACTER_SIZE_MAX);
-  while ((previous_character_size = ply_utf8_character_get_size (bytes + size - bytes_to_remove, bytes_to_remove)) < (ssize_t) bytes_to_remove)
-    {
-      if (previous_character_size > 0)
-        bytes_to_remove -= previous_character_size;
-      else
-        bytes_to_remove--;
-    }
-
-  if (bytes_to_remove <= size)
-    ply_buffer_remove_bytes_at_end (keyboard->line_buffer, bytes_to_remove);
-
-  for (node = ply_list_get_first_node(keyboard->backspace_handler_list);
-       node; node = ply_list_get_next_node(keyboard->backspace_handler_list, node))
-    {
-      ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
-      ply_keyboard_backspace_handler_t backspace_handler =
-        (ply_keyboard_backspace_handler_t) closure->function;
-      backspace_handler (closure->user_data);
-    }
+        size_t bytes_to_remove;
+        ssize_t previous_character_size;
+        const char *bytes;
+        size_t size;
+        ply_list_node_t *node;
+
+        bytes = ply_buffer_get_bytes (keyboard->line_buffer);
+        size = ply_buffer_get_size (keyboard->line_buffer);
+
+        bytes_to_remove = MIN (size, PLY_UTF8_CHARACTER_SIZE_MAX);
+        while ((previous_character_size = ply_utf8_character_get_size (bytes + size - bytes_to_remove, bytes_to_remove)) < (ssize_t) bytes_to_remove) {
+                if (previous_character_size > 0)
+                        bytes_to_remove -= previous_character_size;
+                else
+                        bytes_to_remove--;
+        }
+
+        if (bytes_to_remove <= size)
+                ply_buffer_remove_bytes_at_end (keyboard->line_buffer, bytes_to_remove);
+
+        for (node = ply_list_get_first_node (keyboard->backspace_handler_list);
+             node; node = ply_list_get_next_node (keyboard->backspace_handler_list, node)) {
+                ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
+                ply_keyboard_backspace_handler_t backspace_handler =
+                        (ply_keyboard_backspace_handler_t) closure->function;
+                backspace_handler (closure->user_data);
+        }
 }
 
 static void
 process_line_erase (ply_keyboard_t *keyboard)
 {
-  size_t size;
+        size_t size;
 
-  while ((size = ply_buffer_get_size (keyboard->line_buffer)) > 0)
-    process_backspace (keyboard);
+        while ((size = ply_buffer_get_size (keyboard->line_buffer)) > 0) {
+                process_backspace (keyboard);
+        }
 }
 
 static void
 process_keyboard_input (ply_keyboard_t *keyboard,
-                        const char   *keyboard_input,
-                        size_t        character_size)
+                        const char     *keyboard_input,
+                        size_t          character_size)
 {
-  wchar_t key;
-  ply_list_node_t *node;
-
-  if ((ssize_t) mbrtowc (&key, keyboard_input, character_size, NULL) > 0)
-    {
-      switch (key)
-        {
-          case KEY_CTRL_U:
-          case KEY_CTRL_W:
-            ply_trace ("erase line!");
-            process_line_erase (keyboard);
-            return;
-
-          case KEY_CTRL_V:
-            ply_trace ("toggle verbose mode!");
-            ply_toggle_tracing ();
-            ply_trace ("verbose mode toggled!");
-            return;
-
-          case KEY_ESCAPE:
-            ply_trace ("escape key!");
-            for (node = ply_list_get_first_node(keyboard->escape_handler_list);
-                 node; node = ply_list_get_next_node(keyboard->escape_handler_list, node))
-              {
-                ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
-                ply_keyboard_escape_handler_t escape_handler = (ply_keyboard_escape_handler_t) closure->function;
-                escape_handler (closure->user_data);
-              }
-
-            ply_trace ("end escape key handler");
-            return;
-
-          case KEY_BACKSPACE:
-            ply_trace ("backspace key!");
-            process_backspace (keyboard);
-            return;
-
-          case KEY_RETURN:
-            ply_trace ("return key!");
+        wchar_t key;
+        ply_list_node_t *node;
+
+        if ((ssize_t) mbrtowc (&key, keyboard_input, character_size, NULL) > 0) {
+                switch (key) {
+                case KEY_CTRL_U:
+                case KEY_CTRL_W:
+                        ply_trace ("erase line!");
+                        process_line_erase (keyboard);
+                        return;
+
+                case KEY_CTRL_V:
+                        ply_trace ("toggle verbose mode!");
+                        ply_toggle_tracing ();
+                        ply_trace ("verbose mode toggled!");
+                        return;
+
+                case KEY_ESCAPE:
+                        ply_trace ("escape key!");
+                        for (node = ply_list_get_first_node (keyboard->escape_handler_list);
+                             node; node = ply_list_get_next_node (keyboard->escape_handler_list, node)) {
+                                ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
+                                ply_keyboard_escape_handler_t escape_handler = (ply_keyboard_escape_handler_t) closure->function;
+                                escape_handler (closure->user_data);
+                        }
+
+                        ply_trace ("end escape key handler");
+                        return;
+
+                case KEY_BACKSPACE:
+                        ply_trace ("backspace key!");
+                        process_backspace (keyboard);
+                        return;
+
+                case KEY_RETURN:
+                        ply_trace ("return key!");
+
+                        for (node = ply_list_get_first_node (keyboard->enter_handler_list);
+                             node; node = ply_list_get_next_node (keyboard->enter_handler_list, node)) {
+                                ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
+                                ply_keyboard_enter_handler_t enter_handler = (ply_keyboard_enter_handler_t) closure->function;
+                                enter_handler (closure->user_data, ply_buffer_get_bytes (keyboard->line_buffer));
+                        }
+                        ply_buffer_clear (keyboard->line_buffer);
+                        return;
+
+                default:
+                        ply_buffer_append_bytes (keyboard->line_buffer,
+                                                 keyboard_input, character_size);
+                        break;
+                }
+        }
 
-            for (node = ply_list_get_first_node(keyboard->enter_handler_list);
-                 node; node = ply_list_get_next_node(keyboard->enter_handler_list, node))
-              {
+        for (node = ply_list_get_first_node (keyboard->keyboard_input_handler_list);
+             node; node = ply_list_get_next_node (keyboard->keyboard_input_handler_list, node)) {
                 ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
-                ply_keyboard_enter_handler_t enter_handler = (ply_keyboard_enter_handler_t)  closure->function;
-                enter_handler (closure->user_data, ply_buffer_get_bytes (keyboard->line_buffer));
-              }
-            ply_buffer_clear (keyboard->line_buffer);
-            return;
-
-          default:
-            ply_buffer_append_bytes (keyboard->line_buffer,
-                                     keyboard_input, character_size);
-            break;
+                ply_keyboard_input_handler_t keyboard_input_handler =
+                        (ply_keyboard_input_handler_t) closure->function;
+
+                keyboard_input_handler (closure->user_data,
+                                        keyboard_input, character_size);
         }
-    }
-
-  for (node = ply_list_get_first_node(keyboard->keyboard_input_handler_list);
-       node; node = ply_list_get_next_node(keyboard->keyboard_input_handler_list, node))
-    {
-      ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
-      ply_keyboard_input_handler_t keyboard_input_handler =
-        (ply_keyboard_input_handler_t) closure->function;
-
-      keyboard_input_handler (closure->user_data,
-                              keyboard_input, character_size);
-    }
 }
 
 static void
-on_key_event (ply_keyboard_t   *keyboard,
-              ply_buffer_t     *buffer)
+on_key_event (ply_keyboard_t *keyboard,
+              ply_buffer_t   *buffer)
 {
-  const char *bytes;
-  size_t size, i;
+        const char *bytes;
+        size_t size, i;
 
-  bytes = ply_buffer_get_bytes (buffer);
-  size = ply_buffer_get_size (buffer);
+        bytes = ply_buffer_get_bytes (buffer);
+        size = ply_buffer_get_size (buffer);
 
-  i = 0;
-  while (i < size)
-    {
-      ssize_t character_size;
-      char *keyboard_input;
+        i = 0;
+        while (i < size) {
+                ssize_t character_size;
+                char *keyboard_input;
 
-      character_size = (ssize_t) ply_utf8_character_get_size (bytes + i, size - i);
+                character_size = (ssize_t) ply_utf8_character_get_size (bytes + i, size - i);
 
-      if (character_size < 0)
-        break;
+                if (character_size < 0)
+                        break;
 
-      /* If we're at a NUL character walk through it
-      */
-      if (character_size == 0)
-        {
-          i++;
-          continue;
-        }
+                /* If we're at a NUL character walk through it
+                 */
+                if (character_size == 0) {
+                        i++;
+                        continue;
+                }
 
-      keyboard_input = strndup (bytes + i, character_size);
+                keyboard_input = strndup (bytes + i, character_size);
 
-      process_keyboard_input (keyboard, keyboard_input, character_size);
+                process_keyboard_input (keyboard, keyboard_input, character_size);
 
-      i += character_size;
+                i += character_size;
 
-      free (keyboard_input);
-    }
+                free (keyboard_input);
+        }
 
-  if (i > 0)
-    ply_buffer_remove_bytes (buffer, i);
+        if (i > 0)
+                ply_buffer_remove_bytes (buffer, i);
 }
 
 static bool
 ply_keyboard_watch_for_renderer_input (ply_keyboard_t *keyboard)
 {
-  assert (keyboard != NULL);
-
-  if (!ply_renderer_open_input_source (keyboard->provider.if_renderer->renderer,
-                                       keyboard->provider.if_renderer->input_source))
-    return false;
-
-  ply_renderer_set_handler_for_input_source (keyboard->provider.if_renderer->renderer,
-                                             keyboard->provider.if_renderer->input_source,
-                                             (ply_renderer_input_source_handler_t)
-                                             on_key_event,
-                                             keyboard);
-  return true;
+        assert (keyboard != NULL);
+
+        if (!ply_renderer_open_input_source (keyboard->provider.if_renderer->renderer,
+                                             keyboard->provider.if_renderer->input_source))
+                return false;
+
+        ply_renderer_set_handler_for_input_source (keyboard->provider.if_renderer->renderer,
+                                                   keyboard->provider.if_renderer->input_source,
+                                                   (ply_renderer_input_source_handler_t)
+                                                   on_key_event,
+                                                   keyboard);
+        return true;
 }
 
 static void
 ply_keyboard_stop_watching_for_renderer_input (ply_keyboard_t *keyboard)
 {
-  ply_renderer_set_handler_for_input_source (keyboard->provider.if_renderer->renderer,
-                                             keyboard->provider.if_renderer->input_source,
-                                             (ply_renderer_input_source_handler_t)
-                                             NULL, NULL);
+        ply_renderer_set_handler_for_input_source (keyboard->provider.if_renderer->renderer,
+                                                   keyboard->provider.if_renderer->input_source,
+                                                   (ply_renderer_input_source_handler_t)
+                                                   NULL, NULL);
 
-  ply_renderer_close_input_source (keyboard->provider.if_renderer->renderer,
-                                   keyboard->provider.if_renderer->input_source);
+        ply_renderer_close_input_source (keyboard->provider.if_renderer->renderer,
+                                         keyboard->provider.if_renderer->input_source);
 }
 
 static void
 on_terminal_data (ply_keyboard_t *keyboard)
 {
-  int terminal_fd;
+        int terminal_fd;
 
-  terminal_fd = ply_terminal_get_fd (keyboard->provider.if_terminal->terminal);
-  ply_buffer_append_from_fd (keyboard->provider.if_terminal->key_buffer,
-                             terminal_fd);
-  on_key_event (keyboard, keyboard->provider.if_terminal->key_buffer);
+        terminal_fd = ply_terminal_get_fd (keyboard->provider.if_terminal->terminal);
+        ply_buffer_append_from_fd (keyboard->provider.if_terminal->key_buffer,
+                                   terminal_fd);
+        on_key_event (keyboard, keyboard->provider.if_terminal->key_buffer);
 }
 
 static bool
 ply_keyboard_watch_for_terminal_input (ply_keyboard_t *keyboard)
 {
-  int terminal_fd;
+        int terminal_fd;
 
-  assert (keyboard != NULL);
+        assert (keyboard != NULL);
 
-  terminal_fd = ply_terminal_get_fd (keyboard->provider.if_terminal->terminal);
+        terminal_fd = ply_terminal_get_fd (keyboard->provider.if_terminal->terminal);
 
-  if (terminal_fd < 0 || !ply_terminal_is_open (keyboard->provider.if_terminal->terminal))
-    {
-      ply_trace ("terminal associated with keyboard isn't open");
-      return false;
-    }
+        if (terminal_fd < 0 || !ply_terminal_is_open (keyboard->provider.if_terminal->terminal)) {
+                ply_trace ("terminal associated with keyboard isn't open");
+                return false;
+        }
 
-  ply_terminal_watch_for_input (keyboard->provider.if_terminal->terminal,
-                                (ply_terminal_input_handler_t) on_terminal_data,
-                                keyboard);
+        ply_terminal_watch_for_input (keyboard->provider.if_terminal->terminal,
+                                      (ply_terminal_input_handler_t) on_terminal_data,
+                                      keyboard);
 
-  return true;
+        return true;
 }
 
 static void
 ply_keyboard_stop_watching_for_terminal_input (ply_keyboard_t *keyboard)
 {
-  ply_terminal_stop_watching_for_input (keyboard->provider.if_terminal->terminal,
-                                        (ply_terminal_input_handler_t)
-                                        on_terminal_data,
-                                        keyboard);
+        ply_terminal_stop_watching_for_input (keyboard->provider.if_terminal->terminal,
+                                              (ply_terminal_input_handler_t)
+                                              on_terminal_data,
+                                              keyboard);
 }
 
 bool
 ply_keyboard_watch_for_input (ply_keyboard_t *keyboard)
 {
-  assert (keyboard != NULL);
+        assert (keyboard != NULL);
 
-  switch (keyboard->provider_type)
-    {
-      case PLY_KEYBOARD_PROVIDER_TYPE_RENDERER:
-        return ply_keyboard_watch_for_renderer_input (keyboard);
+        switch (keyboard->provider_type) {
+        case PLY_KEYBOARD_PROVIDER_TYPE_RENDERER:
+                return ply_keyboard_watch_for_renderer_input (keyboard);
 
-      case PLY_KEYBOARD_PROVIDER_TYPE_TERMINAL:
-        return ply_keyboard_watch_for_terminal_input (keyboard);
-    }
+        case PLY_KEYBOARD_PROVIDER_TYPE_TERMINAL:
+                return ply_keyboard_watch_for_terminal_input (keyboard);
+        }
 
-  return false;
+        return false;
 }
 
 void
 ply_keyboard_stop_watching_for_input (ply_keyboard_t *keyboard)
 {
-  assert (keyboard != NULL);
+        assert (keyboard != NULL);
 
-  switch (keyboard->provider_type)
-    {
-      case PLY_KEYBOARD_PROVIDER_TYPE_RENDERER:
-        ply_keyboard_stop_watching_for_renderer_input (keyboard);
-        break;
-
-      case PLY_KEYBOARD_PROVIDER_TYPE_TERMINAL:
-        ply_keyboard_stop_watching_for_terminal_input (keyboard);
-        break;
-    }
+        switch (keyboard->provider_type) {
+        case PLY_KEYBOARD_PROVIDER_TYPE_RENDERER:
+                ply_keyboard_stop_watching_for_renderer_input (keyboard);
+                break;
 
+        case PLY_KEYBOARD_PROVIDER_TYPE_TERMINAL:
+                ply_keyboard_stop_watching_for_terminal_input (keyboard);
+                break;
+        }
 }
 
 void
 ply_keyboard_free (ply_keyboard_t *keyboard)
 {
-  if (keyboard == NULL)
-    return;
+        if (keyboard == NULL)
+                return;
 
-  ply_keyboard_stop_watching_for_input (keyboard);
+        ply_keyboard_stop_watching_for_input (keyboard);
 
-  ply_buffer_free (keyboard->line_buffer);
+        ply_buffer_free (keyboard->line_buffer);
 
-  if (keyboard->provider_type == PLY_KEYBOARD_PROVIDER_TYPE_RENDERER)
-    {
-      free (keyboard->provider.if_renderer);
-    }
-  else
-    {
-      ply_buffer_free (keyboard->provider.if_terminal->key_buffer);
-      free (keyboard->provider.if_terminal);
-    }
+        if (keyboard->provider_type == PLY_KEYBOARD_PROVIDER_TYPE_RENDERER) {
+                free (keyboard->provider.if_renderer);
+        } else {
+                ply_buffer_free (keyboard->provider.if_terminal->key_buffer);
+                free (keyboard->provider.if_terminal);
+        }
 
-  free (keyboard);
+        free (keyboard);
 }
 
 static ply_keyboard_closure_t *
-ply_keyboard_closure_new (ply_keyboard_handler_t  function,
-                          void                   *user_data)
+ply_keyboard_closure_new (ply_keyboard_handler_t function,
+                          void                  *user_data)
 {
-  ply_keyboard_closure_t *closure = calloc (1, sizeof (ply_keyboard_closure_t));
-  closure->function = function;
-  closure->user_data = user_data;
-  return closure;
+        ply_keyboard_closure_t *closure = calloc (1, sizeof(ply_keyboard_closure_t));
+
+        closure->function = function;
+        closure->user_data = user_data;
+        return closure;
 }
 
 
 static void
 ply_keyboard_closure_free (ply_keyboard_closure_t *closure)
 {
-  free (closure);
+        free (closure);
 }
 
 void
-ply_keyboard_add_input_handler (ply_keyboard_t               *keyboard,
-                                ply_keyboard_input_handler_t  input_handler,
-                                void                         *user_data)
+ply_keyboard_add_input_handler (ply_keyboard_t              *keyboard,
+                                ply_keyboard_input_handler_t input_handler,
+                                void                        *user_data)
 {
-  ply_keyboard_closure_t *closure;
+        ply_keyboard_closure_t *closure;
 
-  assert (keyboard != NULL);
+        assert (keyboard != NULL);
 
-  closure = ply_keyboard_closure_new ((ply_keyboard_handler_t) input_handler,
-                                      user_data);
-  ply_list_append_data (keyboard->keyboard_input_handler_list, closure);
+        closure = ply_keyboard_closure_new ((ply_keyboard_handler_t) input_handler,
+                                            user_data);
+        ply_list_append_data (keyboard->keyboard_input_handler_list, closure);
 }
 
 void
-ply_keyboard_remove_input_handler (ply_keyboard_t               *keyboard,
-                                   ply_keyboard_input_handler_t  input_handler)
+ply_keyboard_remove_input_handler (ply_keyboard_t              *keyboard,
+                                   ply_keyboard_input_handler_t input_handler)
 {
-  ply_list_node_t *node;
-
-  assert (keyboard != NULL);
-
-  for (node = ply_list_get_first_node(keyboard->keyboard_input_handler_list);
-       node; node = ply_list_get_next_node(keyboard->keyboard_input_handler_list, node))
-    {
-      ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
-      if ((ply_keyboard_input_handler_t) closure->function == input_handler)
-        {
-          ply_keyboard_closure_free (closure);
-          ply_list_remove_node (keyboard->keyboard_input_handler_list, node);
-          return;
+        ply_list_node_t *node;
+
+        assert (keyboard != NULL);
+
+        for (node = ply_list_get_first_node (keyboard->keyboard_input_handler_list);
+             node; node = ply_list_get_next_node (keyboard->keyboard_input_handler_list, node)) {
+                ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
+                if ((ply_keyboard_input_handler_t) closure->function == input_handler) {
+                        ply_keyboard_closure_free (closure);
+                        ply_list_remove_node (keyboard->keyboard_input_handler_list, node);
+                        return;
+                }
         }
-    }
 }
 
 void
-ply_keyboard_add_backspace_handler (ply_keyboard_t                   *keyboard,
-                                    ply_keyboard_backspace_handler_t  backspace_handler,
-                                    void                             *user_data)
+ply_keyboard_add_backspace_handler (ply_keyboard_t                  *keyboard,
+                                    ply_keyboard_backspace_handler_t backspace_handler,
+                                    void                            *user_data)
 {
-  ply_keyboard_closure_t *closure;
+        ply_keyboard_closure_t *closure;
 
-  assert (keyboard != NULL);
+        assert (keyboard != NULL);
 
-  closure = ply_keyboard_closure_new ((ply_keyboard_handler_t) backspace_handler,
-                                      user_data);
-  ply_list_append_data (keyboard->backspace_handler_list, closure);
+        closure = ply_keyboard_closure_new ((ply_keyboard_handler_t) backspace_handler,
+                                            user_data);
+        ply_list_append_data (keyboard->backspace_handler_list, closure);
 }
 
 
 void
-ply_keyboard_remove_backspace_handler (ply_keyboard_t                   *keyboard,
-                                       ply_keyboard_backspace_handler_t  backspace_handler)
+ply_keyboard_remove_backspace_handler (ply_keyboard_t                  *keyboard,
+                                       ply_keyboard_backspace_handler_t backspace_handler)
 {
-  ply_list_node_t *node;
-
-  assert (keyboard != NULL);
-
-  for (node = ply_list_get_first_node(keyboard->backspace_handler_list);
-       node; node = ply_list_get_next_node(keyboard->backspace_handler_list, node))
-    {
-      ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
-      if ((ply_keyboard_backspace_handler_t) closure->function == backspace_handler)
-        {
-          ply_keyboard_closure_free (closure);
-          ply_list_remove_node (keyboard->backspace_handler_list, node);
-          return;
+        ply_list_node_t *node;
+
+        assert (keyboard != NULL);
+
+        for (node = ply_list_get_first_node (keyboard->backspace_handler_list);
+             node; node = ply_list_get_next_node (keyboard->backspace_handler_list, node)) {
+                ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
+                if ((ply_keyboard_backspace_handler_t) closure->function == backspace_handler) {
+                        ply_keyboard_closure_free (closure);
+                        ply_list_remove_node (keyboard->backspace_handler_list, node);
+                        return;
+                }
         }
-    }
 }
 
 void
-ply_keyboard_add_escape_handler (ply_keyboard_t                *keyboard,
-                                 ply_keyboard_escape_handler_t  escape_handler,
-                                 void                          *user_data)
+ply_keyboard_add_escape_handler (ply_keyboard_t               *keyboard,
+                                 ply_keyboard_escape_handler_t escape_handler,
+                                 void                         *user_data)
 {
-  ply_keyboard_closure_t *closure;
+        ply_keyboard_closure_t *closure;
 
-  assert (keyboard != NULL);
+        assert (keyboard != NULL);
 
-  closure = ply_keyboard_closure_new ((ply_keyboard_handler_t)  escape_handler,
-                                      user_data);
-  ply_list_append_data (keyboard->escape_handler_list, closure);
+        closure = ply_keyboard_closure_new ((ply_keyboard_handler_t) escape_handler,
+                                            user_data);
+        ply_list_append_data (keyboard->escape_handler_list, closure);
 }
 
 
 void
-ply_keyboard_remove_escape_handler (ply_keyboard_t                *keyboard,
-                                    ply_keyboard_escape_handler_t  escape_handler)
+ply_keyboard_remove_escape_handler (ply_keyboard_t               *keyboard,
+                                    ply_keyboard_escape_handler_t escape_handler)
 {
-  ply_list_node_t *node;
-
-  assert (keyboard != NULL);
-
-  for (node = ply_list_get_first_node(keyboard->escape_handler_list);
-       node; node = ply_list_get_next_node(keyboard->escape_handler_list, node))
-    {
-      ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
-      if ((ply_keyboard_escape_handler_t) closure->function == escape_handler)
-        {
-          ply_keyboard_closure_free (closure);
-          ply_list_remove_node (keyboard->escape_handler_list, node);
-          return;
+        ply_list_node_t *node;
+
+        assert (keyboard != NULL);
+
+        for (node = ply_list_get_first_node (keyboard->escape_handler_list);
+             node; node = ply_list_get_next_node (keyboard->escape_handler_list, node)) {
+                ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
+                if ((ply_keyboard_escape_handler_t) closure->function == escape_handler) {
+                        ply_keyboard_closure_free (closure);
+                        ply_list_remove_node (keyboard->escape_handler_list, node);
+                        return;
+                }
         }
-    }
 }
 
 void
-ply_keyboard_add_enter_handler (ply_keyboard_t               *keyboard,
-                                ply_keyboard_enter_handler_t  enter_handler,
-                                void                         *user_data)
+ply_keyboard_add_enter_handler (ply_keyboard_t              *keyboard,
+                                ply_keyboard_enter_handler_t enter_handler,
+                                void                        *user_data)
 {
-  ply_keyboard_closure_t *closure;
+        ply_keyboard_closure_t *closure;
 
-  assert (keyboard != NULL);
+        assert (keyboard != NULL);
 
-  closure = ply_keyboard_closure_new ((ply_keyboard_handler_t) enter_handler,
-                                      user_data);
+        closure = ply_keyboard_closure_new ((ply_keyboard_handler_t) enter_handler,
+                                            user_data);
 
-  ply_list_append_data (keyboard->enter_handler_list, closure);
+        ply_list_append_data (keyboard->enter_handler_list, closure);
 }
 
 void
-ply_keyboard_remove_enter_handler (ply_keyboard_t               *keyboard,
-                                   ply_keyboard_enter_handler_t  enter_handler)
+ply_keyboard_remove_enter_handler (ply_keyboard_t              *keyboard,
+                                   ply_keyboard_enter_handler_t enter_handler)
 {
-  ply_list_node_t *node;
-
-  assert (keyboard != NULL);
-
-  for (node = ply_list_get_first_node(keyboard->enter_handler_list);
-       node; node = ply_list_get_next_node(keyboard->enter_handler_list, node))
-    {
-      ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
-      if ((ply_keyboard_enter_handler_t) closure->function == enter_handler)
-        {
-          ply_keyboard_closure_free (closure);
-          ply_list_remove_node (keyboard->enter_handler_list, node);
-          return;
+        ply_list_node_t *node;
+
+        assert (keyboard != NULL);
+
+        for (node = ply_list_get_first_node (keyboard->enter_handler_list);
+             node; node = ply_list_get_next_node (keyboard->enter_handler_list, node)) {
+                ply_keyboard_closure_t *closure = ply_list_node_get_data (node);
+                if ((ply_keyboard_enter_handler_t) closure->function == enter_handler) {
+                        ply_keyboard_closure_free (closure);
+                        ply_list_remove_node (keyboard->enter_handler_list, node);
+                        return;
+                }
         }
-    }
 }
 
 /* vim: set ts=4 sw=4 et ai ci cino={.5s,^-2,+.5s,t0,g0,e-2,n-2,p2s,(0,=.5s,:.5s */
diff --git a/src/libply-splash-core/ply-keyboard.h b/src/libply-splash-core/ply-keyboard.h
index 74683cf..23497d9 100644
--- a/src/libply-splash-core/ply-keyboard.h
+++ b/src/libply-splash-core/ply-keyboard.h
@@ -32,42 +32,42 @@
 
 typedef struct _ply_keyboard ply_keyboard_t;
 
-typedef void (* ply_keyboard_input_handler_t) (void       *user_data,
-                                               const char *keyboard_input,
-                                               size_t      character_size);
+typedef void (*ply_keyboard_input_handler_t) (void       *user_data,
+                                              const char *keyboard_input,
+                                              size_t      character_size);
 
-typedef void (* ply_keyboard_backspace_handler_t) (void *user_data);
+typedef void (*ply_keyboard_backspace_handler_t) (void *user_data);
 
-typedef void (* ply_keyboard_escape_handler_t) (void *user_data);
+typedef void (*ply_keyboard_escape_handler_t) (void *user_data);
 
-typedef void (* ply_keyboard_enter_handler_t) (void       *user_data,
-                                               const char *line);
+typedef void (*ply_keyboard_enter_handler_t) (void       *user_data,
+                                              const char *line);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_keyboard_t *ply_keyboard_new_for_terminal (ply_terminal_t *terminal);
 ply_keyboard_t *ply_keyboard_new_for_renderer (ply_renderer_t *renderer);
 void ply_keyboard_free (ply_keyboard_t *keyboard);
 
-void ply_keyboard_add_input_handler (ply_keyboard_t               *keyboard,
-                                     ply_keyboard_input_handler_t  input_handler,
-                                     void                         *user_data);
-void ply_keyboard_remove_input_handler (ply_keyboard_t               *keyboard,
-                                        ply_keyboard_input_handler_t  input_handler);
-void ply_keyboard_add_backspace_handler (ply_keyboard_t                   *keyboard,
-                                         ply_keyboard_backspace_handler_t  backspace_handler,
-                                         void                             *user_data);
-void ply_keyboard_remove_backspace_handler (ply_keyboard_t                   *keyboard,
-                                            ply_keyboard_backspace_handler_t  backspace_handler);
-void ply_keyboard_add_escape_handler (ply_keyboard_t                *keyboard,
-                                      ply_keyboard_escape_handler_t  escape_handler,
-                                      void                          *user_data);
-void ply_keyboard_remove_escape_handler (ply_keyboard_t                *keyboard,
-                                         ply_keyboard_escape_handler_t  escape_handler);
-void ply_keyboard_add_enter_handler (ply_keyboard_t               *keyboard,
-                                     ply_keyboard_enter_handler_t  enter_handler,
-                                     void                         *user_data);
-void ply_keyboard_remove_enter_handler (ply_keyboard_t               *keyboard,
-                                        ply_keyboard_enter_handler_t  enter_handler);
+void ply_keyboard_add_input_handler (ply_keyboard_t              *keyboard,
+                                     ply_keyboard_input_handler_t input_handler,
+                                     void                        *user_data);
+void ply_keyboard_remove_input_handler (ply_keyboard_t              *keyboard,
+                                        ply_keyboard_input_handler_t input_handler);
+void ply_keyboard_add_backspace_handler (ply_keyboard_t                  *keyboard,
+                                         ply_keyboard_backspace_handler_t backspace_handler,
+                                         void                            *user_data);
+void ply_keyboard_remove_backspace_handler (ply_keyboard_t                  *keyboard,
+                                            ply_keyboard_backspace_handler_t backspace_handler);
+void ply_keyboard_add_escape_handler (ply_keyboard_t               *keyboard,
+                                      ply_keyboard_escape_handler_t escape_handler,
+                                      void                         *user_data);
+void ply_keyboard_remove_escape_handler (ply_keyboard_t               *keyboard,
+                                         ply_keyboard_escape_handler_t escape_handler);
+void ply_keyboard_add_enter_handler (ply_keyboard_t              *keyboard,
+                                     ply_keyboard_enter_handler_t enter_handler,
+                                     void                        *user_data);
+void ply_keyboard_remove_enter_handler (ply_keyboard_t              *keyboard,
+                                        ply_keyboard_enter_handler_t enter_handler);
 
 bool ply_keyboard_watch_for_input (ply_keyboard_t *keyboard);
 void ply_keyboard_stop_watching_for_input (ply_keyboard_t *keyboard);
diff --git a/src/libply-splash-core/ply-pixel-buffer.c b/src/libply-splash-core/ply-pixel-buffer.c
index a860b7f..c1825cc 100644
--- a/src/libply-splash-core/ply-pixel-buffer.c
+++ b/src/libply-splash-core/ply-pixel-buffer.c
@@ -39,12 +39,12 @@
 
 struct _ply_pixel_buffer
 {
-  uint32_t *bytes;
+        uint32_t       *bytes;
 
-  ply_rectangle_t area;
-  ply_list_t *clip_areas;
+        ply_rectangle_t area;
+        ply_list_t     *clip_areas;
 
-  ply_region_t *updated_areas;
+        ply_region_t   *updated_areas;
 };
 
 static inline void ply_pixel_buffer_blend_value_at_pixel (ply_pixel_buffer_t *buffer,
@@ -61,66 +61,63 @@ static inline uint32_t
 blend_two_pixel_values (uint32_t pixel_value_1,
                         uint32_t pixel_value_2)
 {
-  if ((pixel_value_2 & 0xff000000) == 0xff000000)
-    {
-      uint8_t alpha_1, red_1, green_1, blue_1;
-      uint8_t red_2, green_2, blue_2;
-      uint_least32_t red, green, blue;
-
-      alpha_1 = (uint8_t) (pixel_value_1 >> 24);
-      red_1 = (uint8_t) (pixel_value_1 >> 16);
-      green_1 = (uint8_t) (pixel_value_1 >> 8);
-      blue_1 = (uint8_t) pixel_value_1;
-
-      red_2 = (uint8_t) (pixel_value_2 >> 16);
-      green_2 = (uint8_t) (pixel_value_2 >> 8);
-      blue_2 = (uint8_t) pixel_value_2;
-
-      red = red_1 * 255 + red_2 * (255 - alpha_1);
-      green = green_1 * 255 + green_2 * (255 - alpha_1);
-      blue = blue_1 * 255 + blue_2 * (255 - alpha_1);
-
-      red = (uint8_t) ((red + (red >> 8) + 0x80) >> 8);
-      green = (uint8_t) ((green + (green >> 8) + 0x80) >> 8);
-      blue = (uint8_t) ((blue + (blue >> 8) + 0x80) >> 8);
-
-      return 0xff000000 | (red << 16) | (green << 8) | blue;
-    }
-  else
-    {
-      uint8_t alpha_1, red_1, green_1, blue_1;
-      uint8_t alpha_2, red_2, green_2, blue_2;
-      uint_least32_t alpha, red, green, blue;
-
-      alpha_1 = (uint8_t) (pixel_value_1 >> 24);
-      red_1 = (uint8_t) (pixel_value_1 >> 16);
-      green_1 = (uint8_t) (pixel_value_1 >> 8);
-      blue_1 = (uint8_t) pixel_value_1;
-
-      alpha_2 = (uint8_t) (pixel_value_2 >> 24);
-      red_2 = (uint8_t) (pixel_value_2 >> 16);
-      green_2 = (uint8_t) (pixel_value_2 >> 8);
-      blue_2 = (uint8_t) pixel_value_2;
-
-      red = red_1 * alpha_1 + red_2 * alpha_2 * (255 - alpha_1);
-      green = green_1 * alpha_1 + green_2 * alpha_2 * (255 - alpha_1);
-      blue = blue_1 * alpha_1 + blue_2 * alpha_2 * (255 - alpha_1);
-      alpha = alpha_1 * 255 + alpha_2 * (255 - alpha_1);
-
-      red = (red + (red >> 8) + 0x80) >> 8;
-      red = MIN (red, 0xff);
-
-      green = (green + (green >> 8) + 0x80) >> 8;
-      green = MIN (green, 0xff);
-
-      blue = (blue + (blue >> 8) + 0x80) >> 8;
-      blue = MIN (blue, 0xff);
-
-      alpha = (alpha + (alpha >> 8) + 0x80) >> 8;
-      alpha = MIN (alpha, 0xff);
-
-      return (alpha << 24) | (red << 16) | (green << 8) | blue;
-    }
+        if ((pixel_value_2 & 0xff000000) == 0xff000000) {
+                uint8_t alpha_1, red_1, green_1, blue_1;
+                uint8_t red_2, green_2, blue_2;
+                uint_least32_t red, green, blue;
+
+                alpha_1 = (uint8_t) (pixel_value_1 >> 24);
+                red_1 = (uint8_t) (pixel_value_1 >> 16);
+                green_1 = (uint8_t) (pixel_value_1 >> 8);
+                blue_1 = (uint8_t) pixel_value_1;
+
+                red_2 = (uint8_t) (pixel_value_2 >> 16);
+                green_2 = (uint8_t) (pixel_value_2 >> 8);
+                blue_2 = (uint8_t) pixel_value_2;
+
+                red = red_1 * 255 + red_2 * (255 - alpha_1);
+                green = green_1 * 255 + green_2 * (255 - alpha_1);
+                blue = blue_1 * 255 + blue_2 * (255 - alpha_1);
+
+                red = (uint8_t) ((red + (red >> 8) + 0x80) >> 8);
+                green = (uint8_t) ((green + (green >> 8) + 0x80) >> 8);
+                blue = (uint8_t) ((blue + (blue >> 8) + 0x80) >> 8);
+
+                return 0xff000000 | (red << 16) | (green << 8) | blue;
+        } else {
+                uint8_t alpha_1, red_1, green_1, blue_1;
+                uint8_t alpha_2, red_2, green_2, blue_2;
+                uint_least32_t alpha, red, green, blue;
+
+                alpha_1 = (uint8_t) (pixel_value_1 >> 24);
+                red_1 = (uint8_t) (pixel_value_1 >> 16);
+                green_1 = (uint8_t) (pixel_value_1 >> 8);
+                blue_1 = (uint8_t) pixel_value_1;
+
+                alpha_2 = (uint8_t) (pixel_value_2 >> 24);
+                red_2 = (uint8_t) (pixel_value_2 >> 16);
+                green_2 = (uint8_t) (pixel_value_2 >> 8);
+                blue_2 = (uint8_t) pixel_value_2;
+
+                red = red_1 * alpha_1 + red_2 * alpha_2 * (255 - alpha_1);
+                green = green_1 * alpha_1 + green_2 * alpha_2 * (255 - alpha_1);
+                blue = blue_1 * alpha_1 + blue_2 * alpha_2 * (255 - alpha_1);
+                alpha = alpha_1 * 255 + alpha_2 * (255 - alpha_1);
+
+                red = (red + (red >> 8) + 0x80) >> 8;
+                red = MIN (red, 0xff);
+
+                green = (green + (green >> 8) + 0x80) >> 8;
+                green = MIN (green, 0xff);
+
+                blue = (blue + (blue >> 8) + 0x80) >> 8;
+                blue = MIN (blue, 0xff);
+
+                alpha = (alpha + (alpha >> 8) + 0x80) >> 8;
+                alpha = MIN (alpha, 0xff);
+
+                return (alpha << 24) | (red << 16) | (green << 8) | blue;
+        }
 }
 
 __attribute__((__pure__))
@@ -128,27 +125,27 @@ static inline uint32_t
 make_pixel_value_translucent (uint32_t pixel_value,
                               uint8_t  opacity)
 {
-  uint_least16_t alpha, red, green, blue;
+        uint_least16_t alpha, red, green, blue;
 
-  if (opacity == 255)
-    return pixel_value;
+        if (opacity == 255)
+                return pixel_value;
 
-  alpha = (uint8_t) (pixel_value >> 24);
-  red = (uint8_t) (pixel_value >> 16);
-  green = (uint8_t) (pixel_value >> 8);
-  blue = (uint8_t) pixel_value;
+        alpha = (uint8_t) (pixel_value >> 24);
+        red = (uint8_t) (pixel_value >> 16);
+        green = (uint8_t) (pixel_value >> 8);
+        blue = (uint8_t) pixel_value;
 
-  red *= opacity;
-  green *= opacity;
-  blue *= opacity;
-  alpha *= opacity;
+        red *= opacity;
+        green *= opacity;
+        blue *= opacity;
+        alpha *= opacity;
 
-  red = (uint8_t) ((red + (red >> 8) + 0x80) >> 8);
-  green = (uint8_t) ((green + (green >> 8) + 0x80) >> 8);
-  blue = (uint8_t) ((blue + (blue >> 8) + 0x80) >> 8);
-  alpha = (uint8_t) ((alpha + (alpha >> 8) + 0x80) >> 8);
+        red = (uint8_t) ((red + (red >> 8) + 0x80) >> 8);
+        green = (uint8_t) ((green + (green >> 8) + 0x80) >> 8);
+        blue = (uint8_t) ((blue + (blue >> 8) + 0x80) >> 8);
+        alpha = (uint8_t) ((alpha + (alpha >> 8) + 0x80) >> 8);
 
-  return (alpha << 24) | (red << 16) | (green << 8) | blue;
+        return (alpha << 24) | (red << 16) | (green << 8) | blue;
 }
 
 static inline void
@@ -157,16 +154,15 @@ ply_pixel_buffer_blend_value_at_pixel (ply_pixel_buffer_t *buffer,
                                        int                 y,
                                        uint32_t            pixel_value)
 {
-  uint32_t old_pixel_value;
+        uint32_t old_pixel_value;
 
-  if ((pixel_value >> 24) != 0xff)
-    {
-      old_pixel_value = buffer->bytes[y * buffer->area.width + x];
+        if ((pixel_value >> 24) != 0xff) {
+                old_pixel_value = buffer->bytes[y * buffer->area.width + x];
 
-      pixel_value = blend_two_pixel_values (pixel_value, old_pixel_value);
-    }
+                pixel_value = blend_two_pixel_values (pixel_value, old_pixel_value);
+        }
 
-  buffer->bytes[y * buffer->area.width + x] = pixel_value;
+        buffer->bytes[y * buffer->area.width + x] = pixel_value;
 }
 
 static void
@@ -174,137 +170,135 @@ ply_pixel_buffer_crop_area_to_clip_area (ply_pixel_buffer_t *buffer,
                                          ply_rectangle_t    *area,
                                          ply_rectangle_t    *cropped_area)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  *cropped_area = *area;
+        *cropped_area = *area;
 
-  node = ply_list_get_first_node (buffer->clip_areas);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_rectangle_t *clip_rectangle;
+        node = ply_list_get_first_node (buffer->clip_areas);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_rectangle_t *clip_rectangle;
 
-      clip_rectangle = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (buffer->clip_areas, node);
+                clip_rectangle = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (buffer->clip_areas, node);
 
-      ply_rectangle_intersect (cropped_area, clip_rectangle, cropped_area);
+                ply_rectangle_intersect (cropped_area, clip_rectangle, cropped_area);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
-ply_pixel_buffer_fill_area_with_pixel_value (ply_pixel_buffer_t      *buffer,
-                                             ply_rectangle_t         *fill_area,
-                                             uint32_t                 pixel_value)
-{
-  unsigned long row, column;
-  ply_rectangle_t cropped_area;
-
-  ply_pixel_buffer_crop_area_to_clip_area (buffer, fill_area, &cropped_area);
-
-  for (row = cropped_area.y; row < cropped_area.y + cropped_area.height; row++)
-    {
-      for (column = cropped_area.x; column < cropped_area.x + cropped_area.width; column++)
-        {
-          ply_pixel_buffer_blend_value_at_pixel (buffer,
-                                                 column, row,
-                                                 pixel_value);
+ply_pixel_buffer_fill_area_with_pixel_value (ply_pixel_buffer_t *buffer,
+                                             ply_rectangle_t    *fill_area,
+                                             uint32_t            pixel_value)
+{
+        unsigned long row, column;
+        ply_rectangle_t cropped_area;
+
+        ply_pixel_buffer_crop_area_to_clip_area (buffer, fill_area, &cropped_area);
+
+        for (row = cropped_area.y; row < cropped_area.y + cropped_area.height; row++) {
+                for (column = cropped_area.x; column < cropped_area.x + cropped_area.width; column++) {
+                        ply_pixel_buffer_blend_value_at_pixel (buffer,
+                                                               column, row,
+                                                               pixel_value);
+                }
         }
-    }
 }
 
 void
 ply_pixel_buffer_push_clip_area (ply_pixel_buffer_t *buffer,
                                  ply_rectangle_t    *clip_area)
 {
-  ply_rectangle_t *new_clip_area;
+        ply_rectangle_t *new_clip_area;
 
-  new_clip_area = malloc (sizeof (*new_clip_area));
+        new_clip_area = malloc (sizeof(*new_clip_area));
 
-  *new_clip_area = *clip_area;
-  ply_list_append_data (buffer->clip_areas, new_clip_area);
+        *new_clip_area = *clip_area;
+        ply_list_append_data (buffer->clip_areas, new_clip_area);
 }
 
 void
 ply_pixel_buffer_pop_clip_area (ply_pixel_buffer_t *buffer)
 {
-  ply_list_node_t *last_node;
+        ply_list_node_t *last_node;
 
-  last_node = ply_list_get_last_node (buffer->clip_areas);
-  free (ply_list_node_get_data (last_node));
-  ply_list_remove_node (buffer->clip_areas, last_node);
+        last_node = ply_list_get_last_node (buffer->clip_areas);
+        free (ply_list_node_get_data (last_node));
+        ply_list_remove_node (buffer->clip_areas, last_node);
 }
 
 ply_pixel_buffer_t *
 ply_pixel_buffer_new (unsigned long width,
                       unsigned long height)
 {
-  ply_pixel_buffer_t *buffer;
+        ply_pixel_buffer_t *buffer;
 
-  buffer = calloc (1, sizeof (ply_pixel_buffer_t));
+        buffer = calloc (1, sizeof(ply_pixel_buffer_t));
 
-  buffer->updated_areas = ply_region_new ();
-  buffer->bytes = (uint32_t *) calloc (height, width * sizeof (uint32_t));
-  buffer->area.width = width;
-  buffer->area.height = height;
+        buffer->updated_areas = ply_region_new ();
+        buffer->bytes = (uint32_t *) calloc (height, width * sizeof(uint32_t));
+        buffer->area.width = width;
+        buffer->area.height = height;
 
-  buffer->clip_areas = ply_list_new ();
-  ply_pixel_buffer_push_clip_area (buffer, &buffer->area);
+        buffer->clip_areas = ply_list_new ();
+        ply_pixel_buffer_push_clip_area (buffer, &buffer->area);
 
-  return buffer;
+        return buffer;
 }
 
 static void
 free_clip_areas (ply_pixel_buffer_t *buffer)
 {
-  while (ply_list_get_length (buffer->clip_areas) > 0)
-    ply_pixel_buffer_pop_clip_area (buffer);
+        while (ply_list_get_length (buffer->clip_areas) > 0) {
+                ply_pixel_buffer_pop_clip_area (buffer);
+        }
 
-  ply_list_free (buffer->clip_areas);
-  buffer->clip_areas = NULL;
+        ply_list_free (buffer->clip_areas);
+        buffer->clip_areas = NULL;
 }
 
 void
 ply_pixel_buffer_free (ply_pixel_buffer_t *buffer)
 {
-  if (buffer == NULL)
-    return;
+        if (buffer == NULL)
+                return;
 
-  free_clip_areas (buffer);
-  free (buffer->bytes);
-  ply_region_free (buffer->updated_areas);
-  free (buffer);
+        free_clip_areas (buffer);
+        free (buffer->bytes);
+        ply_region_free (buffer->updated_areas);
+        free (buffer);
 }
 
 void
 ply_pixel_buffer_get_size (ply_pixel_buffer_t *buffer,
                            ply_rectangle_t    *size)
 {
-  assert (buffer != NULL);
-  assert (size != NULL);
+        assert (buffer != NULL);
+        assert (size != NULL);
 
-  *size = buffer->area;
+        *size = buffer->area;
 }
 
-unsigned long 
+unsigned long
 ply_pixel_buffer_get_width (ply_pixel_buffer_t *buffer)
 {
-  assert (buffer != NULL);
-  return buffer->area.width;
+        assert (buffer != NULL);
+        return buffer->area.width;
 }
 
-unsigned long 
+unsigned long
 ply_pixel_buffer_get_height (ply_pixel_buffer_t *buffer)
 {
-  assert (buffer != NULL);
-  return buffer->area.height;
+        assert (buffer != NULL);
+        return buffer->area.height;
 }
 
 ply_region_t *
 ply_pixel_buffer_get_updated_areas (ply_pixel_buffer_t *buffer)
 {
-  return buffer->updated_areas;
+        return buffer->updated_areas;
 }
 
 void
@@ -356,83 +350,75 @@ ply_pixel_buffer_fill_with_gradient (ply_pixel_buffer_t *buffer,
  */
 #define COLOR_MASK (0xff << (24 - NOISE_BITS))
 
-  uint32_t red, green, blue, red_step, green_step, blue_step, t, pixel;
-  uint32_t x, y;
-  /* we use a fixed seed so that the dithering doesn't change on repaints
-   * of the same area.
-   */
-  uint32_t noise = 0x100001;
-  ply_rectangle_t cropped_area;
+        uint32_t red, green, blue, red_step, green_step, blue_step, t, pixel;
+        uint32_t x, y;
+        /* we use a fixed seed so that the dithering doesn't change on repaints
+         * of the same area.
+         */
+        uint32_t noise = 0x100001;
+        ply_rectangle_t cropped_area;
 
-  if (fill_area == NULL)
-    fill_area = &buffer->area;
+        if (fill_area == NULL)
+                fill_area = &buffer->area;
 
-  ply_pixel_buffer_crop_area_to_clip_area (buffer, fill_area, &cropped_area);
+        ply_pixel_buffer_crop_area_to_clip_area (buffer, fill_area, &cropped_area);
 
-  red   = (start << RED_SHIFT) & COLOR_MASK;
-  green = (start << GREEN_SHIFT) & COLOR_MASK;
-  blue  = (start << BLUE_SHIFT) & COLOR_MASK;
+        red = (start << RED_SHIFT) & COLOR_MASK;
+        green = (start << GREEN_SHIFT) & COLOR_MASK;
+        blue = (start << BLUE_SHIFT) & COLOR_MASK;
 
-  t = (end << RED_SHIFT) & COLOR_MASK;
-  red_step = (int32_t) (t - red) / (int32_t) buffer->area.height;
-  t = (end << GREEN_SHIFT) & COLOR_MASK;
-  green_step = (int32_t) (t - green) / (int32_t) buffer->area.height;
-  t = (end << BLUE_SHIFT) & COLOR_MASK;
-  blue_step = (int32_t) (t - blue) / (int32_t) buffer->area.height;
+        t = (end << RED_SHIFT) & COLOR_MASK;
+        red_step = (int32_t) (t - red) / (int32_t) buffer->area.height;
+        t = (end << GREEN_SHIFT) & COLOR_MASK;
+        green_step = (int32_t) (t - green) / (int32_t) buffer->area.height;
+        t = (end << BLUE_SHIFT) & COLOR_MASK;
+        blue_step = (int32_t) (t - blue) / (int32_t) buffer->area.height;
 
 
 #define RANDOMIZE(num) (num = (num + (num << 1)) & NOISE_MASK)
 #define UNROLLED_PIXEL_COUNT 8
 
-  for (y = buffer->area.y; y < buffer->area.y + buffer->area.height; y++)
-    {
-      if (cropped_area.y <= y && y < cropped_area.y + cropped_area.height)
-        {
-          if (cropped_area.width < UNROLLED_PIXEL_COUNT)
-            {
-              for (x = cropped_area.x; x < cropped_area.x + cropped_area.width; x++)
-                {
-                  pixel = 0xff000000;
-                  RANDOMIZE(noise);
-                  pixel |= (((red   + noise) & COLOR_MASK) >> RED_SHIFT);
-                  RANDOMIZE(noise);
-                  pixel |= (((green + noise) & COLOR_MASK) >> GREEN_SHIFT);
-                  RANDOMIZE(noise);
-                  pixel |= (((blue  + noise) & COLOR_MASK) >> BLUE_SHIFT);
-
-                  buffer->bytes[y * buffer->area.width + x] = pixel;
-                }
-            }
-          else
-            {
-              uint32_t shaded_set[UNROLLED_PIXEL_COUNT];
-              uint32_t *ptr = &buffer->bytes[y * buffer->area.width + cropped_area.x];
-              for (x = 0; x < UNROLLED_PIXEL_COUNT; x++)
-                {
-                  shaded_set[x] = 0xff000000;
-                  RANDOMIZE(noise);
-                  shaded_set[x] |= (((red   + noise) & COLOR_MASK) >> RED_SHIFT);
-                  RANDOMIZE(noise);
-                  shaded_set[x] |= (((green + noise) & COLOR_MASK) >> GREEN_SHIFT);
-                  RANDOMIZE(noise);
-                  shaded_set[x] |= (((blue  + noise) & COLOR_MASK) >> BLUE_SHIFT);
-                }
-              for (x = cropped_area.width; x >=UNROLLED_PIXEL_COUNT; x-= UNROLLED_PIXEL_COUNT)
-                {
-                  memcpy (ptr, (void *) shaded_set, UNROLLED_PIXEL_COUNT * sizeof (uint32_t));
-                  ptr += UNROLLED_PIXEL_COUNT;
+        for (y = buffer->area.y; y < buffer->area.y + buffer->area.height; y++) {
+                if (cropped_area.y <= y && y < cropped_area.y + cropped_area.height) {
+                        if (cropped_area.width < UNROLLED_PIXEL_COUNT) {
+                                for (x = cropped_area.x; x < cropped_area.x + cropped_area.width; x++) {
+                                        pixel = 0xff000000;
+                                        RANDOMIZE (noise);
+                                        pixel |= (((red + noise) & COLOR_MASK) >> RED_SHIFT);
+                                        RANDOMIZE (noise);
+                                        pixel |= (((green + noise) & COLOR_MASK) >> GREEN_SHIFT);
+                                        RANDOMIZE (noise);
+                                        pixel |= (((blue + noise) & COLOR_MASK) >> BLUE_SHIFT);
+
+                                        buffer->bytes[y * buffer->area.width + x] = pixel;
+                                }
+                        } else {
+                                uint32_t shaded_set[UNROLLED_PIXEL_COUNT];
+                                uint32_t *ptr = &buffer->bytes[y * buffer->area.width + cropped_area.x];
+                                for (x = 0; x < UNROLLED_PIXEL_COUNT; x++) {
+                                        shaded_set[x] = 0xff000000;
+                                        RANDOMIZE (noise);
+                                        shaded_set[x] |= (((red + noise) & COLOR_MASK) >> RED_SHIFT);
+                                        RANDOMIZE (noise);
+                                        shaded_set[x] |= (((green + noise) & COLOR_MASK) >> GREEN_SHIFT);
+                                        RANDOMIZE (noise);
+                                        shaded_set[x] |= (((blue + noise) & COLOR_MASK) >> BLUE_SHIFT);
+                                }
+                                for (x = cropped_area.width; x >= UNROLLED_PIXEL_COUNT; x -= UNROLLED_PIXEL_COUNT) {
+                                        memcpy (ptr, (void *) shaded_set, UNROLLED_PIXEL_COUNT * sizeof(uint32_t));
+                                        ptr += UNROLLED_PIXEL_COUNT;
+                                }
+
+                                memcpy (ptr, (void *) shaded_set, x * sizeof(uint32_t));
+                        }
                 }
 
-              memcpy (ptr, (void *) shaded_set, x * sizeof (uint32_t));
-            }
+                red += red_step;
+                green += green_step;
+                blue += blue_step;
         }
 
-      red += red_step;
-      green += green_step;
-      blue += blue_step;
-    }
-
-  ply_region_add_rectangle (buffer->updated_areas, &cropped_area);
+        ply_region_add_rectangle (buffer->updated_areas, &cropped_area);
 }
 
 void
@@ -443,25 +429,25 @@ ply_pixel_buffer_fill_with_color (ply_pixel_buffer_t *buffer,
                                   double              blue,
                                   double              alpha)
 {
-  uint32_t pixel_value;
-  ply_rectangle_t cropped_area;
+        uint32_t pixel_value;
+        ply_rectangle_t cropped_area;
 
-  assert (buffer != NULL);
+        assert (buffer != NULL);
 
-  if (fill_area == NULL)
-    fill_area = &buffer->area;
+        if (fill_area == NULL)
+                fill_area = &buffer->area;
 
-  ply_pixel_buffer_crop_area_to_clip_area (buffer, fill_area, &cropped_area);
+        ply_pixel_buffer_crop_area_to_clip_area (buffer, fill_area, &cropped_area);
 
-  red *= alpha;
-  green *= alpha;
-  blue *= alpha;
+        red *= alpha;
+        green *= alpha;
+        blue *= alpha;
 
-  pixel_value = PLY_PIXEL_BUFFER_COLOR_TO_PIXEL_VALUE (red, green, blue, alpha);
+        pixel_value = PLY_PIXEL_BUFFER_COLOR_TO_PIXEL_VALUE (red, green, blue, alpha);
 
-  ply_pixel_buffer_fill_area_with_pixel_value (buffer, &cropped_area, pixel_value);
+        ply_pixel_buffer_fill_area_with_pixel_value (buffer, &cropped_area, pixel_value);
 
-  ply_region_add_rectangle (buffer->updated_areas, &cropped_area);
+        ply_region_add_rectangle (buffer->updated_areas, &cropped_area);
 }
 
 void
@@ -470,41 +456,41 @@ ply_pixel_buffer_fill_with_hex_color_at_opacity (ply_pixel_buffer_t *buffer,
                                                  uint32_t            hex_color,
                                                  double              opacity)
 {
-  ply_rectangle_t cropped_area;
-  uint32_t pixel_value;
-  double red;
-  double green;
-  double blue;
-  double alpha;
+        ply_rectangle_t cropped_area;
+        uint32_t pixel_value;
+        double red;
+        double green;
+        double blue;
+        double alpha;
 
-  assert (buffer != NULL);
+        assert (buffer != NULL);
 
-  if (fill_area == NULL)
-    fill_area = &buffer->area;
+        if (fill_area == NULL)
+                fill_area = &buffer->area;
 
-  ply_pixel_buffer_crop_area_to_clip_area (buffer, fill_area, &cropped_area);
+        ply_pixel_buffer_crop_area_to_clip_area (buffer, fill_area, &cropped_area);
 
-  /* if they only gave an rgb hex number, assume an alpha of 0xff
-   */
-  if ((hex_color & 0xff000000) == 0)
-    hex_color = (hex_color << 8) | 0xff;
+        /* if they only gave an rgb hex number, assume an alpha of 0xff
+         */
+        if ((hex_color & 0xff000000) == 0)
+                hex_color = (hex_color << 8) | 0xff;
 
-  red = ((double) (hex_color & 0xff000000) / 0xff000000);
-  green = ((double) (hex_color & 0x00ff0000) / 0x00ff0000);
-  blue = ((double) (hex_color & 0x0000ff00) / 0x0000ff00);
-  alpha = ((double) (hex_color & 0x000000ff) / 0x000000ff);
+        red = ((double) (hex_color & 0xff000000) / 0xff000000);
+        green = ((double) (hex_color & 0x00ff0000) / 0x00ff0000);
+        blue = ((double) (hex_color & 0x0000ff00) / 0x0000ff00);
+        alpha = ((double) (hex_color & 0x000000ff) / 0x000000ff);
 
-  alpha *= opacity;
+        alpha *= opacity;
 
-  red *= alpha;
-  green *= alpha;
-  blue *= alpha;
+        red *= alpha;
+        green *= alpha;
+        blue *= alpha;
 
-  pixel_value = PLY_PIXEL_BUFFER_COLOR_TO_PIXEL_VALUE (red, green, blue, alpha);
+        pixel_value = PLY_PIXEL_BUFFER_COLOR_TO_PIXEL_VALUE (red, green, blue, alpha);
 
-  ply_pixel_buffer_fill_area_with_pixel_value (buffer, &cropped_area, pixel_value);
+        ply_pixel_buffer_fill_area_with_pixel_value (buffer, &cropped_area, pixel_value);
 
-  ply_region_add_rectangle (buffer->updated_areas, &cropped_area);
+        ply_region_add_rectangle (buffer->updated_areas, &cropped_area);
 }
 
 void
@@ -512,8 +498,8 @@ ply_pixel_buffer_fill_with_hex_color (ply_pixel_buffer_t *buffer,
                                       ply_rectangle_t    *fill_area,
                                       uint32_t            hex_color)
 {
-  return ply_pixel_buffer_fill_with_hex_color_at_opacity (buffer, fill_area,
-                                                          hex_color, 1.0);
+        return ply_pixel_buffer_fill_with_hex_color_at_opacity (buffer, fill_area,
+                                                                hex_color, 1.0);
 }
 
 void
@@ -523,49 +509,46 @@ ply_pixel_buffer_fill_with_argb32_data_at_opacity_with_clip (ply_pixel_buffer_t
                                                              uint32_t           *data,
                                                              double              opacity)
 {
-  unsigned long row, column;
-  uint8_t opacity_as_byte;
-  ply_rectangle_t cropped_area;
-  unsigned long x;
-  unsigned long y;
-
-  assert (buffer != NULL);
+        unsigned long row, column;
+        uint8_t opacity_as_byte;
+        ply_rectangle_t cropped_area;
+        unsigned long x;
+        unsigned long y;
 
-  if (fill_area == NULL)
-    fill_area = &buffer->area;
+        assert (buffer != NULL);
 
-  ply_pixel_buffer_crop_area_to_clip_area (buffer, fill_area, &cropped_area);
+        if (fill_area == NULL)
+                fill_area = &buffer->area;
 
-  if (clip_area)
-    ply_rectangle_intersect (&cropped_area, clip_area, &cropped_area);
+        ply_pixel_buffer_crop_area_to_clip_area (buffer, fill_area, &cropped_area);
 
-  if (cropped_area.width == 0 || cropped_area.height == 0)
-    return;
+        if (clip_area)
+                ply_rectangle_intersect (&cropped_area, clip_area, &cropped_area);
 
-  x = cropped_area.x - fill_area->x;
-  y = cropped_area.y - fill_area->y;
-  opacity_as_byte = (uint8_t) (opacity * 255.0);
+        if (cropped_area.width == 0 || cropped_area.height == 0)
+                return;
 
-  for (row = y; row < y + cropped_area.height; row++)
-    {
-      for (column = x; column < x + cropped_area.width; column++)
-        {
-          uint32_t pixel_value;
+        x = cropped_area.x - fill_area->x;
+        y = cropped_area.y - fill_area->y;
+        opacity_as_byte = (uint8_t) (opacity * 255.0);
 
-          pixel_value = data[fill_area->width * row + column];
-          if ((pixel_value >> 24) == 0x00)
-            continue;
+        for (row = y; row < y + cropped_area.height; row++) {
+                for (column = x; column < x + cropped_area.width; column++) {
+                        uint32_t pixel_value;
 
-          pixel_value = make_pixel_value_translucent (pixel_value, opacity_as_byte);
-          ply_pixel_buffer_blend_value_at_pixel (buffer,
-                                                 cropped_area.x + (column - x),
-                                                 cropped_area.y + (row - y),
-                                                 pixel_value);
+                        pixel_value = data[fill_area->width * row + column];
+                        if ((pixel_value >> 24) == 0x00)
+                                continue;
 
+                        pixel_value = make_pixel_value_translucent (pixel_value, opacity_as_byte);
+                        ply_pixel_buffer_blend_value_at_pixel (buffer,
+                                                               cropped_area.x + (column - x),
+                                                               cropped_area.y + (row - y),
+                                                               pixel_value);
+                }
         }
-    }
 
-  ply_region_add_rectangle (buffer->updated_areas, &cropped_area);
+        ply_region_add_rectangle (buffer->updated_areas, &cropped_area);
 }
 
 void
@@ -574,10 +557,10 @@ ply_pixel_buffer_fill_with_argb32_data_at_opacity (ply_pixel_buffer_t *buffer,
                                                    uint32_t           *data,
                                                    double              opacity)
 {
-  ply_pixel_buffer_fill_with_argb32_data_at_opacity_with_clip (buffer,
-                                                               fill_area,
-                                                               NULL,
-                                                               data, opacity);
+        ply_pixel_buffer_fill_with_argb32_data_at_opacity_with_clip (buffer,
+                                                                     fill_area,
+                                                                     NULL,
+                                                                     data, opacity);
 }
 
 void
@@ -585,10 +568,10 @@ ply_pixel_buffer_fill_with_argb32_data (ply_pixel_buffer_t *buffer,
                                         ply_rectangle_t    *fill_area,
                                         uint32_t           *data)
 {
-  ply_pixel_buffer_fill_with_argb32_data_at_opacity_with_clip (buffer,
-                                                               fill_area,
-                                                               NULL,
-                                                               data, 1.0);
+        ply_pixel_buffer_fill_with_argb32_data_at_opacity_with_clip (buffer,
+                                                                     fill_area,
+                                                                     NULL,
+                                                                     data, 1.0);
 }
 
 void
@@ -597,10 +580,10 @@ ply_pixel_buffer_fill_with_argb32_data_with_clip (ply_pixel_buffer_t *buffer,
                                                   ply_rectangle_t    *clip_area,
                                                   uint32_t           *data)
 {
-  ply_pixel_buffer_fill_with_argb32_data_at_opacity_with_clip (buffer,
-                                                               fill_area,
-                                                               clip_area,
-                                                               data, 1.0);
+        ply_pixel_buffer_fill_with_argb32_data_at_opacity_with_clip (buffer,
+                                                                     fill_area,
+                                                                     clip_area,
+                                                                     data, 1.0);
 }
 
 void
@@ -611,54 +594,51 @@ ply_pixel_buffer_fill_with_buffer_at_opacity_with_clip (ply_pixel_buffer_t *canv
                                                         ply_rectangle_t    *clip_area,
                                                         float               opacity)
 {
-  unsigned long row, column;
-  uint8_t opacity_as_byte;
-  ply_rectangle_t cropped_area;
-  unsigned long x;
-  unsigned long y;
+        unsigned long row, column;
+        uint8_t opacity_as_byte;
+        ply_rectangle_t cropped_area;
+        unsigned long x;
+        unsigned long y;
 
-  assert (canvas != NULL);
-  assert (source != NULL);
+        assert (canvas != NULL);
+        assert (source != NULL);
 
-  cropped_area.x = x_offset;
-  cropped_area.y = y_offset;
-  cropped_area.width = source->area.width;
-  cropped_area.height = source->area.height;
+        cropped_area.x = x_offset;
+        cropped_area.y = y_offset;
+        cropped_area.width = source->area.width;
+        cropped_area.height = source->area.height;
 
-  ply_pixel_buffer_crop_area_to_clip_area (canvas, &cropped_area, &cropped_area);
+        ply_pixel_buffer_crop_area_to_clip_area (canvas, &cropped_area, &cropped_area);
 
-  if (clip_area)
-    ply_rectangle_intersect (&cropped_area, clip_area, &cropped_area);
+        if (clip_area)
+                ply_rectangle_intersect (&cropped_area, clip_area, &cropped_area);
 
-  if (cropped_area.width == 0 || cropped_area.height == 0)
-    return;
+        if (cropped_area.width == 0 || cropped_area.height == 0)
+                return;
 
-  x = cropped_area.x - x_offset;
-  y = cropped_area.y - y_offset;
-  opacity_as_byte = (uint8_t) (opacity * 255.0);
+        x = cropped_area.x - x_offset;
+        y = cropped_area.y - y_offset;
+        opacity_as_byte = (uint8_t) (opacity * 255.0);
 
-  for (row = y; row < y + cropped_area.height; row++)
-    {
-      for (column = x; column < x + cropped_area.width; column++)
-        {
-          uint32_t pixel_value;
+        for (row = y; row < y + cropped_area.height; row++) {
+                for (column = x; column < x + cropped_area.width; column++) {
+                        uint32_t pixel_value;
 
-          pixel_value = source->bytes[row * source->area.width + column];
+                        pixel_value = source->bytes[row * source->area.width + column];
 
-          pixel_value = make_pixel_value_translucent (pixel_value, opacity_as_byte);
-          
-          if ((pixel_value >> 24) == 0x00)
-            continue;
+                        pixel_value = make_pixel_value_translucent (pixel_value, opacity_as_byte);
 
-          ply_pixel_buffer_blend_value_at_pixel (canvas,
-                                                 cropped_area.x + (column - x),
-                                                 cropped_area.y + (row - y),
-                                                 pixel_value);
+                        if ((pixel_value >> 24) == 0x00)
+                                continue;
 
+                        ply_pixel_buffer_blend_value_at_pixel (canvas,
+                                                               cropped_area.x + (column - x),
+                                                               cropped_area.y + (row - y),
+                                                               pixel_value);
+                }
         }
-    }
 
-  ply_region_add_rectangle (canvas->updated_areas, &cropped_area);
+        ply_region_add_rectangle (canvas->updated_areas, &cropped_area);
 }
 
 void
@@ -668,12 +648,12 @@ ply_pixel_buffer_fill_with_buffer_at_opacity (ply_pixel_buffer_t *canvas,
                                               int                 y_offset,
                                               float               opacity)
 {
-  ply_pixel_buffer_fill_with_buffer_at_opacity_with_clip (canvas,
-                                                          source,
-                                                          x_offset,
-                                                          y_offset,
-                                                          NULL,
-                                                          opacity);
+        ply_pixel_buffer_fill_with_buffer_at_opacity_with_clip (canvas,
+                                                                source,
+                                                                x_offset,
+                                                                y_offset,
+                                                                NULL,
+                                                                opacity);
 }
 
 void
@@ -683,12 +663,12 @@ ply_pixel_buffer_fill_with_buffer_with_clip (ply_pixel_buffer_t *canvas,
                                              int                 y_offset,
                                              ply_rectangle_t    *clip_area)
 {
-  ply_pixel_buffer_fill_with_buffer_at_opacity_with_clip (canvas,
-                                                          source,
-                                                          x_offset,
-                                                          y_offset,
-                                                          clip_area,
-                                                          1.0);
+        ply_pixel_buffer_fill_with_buffer_at_opacity_with_clip (canvas,
+                                                                source,
+                                                                x_offset,
+                                                                y_offset,
+                                                                clip_area,
+                                                                1.0);
 }
 
 void
@@ -697,18 +677,18 @@ ply_pixel_buffer_fill_with_buffer (ply_pixel_buffer_t *canvas,
                                    int                 x_offset,
                                    int                 y_offset)
 {
-  ply_pixel_buffer_fill_with_buffer_at_opacity_with_clip (canvas,
-                                                          source,
-                                                          x_offset,
-                                                          y_offset,
-                                                          NULL,
-                                                          1.0);
+        ply_pixel_buffer_fill_with_buffer_at_opacity_with_clip (canvas,
+                                                                source,
+                                                                x_offset,
+                                                                y_offset,
+                                                                NULL,
+                                                                1.0);
 }
 
 uint32_t *
 ply_pixel_buffer_get_argb32_data (ply_pixel_buffer_t *buffer)
 {
-  return buffer->bytes;
+        return buffer->bytes;
 }
 
 static inline uint32_t
@@ -716,53 +696,52 @@ ply_pixel_buffer_interpolate (ply_pixel_buffer_t *buffer,
                               double              x,
                               double              y)
 {
-  int ix;
-  int iy;
-  int width;
-  int height;
-  
-  int i;
-  
-  int offset_x;
-  int offset_y;
-  uint32_t pixels[2][2];
-  uint32_t reply = 0;
-  uint32_t *bytes;
-  
-  width = buffer->area.width;
-  height = buffer->area.height;
-
-  
-  bytes = ply_pixel_buffer_get_argb32_data (buffer);
-  
-  for (offset_y = 0; offset_y < 2; offset_y++)
-  for (offset_x = 0; offset_x < 2; offset_x++)
-    {
-      ix = x + offset_x;
-      iy = y + offset_y;
-      
-      if (ix < 0 || ix >= width || iy < 0 || iy >= height)
-        pixels[offset_y][offset_x] = 0x00000000;
-      else
-        pixels[offset_y][offset_x] = bytes[ix + iy * width];
-    }
-  if (!pixels[0][0] && !pixels[0][1] && !pixels[1][0] && !pixels[1][1]) return 0;
-  
-  ix = x;
-  iy = y;
-  x -= ix;
-  y -= iy;
-  for (i = 0; i < 4; i++)
-    {
-      uint32_t value = 0;
-      uint32_t mask = 0xFF << (i * 8);
-      value += ((pixels[0][0]) & mask) * (1-x) * (1-y);
-      value += ((pixels[0][1]) & mask) * x * (1-y);
-      value += ((pixels[1][0]) & mask) * (1-x) * y;
-      value += ((pixels[1][1]) & mask) * x * y;
-      reply |= value & mask;
-    }
-  return reply;
+        int ix;
+        int iy;
+        int width;
+        int height;
+
+        int i;
+
+        int offset_x;
+        int offset_y;
+        uint32_t pixels[2][2];
+        uint32_t reply = 0;
+        uint32_t *bytes;
+
+        width = buffer->area.width;
+        height = buffer->area.height;
+
+
+        bytes = ply_pixel_buffer_get_argb32_data (buffer);
+
+        for (offset_y = 0; offset_y < 2; offset_y++) {
+                for (offset_x = 0; offset_x < 2; offset_x++) {
+                        ix = x + offset_x;
+                        iy = y + offset_y;
+
+                        if (ix < 0 || ix >= width || iy < 0 || iy >= height)
+                                pixels[offset_y][offset_x] = 0x00000000;
+                        else
+                                pixels[offset_y][offset_x] = bytes[ix + iy * width];
+                }
+        }
+        if (!pixels[0][0] && !pixels[0][1] && !pixels[1][0] && !pixels[1][1]) return 0;
+
+        ix = x;
+        iy = y;
+        x -= ix;
+        y -= iy;
+        for (i = 0; i < 4; i++) {
+                uint32_t value = 0;
+                uint32_t mask = 0xFF << (i * 8);
+                value += ((pixels[0][0]) & mask) * (1 - x) * (1 - y);
+                value += ((pixels[0][1]) & mask) * x * (1 - y);
+                value += ((pixels[1][0]) & mask) * (1 - x) * y;
+                value += ((pixels[1][1]) & mask) * x * y;
+                reply |= value & mask;
+        }
+        return reply;
 }
 
 ply_pixel_buffer_t *
@@ -770,34 +749,32 @@ ply_pixel_buffer_resize (ply_pixel_buffer_t *old_buffer,
                          long                width,
                          long                height)
 {
-  ply_pixel_buffer_t *buffer;
-  int x, y;
-  double old_x, old_y;
-  int old_width, old_height;
-  float scale_x, scale_y;
-  uint32_t *bytes;
-  
-  buffer = ply_pixel_buffer_new (width, height);
-
-  bytes = ply_pixel_buffer_get_argb32_data (buffer);
-
-  old_width = old_buffer->area.width;
-  old_height = old_buffer->area.height;
-
-  scale_x = ((double) old_width - 1) / MAX (width - 1, 1);
-  scale_y = ((double) old_height - 1) / MAX (height - 1, 1);
-
-  for (y = 0; y < height; y++)
-    {
-      old_y = y * scale_y;
-      for (x=0; x < width; x++)
-        {
-          old_x = x * scale_x;
-          bytes[x + y * width] =
-                    ply_pixel_buffer_interpolate (old_buffer, old_x, old_y);
+        ply_pixel_buffer_t *buffer;
+        int x, y;
+        double old_x, old_y;
+        int old_width, old_height;
+        float scale_x, scale_y;
+        uint32_t *bytes;
+
+        buffer = ply_pixel_buffer_new (width, height);
+
+        bytes = ply_pixel_buffer_get_argb32_data (buffer);
+
+        old_width = old_buffer->area.width;
+        old_height = old_buffer->area.height;
+
+        scale_x = ((double) old_width - 1) / MAX (width - 1, 1);
+        scale_y = ((double) old_height - 1) / MAX (height - 1, 1);
+
+        for (y = 0; y < height; y++) {
+                old_y = y * scale_y;
+                for (x = 0; x < width; x++) {
+                        old_x = x * scale_x;
+                        bytes[x + y * width] =
+                                ply_pixel_buffer_interpolate (old_buffer, old_x, old_y);
+                }
         }
-    }
-  return buffer;
+        return buffer;
 }
 
 ply_pixel_buffer_t *
@@ -806,46 +783,44 @@ ply_pixel_buffer_rotate (ply_pixel_buffer_t *old_buffer,
                          long                center_y,
                          double              theta_offset)
 {
-  ply_pixel_buffer_t *buffer;
-  int x, y;
-  double old_x, old_y;
-  int width;
-  int height;
-  uint32_t *bytes;
-
-  width = old_buffer->area.width;
-  height = old_buffer->area.height;
-
-  buffer = ply_pixel_buffer_new (width, height);
-
-  bytes = ply_pixel_buffer_get_argb32_data (buffer);
-
-  double d = sqrt ((center_x * center_x +
-                    center_y * center_y));
-  double theta = atan2 (-center_y, -center_x) - theta_offset;
-  double start_x = center_x + d * cos (theta);
-  double start_y = center_y + d * sin (theta);
-  double step_x = cos (-theta_offset);
-  double step_y = sin (-theta_offset);
-  
-  for (y = 0; y < height; y++)
-    {
-      old_y = start_y;
-      old_x = start_x;
-      start_y += step_x;
-      start_x -= step_y;
-      for (x = 0; x < width; x++)
-        {
-          if (old_x < 0 || old_x > width || old_y < 0 || old_y > height)
-            bytes[x + y * width] = 0;
-          else
-            bytes[x + y * width] =
-                    ply_pixel_buffer_interpolate (old_buffer, old_x, old_y);
-          old_x += step_x;
-          old_y += step_y;
+        ply_pixel_buffer_t *buffer;
+        int x, y;
+        double old_x, old_y;
+        int width;
+        int height;
+        uint32_t *bytes;
+
+        width = old_buffer->area.width;
+        height = old_buffer->area.height;
+
+        buffer = ply_pixel_buffer_new (width, height);
+
+        bytes = ply_pixel_buffer_get_argb32_data (buffer);
+
+        double d = sqrt ((center_x * center_x +
+                          center_y * center_y));
+        double theta = atan2 (-center_y, -center_x) - theta_offset;
+        double start_x = center_x + d * cos (theta);
+        double start_y = center_y + d * sin (theta);
+        double step_x = cos (-theta_offset);
+        double step_y = sin (-theta_offset);
+
+        for (y = 0; y < height; y++) {
+                old_y = start_y;
+                old_x = start_x;
+                start_y += step_x;
+                start_x -= step_y;
+                for (x = 0; x < width; x++) {
+                        if (old_x < 0 || old_x > width || old_y < 0 || old_y > height)
+                                bytes[x + y * width] = 0;
+                        else
+                                bytes[x + y * width] =
+                                        ply_pixel_buffer_interpolate (old_buffer, old_x, old_y);
+                        old_x += step_x;
+                        old_y += step_y;
+                }
         }
-    }
-  return buffer;
+        return buffer;
 }
 
 ply_pixel_buffer_t *
@@ -853,30 +828,28 @@ ply_pixel_buffer_tile (ply_pixel_buffer_t *old_buffer,
                        long                width,
                        long                height)
 {
-  long x, y;
-  long old_x, old_y;
-  long old_width, old_height;
-  uint32_t *bytes, *old_bytes;
-  ply_pixel_buffer_t *buffer;
+        long x, y;
+        long old_x, old_y;
+        long old_width, old_height;
+        uint32_t *bytes, *old_bytes;
+        ply_pixel_buffer_t *buffer;
 
-  buffer = ply_pixel_buffer_new (width, height);
+        buffer = ply_pixel_buffer_new (width, height);
 
-  old_bytes = ply_pixel_buffer_get_argb32_data (old_buffer);
-  bytes = ply_pixel_buffer_get_argb32_data (buffer);
+        old_bytes = ply_pixel_buffer_get_argb32_data (old_buffer);
+        bytes = ply_pixel_buffer_get_argb32_data (buffer);
 
-  old_width = old_buffer->area.width;
-  old_height = old_buffer->area.height;
+        old_width = old_buffer->area.width;
+        old_height = old_buffer->area.height;
 
-  for (y = 0; y < height; y++)
-    {
-      old_y = y % old_height;
-      for (x = 0; x < width; x++)
-        {
-          old_x = x % old_width;
-          bytes[x + y * width] = old_bytes[old_x + old_y * old_width];
+        for (y = 0; y < height; y++) {
+                old_y = y % old_height;
+                for (x = 0; x < width; x++) {
+                        old_x = x % old_width;
+                        bytes[x + y * width] = old_bytes[old_x + old_y * old_width];
+                }
         }
-    }
-  return buffer;
+        return buffer;
 }
 
 /* vim: set ts=4 sw=4 et ai ci cino={.5s,^-2,+.5s,t0,g0,e-2,n-2,p2s,(0,=.5s,:.5s */
diff --git a/src/libply-splash-core/ply-pixel-buffer.h b/src/libply-splash-core/ply-pixel-buffer.h
index e0dffda..7848a98 100644
--- a/src/libply-splash-core/ply-pixel-buffer.h
+++ b/src/libply-splash-core/ply-pixel-buffer.h
@@ -31,11 +31,11 @@
 
 typedef struct _ply_pixel_buffer ply_pixel_buffer_t;
 
-#define PLY_PIXEL_BUFFER_COLOR_TO_PIXEL_VALUE(r,g,b,a)                        \
-    (((uint8_t) (CLAMP (a * 255.0, 0.0, 255.0)) << 24)                        \
-      | ((uint8_t) (CLAMP (r * 255.0, 0.0, 255.0)) << 16)                     \
-      | ((uint8_t) (CLAMP (g * 255.0, 0.0, 255.0)) << 8)                      \
-      | ((uint8_t) (CLAMP (b * 255.0, 0.0, 255.0))))
+#define PLY_PIXEL_BUFFER_COLOR_TO_PIXEL_VALUE(r, g, b, a)                        \
+        (((uint8_t) (CLAMP (a * 255.0, 0.0, 255.0)) << 24)                        \
+         | ((uint8_t) (CLAMP (r * 255.0, 0.0, 255.0)) << 16)                     \
+         | ((uint8_t) (CLAMP (g * 255.0, 0.0, 255.0)) << 8)                      \
+         | ((uint8_t) (CLAMP (b * 255.0, 0.0, 255.0))))
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_pixel_buffer_t *ply_pixel_buffer_new (unsigned long width,
diff --git a/src/libply-splash-core/ply-pixel-display.c b/src/libply-splash-core/ply-pixel-display.c
index 3715120..b061bfc 100644
--- a/src/libply-splash-core/ply-pixel-display.c
+++ b/src/libply-splash-core/ply-pixel-display.c
@@ -44,81 +44,80 @@
 
 struct _ply_pixel_display
 {
-  ply_event_loop_t *loop;
+        ply_event_loop_t                *loop;
 
-  ply_renderer_t *renderer;
-  ply_renderer_head_t *head;
+        ply_renderer_t                  *renderer;
+        ply_renderer_head_t             *head;
 
-  unsigned long width;
-  unsigned long height;
+        unsigned long                    width;
+        unsigned long                    height;
 
-  ply_pixel_display_draw_handler_t draw_handler;
-  void *draw_handler_user_data;
-
-  int pause_count;
+        ply_pixel_display_draw_handler_t draw_handler;
+        void                            *draw_handler_user_data;
 
+        int                              pause_count;
 };
 
 ply_pixel_display_t *
 ply_pixel_display_new (ply_renderer_t      *renderer,
                        ply_renderer_head_t *head)
 {
-  ply_pixel_display_t *display;
-  ply_pixel_buffer_t  *pixel_buffer;
-  ply_rectangle_t      size;
+        ply_pixel_display_t *display;
+        ply_pixel_buffer_t *pixel_buffer;
+        ply_rectangle_t size;
 
-  display = calloc (1, sizeof (ply_pixel_display_t));
+        display = calloc (1, sizeof(ply_pixel_display_t));
 
-  display->loop = ply_event_loop_get_default ();
-  display->renderer = renderer;
-  display->head = head;
+        display->loop = ply_event_loop_get_default ();
+        display->renderer = renderer;
+        display->head = head;
 
-  pixel_buffer = ply_renderer_get_buffer_for_head (renderer, head);
-  ply_pixel_buffer_get_size (pixel_buffer, &size);
+        pixel_buffer = ply_renderer_get_buffer_for_head (renderer, head);
+        ply_pixel_buffer_get_size (pixel_buffer, &size);
 
-  display->width = size.width;
-  display->height = size.height;
+        display->width = size.width;
+        display->height = size.height;
 
-  return display;
+        return display;
 }
 
 unsigned long
 ply_pixel_display_get_width (ply_pixel_display_t *display)
 {
-  return display->width;
+        return display->width;
 }
 
 unsigned long
 ply_pixel_display_get_height (ply_pixel_display_t *display)
 {
-  return display->height;
+        return display->height;
 }
 
 static void
 ply_pixel_display_flush (ply_pixel_display_t *display)
 {
-  if (display->pause_count > 0)
-    return;
+        if (display->pause_count > 0)
+                return;
 
-  ply_renderer_flush_head (display->renderer, display->head);
+        ply_renderer_flush_head (display->renderer, display->head);
 }
 
 void
 ply_pixel_display_pause_updates (ply_pixel_display_t *display)
 {
-  assert (display != NULL);
+        assert (display != NULL);
 
-  display->pause_count++;
+        display->pause_count++;
 }
 
 void
 ply_pixel_display_unpause_updates (ply_pixel_display_t *display)
 {
-  assert (display != NULL);
+        assert (display != NULL);
 
-  display->pause_count--;
+        display->pause_count--;
 
-  ply_pixel_display_flush (display);
+        ply_pixel_display_flush (display);
 }
 
 void
@@ -128,48 +127,46 @@ ply_pixel_display_draw_area (ply_pixel_display_t *display,
                              int                  width,
                              int                  height)
 {
-
-  ply_pixel_buffer_t *pixel_buffer;
-
-  pixel_buffer = ply_renderer_get_buffer_for_head (display->renderer,
-                                                   display->head);
-
-  if (display->draw_handler != NULL)
-    {
-      ply_rectangle_t clip_area;
-
-      clip_area.x = x;
-      clip_area.y = y;
-      clip_area.width = width;
-      clip_area.height = height;
-      ply_pixel_buffer_push_clip_area (pixel_buffer, &clip_area);
-      display->draw_handler (display->draw_handler_user_data,
-                             pixel_buffer,
-                             x, y, width, height, display);
-      ply_pixel_buffer_pop_clip_area (pixel_buffer);
-    }
-
-  ply_pixel_display_flush (display);
+        ply_pixel_buffer_t *pixel_buffer;
+
+        pixel_buffer = ply_renderer_get_buffer_for_head (display->renderer,
+                                                         display->head);
+
+        if (display->draw_handler != NULL) {
+                ply_rectangle_t clip_area;
+
+                clip_area.x = x;
+                clip_area.y = y;
+                clip_area.width = width;
+                clip_area.height = height;
+                ply_pixel_buffer_push_clip_area (pixel_buffer, &clip_area);
+                display->draw_handler (display->draw_handler_user_data,
+                                       pixel_buffer,
+                                       x, y, width, height, display);
+                ply_pixel_buffer_pop_clip_area (pixel_buffer);
+        }
+
+        ply_pixel_display_flush (display);
 }
 
 void
 ply_pixel_display_free (ply_pixel_display_t *display)
 {
-  if (display == NULL)
-    return;
+        if (display == NULL)
+                return;
 
-  free (display);
+        free (display);
 }
 
 void
-ply_pixel_display_set_draw_handler (ply_pixel_display_t *display,
+ply_pixel_display_set_draw_handler (ply_pixel_display_t             *display,
                                     ply_pixel_display_draw_handler_t draw_handler,
-                                    void                *user_data)
+                                    void                            *user_data)
 {
-  assert (display != NULL);
+        assert (display != NULL);
 
-  display->draw_handler = draw_handler;
-  display->draw_handler_user_data = user_data;
+        display->draw_handler = draw_handler;
+        display->draw_handler_user_data = user_data;
 }
 
 /* vim: set ts=4 sw=4 et ai ci cino={.5s,^-2,+.5s,t0,g0,e-2,n-2,p2s,(0,=.5s,:.5s */
diff --git a/src/libply-splash-core/ply-pixel-display.h b/src/libply-splash-core/ply-pixel-display.h
index 98a6b3c..62a36da 100644
--- a/src/libply-splash-core/ply-pixel-display.h
+++ b/src/libply-splash-core/ply-pixel-display.h
@@ -32,13 +32,13 @@
 
 typedef struct _ply_pixel_display ply_pixel_display_t;
 
-typedef void (* ply_pixel_display_draw_handler_t) (void               *user_data,
-                                                   ply_pixel_buffer_t *pixel_buffer,
-                                                   int                 x,
-                                                   int                 y,
-                                                   int                 width,
-                                                   int                 height,
-                                                   ply_pixel_display_t *pixel_display);
+typedef void (*ply_pixel_display_draw_handler_t) (void                *user_data,
+                                                  ply_pixel_buffer_t  *pixel_buffer,
+                                                  int                  x,
+                                                  int                  y,
+                                                  int                  width,
+                                                  int                  height,
+                                                  ply_pixel_display_t *pixel_display);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_pixel_display_t *ply_pixel_display_new (ply_renderer_t      *renderer,
@@ -46,12 +46,12 @@ ply_pixel_display_t *ply_pixel_display_new (ply_renderer_t      *renderer,
 
 void ply_pixel_display_free (ply_pixel_display_t *display);
 
-unsigned long ply_pixel_display_get_width  (ply_pixel_display_t *display);
+unsigned long ply_pixel_display_get_width (ply_pixel_display_t *display);
 unsigned long ply_pixel_display_get_height (ply_pixel_display_t *display);
 
-void ply_pixel_display_set_draw_handler (ply_pixel_display_t              *display,
-                                         ply_pixel_display_draw_handler_t  draw_handler,
-                                         void                             *user_data);
+void ply_pixel_display_set_draw_handler (ply_pixel_display_t             *display,
+                                         ply_pixel_display_draw_handler_t draw_handler,
+                                         void                            *user_data);
 
 void ply_pixel_display_draw_area (ply_pixel_display_t *display,
                                   int                  x,
diff --git a/src/libply-splash-core/ply-renderer-plugin.h b/src/libply-splash-core/ply-renderer-plugin.h
index 68ac7e9..82ef913 100644
--- a/src/libply-splash-core/ply-renderer-plugin.h
+++ b/src/libply-splash-core/ply-renderer-plugin.h
@@ -37,35 +37,35 @@ typedef struct _ply_renderer_backend ply_renderer_backend_t;
 
 typedef struct
 {
-  ply_renderer_backend_t * (* create_backend) (const char *device_name,
-                                               ply_terminal_t *terminal);
-  void (* destroy_backend) (ply_renderer_backend_t *backend);
-  bool (* open_device) (ply_renderer_backend_t *backend);
-  void (* close_device) (ply_renderer_backend_t *backend);
-  bool (* query_device) (ply_renderer_backend_t *backend);
-  bool (* map_to_device) (ply_renderer_backend_t *backend);
-  void (* unmap_from_device) (ply_renderer_backend_t *backend);
-  void (* activate) (ply_renderer_backend_t *backend);
-  void (* deactivate) (ply_renderer_backend_t *backend);
-  void (* flush_head) (ply_renderer_backend_t *backend,
-                       ply_renderer_head_t    *head);
+        ply_renderer_backend_t * (*create_backend)(const char *device_name,
+                                                   ply_terminal_t * terminal);
+        void (*destroy_backend)(ply_renderer_backend_t *backend);
+        bool (*open_device)(ply_renderer_backend_t *backend);
+        void (*close_device)(ply_renderer_backend_t *backend);
+        bool (*query_device)(ply_renderer_backend_t *backend);
+        bool (*map_to_device)(ply_renderer_backend_t *backend);
+        void (*unmap_from_device)(ply_renderer_backend_t *backend);
+        void (*activate)(ply_renderer_backend_t *backend);
+        void (*deactivate)(ply_renderer_backend_t *backend);
+        void (*flush_head)(ply_renderer_backend_t *backend,
+                           ply_renderer_head_t    *head);
 
-  ply_list_t * (* get_heads) (ply_renderer_backend_t *backend);
+        ply_list_t * (*get_heads)(ply_renderer_backend_t * backend);
 
-  ply_pixel_buffer_t * (* get_buffer_for_head) (ply_renderer_backend_t *backend,
-                                                ply_renderer_head_t    *head);
+        ply_pixel_buffer_t * (*get_buffer_for_head)(ply_renderer_backend_t * backend,
+                                                    ply_renderer_head_t * head);
 
-  ply_renderer_input_source_t * (* get_input_source) (ply_renderer_backend_t *backend);
-  bool                 (* open_input_source) (ply_renderer_backend_t *backend,
-                                              ply_renderer_input_source_t *input_source);
+        ply_renderer_input_source_t * (*get_input_source)(ply_renderer_backend_t * backend);
+        bool (*open_input_source)(ply_renderer_backend_t      *backend,
+                                  ply_renderer_input_source_t *input_source);
 
-  void                 (* set_handler_for_input_source) (ply_renderer_backend_t    *backend,
-                                                         ply_renderer_input_source_t *input_source,
-                                                         ply_renderer_input_source_handler_t handler,
-                                                         void                      *user_data);
+        void (*set_handler_for_input_source)(ply_renderer_backend_t             *backend,
+                                             ply_renderer_input_source_t        *input_source,
+                                             ply_renderer_input_source_handler_t handler,
+                                             void                               *user_data);
 
-  void                 (* close_input_source) (ply_renderer_backend_t *backend,
-                                               ply_renderer_input_source_t *input_source);
+        void (*close_input_source)(ply_renderer_backend_t      *backend,
+                                   ply_renderer_input_source_t *input_source);
 } ply_renderer_plugin_interface_t;
 
 #endif /* PLY_RENDERER_PLUGIN_H */
diff --git a/src/libply-splash-core/ply-renderer.c b/src/libply-splash-core/ply-renderer.c
index 04a99ce..f64eac5 100644
--- a/src/libply-splash-core/ply-renderer.c
+++ b/src/libply-splash-core/ply-renderer.c
@@ -44,357 +44,348 @@
 
 struct _ply_renderer
 {
-  ply_event_loop_t *loop;
-  ply_module_handle_t *module_handle;
-  const ply_renderer_plugin_interface_t *plugin_interface;
-  ply_renderer_backend_t *backend;
+        ply_event_loop_t                      *loop;
+        ply_module_handle_t                   *module_handle;
+        const ply_renderer_plugin_interface_t *plugin_interface;
+        ply_renderer_backend_t                *backend;
 
-  ply_renderer_type_t type;
-  char *device_name;
-  ply_terminal_t *terminal;
+        ply_renderer_type_t                    type;
+        char                                  *device_name;
+        ply_terminal_t                        *terminal;
 
-  uint32_t input_source_is_open : 1;
-  uint32_t is_mapped : 1;
+        uint32_t                               input_source_is_open : 1;
+        uint32_t                               is_mapped : 1;
 };
 
 typedef const ply_renderer_plugin_interface_t *
-        (* get_backend_interface_function_t) (void);
+(*get_backend_interface_function_t) (void);
 
 static void ply_renderer_unload_plugin (ply_renderer_t *renderer);
 
 ply_renderer_t *
-ply_renderer_new (ply_renderer_type_t  renderer_type,
-                  const char          *device_name,
-                  ply_terminal_t      *terminal)
+ply_renderer_new (ply_renderer_type_t renderer_type,
+                  const char         *device_name,
+                  ply_terminal_t     *terminal)
 {
-  ply_renderer_t *renderer;
+        ply_renderer_t *renderer;
 
-  renderer = calloc (1, sizeof (struct _ply_renderer));
+        renderer = calloc (1, sizeof(struct _ply_renderer));
 
-  renderer->type = renderer_type;
+        renderer->type = renderer_type;
 
-  if (device_name != NULL)
-    renderer->device_name = strdup (device_name);
+        if (device_name != NULL)
+                renderer->device_name = strdup (device_name);
 
-  renderer->terminal = terminal;
+        renderer->terminal = terminal;
 
-  return renderer;
+        return renderer;
 }
 
 void
 ply_renderer_free (ply_renderer_t *renderer)
 {
-  if (renderer == NULL)
-    return;
+        if (renderer == NULL)
+                return;
 
-  if (renderer->plugin_interface != NULL)
-    {
-      ply_trace ("Unloading renderer backend plugin");
-      ply_renderer_unload_plugin (renderer);
-    }
+        if (renderer->plugin_interface != NULL) {
+                ply_trace ("Unloading renderer backend plugin");
+                ply_renderer_unload_plugin (renderer);
+        }
 
-  free (renderer->device_name);
-  free (renderer);
+        free (renderer->device_name);
+        free (renderer);
 }
 
 const char *
 ply_renderer_get_device_name (ply_renderer_t *renderer)
 {
-  return renderer->device_name;
+        return renderer->device_name;
 }
 
 static bool
 ply_renderer_load_plugin (ply_renderer_t *renderer,
                           const char     *module_path)
 {
-  assert (renderer != NULL);
-
-  get_backend_interface_function_t get_renderer_backend_interface;
-
-  renderer->module_handle = ply_open_module (module_path);
-
-  if (renderer->module_handle == NULL)
-    return false;
-
-  get_renderer_backend_interface = (get_backend_interface_function_t)
-      ply_module_look_up_function (renderer->module_handle,
-                                   "ply_renderer_backend_get_interface");
-
-  if (get_renderer_backend_interface == NULL)
-    {
-      ply_save_errno ();
-      ply_trace ("module '%s' is not a renderer plugin",
-                 module_path);
-      ply_close_module (renderer->module_handle);
-      renderer->module_handle = NULL;
-      ply_restore_errno ();
-      return false;
-    }
-
-  renderer->plugin_interface = get_renderer_backend_interface ();
-
-  if (renderer->plugin_interface == NULL)
-    {
-      ply_trace ("module '%s' is not a valid renderer plugin",
-                 module_path);
-      ply_save_errno ();
-      ply_close_module (renderer->module_handle);
-      renderer->module_handle = NULL;
-      ply_restore_errno ();
-      return false;
-    }
-
-  renderer->backend = renderer->plugin_interface->create_backend (renderer->device_name,
-                                                                  renderer->terminal);
-
-  if (renderer->backend == NULL)
-    {
-      ply_save_errno ();
-      ply_trace ("module '%s' renderer backend could not be created",
-                 module_path);
-      ply_close_module (renderer->module_handle);
-      renderer->module_handle = NULL;
-      ply_restore_errno ();
-      return false;
-    }
-
-  return true;
+        assert (renderer != NULL);
+
+        get_backend_interface_function_t get_renderer_backend_interface;
+
+        renderer->module_handle = ply_open_module (module_path);
+
+        if (renderer->module_handle == NULL)
+                return false;
+
+        get_renderer_backend_interface = (get_backend_interface_function_t)
+                                         ply_module_look_up_function (renderer->module_handle,
+                                                                      "ply_renderer_backend_get_interface");
+
+        if (get_renderer_backend_interface == NULL) {
+                ply_save_errno ();
+                ply_trace ("module '%s' is not a renderer plugin",
+                           module_path);
+                ply_close_module (renderer->module_handle);
+                renderer->module_handle = NULL;
+                ply_restore_errno ();
+                return false;
+        }
+
+        renderer->plugin_interface = get_renderer_backend_interface ();
+
+        if (renderer->plugin_interface == NULL) {
+                ply_trace ("module '%s' is not a valid renderer plugin",
+                           module_path);
+                ply_save_errno ();
+                ply_close_module (renderer->module_handle);
+                renderer->module_handle = NULL;
+                ply_restore_errno ();
+                return false;
+        }
+
+        renderer->backend = renderer->plugin_interface->create_backend (renderer->device_name,
+                                                                        renderer->terminal);
+
+        if (renderer->backend == NULL) {
+                ply_save_errno ();
+                ply_trace ("module '%s' renderer backend could not be created",
+                           module_path);
+                ply_close_module (renderer->module_handle);
+                renderer->module_handle = NULL;
+                ply_restore_errno ();
+                return false;
+        }
+
+        return true;
 }
 
 static void
 ply_renderer_unload_plugin (ply_renderer_t *renderer)
 {
-  assert (renderer != NULL);
-  assert (renderer->plugin_interface != NULL);
-  assert (renderer->module_handle != NULL);
+        assert (renderer != NULL);
+        assert (renderer->plugin_interface != NULL);
+        assert (renderer->module_handle != NULL);
 
-  ply_close_module (renderer->module_handle);
-  renderer->plugin_interface = NULL;
-  renderer->module_handle = NULL;
+        ply_close_module (renderer->module_handle);
+        renderer->plugin_interface = NULL;
+        renderer->module_handle = NULL;
 }
 
 static bool
 ply_renderer_open_device (ply_renderer_t *renderer)
 {
-  assert (renderer != NULL);
-  assert (renderer->plugin_interface != NULL);
+        assert (renderer != NULL);
+        assert (renderer->plugin_interface != NULL);
 
-  return renderer->plugin_interface->open_device (renderer->backend);
+        return renderer->plugin_interface->open_device (renderer->backend);
 }
 
 static void
 ply_renderer_close_device (ply_renderer_t *renderer)
 {
-  assert (renderer != NULL);
-  assert (renderer->plugin_interface != NULL);
+        assert (renderer != NULL);
+        assert (renderer->plugin_interface != NULL);
 
-  renderer->plugin_interface->close_device (renderer->backend);
+        renderer->plugin_interface->close_device (renderer->backend);
 }
 
 static bool
 ply_renderer_query_device (ply_renderer_t *renderer)
 {
-  assert (renderer != NULL);
-  assert (renderer->plugin_interface != NULL);
+        assert (renderer != NULL);
+        assert (renderer->plugin_interface != NULL);
 
-  return renderer->plugin_interface->query_device (renderer->backend);
+        return renderer->plugin_interface->query_device (renderer->backend);
 }
 
 static bool
 ply_renderer_map_to_device (ply_renderer_t *renderer)
 {
-  assert (renderer != NULL);
-  assert (renderer->plugin_interface != NULL);
+        assert (renderer != NULL);
+        assert (renderer->plugin_interface != NULL);
 
-  if (renderer->is_mapped)
-    return true;
+        if (renderer->is_mapped)
+                return true;
 
-  renderer->is_mapped = renderer->plugin_interface->map_to_device (renderer->backend);
+        renderer->is_mapped = renderer->plugin_interface->map_to_device (renderer->backend);
 
-  return renderer->is_mapped;
+        return renderer->is_mapped;
 }
 
 static void
 ply_renderer_unmap_from_device (ply_renderer_t *renderer)
 {
-  assert (renderer != NULL);
-  assert (renderer->plugin_interface != NULL);
+        assert (renderer != NULL);
+        assert (renderer->plugin_interface != NULL);
 
-  if (!renderer->is_mapped)
-    return;
+        if (!renderer->is_mapped)
+                return;
 
-  renderer->plugin_interface->unmap_from_device (renderer->backend);
-  renderer->is_mapped = false;
+        renderer->plugin_interface->unmap_from_device (renderer->backend);
+        renderer->is_mapped = false;
 }
 
 static bool
 ply_renderer_open_plugin (ply_renderer_t *renderer,
                           const char     *plugin_path)
 {
-  ply_trace ("trying to open renderer plugin %s", plugin_path);
-
-  if (!ply_renderer_load_plugin (renderer, plugin_path))
-    return false;
-
-  if (!ply_renderer_open_device (renderer))
-    {
-      ply_trace ("could not open rendering device for plugin %s",
-                 plugin_path);
-      ply_renderer_unload_plugin (renderer);
-      return false;
-    }
-
-  if (!ply_renderer_query_device (renderer))
-    {
-      ply_trace ("could not query rendering device for plugin %s",
-                 plugin_path);
-      ply_renderer_close_device (renderer);
-      ply_renderer_unload_plugin (renderer);
-      return false;
-    }
-
-  ply_trace ("opened renderer plugin %s", plugin_path);
-  return true;
+        ply_trace ("trying to open renderer plugin %s", plugin_path);
+
+        if (!ply_renderer_load_plugin (renderer, plugin_path))
+                return false;
+
+        if (!ply_renderer_open_device (renderer)) {
+                ply_trace ("could not open rendering device for plugin %s",
+                           plugin_path);
+                ply_renderer_unload_plugin (renderer);
+                return false;
+        }
+
+        if (!ply_renderer_query_device (renderer)) {
+                ply_trace ("could not query rendering device for plugin %s",
+                           plugin_path);
+                ply_renderer_close_device (renderer);
+                ply_renderer_unload_plugin (renderer);
+                return false;
+        }
+
+        ply_trace ("opened renderer plugin %s", plugin_path);
+        return true;
 }
 
 bool
 ply_renderer_open (ply_renderer_t *renderer)
 {
-  int i;
-
-  struct
-    {
-      ply_renderer_type_t  type;
-      const char          *path;
-    } known_plugins[] =
-    {
-      { PLY_RENDERER_TYPE_X11, PLYMOUTH_PLUGIN_PATH "renderers/x11.so" },
-      { PLY_RENDERER_TYPE_DRM, PLYMOUTH_PLUGIN_PATH "renderers/drm.so" },
-      { PLY_RENDERER_TYPE_FRAME_BUFFER, PLYMOUTH_PLUGIN_PATH "renderers/frame-buffer.so" },
-      { PLY_RENDERER_TYPE_NONE, NULL }
-    };
-
-  for (i = 0; known_plugins[i].type != PLY_RENDERER_TYPE_NONE; i++)
-    {
-      if (renderer->type == known_plugins[i].type ||
-          renderer->type == PLY_RENDERER_TYPE_AUTO)
+        int i;
+
+        struct
+        {
+                ply_renderer_type_t type;
+                const char         *path;
+        } known_plugins[] =
         {
-          if (ply_renderer_open_plugin (renderer, known_plugins[i].path))
-            return true;
+                { PLY_RENDERER_TYPE_X11,          PLYMOUTH_PLUGIN_PATH "renderers/x11.so"          },
+                { PLY_RENDERER_TYPE_DRM,          PLYMOUTH_PLUGIN_PATH "renderers/drm.so"          },
+                { PLY_RENDERER_TYPE_FRAME_BUFFER, PLYMOUTH_PLUGIN_PATH "renderers/frame-buffer.so" },
+                { PLY_RENDERER_TYPE_NONE,         NULL                                             }
+        };
+
+        for (i = 0; known_plugins[i].type != PLY_RENDERER_TYPE_NONE; i++) {
+                if (renderer->type == known_plugins[i].type ||
+                    renderer->type == PLY_RENDERER_TYPE_AUTO)
+                        if (ply_renderer_open_plugin (renderer, known_plugins[i].path))
+                                return true;
         }
-    }
 
-  ply_trace ("could not find suitable rendering plugin");
-  return false;
+        ply_trace ("could not find suitable rendering plugin");
+        return false;
 }
 
 void
 ply_renderer_close (ply_renderer_t *renderer)
 {
-  ply_renderer_unmap_from_device (renderer);
-  ply_renderer_close_device (renderer);
+        ply_renderer_unmap_from_device (renderer);
+        ply_renderer_close_device (renderer);
 }
 
 void
 ply_renderer_activate (ply_renderer_t *renderer)
 {
-  assert (renderer->plugin_interface != NULL);
+        assert (renderer->plugin_interface != NULL);
 
-  return renderer->plugin_interface->activate (renderer->backend);
+        return renderer->plugin_interface->activate (renderer->backend);
 }
 
 void
 ply_renderer_deactivate (ply_renderer_t *renderer)
 {
-  assert (renderer->plugin_interface != NULL);
+        assert (renderer->plugin_interface != NULL);
 
-  return renderer->plugin_interface->deactivate (renderer->backend);
+        return renderer->plugin_interface->deactivate (renderer->backend);
 }
 
 ply_list_t *
 ply_renderer_get_heads (ply_renderer_t *renderer)
 {
-  assert (renderer->plugin_interface != NULL);
+        assert (renderer->plugin_interface != NULL);
 
-  return renderer->plugin_interface->get_heads (renderer->backend);
+        return renderer->plugin_interface->get_heads (renderer->backend);
 }
 
 ply_pixel_buffer_t *
 ply_renderer_get_buffer_for_head (ply_renderer_t      *renderer,
                                   ply_renderer_head_t *head)
 {
-  assert (renderer != NULL);
-  assert (renderer->plugin_interface != NULL);
-  assert (head != NULL);
+        assert (renderer != NULL);
+        assert (renderer->plugin_interface != NULL);
+        assert (head != NULL);
 
-  return renderer->plugin_interface->get_buffer_for_head (renderer->backend,
-                                                          head);
+        return renderer->plugin_interface->get_buffer_for_head (renderer->backend,
+                                                                head);
 }
 
 void
 ply_renderer_flush_head (ply_renderer_t      *renderer,
                          ply_renderer_head_t *head)
 {
-  assert (renderer != NULL);
-  assert (renderer->plugin_interface != NULL);
-  assert (head != NULL);
+        assert (renderer != NULL);
+        assert (renderer->plugin_interface != NULL);
+        assert (head != NULL);
 
-  if (!ply_renderer_map_to_device (renderer))
-    return;
+        if (!ply_renderer_map_to_device (renderer))
+                return;
 
-  renderer->plugin_interface->flush_head (renderer->backend, head);
+        renderer->plugin_interface->flush_head (renderer->backend, head);
 }
 
 ply_renderer_input_source_t *
 ply_renderer_get_input_source (ply_renderer_t *renderer)
 {
-  assert (renderer != NULL);
-  assert (renderer->plugin_interface != NULL);
+        assert (renderer != NULL);
+        assert (renderer->plugin_interface != NULL);
 
-  return renderer->plugin_interface->get_input_source (renderer->backend);
+        return renderer->plugin_interface->get_input_source (renderer->backend);
 }
 
 bool
 ply_renderer_open_input_source (ply_renderer_t              *renderer,
                                 ply_renderer_input_source_t *input_source)
 {
-  assert (renderer != NULL);
-  assert (input_source != NULL);
+        assert (renderer != NULL);
+        assert (input_source != NULL);
 
-  renderer->input_source_is_open = renderer->plugin_interface->open_input_source (renderer->backend,
-                                                                                  input_source);
+        renderer->input_source_is_open = renderer->plugin_interface->open_input_source (renderer->backend,
+                                                                                        input_source);
 
-  return renderer->input_source_is_open;
+        return renderer->input_source_is_open;
 }
 
 void
-ply_renderer_set_handler_for_input_source (ply_renderer_t                      *renderer,
-                                           ply_renderer_input_source_t         *input_source,
-                                           ply_renderer_input_source_handler_t  handler,
-                                           void                                *user_data)
+ply_renderer_set_handler_for_input_source (ply_renderer_t                     *renderer,
+                                           ply_renderer_input_source_t        *input_source,
+                                           ply_renderer_input_source_handler_t handler,
+                                           void                               *user_data)
 {
-  assert (renderer != NULL);
-  assert (input_source != NULL);
+        assert (renderer != NULL);
+        assert (input_source != NULL);
 
-  renderer->plugin_interface->set_handler_for_input_source (renderer->backend,
-                                                            input_source,
-                                                            handler,
-                                                            user_data);
+        renderer->plugin_interface->set_handler_for_input_source (renderer->backend,
+                                                                  input_source,
+                                                                  handler,
+                                                                  user_data);
 }
 
 void
 ply_renderer_close_input_source (ply_renderer_t              *renderer,
                                  ply_renderer_input_source_t *input_source)
 {
-  assert (renderer != NULL);
-  assert (input_source != NULL);
+        assert (renderer != NULL);
+        assert (input_source != NULL);
 
-  if (!renderer->input_source_is_open)
-    return;
+        if (!renderer->input_source_is_open)
+                return;
 
-  renderer->plugin_interface->close_input_source (renderer->backend,
-                                                  input_source);
-  renderer->input_source_is_open = false;
+        renderer->plugin_interface->close_input_source (renderer->backend,
+                                                        input_source);
+        renderer->input_source_is_open = false;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-core/ply-renderer.h b/src/libply-splash-core/ply-renderer.h
index 3d48341..a019a4d 100644
--- a/src/libply-splash-core/ply-renderer.h
+++ b/src/libply-splash-core/ply-renderer.h
@@ -37,21 +37,21 @@ typedef struct _ply_renderer_input_source ply_renderer_input_source_t;
 
 typedef enum
 {
-  PLY_RENDERER_TYPE_NONE = -1,
-  PLY_RENDERER_TYPE_AUTO,
-  PLY_RENDERER_TYPE_DRM,
-  PLY_RENDERER_TYPE_FRAME_BUFFER,
-  PLY_RENDERER_TYPE_X11
+        PLY_RENDERER_TYPE_NONE = -1,
+        PLY_RENDERER_TYPE_AUTO,
+        PLY_RENDERER_TYPE_DRM,
+        PLY_RENDERER_TYPE_FRAME_BUFFER,
+        PLY_RENDERER_TYPE_X11
 } ply_renderer_type_t;
 
-typedef void (* ply_renderer_input_source_handler_t) (void                        *user_data,
-                                                      ply_buffer_t                *key_buffer,
-                                                      ply_renderer_input_source_t *input_source);
+typedef void (*ply_renderer_input_source_handler_t) (void                        *user_data,
+                                                     ply_buffer_t                *key_buffer,
+                                                     ply_renderer_input_source_t *input_source);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_renderer_t *ply_renderer_new (ply_renderer_type_t renderer_type,
-                                  const char     *device_name,
-                                  ply_terminal_t *terminal);
+                                  const char         *device_name,
+                                  ply_terminal_t     *terminal);
 void ply_renderer_free (ply_renderer_t *renderer);
 bool ply_renderer_open (ply_renderer_t *renderer);
 void ply_renderer_close (ply_renderer_t *renderer);
@@ -68,10 +68,10 @@ void ply_renderer_flush_head (ply_renderer_t      *renderer,
 ply_renderer_input_source_t *ply_renderer_get_input_source (ply_renderer_t *renderer);
 bool ply_renderer_open_input_source (ply_renderer_t              *renderer,
                                      ply_renderer_input_source_t *input_source);
-void ply_renderer_set_handler_for_input_source (ply_renderer_t                      *renderer,
-                                                ply_renderer_input_source_t         *input_source,
-                                                ply_renderer_input_source_handler_t  handler,
-                                                void                                *user_data);
+void ply_renderer_set_handler_for_input_source (ply_renderer_t                     *renderer,
+                                                ply_renderer_input_source_t        *input_source,
+                                                ply_renderer_input_source_handler_t handler,
+                                                void                               *user_data);
 
 void ply_renderer_close_input_source (ply_renderer_t              *renderer,
                                       ply_renderer_input_source_t *input_source);
diff --git a/src/libply-splash-core/ply-seat.c b/src/libply-splash-core/ply-seat.c
index 2ac8bf7..04ae43e 100644
--- a/src/libply-splash-core/ply-seat.c
+++ b/src/libply-splash-core/ply-seat.c
@@ -40,348 +40,333 @@
 
 struct _ply_seat
 {
-  ply_event_loop_t *loop;
+        ply_event_loop_t  *loop;
 
-  ply_boot_splash_t *splash;
-  ply_terminal_t *terminal;
-  ply_renderer_t *renderer;
-  ply_keyboard_t *keyboard;
-  ply_list_t *text_displays;
-  ply_list_t *pixel_displays;
+        ply_boot_splash_t *splash;
+        ply_terminal_t    *terminal;
+        ply_renderer_t    *renderer;
+        ply_keyboard_t    *keyboard;
+        ply_list_t        *text_displays;
+        ply_list_t        *pixel_displays;
 
-  uint32_t renderer_active : 1;
-  uint32_t keyboard_active : 1;
+        uint32_t           renderer_active : 1;
+        uint32_t           keyboard_active : 1;
 };
 
 ply_seat_t *
 ply_seat_new (ply_terminal_t *terminal)
 {
-  ply_seat_t *seat;
+        ply_seat_t *seat;
 
-  seat = calloc (1, sizeof (ply_seat_t));
+        seat = calloc (1, sizeof(ply_seat_t));
 
-  seat->loop = ply_event_loop_get_default ();
-  seat->terminal = terminal;
-  seat->text_displays = ply_list_new ();
-  seat->pixel_displays = ply_list_new ();
+        seat->loop = ply_event_loop_get_default ();
+        seat->terminal = terminal;
+        seat->text_displays = ply_list_new ();
+        seat->pixel_displays = ply_list_new ();
 
-  return seat;
+        return seat;
 }
 
 static void
 add_pixel_displays (ply_seat_t *seat)
 {
-  ply_list_t *heads;
-  ply_list_node_t *node;
+        ply_list_t *heads;
+        ply_list_node_t *node;
 
-  heads = ply_renderer_get_heads (seat->renderer);
+        heads = ply_renderer_get_heads (seat->renderer);
 
-  ply_trace ("Adding displays for %d heads",
-             ply_list_get_length (heads));
+        ply_trace ("Adding displays for %d heads",
+                   ply_list_get_length (heads));
 
-  node = ply_list_get_first_node (heads);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_renderer_head_t *head;
-      ply_pixel_display_t *display;
+        node = ply_list_get_first_node (heads);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_renderer_head_t *head;
+                ply_pixel_display_t *display;
 
-      head = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (heads, node);
+                head = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (heads, node);
 
-      display = ply_pixel_display_new (seat->renderer, head);
+                display = ply_pixel_display_new (seat->renderer, head);
 
-      ply_list_append_data (seat->pixel_displays, display);
+                ply_list_append_data (seat->pixel_displays, display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 add_text_displays (ply_seat_t *seat)
 {
-  ply_text_display_t *display;
-
-  if (!ply_terminal_is_open (seat->terminal))
-    {
-      if (!ply_terminal_open (seat->terminal))
-        {
-          ply_trace ("could not add terminal %s: %m",
-                     ply_terminal_get_name (seat->terminal));
-          return;
+        ply_text_display_t *display;
+
+        if (!ply_terminal_is_open (seat->terminal)) {
+                if (!ply_terminal_open (seat->terminal)) {
+                        ply_trace ("could not add terminal %s: %m",
+                                   ply_terminal_get_name (seat->terminal));
+                        return;
+                }
         }
-    }
 
-  ply_trace ("adding text display for terminal %s",
-             ply_terminal_get_name (seat->terminal));
+        ply_trace ("adding text display for terminal %s",
+                   ply_terminal_get_name (seat->terminal));
 
-  display = ply_text_display_new (seat->terminal);
-  ply_list_append_data (seat->text_displays, display);
+        display = ply_text_display_new (seat->terminal);
+        ply_list_append_data (seat->text_displays, display);
 }
 
 bool
-ply_seat_open (ply_seat_t          *seat,
-               ply_renderer_type_t  renderer_type,
-               const char          *device)
+ply_seat_open (ply_seat_t         *seat,
+               ply_renderer_type_t renderer_type,
+               const char         *device)
 {
-  if (renderer_type != PLY_RENDERER_TYPE_NONE)
-    {
-      ply_renderer_t *renderer;
+        if (renderer_type != PLY_RENDERER_TYPE_NONE) {
+                ply_renderer_t *renderer;
 
-      renderer = ply_renderer_new (renderer_type, device, seat->terminal);
+                renderer = ply_renderer_new (renderer_type, device, seat->terminal);
 
-      if (!ply_renderer_open (renderer))
-        {
-          ply_trace ("could not open renderer for %s", device);
-          ply_renderer_free (renderer);
+                if (!ply_renderer_open (renderer)) {
+                        ply_trace ("could not open renderer for %s", device);
+                        ply_renderer_free (renderer);
 
-          seat->renderer = NULL;
-          seat->renderer_active = false;
+                        seat->renderer = NULL;
+                        seat->renderer_active = false;
 
-          if (renderer_type != PLY_RENDERER_TYPE_AUTO)
-            return false;
-        }
-      else
-        {
-          seat->renderer = renderer;
-          seat->renderer_active = true;
+                        if (renderer_type != PLY_RENDERER_TYPE_AUTO)
+                                return false;
+                } else {
+                        seat->renderer = renderer;
+                        seat->renderer_active = true;
+                }
         }
-    }
 
-  if (seat->renderer != NULL)
-    {
-      seat->keyboard = ply_keyboard_new_for_renderer (seat->renderer);
-      add_pixel_displays (seat);
-
-    }
-  else
-    {
-      seat->keyboard = ply_keyboard_new_for_terminal (seat->terminal);
-    }
-  add_text_displays (seat);
+        if (seat->renderer != NULL) {
+                seat->keyboard = ply_keyboard_new_for_renderer (seat->renderer);
+                add_pixel_displays (seat);
+        } else {
+                seat->keyboard = ply_keyboard_new_for_terminal (seat->terminal);
+        }
+        add_text_displays (seat);
 
-  ply_keyboard_watch_for_input (seat->keyboard);
-  seat->keyboard_active = true;
+        ply_keyboard_watch_for_input (seat->keyboard);
+        seat->keyboard_active = true;
 
-  return true;
+        return true;
 }
 
 bool
 ply_seat_is_open (ply_seat_t *seat)
 {
-  return ply_list_get_length (seat->pixel_displays) > 0 ||
-         ply_list_get_length (seat->text_displays) > 0;
+        return ply_list_get_length (seat->pixel_displays) > 0 ||
+               ply_list_get_length (seat->text_displays) > 0;
 }
 
 void
 ply_seat_deactivate_keyboard (ply_seat_t *seat)
 {
-  if (!seat->keyboard_active)
-    return;
+        if (!seat->keyboard_active)
+                return;
 
-  seat->keyboard_active = false;
+        seat->keyboard_active = false;
 
-  if (seat->keyboard == NULL)
-    return;
+        if (seat->keyboard == NULL)
+                return;
 
-  ply_trace ("deactivating keybord");
-  ply_keyboard_stop_watching_for_input (seat->keyboard);
+        ply_trace ("deactivating keybord");
+        ply_keyboard_stop_watching_for_input (seat->keyboard);
 }
 
 void
 ply_seat_deactivate_renderer (ply_seat_t *seat)
 {
-  if (!seat->renderer_active)
-    return;
+        if (!seat->renderer_active)
+                return;
 
-  seat->renderer_active = false;
+        seat->renderer_active = false;
 
-  if (seat->renderer == NULL)
-    return;
+        if (seat->renderer == NULL)
+                return;
 
-  ply_trace ("deactivating renderer");
-  ply_renderer_deactivate (seat->renderer);
+        ply_trace ("deactivating renderer");
+        ply_renderer_deactivate (seat->renderer);
 }
 
 void
 ply_seat_activate_keyboard (ply_seat_t *seat)
 {
-  if (seat->keyboard_active)
-    return;
+        if (seat->keyboard_active)
+                return;
 
-  if (seat->keyboard == NULL)
-    return;
+        if (seat->keyboard == NULL)
+                return;
 
-  ply_trace ("activating keyboard");
-  ply_keyboard_watch_for_input (seat->keyboard);
+        ply_trace ("activating keyboard");
+        ply_keyboard_watch_for_input (seat->keyboard);
 
-  seat->keyboard_active = true;
+        seat->keyboard_active = true;
 }
 
 void
 ply_seat_activate_renderer (ply_seat_t *seat)
 {
-  if (seat->renderer_active)
-    return;
+        if (seat->renderer_active)
+                return;
 
-  if (seat->renderer == NULL)
-    return;
+        if (seat->renderer == NULL)
+                return;
 
-  ply_trace ("activating renderer");
-  ply_renderer_activate (seat->renderer);
+        ply_trace ("activating renderer");
+        ply_renderer_activate (seat->renderer);
 
-  seat->renderer_active = true;
+        seat->renderer_active = true;
 }
 
 void
 ply_seat_refresh_displays (ply_seat_t *seat)
 {
-  ply_list_node_t *node;
-
-  node = ply_list_get_first_node (seat->pixel_displays);
-  while (node != NULL)
-    {
-      ply_pixel_display_t *display;
-      ply_list_node_t *next_node;
-      unsigned long width, height;
-
-      display = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (seat->pixel_displays, node);
-
-      width = ply_pixel_display_get_width (display);
-      height = ply_pixel_display_get_height (display);
-
-      ply_pixel_display_draw_area (display, 0, 0, width, height);
-      node = next_node;
-    }
-
-  node = ply_list_get_first_node (seat->text_displays);
-  while (node != NULL)
-    {
-      ply_text_display_t *display;
-      ply_list_node_t *next_node;
-      int number_of_columns, number_of_rows;
-
-      display = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (seat->text_displays, node);
-
-      number_of_columns = ply_text_display_get_number_of_columns (display);
-      number_of_rows = ply_text_display_get_number_of_rows (display);
-
-      ply_text_display_draw_area (display, 0, 0,
-                                  number_of_columns,
-                                  number_of_rows);
-      node = next_node;
-    }
+        ply_list_node_t *node;
+
+        node = ply_list_get_first_node (seat->pixel_displays);
+        while (node != NULL) {
+                ply_pixel_display_t *display;
+                ply_list_node_t *next_node;
+                unsigned long width, height;
+
+                display = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (seat->pixel_displays, node);
+
+                width = ply_pixel_display_get_width (display);
+                height = ply_pixel_display_get_height (display);
+
+                ply_pixel_display_draw_area (display, 0, 0, width, height);
+                node = next_node;
+        }
+
+        node = ply_list_get_first_node (seat->text_displays);
+        while (node != NULL) {
+                ply_text_display_t *display;
+                ply_list_node_t *next_node;
+                int number_of_columns, number_of_rows;
+
+                display = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (seat->text_displays, node);
+
+                number_of_columns = ply_text_display_get_number_of_columns (display);
+                number_of_rows = ply_text_display_get_number_of_rows (display);
+
+                ply_text_display_draw_area (display, 0, 0,
+                                            number_of_columns,
+                                            number_of_rows);
+                node = next_node;
+        }
 }
 
 void
 ply_seat_close (ply_seat_t *seat)
 {
-  if (seat->renderer == NULL)
-    return;
+        if (seat->renderer == NULL)
+                return;
 
-  ply_trace ("destroying renderer");
-  ply_renderer_close (seat->renderer);
-  ply_renderer_free (seat->renderer);
-  seat->renderer = NULL;
+        ply_trace ("destroying renderer");
+        ply_renderer_close (seat->renderer);
+        ply_renderer_free (seat->renderer);
+        seat->renderer = NULL;
 }
 
 void
 ply_seat_set_splash (ply_seat_t        *seat,
                      ply_boot_splash_t *splash)
 {
-  if (seat->splash == splash)
-    return;
+        if (seat->splash == splash)
+                return;
 
-  if (seat->splash != NULL)
-    ply_boot_splash_detach_from_seat (splash, seat);
+        if (seat->splash != NULL)
+                ply_boot_splash_detach_from_seat (splash, seat);
 
-  if (splash != NULL)
-    ply_boot_splash_attach_to_seat (splash, seat);
+        if (splash != NULL)
+                ply_boot_splash_attach_to_seat (splash, seat);
 
-  seat->splash = splash;
+        seat->splash = splash;
 }
 
 static void
 free_pixel_displays (ply_seat_t *seat)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("freeing %d pixel displays", ply_list_get_length (seat->pixel_displays));
-  node = ply_list_get_first_node (seat->pixel_displays);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_pixel_display_t *display;
+        ply_trace ("freeing %d pixel displays", ply_list_get_length (seat->pixel_displays));
+        node = ply_list_get_first_node (seat->pixel_displays);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_pixel_display_t *display;
 
-      next_node = ply_list_get_next_node (seat->pixel_displays, node);
-      display = ply_list_node_get_data (node);
-      ply_pixel_display_free (display);
+                next_node = ply_list_get_next_node (seat->pixel_displays, node);
+                display = ply_list_node_get_data (node);
+                ply_pixel_display_free (display);
 
-      ply_list_remove_node (seat->pixel_displays, node);
+                ply_list_remove_node (seat->pixel_displays, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 free_text_displays (ply_seat_t *seat)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("freeing %d text displays", ply_list_get_length (seat->text_displays));
-  node = ply_list_get_first_node (seat->text_displays);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_text_display_t *display;
+        ply_trace ("freeing %d text displays", ply_list_get_length (seat->text_displays));
+        node = ply_list_get_first_node (seat->text_displays);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_text_display_t *display;
 
-      next_node = ply_list_get_next_node (seat->text_displays, node);
-      display = ply_list_node_get_data (node);
-      ply_text_display_free (display);
+                next_node = ply_list_get_next_node (seat->text_displays, node);
+                display = ply_list_node_get_data (node);
+                ply_text_display_free (display);
 
-      ply_list_remove_node (seat->text_displays, node);
+                ply_list_remove_node (seat->text_displays, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 void
 ply_seat_free (ply_seat_t *seat)
 {
-  if (seat == NULL)
-    return;
+        if (seat == NULL)
+                return;
 
-  free_pixel_displays (seat);
-  free_text_displays (seat);
-  ply_keyboard_free (seat->keyboard);
+        free_pixel_displays (seat);
+        free_text_displays (seat);
+        ply_keyboard_free (seat->keyboard);
 
-  free (seat);
+        free (seat);
 }
 
 ply_list_t *
 ply_seat_get_pixel_displays (ply_seat_t *seat)
 {
-  return seat->pixel_displays;
+        return seat->pixel_displays;
 }
 
 ply_list_t *
 ply_seat_get_text_displays (ply_seat_t *seat)
 {
-  return seat->text_displays;
+        return seat->text_displays;
 }
 
 ply_keyboard_t *
 ply_seat_get_keyboard (ply_seat_t *seat)
 {
-  return seat->keyboard;
+        return seat->keyboard;
 }
 
 ply_renderer_t *
 ply_seat_get_renderer (ply_seat_t *seat)
 {
-  return seat->renderer;
+        return seat->renderer;
 }
 
 /* vim: set ts=4 sw=4 et ai ci cino={.5s,^-2,+.5s,t0,g0,e-2,n-2,p2s,(0,=.5s,:.5s */
diff --git a/src/libply-splash-core/ply-seat.h b/src/libply-splash-core/ply-seat.h
index d5d3397..f9ed15d 100644
--- a/src/libply-splash-core/ply-seat.h
+++ b/src/libply-splash-core/ply-seat.h
@@ -43,9 +43,9 @@ typedef struct _ply_seat ply_seat_t;
 ply_seat_t *ply_seat_new (ply_terminal_t *terminal);
 
 void ply_seat_free (ply_seat_t *seat);
-bool ply_seat_open (ply_seat_t          *seat,
-                    ply_renderer_type_t  renderer_type,
-                    const char          *device);
+bool ply_seat_open (ply_seat_t         *seat,
+                    ply_renderer_type_t renderer_type,
+                    const char         *device);
 bool ply_seat_is_open (ply_seat_t *seat);
 void ply_seat_deactivate_keyboard (ply_seat_t *seat);
 void ply_seat_activate_keyboard (ply_seat_t *seat);
diff --git a/src/libply-splash-core/ply-terminal.c b/src/libply-splash-core/ply-terminal.c
index 992dd3f..1bbeb42 100644
--- a/src/libply-splash-core/ply-terminal.c
+++ b/src/libply-splash-core/ply-terminal.c
@@ -60,56 +60,56 @@
 
 typedef struct
 {
-  ply_terminal_input_handler_t handler;
-  void *user_data;
+        ply_terminal_input_handler_t handler;
+        void                        *user_data;
 } ply_terminal_input_closure_t;
 
 typedef struct
 {
-  ply_terminal_active_vt_changed_handler_t handler;
-  void *user_data;
+        ply_terminal_active_vt_changed_handler_t handler;
+        void                                    *user_data;
 } ply_terminal_active_vt_changed_closure_t;
 
 struct _ply_terminal
 {
-  ply_event_loop_t *loop;
-
-  struct termios original_term_attributes;
-  struct termios original_locked_term_attributes;
-
-  char *name;
-  int   fd;
-  int   vt_number;
-  int   initial_vt_number;
-  int   number_of_reopen_tries;
-
-  ply_list_t *vt_change_closures;
-  ply_list_t *input_closures;
-  ply_fd_watch_t *fd_watch;
-  ply_terminal_color_t foreground_color;
-  ply_terminal_color_t background_color;
-
-  uint8_t original_color_palette[TEXT_PALETTE_SIZE];
-  uint8_t color_palette[TEXT_PALETTE_SIZE];
-
-  int number_of_rows;
-  int number_of_columns;
-
-  uint32_t original_term_attributes_saved : 1;
-  uint32_t original_locked_term_attributes_saved : 1;
-  uint32_t supports_text_color : 1;
-  uint32_t is_open : 1;
-  uint32_t is_active : 1;
-  uint32_t is_unbuffered : 1;
-  uint32_t is_watching_for_vt_changes : 1;
-  uint32_t should_ignore_mode_changes : 1;
+        ply_event_loop_t    *loop;
+
+        struct termios       original_term_attributes;
+        struct termios       original_locked_term_attributes;
+
+        char                *name;
+        int                  fd;
+        int                  vt_number;
+        int                  initial_vt_number;
+        int                  number_of_reopen_tries;
+
+        ply_list_t          *vt_change_closures;
+        ply_list_t          *input_closures;
+        ply_fd_watch_t      *fd_watch;
+        ply_terminal_color_t foreground_color;
+        ply_terminal_color_t background_color;
+
+        uint8_t              original_color_palette[TEXT_PALETTE_SIZE];
+        uint8_t              color_palette[TEXT_PALETTE_SIZE];
+
+        int                  number_of_rows;
+        int                  number_of_columns;
+
+        uint32_t             original_term_attributes_saved : 1;
+        uint32_t             original_locked_term_attributes_saved : 1;
+        uint32_t             supports_text_color : 1;
+        uint32_t             is_open : 1;
+        uint32_t             is_active : 1;
+        uint32_t             is_unbuffered : 1;
+        uint32_t             is_watching_for_vt_changes : 1;
+        uint32_t             should_ignore_mode_changes : 1;
 };
 
 typedef enum
 {
-  PLY_TERMINAL_OPEN_RESULT_INCOMPLETE,
-  PLY_TERMINAL_OPEN_RESULT_FAILURE,
-  PLY_TERMINAL_OPEN_RESULT_SUCCESS,
+        PLY_TERMINAL_OPEN_RESULT_INCOMPLETE,
+        PLY_TERMINAL_OPEN_RESULT_FAILURE,
+        PLY_TERMINAL_OPEN_RESULT_SUCCESS,
 } ply_terminal_open_result_t;
 
 static ply_terminal_open_result_t ply_terminal_open_device (ply_terminal_t *terminal);
@@ -117,199 +117,191 @@ static ply_terminal_open_result_t ply_terminal_open_device (ply_terminal_t *term
 ply_terminal_t *
 ply_terminal_new (const char *device_name)
 {
-  ply_terminal_t *terminal;
+        ply_terminal_t *terminal;
 
-  assert (device_name != NULL);
+        assert (device_name != NULL);
 
-  terminal = calloc (1, sizeof (ply_terminal_t));
+        terminal = calloc (1, sizeof(ply_terminal_t));
 
-  terminal->loop = ply_event_loop_get_default ();
-  terminal->vt_change_closures = ply_list_new ();
-  terminal->input_closures = ply_list_new ();
+        terminal->loop = ply_event_loop_get_default ();
+        terminal->vt_change_closures = ply_list_new ();
+        terminal->input_closures = ply_list_new ();
 
-  if (strncmp (device_name, "/dev/", strlen ("/dev/")) == 0)
-    terminal->name = strdup (device_name);
-  else
-    asprintf (&terminal->name, "/dev/%s", device_name);
+        if (strncmp (device_name, "/dev/", strlen ("/dev/")) == 0)
+                terminal->name = strdup (device_name);
+        else
+                asprintf (&terminal->name, "/dev/%s", device_name);
 
-  terminal->fd = -1;
-  terminal->vt_number = -1;
-  terminal->initial_vt_number = -1;
+        terminal->fd = -1;
+        terminal->vt_number = -1;
+        terminal->initial_vt_number = -1;
 
-  return terminal;
+        return terminal;
 }
 
 static void
 ply_terminal_look_up_color_palette (ply_terminal_t *terminal)
 {
-  if (ioctl (terminal->fd, GIO_CMAP, terminal->color_palette) < 0)
-    terminal->supports_text_color = false;
-  else
-    terminal->supports_text_color = true;
+        if (ioctl (terminal->fd, GIO_CMAP, terminal->color_palette) < 0)
+                terminal->supports_text_color = false;
+        else
+                terminal->supports_text_color = true;
 }
 
 static bool
 ply_terminal_change_color_palette (ply_terminal_t *terminal)
 {
-  if (!terminal->supports_text_color)
-    return true;
+        if (!terminal->supports_text_color)
+                return true;
 
-  if (ioctl (terminal->fd, PIO_CMAP, terminal->color_palette) < 0)
-    return false;
+        if (ioctl (terminal->fd, PIO_CMAP, terminal->color_palette) < 0)
+                return false;
 
-  return true;
+        return true;
 }
 
 static void
 ply_terminal_save_color_palette (ply_terminal_t *terminal)
 {
-  if (!terminal->supports_text_color)
-    return;
+        if (!terminal->supports_text_color)
+                return;
 
-  memcpy (terminal->original_color_palette, terminal->color_palette,
-          TEXT_PALETTE_SIZE);
+        memcpy (terminal->original_color_palette, terminal->color_palette,
+                TEXT_PALETTE_SIZE);
 }
 
 static void
 ply_terminal_restore_color_palette (ply_terminal_t *terminal)
 {
-  if (!terminal->supports_text_color)
-    return;
+        if (!terminal->supports_text_color)
+                return;
 
-  memcpy (terminal->color_palette, terminal->original_color_palette,
-          TEXT_PALETTE_SIZE);
+        memcpy (terminal->color_palette, terminal->original_color_palette,
+                TEXT_PALETTE_SIZE);
 
-  ply_terminal_change_color_palette (terminal);
+        ply_terminal_change_color_palette (terminal);
 }
 
 void
 ply_terminal_reset_colors (ply_terminal_t *terminal)
 {
-  assert (terminal != NULL);
+        assert (terminal != NULL);
 
-  ply_terminal_restore_color_palette (terminal);
+        ply_terminal_restore_color_palette (terminal);
 }
 
 static void
 ply_terminal_unlock (ply_terminal_t *terminal)
 {
-  struct termios locked_term_attributes;
+        struct termios locked_term_attributes;
 
-  assert (terminal != NULL);
+        assert (terminal != NULL);
 
-  if (terminal->original_locked_term_attributes_saved)
-    locked_term_attributes = terminal->original_locked_term_attributes;
-  else
-    memset (&locked_term_attributes, 0x0, sizeof (locked_term_attributes));
+        if (terminal->original_locked_term_attributes_saved)
+                locked_term_attributes = terminal->original_locked_term_attributes;
+        else
+                memset (&locked_term_attributes, 0x0, sizeof(locked_term_attributes));
 
-  if (ioctl (terminal->fd, TIOCSLCKTRMIOS,
-             &locked_term_attributes) < 0)
-    {
-      ply_trace ("couldn't unlock terminal settings: %m");
-    }
+        if (ioctl (terminal->fd, TIOCSLCKTRMIOS,
+                   &locked_term_attributes) < 0)
+                ply_trace ("couldn't unlock terminal settings: %m");
 
-  terminal->original_locked_term_attributes_saved = false;
+        terminal->original_locked_term_attributes_saved = false;
 }
 
 static void
 ply_terminal_lock (ply_terminal_t *terminal)
 {
-  struct termios locked_term_attributes;
+        struct termios locked_term_attributes;
 
-  assert (terminal != NULL);
+        assert (terminal != NULL);
 
-  if (!terminal->original_locked_term_attributes_saved &&
-      ioctl (terminal->fd, TIOCGLCKTRMIOS, &locked_term_attributes) == 0)
-    {
-      terminal->original_locked_term_attributes = locked_term_attributes;
-      terminal->original_locked_term_attributes_saved = true;
+        if (!terminal->original_locked_term_attributes_saved &&
+            ioctl (terminal->fd, TIOCGLCKTRMIOS, &locked_term_attributes) == 0) {
+                terminal->original_locked_term_attributes = locked_term_attributes;
+                terminal->original_locked_term_attributes_saved = true;
 
-      memset (&locked_term_attributes, 0xff, sizeof (locked_term_attributes));
-      if (ioctl (terminal->fd, TIOCSLCKTRMIOS, &locked_term_attributes) < 0)
-        {
-          ply_trace ("couldn't lock terminal settings: %m");
+                memset (&locked_term_attributes, 0xff, sizeof(locked_term_attributes));
+                if (ioctl (terminal->fd, TIOCSLCKTRMIOS, &locked_term_attributes) < 0)
+                        ply_trace ("couldn't lock terminal settings: %m");
         }
-    }
 }
 
 bool
 ply_terminal_set_unbuffered_input (ply_terminal_t *terminal)
 {
-  struct termios term_attributes;
+        struct termios term_attributes;
 
-  ply_terminal_unlock (terminal);
+        ply_terminal_unlock (terminal);
 
-  tcgetattr (terminal->fd, &term_attributes);
+        tcgetattr (terminal->fd, &term_attributes);
 
-  if (!terminal->original_term_attributes_saved)
-    {
-      terminal->original_term_attributes = term_attributes;
-      terminal->original_term_attributes_saved = true;
-    }
+        if (!terminal->original_term_attributes_saved) {
+                terminal->original_term_attributes = term_attributes;
+                terminal->original_term_attributes_saved = true;
+        }
 
-  cfmakeraw (&term_attributes);
+        cfmakeraw (&term_attributes);
 
-  /* Make return output new line like canonical mode */
-  term_attributes.c_iflag |= ICRNL;
+        /* Make return output new line like canonical mode */
+        term_attributes.c_iflag |= ICRNL;
 
-  /* Make \n return go to the beginning of the next line */
-  term_attributes.c_oflag |= ONLCR | OPOST;
+        /* Make \n return go to the beginning of the next line */
+        term_attributes.c_oflag |= ONLCR | OPOST;
 
-  if (tcsetattr (terminal->fd, TCSANOW, &term_attributes) != 0)
-    return false;
+        if (tcsetattr (terminal->fd, TCSANOW, &term_attributes) != 0)
+                return false;
 
-  ply_terminal_lock (terminal);
+        ply_terminal_lock (terminal);
 
-  terminal->is_unbuffered = true;
+        terminal->is_unbuffered = true;
 
-  return true;
+        return true;
 }
 
 bool
 ply_terminal_set_buffered_input (ply_terminal_t *terminal)
 {
-  struct termios term_attributes;
+        struct termios term_attributes;
 
-  if (!terminal->is_unbuffered)
-    return true;
+        if (!terminal->is_unbuffered)
+                return true;
 
-  ply_terminal_unlock (terminal);
+        ply_terminal_unlock (terminal);
 
-  tcgetattr (terminal->fd, &term_attributes);
+        tcgetattr (terminal->fd, &term_attributes);
 
-  /* If someone already messed with the terminal settings,
-   * and they seem good enough, bail
-   */
-  if (term_attributes.c_lflag & ICANON)
-    {
-      terminal->is_unbuffered = false;
+        /* If someone already messed with the terminal settings,
+         * and they seem good enough, bail
+         */
+        if (term_attributes.c_lflag & ICANON) {
+                terminal->is_unbuffered = false;
 
-      return true;
-    }
+                return true;
+        }
 
-  /* If we don't know the original term attributes, or they were originally sucky,
-   * then invent some that are probably good enough.
-   */
-  if (!terminal->original_term_attributes_saved || !(terminal->original_term_attributes.c_lflag & ICANON))
-    {
-      term_attributes.c_iflag |= BRKINT | IGNPAR | ICRNL | IXON;
-      term_attributes.c_oflag |= OPOST;
-      term_attributes.c_lflag |= ECHO | ICANON | ISIG | IEXTEN;
+        /* If we don't know the original term attributes, or they were originally sucky,
+         * then invent some that are probably good enough.
+         */
+        if (!terminal->original_term_attributes_saved || !(terminal->original_term_attributes.c_lflag & ICANON)) {
+                term_attributes.c_iflag |= BRKINT | IGNPAR | ICRNL | IXON;
+                term_attributes.c_oflag |= OPOST;
+                term_attributes.c_lflag |= ECHO | ICANON | ISIG | IEXTEN;
 
-      if (tcsetattr (terminal->fd, TCSANOW, &term_attributes) != 0)
-        return false;
+                if (tcsetattr (terminal->fd, TCSANOW, &term_attributes) != 0)
+                        return false;
 
-      terminal->is_unbuffered = false;
+                terminal->is_unbuffered = false;
 
-      return true;
-    }
+                return true;
+        }
 
-  if (tcsetattr (terminal->fd, TCSANOW, &terminal->original_term_attributes) != 0)
-    return false;
+        if (tcsetattr (terminal->fd, TCSANOW, &terminal->original_term_attributes) != 0)
+                return false;
 
-  terminal->is_unbuffered = false;
+        terminal->is_unbuffered = false;
 
-  return true;
+        return true;
 }
 
 void
@@ -317,777 +309,741 @@ ply_terminal_write (ply_terminal_t *terminal,
                     const char     *format,
                     ...)
 {
-  va_list args;
-  char *string;
-  int size;
+        va_list args;
+        char *string;
+        int size;
 
-  assert (terminal != NULL);
-  assert (format != NULL);
+        assert (terminal != NULL);
+        assert (format != NULL);
 
-  string = NULL;
-  va_start (args, format);
-  size = vasprintf (&string, format, args);
-  va_end (args);
+        string = NULL;
+        va_start (args, format);
+        size = vasprintf (&string, format, args);
+        va_end (args);
 
-  write (terminal->fd, string, size);
-  free (string);
+        write (terminal->fd, string, size);
+        free (string);
 }
 
 static void
 ply_terminal_reopen_device (ply_terminal_t *terminal)
 {
-  ply_terminal_open_result_t open_result;
+        ply_terminal_open_result_t open_result;
 
-  ply_trace ("trying to reopen terminal '%s' (attempt %d)",
-             terminal->name,
-             terminal->number_of_reopen_tries);
+        ply_trace ("trying to reopen terminal '%s' (attempt %d)",
+                   terminal->name,
+                   terminal->number_of_reopen_tries);
 
-  terminal->number_of_reopen_tries++;
+        terminal->number_of_reopen_tries++;
 
-  open_result = ply_terminal_open_device (terminal);
+        open_result = ply_terminal_open_device (terminal);
 
-  if (open_result == PLY_TERMINAL_OPEN_RESULT_INCOMPLETE)
-    {
-      int total_retries;
+        if (open_result == PLY_TERMINAL_OPEN_RESULT_INCOMPLETE) {
+                int total_retries;
 
-      total_retries = (int) (PLY_TERMINAL_REOPEN_TIMEOUT / PLY_TERMINAL_REOPEN_INTERVAL);
+                total_retries = (int) (PLY_TERMINAL_REOPEN_TIMEOUT / PLY_TERMINAL_REOPEN_INTERVAL);
 
-      if (terminal->number_of_reopen_tries < total_retries)
-        {
-          ply_event_loop_watch_for_timeout (terminal->loop,
-                                            PLY_TERMINAL_REOPEN_INTERVAL,
-                                            (ply_event_loop_timeout_handler_t)
-                                            ply_terminal_reopen_device,
-                                            terminal);
+                if (terminal->number_of_reopen_tries < total_retries) {
+                        ply_event_loop_watch_for_timeout (terminal->loop,
+                                                          PLY_TERMINAL_REOPEN_INTERVAL,
+                                                          (ply_event_loop_timeout_handler_t)
+                                                          ply_terminal_reopen_device,
+                                                          terminal);
+                } else {
+                        ply_trace ("couldn't reopen tty, giving up");
+                        terminal->number_of_reopen_tries = 0;
+                }
         }
-      else
-        {
-          ply_trace ("couldn't reopen tty, giving up");
-          terminal->number_of_reopen_tries = 0;
-        }
-    }
 }
 
 static void
 on_tty_input (ply_terminal_t *terminal)
 {
+        ply_list_node_t *node;
 
-  ply_list_node_t *node;
-
-  node = ply_list_get_first_node (terminal->input_closures);
-  while (node != NULL)
-    {
-      ply_terminal_input_closure_t *closure;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (terminal->input_closures);
+        while (node != NULL) {
+                ply_terminal_input_closure_t *closure;
+                ply_list_node_t *next_node;
 
-      closure = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (terminal->input_closures, node);
+                closure = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (terminal->input_closures, node);
 
-      if (closure->handler != NULL)
-        closure->handler (closure->user_data, terminal);
+                if (closure->handler != NULL)
+                        closure->handler (closure->user_data, terminal);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 on_tty_disconnected (ply_terminal_t *terminal)
 {
-  ply_trace ("tty disconnected (fd %d)", terminal->fd);
-  terminal->fd_watch = NULL;
-  terminal->fd = -1;
-  terminal->number_of_reopen_tries = 0;
+        ply_trace ("tty disconnected (fd %d)", terminal->fd);
+        terminal->fd_watch = NULL;
+        terminal->fd = -1;
+        terminal->number_of_reopen_tries = 0;
 
-  ply_terminal_reopen_device (terminal);
+        ply_terminal_reopen_device (terminal);
 }
 
 static bool
 ply_terminal_look_up_geometry (ply_terminal_t *terminal)
 {
-    struct winsize terminal_size;
+        struct winsize terminal_size;
 
-    ply_trace ("looking up terminal text geometry");
+        ply_trace ("looking up terminal text geometry");
 
-    if (ioctl (terminal->fd, TIOCGWINSZ, &terminal_size) < 0)
-      {
-        ply_trace ("could not read terminal text geometry: %m");
-        terminal->number_of_columns = 80;
-        terminal->number_of_rows = 24;
-        return false;
-      }
+        if (ioctl (terminal->fd, TIOCGWINSZ, &terminal_size) < 0) {
+                ply_trace ("could not read terminal text geometry: %m");
+                terminal->number_of_columns = 80;
+                terminal->number_of_rows = 24;
+                return false;
+        }
 
-    terminal->number_of_rows = terminal_size.ws_row;
-    terminal->number_of_columns = terminal_size.ws_col;
+        terminal->number_of_rows = terminal_size.ws_row;
+        terminal->number_of_columns = terminal_size.ws_col;
 
-    ply_trace ("terminal is now %dx%d text cells",
-               terminal->number_of_columns,
-               terminal->number_of_rows);
+        ply_trace ("terminal is now %dx%d text cells",
+                   terminal->number_of_columns,
+                   terminal->number_of_rows);
 
-    return true;
+        return true;
 }
 
 static void
 ply_terminal_check_for_vt (ply_terminal_t *terminal)
 {
-  int major_number, minor_number;
-  struct stat file_attributes;
+        int major_number, minor_number;
+        struct stat file_attributes;
 
-  assert (terminal != NULL);
-  assert (terminal->fd >= 0);
+        assert (terminal != NULL);
+        assert (terminal->fd >= 0);
 
-  if (fstat (terminal->fd, &file_attributes) != 0)
-    return;
+        if (fstat (terminal->fd, &file_attributes) != 0)
+                return;
 
-  major_number = major (file_attributes.st_rdev);
-  minor_number = minor (file_attributes.st_rdev);
+        major_number = major (file_attributes.st_rdev);
+        minor_number = minor (file_attributes.st_rdev);
 
-  if ((major_number == TTY_MAJOR) && (minor_number <= MAX_NR_CONSOLES))
-    terminal->vt_number = minor_number;
-  else
-    terminal->vt_number = -1;
+        if ((major_number == TTY_MAJOR) && (minor_number <= MAX_NR_CONSOLES))
+                terminal->vt_number = minor_number;
+        else
+                terminal->vt_number = -1;
 }
 
 static int
 get_active_vt (ply_terminal_t *terminal)
 {
-  struct vt_stat vt_state = { 0 };
+        struct vt_stat vt_state = { 0 };
 
-  if (ioctl (terminal->fd, VT_GETSTATE, &vt_state) < 0)
-    return -1;
+        if (ioctl (terminal->fd, VT_GETSTATE, &vt_state) < 0)
+                return -1;
 
-  if (terminal->initial_vt_number < 0)
-    {
-      terminal->initial_vt_number = vt_state.v_active;
-      ply_trace ("Remembering that initial vt is %d",
-                 terminal->initial_vt_number);
-    }
+        if (terminal->initial_vt_number < 0) {
+                terminal->initial_vt_number = vt_state.v_active;
+                ply_trace ("Remembering that initial vt is %d",
+                           terminal->initial_vt_number);
+        }
 
-  return vt_state.v_active;
+        return vt_state.v_active;
 }
 
 static void
 do_active_vt_changed (ply_terminal_t *terminal)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (terminal->vt_change_closures);
-  while (node != NULL)
-    {
-      ply_terminal_active_vt_changed_closure_t *closure;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (terminal->vt_change_closures);
+        while (node != NULL) {
+                ply_terminal_active_vt_changed_closure_t *closure;
+                ply_list_node_t *next_node;
 
-      closure = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (terminal->vt_change_closures, node);
+                closure = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (terminal->vt_change_closures, node);
 
-      if (closure->handler != NULL)
-        closure->handler (closure->user_data, terminal);
+                if (closure->handler != NULL)
+                        closure->handler (closure->user_data, terminal);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 on_leave_vt (ply_terminal_t *terminal)
 {
-  ioctl (terminal->fd, VT_RELDISP, 1);
+        ioctl (terminal->fd, VT_RELDISP, 1);
 
-  terminal->is_active = false;
-  do_active_vt_changed (terminal);
+        terminal->is_active = false;
+        do_active_vt_changed (terminal);
 }
 
 static void
 on_enter_vt (ply_terminal_t *terminal)
 {
-  ioctl (terminal->fd, VT_RELDISP, VT_ACKACQ);
+        ioctl (terminal->fd, VT_RELDISP, VT_ACKACQ);
 
-  terminal->is_active = true;
-  do_active_vt_changed (terminal);
+        terminal->is_active = true;
+        do_active_vt_changed (terminal);
 }
 
 void
 ply_terminal_watch_for_vt_changes (ply_terminal_t *terminal)
 {
-  assert (terminal != NULL);
+        assert (terminal != NULL);
 
-  struct vt_mode mode = { 0 };
+        struct vt_mode mode = { 0 };
 
-  if (terminal->fd < 0)
-    return;
+        if (terminal->fd < 0)
+                return;
 
-  if (!ply_terminal_is_vt (terminal))
-    return;
+        if (!ply_terminal_is_vt (terminal))
+                return;
 
-  if (terminal->is_watching_for_vt_changes)
-    return;
+        if (terminal->is_watching_for_vt_changes)
+                return;
 
-  mode.mode = VT_PROCESS;
-  mode.relsig = SIGUSR1;
-  mode.acqsig = SIGUSR2;
+        mode.mode = VT_PROCESS;
+        mode.relsig = SIGUSR1;
+        mode.acqsig = SIGUSR2;
 
-  if (ioctl (terminal->fd, VT_SETMODE, &mode) < 0)
-    return;
+        if (ioctl (terminal->fd, VT_SETMODE, &mode) < 0)
+                return;
 
-  ply_event_loop_watch_signal (terminal->loop,
-                               SIGUSR1,
-                               (ply_event_handler_t)
-                               on_leave_vt, terminal);
+        ply_event_loop_watch_signal (terminal->loop,
+                                     SIGUSR1,
+                                     (ply_event_handler_t)
+                                     on_leave_vt, terminal);
 
-  ply_event_loop_watch_signal (terminal->loop,
-                               SIGUSR2,
-                               (ply_event_handler_t)
-                               on_enter_vt, terminal);
+        ply_event_loop_watch_signal (terminal->loop,
+                                     SIGUSR2,
+                                     (ply_event_handler_t)
+                                     on_enter_vt, terminal);
 
-  terminal->is_watching_for_vt_changes = true;
+        terminal->is_watching_for_vt_changes = true;
 }
 
 void
 ply_terminal_stop_watching_for_vt_changes (ply_terminal_t *terminal)
 {
-  struct vt_mode mode = { 0 };
+        struct vt_mode mode = { 0 };
 
-  if (!ply_terminal_is_vt (terminal))
-    return;
+        if (!ply_terminal_is_vt (terminal))
+                return;
 
-  if (!terminal->is_watching_for_vt_changes)
-    return;
+        if (!terminal->is_watching_for_vt_changes)
+                return;
 
-  terminal->is_watching_for_vt_changes = false;
+        terminal->is_watching_for_vt_changes = false;
 
-  ply_event_loop_stop_watching_signal (terminal->loop, SIGUSR1);
-  ply_event_loop_stop_watching_signal (terminal->loop, SIGUSR2);
+        ply_event_loop_stop_watching_signal (terminal->loop, SIGUSR1);
+        ply_event_loop_stop_watching_signal (terminal->loop, SIGUSR2);
 
-  mode.mode = VT_AUTO;
-  ioctl (terminal->fd, VT_SETMODE, &mode);
+        mode.mode = VT_AUTO;
+        ioctl (terminal->fd, VT_SETMODE, &mode);
 }
 
 static ply_terminal_open_result_t
 ply_terminal_open_device (ply_terminal_t *terminal)
 {
-  assert (terminal != NULL);
-  assert (terminal->name != NULL);
-  assert (terminal->fd < 0);
-  assert (terminal->fd_watch == NULL);
-
-  terminal->fd = open (terminal->name, O_RDWR | O_NOCTTY);
-
-  if (terminal->fd < 0)
-    {
-      ply_trace ("Unable to open terminal device '%s': %m", terminal->name);
-
-      /* The kernel will apparently return EIO spurriously when opening a tty that's
-       * in the process of closing down.  There's more information here:
-       *
-       * https://bugs.launchpad.net/ubuntu/+source/linux/+bug/554172/comments/245
-       *
-       * Work around it here.
-       */
-      if (errno == EIO)
-        return PLY_TERMINAL_OPEN_RESULT_INCOMPLETE;
-
-      terminal->number_of_reopen_tries = 0;
-      return PLY_TERMINAL_OPEN_RESULT_FAILURE;
-    }
-
-  terminal->fd_watch = ply_event_loop_watch_fd (terminal->loop, terminal->fd,
-                                                PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                                                (ply_event_handler_t) on_tty_input,
-                                                (ply_event_handler_t) on_tty_disconnected,
-                                                terminal);
-
-  ply_terminal_check_for_vt (terminal);
-
-  if (!ply_terminal_set_unbuffered_input (terminal))
-    ply_trace ("terminal '%s' will be line buffered", terminal->name);
-
-  terminal->number_of_reopen_tries = 0;
-  return PLY_TERMINAL_OPEN_RESULT_SUCCESS;
+        assert (terminal != NULL);
+        assert (terminal->name != NULL);
+        assert (terminal->fd < 0);
+        assert (terminal->fd_watch == NULL);
+
+        terminal->fd = open (terminal->name, O_RDWR | O_NOCTTY);
+
+        if (terminal->fd < 0) {
+                ply_trace ("Unable to open terminal device '%s': %m", terminal->name);
+
+                /* The kernel will apparently return EIO spurriously when opening a tty that's
+                 * in the process of closing down.  There's more information here:
+                 *
+                 * https://bugs.launchpad.net/ubuntu/+source/linux/+bug/554172/comments/245
+                 *
+                 * Work around it here.
+                 */
+                if (errno == EIO)
+                        return PLY_TERMINAL_OPEN_RESULT_INCOMPLETE;
+
+                terminal->number_of_reopen_tries = 0;
+                return PLY_TERMINAL_OPEN_RESULT_FAILURE;
+        }
+
+        terminal->fd_watch = ply_event_loop_watch_fd (terminal->loop, terminal->fd,
+                                                      PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                                      (ply_event_handler_t) on_tty_input,
+                                                      (ply_event_handler_t) on_tty_disconnected,
+                                                      terminal);
+
+        ply_terminal_check_for_vt (terminal);
+
+        if (!ply_terminal_set_unbuffered_input (terminal))
+                ply_trace ("terminal '%s' will be line buffered", terminal->name);
+
+        terminal->number_of_reopen_tries = 0;
+        return PLY_TERMINAL_OPEN_RESULT_SUCCESS;
 }
 
 bool
 ply_terminal_open (ply_terminal_t *terminal)
 {
-  ply_terminal_open_result_t open_result;
+        ply_terminal_open_result_t open_result;
 
-  assert (terminal != NULL);
+        assert (terminal != NULL);
 
-  if (terminal->is_open)
-    {
-      ply_trace ("terminal %s is already open", terminal->name);
-      return true;
-    }
+        if (terminal->is_open) {
+                ply_trace ("terminal %s is already open", terminal->name);
+                return true;
+        }
 
-  ply_trace ("trying to open terminal '%s'", terminal->name);
+        ply_trace ("trying to open terminal '%s'", terminal->name);
 
-  open_result = ply_terminal_open_device (terminal);
-  if (open_result != PLY_TERMINAL_OPEN_RESULT_SUCCESS)
-    {
-      ply_trace ("could not open %s : %m", terminal->name);
-      return false;
-    }
+        open_result = ply_terminal_open_device (terminal);
+        if (open_result != PLY_TERMINAL_OPEN_RESULT_SUCCESS) {
+                ply_trace ("could not open %s : %m", terminal->name);
+                return false;
+        }
 
-  ply_terminal_look_up_geometry (terminal);
+        ply_terminal_look_up_geometry (terminal);
 
-  ply_terminal_look_up_color_palette (terminal);
-  ply_terminal_save_color_palette (terminal);
+        ply_terminal_look_up_color_palette (terminal);
+        ply_terminal_save_color_palette (terminal);
 
-  ply_event_loop_watch_signal (terminal->loop,
-                               SIGWINCH,
-                               (ply_event_handler_t)
-                               ply_terminal_look_up_geometry,
-                               terminal);
+        ply_event_loop_watch_signal (terminal->loop,
+                                     SIGWINCH,
+                                     (ply_event_handler_t)
+                                     ply_terminal_look_up_geometry,
+                                     terminal);
 
-  if (ply_terminal_is_vt (terminal))
-    {
-      ply_terminal_watch_for_vt_changes (terminal);
+        if (ply_terminal_is_vt (terminal)) {
+                ply_terminal_watch_for_vt_changes (terminal);
 
-      if (get_active_vt (terminal) == terminal->vt_number)
-        terminal->is_active = true;
-      else
-        terminal->is_active = false;
-    }
+                if (get_active_vt (terminal) == terminal->vt_number)
+                        terminal->is_active = true;
+                else
+                        terminal->is_active = false;
+        }
 
-  terminal->is_open = true;
+        terminal->is_open = true;
 
-  return true;
+        return true;
 }
 
 int
 ply_terminal_get_fd (ply_terminal_t *terminal)
 {
-  return terminal->fd;
+        return terminal->fd;
 }
 
 bool
 ply_terminal_is_vt (ply_terminal_t *terminal)
 {
-  return terminal->vt_number > 0;
+        return terminal->vt_number > 0;
 }
 
 bool
 ply_terminal_is_open (ply_terminal_t *terminal)
 {
-  return terminal->is_open;
+        return terminal->is_open;
 }
 
 bool
 ply_terminal_is_active (ply_terminal_t *terminal)
 {
-  return terminal->is_active;
+        return terminal->is_active;
 }
 
 void
 ply_terminal_close (ply_terminal_t *terminal)
 {
-  if (!terminal->is_open)
-    {
-      ply_trace ("terminal %s is already closed", terminal->name);
-      return;
-    }
+        if (!terminal->is_open) {
+                ply_trace ("terminal %s is already closed", terminal->name);
+                return;
+        }
 
-  terminal->is_open = false;
+        terminal->is_open = false;
 
-  ply_terminal_stop_watching_for_vt_changes (terminal);
+        ply_terminal_stop_watching_for_vt_changes (terminal);
 
-  ply_trace ("restoring color palette");
-  ply_terminal_restore_color_palette (terminal);
+        ply_trace ("restoring color palette");
+        ply_terminal_restore_color_palette (terminal);
 
-  if (terminal->fd_watch != NULL)
-    {
-      ply_trace ("stop watching tty fd");
-      ply_event_loop_stop_watching_fd (terminal->loop, terminal->fd_watch);
-      terminal->fd_watch = NULL;
-    }
+        if (terminal->fd_watch != NULL) {
+                ply_trace ("stop watching tty fd");
+                ply_event_loop_stop_watching_fd (terminal->loop, terminal->fd_watch);
+                terminal->fd_watch = NULL;
+        }
 
-  if (terminal->loop != NULL)
-    {
-      ply_trace ("stop watching SIGWINCH signal");
-      ply_event_loop_stop_watching_signal (terminal->loop, SIGWINCH);
-    }
+        if (terminal->loop != NULL) {
+                ply_trace ("stop watching SIGWINCH signal");
+                ply_event_loop_stop_watching_signal (terminal->loop, SIGWINCH);
+        }
 
-  ply_trace ("setting buffered input");
-  ply_terminal_set_buffered_input (terminal);
+        ply_trace ("setting buffered input");
+        ply_terminal_set_buffered_input (terminal);
 
-  close (terminal->fd);
-  terminal->fd = -1;
+        close (terminal->fd);
+        terminal->fd = -1;
 }
 
 int
 ply_terminal_get_number_of_columns (ply_terminal_t *terminal)
 {
-  return terminal->number_of_columns;
+        return terminal->number_of_columns;
 }
 
 int
 ply_terminal_get_number_of_rows (ply_terminal_t *terminal)
 {
-  return terminal->number_of_rows;
+        return terminal->number_of_rows;
 }
 
 uint32_t
-ply_terminal_get_color_hex_value (ply_terminal_t       *terminal,
-                                  ply_terminal_color_t  color)
+ply_terminal_get_color_hex_value (ply_terminal_t      *terminal,
+                                  ply_terminal_color_t color)
 {
-  uint8_t red, green, blue;
+        uint8_t red, green, blue;
 
-  assert (terminal != NULL);
-  assert (color <= PLY_TERMINAL_COLOR_WHITE);
+        assert (terminal != NULL);
+        assert (color <= PLY_TERMINAL_COLOR_WHITE);
 
-  red   = terminal->color_palette[3*color];
-  green = terminal->color_palette[3*color+1];
-  blue  = terminal->color_palette[3*color+2];
+        red = terminal->color_palette[3 * color];
+        green = terminal->color_palette[3 * color + 1];
+        blue = terminal->color_palette[3 * color + 2];
 
-  return red << 16 | green << 8 | blue;
+        return red << 16 | green << 8 | blue;
 }
 
 void
-ply_terminal_set_color_hex_value (ply_terminal_t       *terminal,
-                                  ply_terminal_color_t  color,
-                                  uint32_t              hex_value)
+ply_terminal_set_color_hex_value (ply_terminal_t      *terminal,
+                                  ply_terminal_color_t color,
+                                  uint32_t             hex_value)
 {
-  assert (terminal != NULL);
-  assert (color <= PLY_TERMINAL_COLOR_WHITE);
+        assert (terminal != NULL);
+        assert (color <= PLY_TERMINAL_COLOR_WHITE);
 
-  terminal->color_palette[3*color]   = (hex_value >> 16) & 0xff;
-  terminal->color_palette[3*color+1] = (hex_value >> 8) & 0xff;
-  terminal->color_palette[3*color+2] = hex_value & 0xff;
+        terminal->color_palette[3 * color] = (hex_value >> 16) & 0xff;
+        terminal->color_palette[3 * color + 1] = (hex_value >> 8) & 0xff;
+        terminal->color_palette[3 * color + 2] = hex_value & 0xff;
 
-  ply_terminal_change_color_palette (terminal);
+        ply_terminal_change_color_palette (terminal);
 }
 
 bool
 ply_terminal_supports_color (ply_terminal_t *terminal)
 {
-  return terminal->supports_text_color;
+        return terminal->supports_text_color;
 }
 
 void
 ply_terminal_set_mode (ply_terminal_t     *terminal,
                        ply_terminal_mode_t mode)
 {
+        assert (terminal != NULL);
+        assert (mode == PLY_TERMINAL_MODE_TEXT || mode == PLY_TERMINAL_MODE_GRAPHICS);
 
-  assert (terminal != NULL);
-  assert (mode == PLY_TERMINAL_MODE_TEXT || mode == PLY_TERMINAL_MODE_GRAPHICS);
-
-  if (!ply_terminal_is_vt (terminal))
-    return;
+        if (!ply_terminal_is_vt (terminal))
+                return;
 
-  if (terminal->should_ignore_mode_changes)
-    return;
+        if (terminal->should_ignore_mode_changes)
+                return;
 
-  switch (mode)
-    {
-      case PLY_TERMINAL_MODE_TEXT:
-        if (ioctl (terminal->fd, KDSETMODE, KD_TEXT) < 0)
-          return;
-        break;
+        switch (mode) {
+        case PLY_TERMINAL_MODE_TEXT:
+                if (ioctl (terminal->fd, KDSETMODE, KD_TEXT) < 0)
+                        return;
+                break;
 
-      case PLY_TERMINAL_MODE_GRAPHICS:
-        if (ioctl (terminal->fd, KDSETMODE, KD_GRAPHICS) < 0)
-          return;
-        break;
-    }
+        case PLY_TERMINAL_MODE_GRAPHICS:
+                if (ioctl (terminal->fd, KDSETMODE, KD_GRAPHICS) < 0)
+                        return;
+                break;
+        }
 }
 
 void
 ply_terminal_ignore_mode_changes (ply_terminal_t *terminal,
                                   bool            should_ignore)
 {
-  if (!ply_terminal_is_vt (terminal))
-    return;
+        if (!ply_terminal_is_vt (terminal))
+                return;
 
-  terminal->should_ignore_mode_changes = should_ignore;
+        terminal->should_ignore_mode_changes = should_ignore;
 }
 
 static void
 ply_terminal_detach_from_event_loop (ply_terminal_t *terminal)
 {
-  assert (terminal != NULL);
-  terminal->loop = NULL;
-  terminal->fd_watch = NULL;
+        assert (terminal != NULL);
+        terminal->loop = NULL;
+        terminal->fd_watch = NULL;
 }
 
 static void
 free_vt_change_closures (ply_terminal_t *terminal)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (terminal->vt_change_closures);
-  while (node != NULL)
-    {
-      ply_terminal_active_vt_changed_closure_t *closure;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (terminal->vt_change_closures);
+        while (node != NULL) {
+                ply_terminal_active_vt_changed_closure_t *closure;
+                ply_list_node_t *next_node;
 
-      closure = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (terminal->vt_change_closures, node);
+                closure = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (terminal->vt_change_closures, node);
 
-      free (closure);
-      node = next_node;
-    }
-  ply_list_free (terminal->vt_change_closures);
+                free (closure);
+                node = next_node;
+        }
+        ply_list_free (terminal->vt_change_closures);
 }
 
 static void
 free_input_closures (ply_terminal_t *terminal)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (terminal->input_closures);
-  while (node != NULL)
-    {
-      ply_terminal_input_closure_t *closure;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (terminal->input_closures);
+        while (node != NULL) {
+                ply_terminal_input_closure_t *closure;
+                ply_list_node_t *next_node;
 
-      closure = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (terminal->input_closures, node);
+                closure = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (terminal->input_closures, node);
 
-      free (closure);
-      node = next_node;
-    }
-  ply_list_free (terminal->input_closures);
+                free (closure);
+                node = next_node;
+        }
+        ply_list_free (terminal->input_closures);
 }
 
 void
 ply_terminal_free (ply_terminal_t *terminal)
 {
-  if (terminal == NULL)
-    return;
-
-  if (terminal->loop != NULL)
-    {
-      ply_event_loop_stop_watching_for_exit (terminal->loop,
-                                             (ply_event_loop_exit_handler_t)
-                                             ply_terminal_detach_from_event_loop,
-                                             terminal);
-
-      if (terminal->number_of_reopen_tries > 0)
-        {
-          ply_event_loop_stop_watching_for_timeout (terminal->loop,
-                                                    (ply_event_loop_timeout_handler_t)
-                                                    ply_terminal_reopen_device, terminal);
+        if (terminal == NULL)
+                return;
+
+        if (terminal->loop != NULL) {
+                ply_event_loop_stop_watching_for_exit (terminal->loop,
+                                                       (ply_event_loop_exit_handler_t)
+                                                       ply_terminal_detach_from_event_loop,
+                                                       terminal);
+
+                if (terminal->number_of_reopen_tries > 0) {
+                        ply_event_loop_stop_watching_for_timeout (terminal->loop,
+                                                                  (ply_event_loop_timeout_handler_t)
+                                                                  ply_terminal_reopen_device, terminal);
+                }
         }
-    }
 
-  if (terminal->is_open)
-    ply_terminal_close (terminal);
+        if (terminal->is_open)
+                ply_terminal_close (terminal);
 
-  free_vt_change_closures (terminal);
-  free_input_closures (terminal);
-  free (terminal->name);
-  free (terminal);
+        free_vt_change_closures (terminal);
+        free_input_closures (terminal);
+        free (terminal->name);
+        free (terminal);
 }
 
 const char *
 ply_terminal_get_name (ply_terminal_t *terminal)
 {
-  return terminal->name;
+        return terminal->name;
 }
 
 int
 ply_terminal_get_vt_number (ply_terminal_t *terminal)
 {
-  return terminal->vt_number;
+        return terminal->vt_number;
 }
 
 static bool
 set_active_vt (ply_terminal_t *terminal,
                int             vt_number)
 {
-  if (ioctl (terminal->fd, VT_ACTIVATE, vt_number) < 0)
-    return false;
+        if (ioctl (terminal->fd, VT_ACTIVATE, vt_number) < 0)
+                return false;
 
-  return true;
+        return true;
 }
 
 static bool
 wait_for_vt_to_become_active (ply_terminal_t *terminal,
                               int             vt_number)
 {
-  if (ioctl (terminal->fd, VT_WAITACTIVE, vt_number) < 0)
-    return false;
+        if (ioctl (terminal->fd, VT_WAITACTIVE, vt_number) < 0)
+                return false;
 
-  return true;
+        return true;
 }
 
 static bool
 deallocate_vt (ply_terminal_t *terminal,
                int             vt_number)
 {
-  if (ioctl (terminal->fd, VT_DISALLOCATE, vt_number) < 0)
-    return false;
+        if (ioctl (terminal->fd, VT_DISALLOCATE, vt_number) < 0)
+                return false;
 
-  return true;
+        return true;
 }
 
 bool
 ply_terminal_activate_vt (ply_terminal_t *terminal)
 {
-  assert (terminal != NULL);
+        assert (terminal != NULL);
 
-  if (!ply_terminal_is_vt (terminal))
-    return false;
+        if (!ply_terminal_is_vt (terminal))
+                return false;
 
-  if (terminal->is_active)
-    return true;
+        if (terminal->is_active)
+                return true;
 
-  if (!set_active_vt (terminal, terminal->vt_number))
-    {
-      ply_trace ("unable to set active vt to %d: %m",
-                 terminal->vt_number);
-      return false;
-    }
+        if (!set_active_vt (terminal, terminal->vt_number)) {
+                ply_trace ("unable to set active vt to %d: %m",
+                           terminal->vt_number);
+                return false;
+        }
 
-  return true;
+        return true;
 }
 
 bool
 ply_terminal_deactivate_vt (ply_terminal_t *terminal)
 {
-  int old_vt_number;
-
-  assert (terminal != NULL);
-
-  if (!ply_terminal_is_vt (terminal))
-    {
-      ply_trace ("terminal is not for a VT");
-      return false;
-    }
-
-  if (terminal->initial_vt_number < 0)
-    {
-      ply_trace ("Don't know where to jump to");
-      return false;
-    }
-
-  if (terminal->initial_vt_number == terminal->vt_number)
-    {
-      ply_trace ("can't deactivate initial VT");
-      return false;
-    }
-
-  /* Otherwise we'd close and free the terminal before handling the
-   * "leaving the VT" signal.
-   */
-  ply_terminal_stop_watching_for_vt_changes (terminal);
-
-  old_vt_number = terminal->vt_number;
-
-  if (ply_terminal_is_active (terminal))
-    {
-      ply_trace ("Attempting to set active vt back to %d from %d",
-                 terminal->initial_vt_number, old_vt_number);
-      if (!set_active_vt (terminal, terminal->initial_vt_number))
-        {
-          ply_trace ("Couldn't move console to initial vt: %m");
-          return false;
+        int old_vt_number;
+
+        assert (terminal != NULL);
+
+        if (!ply_terminal_is_vt (terminal)) {
+                ply_trace ("terminal is not for a VT");
+                return false;
+        }
+
+        if (terminal->initial_vt_number < 0) {
+                ply_trace ("Don't know where to jump to");
+                return false;
+        }
+
+        if (terminal->initial_vt_number == terminal->vt_number) {
+                ply_trace ("can't deactivate initial VT");
+                return false;
+        }
+
+        /* Otherwise we'd close and free the terminal before handling the
+         * "leaving the VT" signal.
+         */
+        ply_terminal_stop_watching_for_vt_changes (terminal);
+
+        old_vt_number = terminal->vt_number;
+
+        if (ply_terminal_is_active (terminal)) {
+                ply_trace ("Attempting to set active vt back to %d from %d",
+                           terminal->initial_vt_number, old_vt_number);
+                if (!set_active_vt (terminal, terminal->initial_vt_number)) {
+                        ply_trace ("Couldn't move console to initial vt: %m");
+                        return false;
+                }
+
+                if (!wait_for_vt_to_become_active (terminal, terminal->initial_vt_number)) {
+                        ply_trace ("Error while waiting for vt %d to become active: %m",
+                                   terminal->initial_vt_number);
+                        return false;
+                }
+        } else {
+                ply_trace ("terminal for vt %d is inactive", terminal->vt_number);
         }
 
-      if (!wait_for_vt_to_become_active (terminal, terminal->initial_vt_number))
-        {
-          ply_trace ("Error while waiting for vt %d to become active: %m",
-                     terminal->initial_vt_number);
-          return false;
+        if (!deallocate_vt (terminal, old_vt_number)) {
+                ply_trace ("couldn't deallocate vt %d: %m", old_vt_number);
+                return false;
         }
-    }
-  else
-    {
-      ply_trace ("terminal for vt %d is inactive", terminal->vt_number);
-    }
-
-  if (!deallocate_vt (terminal, old_vt_number))
-    {
-      ply_trace ("couldn't deallocate vt %d: %m", old_vt_number);
-      return false;
-    }
-
-  return true;
+
+        return true;
 }
 
 void
-ply_terminal_watch_for_active_vt_change (ply_terminal_t *terminal,
+ply_terminal_watch_for_active_vt_change (ply_terminal_t                          *terminal,
                                          ply_terminal_active_vt_changed_handler_t active_vt_changed_handler,
-                                         void *user_data)
+                                         void                                    *user_data)
 {
-  ply_terminal_active_vt_changed_closure_t *closure;
+        ply_terminal_active_vt_changed_closure_t *closure;
 
-  if (!ply_terminal_is_vt (terminal))
-    return;
+        if (!ply_terminal_is_vt (terminal))
+                return;
 
-  closure = calloc (1, sizeof (*closure));
-  closure->handler = active_vt_changed_handler;
-  closure->user_data = user_data;
+        closure = calloc (1, sizeof(*closure));
+        closure->handler = active_vt_changed_handler;
+        closure->user_data = user_data;
 
-  ply_list_append_data (terminal->vt_change_closures, closure);
+        ply_list_append_data (terminal->vt_change_closures, closure);
 }
 
 void
-ply_terminal_stop_watching_for_active_vt_change (ply_terminal_t *terminal,
+ply_terminal_stop_watching_for_active_vt_change (ply_terminal_t                          *terminal,
                                                  ply_terminal_active_vt_changed_handler_t active_vt_changed_handler,
-                                                 void *user_data)
+                                                 void                                    *user_data)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (!ply_terminal_is_vt (terminal))
-    return;
+        if (!ply_terminal_is_vt (terminal))
+                return;
 
-  node = ply_list_get_first_node (terminal->vt_change_closures);
-  while (node != NULL)
-    {
-      ply_terminal_active_vt_changed_closure_t *closure;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (terminal->vt_change_closures);
+        while (node != NULL) {
+                ply_terminal_active_vt_changed_closure_t *closure;
+                ply_list_node_t *next_node;
 
-      closure = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (terminal->vt_change_closures, node);
+                closure = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (terminal->vt_change_closures, node);
 
-      if (closure->handler == active_vt_changed_handler &&
-          closure->user_data == user_data)
-        {
-          free (closure);
-          ply_list_remove_node (terminal->vt_change_closures, node);
-        }
+                if (closure->handler == active_vt_changed_handler &&
+                    closure->user_data == user_data) {
+                        free (closure);
+                        ply_list_remove_node (terminal->vt_change_closures, node);
+                }
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 void
-ply_terminal_watch_for_input (ply_terminal_t               *terminal,
-                              ply_terminal_input_handler_t  input_handler,
-                              void                         *user_data)
+ply_terminal_watch_for_input (ply_terminal_t              *terminal,
+                              ply_terminal_input_handler_t input_handler,
+                              void                        *user_data)
 {
-  ply_terminal_input_closure_t *closure;
+        ply_terminal_input_closure_t *closure;
 
-  closure = calloc (1, sizeof (*closure));
-  closure->handler = input_handler;
-  closure->user_data = user_data;
+        closure = calloc (1, sizeof(*closure));
+        closure->handler = input_handler;
+        closure->user_data = user_data;
 
-  ply_list_append_data (terminal->input_closures, closure);
+        ply_list_append_data (terminal->input_closures, closure);
 }
 
 void
-ply_terminal_stop_watching_for_input (ply_terminal_t               *terminal,
-                                      ply_terminal_input_handler_t  input_handler,
-                                      void                         *user_data)
+ply_terminal_stop_watching_for_input (ply_terminal_t              *terminal,
+                                      ply_terminal_input_handler_t input_handler,
+                                      void                        *user_data)
 {
-  ply_list_node_t *node;
-
-  node = ply_list_get_first_node (terminal->input_closures);
-  while (node != NULL)
-    {
-      ply_terminal_input_closure_t *closure;
-      ply_list_node_t *next_node;
-
-      closure = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (terminal->input_closures, node);
-
-      if (closure->handler == input_handler &&
-          closure->user_data == user_data)
-        {
-          free (closure);
-          ply_list_remove_node (terminal->input_closures, node);
-        }
+        ply_list_node_t *node;
+
+        node = ply_list_get_first_node (terminal->input_closures);
+        while (node != NULL) {
+                ply_terminal_input_closure_t *closure;
+                ply_list_node_t *next_node;
+
+                closure = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (terminal->input_closures, node);
 
-      node = next_node;
-    }
+                if (closure->handler == input_handler &&
+                    closure->user_data == user_data) {
+                        free (closure);
+                        ply_list_remove_node (terminal->input_closures, node);
+                }
+
+                node = next_node;
+        }
 }
 
 /* vim: set ts=4 sw=4 et ai ci cino={.5s,^-2,+.5s,t0,g0,e-2,n-2,p2s,(0,=.5s,:.5s */
diff --git a/src/libply-splash-core/ply-terminal.h b/src/libply-splash-core/ply-terminal.h
index 48b4f77..dc83ec3 100644
--- a/src/libply-splash-core/ply-terminal.h
+++ b/src/libply-splash-core/ply-terminal.h
@@ -31,27 +31,27 @@
 #include "ply-event-loop.h"
 
 typedef struct _ply_terminal ply_terminal_t;
-typedef void (* ply_terminal_active_vt_changed_handler_t) (void           *user_data,
-                                                           ply_terminal_t *terminal);
-typedef void (* ply_terminal_input_handler_t) (void           *user_data,
-                                               ply_terminal_t *terminal);
+typedef void (*ply_terminal_active_vt_changed_handler_t) (void           *user_data,
+                                                          ply_terminal_t *terminal);
+typedef void (*ply_terminal_input_handler_t) (void           *user_data,
+                                              ply_terminal_t *terminal);
 typedef enum
 {
-  PLY_TERMINAL_COLOR_BLACK = 0,
-  PLY_TERMINAL_COLOR_RED,
-  PLY_TERMINAL_COLOR_GREEN,
-  PLY_TERMINAL_COLOR_BROWN,
-  PLY_TERMINAL_COLOR_BLUE,
-  PLY_TERMINAL_COLOR_MAGENTA,
-  PLY_TERMINAL_COLOR_CYAN,
-  PLY_TERMINAL_COLOR_WHITE,
-  PLY_TERMINAL_COLOR_DEFAULT = PLY_TERMINAL_COLOR_WHITE + 2
+        PLY_TERMINAL_COLOR_BLACK = 0,
+        PLY_TERMINAL_COLOR_RED,
+        PLY_TERMINAL_COLOR_GREEN,
+        PLY_TERMINAL_COLOR_BROWN,
+        PLY_TERMINAL_COLOR_BLUE,
+        PLY_TERMINAL_COLOR_MAGENTA,
+        PLY_TERMINAL_COLOR_CYAN,
+        PLY_TERMINAL_COLOR_WHITE,
+        PLY_TERMINAL_COLOR_DEFAULT = PLY_TERMINAL_COLOR_WHITE + 2
 } ply_terminal_color_t;
 
 typedef enum
 {
-  PLY_TERMINAL_MODE_TEXT,
-  PLY_TERMINAL_MODE_GRAPHICS
+        PLY_TERMINAL_MODE_TEXT,
+        PLY_TERMINAL_MODE_GRAPHICS
 } ply_terminal_mode_t;
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
@@ -78,12 +78,12 @@ int ply_terminal_get_number_of_columns (ply_terminal_t *terminal);
 int ply_terminal_get_number_of_rows (ply_terminal_t *terminal);
 
 bool ply_terminal_supports_color (ply_terminal_t *terminal);
-uint32_t ply_terminal_get_color_hex_value (ply_terminal_t       *terminal,
-                                           ply_terminal_color_t  color);
+uint32_t ply_terminal_get_color_hex_value (ply_terminal_t      *terminal,
+                                           ply_terminal_color_t color);
 
-void ply_terminal_set_color_hex_value (ply_terminal_t       *terminal,
-                                       ply_terminal_color_t  color,
-                                       uint32_t              hex_value);
+void ply_terminal_set_color_hex_value (ply_terminal_t      *terminal,
+                                       ply_terminal_color_t color,
+                                       uint32_t             hex_value);
 
 void ply_terminal_set_mode (ply_terminal_t     *terminal,
                             ply_terminal_mode_t mode);
@@ -99,19 +99,19 @@ bool ply_terminal_deactivate_vt (ply_terminal_t *terminal);
 void ply_terminal_watch_for_vt_changes (ply_terminal_t *terminal);
 void ply_terminal_stop_watching_for_vt_changes (ply_terminal_t *terminal);
 
-void ply_terminal_watch_for_active_vt_change (ply_terminal_t *terminal,
+void ply_terminal_watch_for_active_vt_change (ply_terminal_t                          *terminal,
                                               ply_terminal_active_vt_changed_handler_t active_vt_changed_handler,
-                                              void *user_data);
-void ply_terminal_stop_watching_for_active_vt_change (ply_terminal_t *terminal,
+                                              void                                    *user_data);
+void ply_terminal_stop_watching_for_active_vt_change (ply_terminal_t                          *terminal,
                                                       ply_terminal_active_vt_changed_handler_t active_vt_changed_handler,
-                                                      void *user_data);
+                                                      void                                    *user_data);
 
-void ply_terminal_watch_for_input (ply_terminal_t *terminal,
+void ply_terminal_watch_for_input (ply_terminal_t              *terminal,
                                    ply_terminal_input_handler_t input_handler,
-                                   void *user_data);
-void ply_terminal_stop_watching_for_input (ply_terminal_t *terminal,
+                                   void                        *user_data);
+void ply_terminal_stop_watching_for_input (ply_terminal_t              *terminal,
                                            ply_terminal_input_handler_t input_handler,
-                                           void *user_data);
+                                           void                        *user_data);
 
 #endif
 
diff --git a/src/libply-splash-core/ply-text-display.c b/src/libply-splash-core/ply-text-display.c
index 7cabd98..83bf602 100644
--- a/src/libply-splash-core/ply-text-display.c
+++ b/src/libply-splash-core/ply-text-display.c
@@ -92,40 +92,40 @@
 
 struct _ply_text_display
 {
-  ply_event_loop_t *loop;
+        ply_event_loop_t               *loop;
 
-  ply_terminal_t *terminal;
+        ply_terminal_t                 *terminal;
 
-  ply_terminal_color_t foreground_color;
-  ply_terminal_color_t background_color;
+        ply_terminal_color_t            foreground_color;
+        ply_terminal_color_t            background_color;
 
-  ply_text_display_draw_handler_t draw_handler;
-  void *draw_handler_user_data;
+        ply_text_display_draw_handler_t draw_handler;
+        void                           *draw_handler_user_data;
 };
 
 ply_text_display_t *
 ply_text_display_new (ply_terminal_t *terminal)
 {
-  ply_text_display_t *display;
+        ply_text_display_t *display;
 
-  display = calloc (1, sizeof (ply_text_display_t));
+        display = calloc (1, sizeof(ply_text_display_t));
 
-  display->loop = NULL;
-  display->terminal = terminal;
+        display->loop = NULL;
+        display->terminal = terminal;
 
-  return display;
+        return display;
 }
 
 int
 ply_text_display_get_number_of_columns (ply_text_display_t *display)
 {
-  return ply_terminal_get_number_of_columns (display->terminal);
+        return ply_terminal_get_number_of_columns (display->terminal);
 }
 
 int
 ply_text_display_get_number_of_rows (ply_text_display_t *display)
 {
-  return ply_terminal_get_number_of_rows (display->terminal);
+        return ply_terminal_get_number_of_rows (display->terminal);
 }
 
 void
@@ -133,80 +133,78 @@ ply_text_display_set_cursor_position (ply_text_display_t *display,
                                       int                 column,
                                       int                 row)
 {
-  int number_of_columns;
-  int number_of_rows;
+        int number_of_columns;
+        int number_of_rows;
 
-  number_of_columns = ply_text_display_get_number_of_columns (display);
-  number_of_rows = ply_text_display_get_number_of_rows (display);
+        number_of_columns = ply_text_display_get_number_of_columns (display);
+        number_of_rows = ply_text_display_get_number_of_rows (display);
 
-  column = CLAMP (column, 0, number_of_columns - 1);
-  row = CLAMP (row, 0, number_of_rows - 1);
+        column = CLAMP (column, 0, number_of_columns - 1);
+        row = CLAMP (row, 0, number_of_rows - 1);
 
-  ply_terminal_write (display->terminal,
-                      MOVE_CURSOR_SEQUENCE,
-                      row, column);
+        ply_terminal_write (display->terminal,
+                            MOVE_CURSOR_SEQUENCE,
+                            row, column);
 }
 
 void
 ply_text_display_clear_screen (ply_text_display_t *display)
 {
-  if (ply_is_tracing ())
-    return;
+        if (ply_is_tracing ())
+                return;
 
-  ply_terminal_write (display->terminal,
-                      CLEAR_SCREEN_SEQUENCE);
+        ply_terminal_write (display->terminal,
+                            CLEAR_SCREEN_SEQUENCE);
 
-  ply_text_display_set_cursor_position (display, 0, 0);
+        ply_text_display_set_cursor_position (display, 0, 0);
 }
 
 void
 ply_text_display_clear_line (ply_text_display_t *display)
 {
-
-  ply_terminal_write (display->terminal,
-                      CLEAR_LINE_SEQUENCE);
+        ply_terminal_write (display->terminal,
+                            CLEAR_LINE_SEQUENCE);
 }
 
 void
 ply_text_display_remove_character (ply_text_display_t *display)
 {
-  ply_terminal_write (display->terminal,
-                      BACKSPACE);
+        ply_terminal_write (display->terminal,
+                            BACKSPACE);
 }
 
 void
-ply_text_display_set_background_color (ply_text_display_t   *display,
-                                       ply_terminal_color_t  color)
+ply_text_display_set_background_color (ply_text_display_t  *display,
+                                       ply_terminal_color_t color)
 {
+        ply_terminal_write (display->terminal,
+                            COLOR_SEQUENCE_FORMAT,
+                            BACKGROUND_COLOR_BASE + color);
 
-  ply_terminal_write (display->terminal,
-                      COLOR_SEQUENCE_FORMAT,
-                      BACKGROUND_COLOR_BASE + color);
-
-  display->background_color = color;
+        display->background_color = color;
 }
 
 void
-ply_text_display_set_foreground_color (ply_text_display_t       *display,
-                                       ply_terminal_color_t  color)
+ply_text_display_set_foreground_color (ply_text_display_t  *display,
+                                       ply_terminal_color_t color)
 {
-  ply_terminal_write (display->terminal,
-                      COLOR_SEQUENCE_FORMAT,
-                      FOREGROUND_COLOR_BASE + color);
+        ply_terminal_write (display->terminal,
+                            COLOR_SEQUENCE_FORMAT,
+                            FOREGROUND_COLOR_BASE + color);
 
-  display->foreground_color = color;
+        display->foreground_color = color;
 }
 
 ply_terminal_color_t
 ply_text_display_get_background_color (ply_text_display_t *display)
 {
-  return display->background_color;
+        return display->background_color;
 }
 
 ply_terminal_color_t
 ply_text_display_get_foreground_color (ply_text_display_t *display)
 {
-  return display->foreground_color;
+        return display->foreground_color;
 }
 
 void
@@ -216,17 +214,17 @@ ply_text_display_draw_area (ply_text_display_t *display,
                             int                 width,
                             int                 height)
 {
-  if (display->draw_handler != NULL)
-    display->draw_handler (display->draw_handler_user_data,
-                           display->terminal,
-                           x, y, width, height);
+        if (display->draw_handler != NULL)
+                display->draw_handler (display->draw_handler_user_data,
+                                       display->terminal,
+                                       x, y, width, height);
 }
 
 void
 ply_text_display_hide_cursor (ply_text_display_t *display)
 {
-  ply_terminal_write (display->terminal,
-                      HIDE_CURSOR_SEQUENCE);
+        ply_terminal_write (display->terminal,
+                            HIDE_CURSOR_SEQUENCE);
 }
 
 void
@@ -234,104 +232,105 @@ ply_text_display_write (ply_text_display_t *display,
                         const char         *format,
                         ...)
 {
-  int fd;
+        int fd;
 
-  va_list args;
-  char *string;
+        va_list args;
+        char *string;
 
-  assert (display != NULL);
-  assert (format != NULL);
+        assert (display != NULL);
+        assert (format != NULL);
 
-  fd = ply_terminal_get_fd (display->terminal);
+        fd = ply_terminal_get_fd (display->terminal);
 
-  string = NULL;
-  va_start (args, format);
-  vasprintf (&string, format, args);
-  va_end (args);
+        string = NULL;
+        va_start (args, format);
+        vasprintf (&string, format, args);
+        va_end (args);
 
-  write (fd, string, strlen (string));
-  free (string);
+        write (fd, string, strlen (string));
+        free (string);
 }
 
 void
 ply_text_display_show_cursor (ply_text_display_t *display)
 {
-  ply_terminal_write (display->terminal,
-                      SHOW_CURSOR_SEQUENCE);
+        ply_terminal_write (display->terminal,
+                            SHOW_CURSOR_SEQUENCE);
 }
 
 bool
 ply_text_display_supports_color (ply_text_display_t *display)
 {
-  return ply_terminal_supports_color (display->terminal);
+        return ply_terminal_supports_color (display->terminal);
 }
 
 static void
 ply_text_display_detach_from_event_loop (ply_text_display_t *display)
 {
-  assert (display != NULL);
-  display->loop = NULL;
+        assert (display != NULL);
+        display->loop = NULL;
 }
 
 void
 ply_text_display_free (ply_text_display_t *display)
 {
-  if (display == NULL)
-    return;
+        if (display == NULL)
+                return;
 
-  if (display->loop != NULL)
-    ply_event_loop_stop_watching_for_exit (display->loop,
-                                           (ply_event_loop_exit_handler_t)
-                                           ply_text_display_detach_from_event_loop,
-                                           display);
+        if (display->loop != NULL) {
+                ply_event_loop_stop_watching_for_exit (display->loop,
+                                                       (ply_event_loop_exit_handler_t)
+                                                       ply_text_display_detach_from_event_loop,
+                                                       display);
+        }
 
-  free (display);
+        free (display);
 }
 
 void
-ply_text_display_set_draw_handler (ply_text_display_t *display,
+ply_text_display_set_draw_handler (ply_text_display_t             *display,
                                    ply_text_display_draw_handler_t draw_handler,
-                                   void               *user_data)
+                                   void                           *user_data)
 {
-  assert (display != NULL);
+        assert (display != NULL);
 
-  display->draw_handler = draw_handler;
-  display->draw_handler_user_data = user_data;
+        display->draw_handler = draw_handler;
+        display->draw_handler_user_data = user_data;
 }
 
 void
 ply_text_display_pause_updates (ply_text_display_t *display)
 {
-  ply_terminal_write (display->terminal,
-                      PAUSE_SEQUENCE);
+        ply_terminal_write (display->terminal,
+                            PAUSE_SEQUENCE);
 }
 
 void
 ply_text_display_unpause_updates (ply_text_display_t *display)
 {
-  ply_terminal_write (display->terminal,
-                      UNPAUSE_SEQUENCE);
+        ply_terminal_write (display->terminal,
+                            UNPAUSE_SEQUENCE);
 }
 
 void
 ply_text_display_attach_to_event_loop (ply_text_display_t *display,
                                        ply_event_loop_t   *loop)
 {
-  assert (display != NULL);
-  assert (loop != NULL);
-  assert (display->loop == NULL);
+        assert (display != NULL);
+        assert (loop != NULL);
+        assert (display->loop == NULL);
 
-  display->loop = loop;
+        display->loop = loop;
 
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
-                                 ply_text_display_detach_from_event_loop,
-                                 display);
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       ply_text_display_detach_from_event_loop,
+                                       display);
 }
 
 ply_terminal_t *
 ply_text_display_get_terminal (ply_text_display_t *display)
 {
-  return display->terminal;
+        return display->terminal;
 }
 
 /* vim: set ts= 4 sw= 4 et ai ci cino= {.5s,^-2,+.5s,t0,g0,e-2,n-2,p2s,(0,=.5s,:.5s */
diff --git a/src/libply-splash-core/ply-text-display.h b/src/libply-splash-core/ply-text-display.h
index 3fd7dab..4a56aba 100644
--- a/src/libply-splash-core/ply-text-display.h
+++ b/src/libply-splash-core/ply-text-display.h
@@ -32,12 +32,12 @@
 
 typedef struct _ply_text_display ply_text_display_t;
 
-typedef void (* ply_text_display_draw_handler_t) (void *user_data,
-                                                  ply_terminal_t *terminal,
-                                                  int   column,
-                                                  int   row,
-                                                  int   number_of_columns,
-                                                  int   number_of_rows);
+typedef void (*ply_text_display_draw_handler_t) (void           *user_data,
+                                                 ply_terminal_t *terminal,
+                                                 int             column,
+                                                 int             row,
+                                                 int             number_of_columns,
+                                                 int             number_of_rows);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_text_display_t *ply_text_display_new (ply_terminal_t *terminal);
@@ -64,22 +64,22 @@ void ply_text_display_clear_screen (ply_text_display_t *display);
 void ply_text_display_clear_line (ply_text_display_t *display);
 void ply_text_display_remove_character (ply_text_display_t *display);
 bool ply_text_display_supports_color (ply_text_display_t *display);
-void ply_text_display_set_background_color (ply_text_display_t       *display,
-                                            ply_terminal_color_t  color);
-void ply_text_display_set_foreground_color (ply_text_display_t       *display,
-                                            ply_terminal_color_t  color);
+void ply_text_display_set_background_color (ply_text_display_t  *display,
+                                            ply_terminal_color_t color);
+void ply_text_display_set_foreground_color (ply_text_display_t  *display,
+                                            ply_terminal_color_t color);
 ply_terminal_color_t ply_text_display_get_background_color (ply_text_display_t *display);
 ply_terminal_color_t ply_text_display_get_foreground_color (ply_text_display_t *display);
 
 void ply_text_display_draw_area (ply_text_display_t *display,
-                                 int           column,
-                                 int           row,
-                                 int           number_of_columns,
-                                 int           number_of_rows);
+                                 int                 column,
+                                 int                 row,
+                                 int                 number_of_columns,
+                                 int                 number_of_rows);
 
-void ply_text_display_set_draw_handler (ply_text_display_t                *display,
-                                        ply_text_display_draw_handler_t    draw_handler,
-                                        void                        *user_data);
+void ply_text_display_set_draw_handler (ply_text_display_t             *display,
+                                        ply_text_display_draw_handler_t draw_handler,
+                                        void                           *user_data);
 void ply_text_display_pause_updates (ply_text_display_t *display);
 void ply_text_display_unpause_updates (ply_text_display_t *display);
 
diff --git a/src/libply-splash-core/ply-text-progress-bar.c b/src/libply-splash-core/ply-text-progress-bar.c
index 8c4e759..dc27513 100644
--- a/src/libply-splash-core/ply-text-progress-bar.c
+++ b/src/libply-splash-core/ply-text-progress-bar.c
@@ -61,233 +61,229 @@ static char *os_string;
 
 struct _ply_text_progress_bar
 {
-  ply_text_display_t *display;
+        ply_text_display_t *display;
 
-  int column, row;
-  int number_of_rows;
-  int number_of_columns;
+        int                 column, row;
+        int                 number_of_rows;
+        int                 number_of_columns;
 
-  double percent_done;
-  uint32_t is_hidden : 1;
+        double              percent_done;
+        uint32_t            is_hidden : 1;
 };
 
 ply_text_progress_bar_t *
 ply_text_progress_bar_new (void)
 {
-  ply_text_progress_bar_t *progress_bar;
+        ply_text_progress_bar_t *progress_bar;
 
-  progress_bar = calloc (1, sizeof (ply_text_progress_bar_t));
+        progress_bar = calloc (1, sizeof(ply_text_progress_bar_t));
 
-  progress_bar->row = 0;
-  progress_bar->column = 0;
-  progress_bar->number_of_columns = 0;
-  progress_bar->number_of_rows = 0;
+        progress_bar->row = 0;
+        progress_bar->column = 0;
+        progress_bar->number_of_columns = 0;
+        progress_bar->number_of_rows = 0;
 
-  return progress_bar;
+        return progress_bar;
 }
 
 void
 ply_text_progress_bar_free (ply_text_progress_bar_t *progress_bar)
 {
-  if (progress_bar == NULL)
-    return;
+        if (progress_bar == NULL)
+                return;
 
-  free (progress_bar);
+        free (progress_bar);
 }
 
 static void
 get_os_string (void)
 {
-  int fd;
-  char *buf, *pos, *pos2;
-  struct stat sbuf;
-
-  buf = NULL;
-
-  fd = open (RELEASE_FILE, O_RDONLY|O_CLOEXEC);
-  if (fd == -1)
-    goto out;
-
-  if (fstat (fd, &sbuf) == -1) {
-    close (fd);
-    goto out;
-  }
-
-  buf = calloc (sbuf.st_size + 1, sizeof(char));
-  read (fd, buf, sbuf.st_size);
-  close (fd);
-
-  if (strcmp (RELEASE_FILE, "/etc/os-release") == 0)
-    {
-      char key[] = "PRETTY_NAME=";
-
-      for (pos = strstr (buf, key);
-           pos != NULL;
-           pos = strstr (pos, key))
-        {
-          if (pos == buf || pos[-1] == '\n')
-            break;
+        int fd;
+        char *buf, *pos, *pos2;
+        struct stat sbuf;
+
+        buf = NULL;
+
+        fd = open (RELEASE_FILE, O_RDONLY | O_CLOEXEC);
+        if (fd == -1)
+                goto out;
+
+        if (fstat (fd, &sbuf) == -1) {
+                close (fd);
+                goto out;
         }
 
-      if (pos != NULL)
-        {
-          pos += strlen (key);
-          pos2 = strstr (pos, "\n");
-
-          if (pos2 != NULL)
-            *pos2 = '\0';
-          else
-            pos2 = pos + strlen(pos) - 1;
-
-          if ((*pos == '\"' && pos2[-1] == '\"') ||
-              (*pos == '\'' && pos2[-1] == '\''))
-            {
-              pos++;
-              pos2--;
-
-              *pos2 = '\0';
-            }
-          asprintf (&os_string, " %s", pos);
+        buf = calloc (sbuf.st_size + 1, sizeof(char));
+        read (fd, buf, sbuf.st_size);
+        close (fd);
+
+        if (strcmp (RELEASE_FILE, "/etc/os-release") == 0) {
+                char key[] = "PRETTY_NAME=";
+
+                for (pos = strstr (buf, key);
+                     pos != NULL;
+                     pos = strstr (pos, key)) {
+                        if (pos == buf || pos[-1] == '\n')
+                                break;
+                }
+
+                if (pos != NULL) {
+                        pos += strlen (key);
+                        pos2 = strstr (pos, "\n");
+
+                        if (pos2 != NULL)
+                                *pos2 = '\0';
+                        else
+                                pos2 = pos + strlen (pos) - 1;
+
+                        if ((*pos == '\"' && pos2[-1] == '\"') ||
+                            (*pos == '\'' && pos2[-1] == '\'')) {
+                                pos++;
+                                pos2--;
+
+                                *pos2 = '\0';
+                        }
+                        asprintf (&os_string, " %s", pos);
+                }
+                goto out;
         }
-      goto out;
-    }
 
-  pos = strstr (buf, " release ");
+        pos = strstr (buf, " release ");
 
-  if (pos == NULL)
-    goto out;
+        if (pos == NULL)
+                goto out;
 
-  pos2 = strstr (pos, " (");
+        pos2 = strstr (pos, " (");
 
-  if (pos2 == NULL)
-    goto out;
+        if (pos2 == NULL)
+                goto out;
 
-  *pos = '\0';
-  pos += strlen (" release ");
+        *pos = '\0';
+        pos += strlen (" release ");
 
-  *pos2 = '\0';
-  asprintf (&os_string, " %s %s", buf, pos);
+        *pos2 = '\0';
+        asprintf (&os_string, " %s %s", buf, pos);
 
 out:
-  free (buf);
+        free (buf);
 
-  if (os_string == NULL)
-    os_string = strdup ("");
+        if (os_string == NULL)
+                os_string = strdup ("");
 }
 
 void
 ply_text_progress_bar_draw (ply_text_progress_bar_t *progress_bar)
 {
-    int i, width;
-    double brown_fraction, blue_fraction, white_fraction;
-
-    if (progress_bar->is_hidden)
-      return;
-
-    width = progress_bar->number_of_columns - 2 - strlen (os_string);
-
-    ply_text_display_set_cursor_position (progress_bar->display,
-                                          progress_bar->column,
-                                          progress_bar->row);
-
-    brown_fraction = - (progress_bar->percent_done * progress_bar->percent_done) + 2 * progress_bar->percent_done;
-    blue_fraction  = progress_bar->percent_done;
-    white_fraction = progress_bar->percent_done * progress_bar->percent_done;
-
-    for (i = 0; i < width; i++) {
-        double f;
-
-        f = (double) i / (double) width;
-        if (f < white_fraction)
-            ply_text_display_set_background_color (progress_bar->display,
-                                                   PLY_TERMINAL_COLOR_WHITE);
-        else if (f < blue_fraction)
-            ply_text_display_set_background_color (progress_bar->display,
-                                             PLY_TERMINAL_COLOR_BLUE);
-        else if (f < brown_fraction)
-            ply_text_display_set_background_color (progress_bar->display,
-                                             PLY_TERMINAL_COLOR_BROWN);
-        else
-          break;
-
-        ply_text_display_write (progress_bar->display, "%c", ' ');
-    }
-
-    ply_text_display_set_background_color (progress_bar->display,
-                                           PLY_TERMINAL_COLOR_BLACK);
-
-    if (brown_fraction > 0.5) {
-        if (white_fraction > 0.875)
-            ply_text_display_set_foreground_color (progress_bar->display,
-                                                   PLY_TERMINAL_COLOR_WHITE);
-        else if (blue_fraction > 0.66)
-            ply_text_display_set_foreground_color (progress_bar->display,
-                                                   PLY_TERMINAL_COLOR_BLUE);
-        else
-            ply_text_display_set_foreground_color (progress_bar->display,
-                                                   PLY_TERMINAL_COLOR_BROWN);
+        int i, width;
+        double brown_fraction, blue_fraction, white_fraction;
+
+        if (progress_bar->is_hidden)
+                return;
+
+        width = progress_bar->number_of_columns - 2 - strlen (os_string);
 
         ply_text_display_set_cursor_position (progress_bar->display,
-                                              progress_bar->column + width,
+                                              progress_bar->column,
                                               progress_bar->row);
 
-        ply_text_display_write (progress_bar->display, "%s", os_string);
+        brown_fraction = -(progress_bar->percent_done * progress_bar->percent_done) + 2 * progress_bar->percent_done;
+        blue_fraction = progress_bar->percent_done;
+        white_fraction = progress_bar->percent_done * progress_bar->percent_done;
+
+        for (i = 0; i < width; i++) {
+                double f;
+
+                f = (double) i / (double) width;
+                if (f < white_fraction)
+                        ply_text_display_set_background_color (progress_bar->display,
+                                                               PLY_TERMINAL_COLOR_WHITE);
+                else if (f < blue_fraction)
+                        ply_text_display_set_background_color (progress_bar->display,
+                                                               PLY_TERMINAL_COLOR_BLUE);
+                else if (f < brown_fraction)
+                        ply_text_display_set_background_color (progress_bar->display,
+                                                               PLY_TERMINAL_COLOR_BROWN);
+                else
+                        break;
+
+                ply_text_display_write (progress_bar->display, "%c", ' ');
+        }
 
-        ply_text_display_set_foreground_color (progress_bar->display,
-                                               PLY_TERMINAL_COLOR_DEFAULT);
-    }
+        ply_text_display_set_background_color (progress_bar->display,
+                                               PLY_TERMINAL_COLOR_BLACK);
+
+        if (brown_fraction > 0.5) {
+                if (white_fraction > 0.875)
+                        ply_text_display_set_foreground_color (progress_bar->display,
+                                                               PLY_TERMINAL_COLOR_WHITE);
+                else if (blue_fraction > 0.66)
+                        ply_text_display_set_foreground_color (progress_bar->display,
+                                                               PLY_TERMINAL_COLOR_BLUE);
+                else
+                        ply_text_display_set_foreground_color (progress_bar->display,
+                                                               PLY_TERMINAL_COLOR_BROWN);
+
+                ply_text_display_set_cursor_position (progress_bar->display,
+                                                      progress_bar->column + width,
+                                                      progress_bar->row);
+
+                ply_text_display_write (progress_bar->display, "%s", os_string);
+
+                ply_text_display_set_foreground_color (progress_bar->display,
+                                                       PLY_TERMINAL_COLOR_DEFAULT);
+        }
 }
 
 void
-ply_text_progress_bar_show (ply_text_progress_bar_t  *progress_bar,
-                            ply_text_display_t       *display)
+ply_text_progress_bar_show (ply_text_progress_bar_t *progress_bar,
+                            ply_text_display_t      *display)
 {
-  assert (progress_bar != NULL);
+        assert (progress_bar != NULL);
 
-  progress_bar->display = display;
+        progress_bar->display = display;
 
-  progress_bar->number_of_rows = ply_text_display_get_number_of_rows (display);
-  progress_bar->row = progress_bar->number_of_rows - 1;
-  progress_bar->number_of_columns = ply_text_display_get_number_of_columns (display);
-  progress_bar->column = 2;
+        progress_bar->number_of_rows = ply_text_display_get_number_of_rows (display);
+        progress_bar->row = progress_bar->number_of_rows - 1;
+        progress_bar->number_of_columns = ply_text_display_get_number_of_columns (display);
+        progress_bar->column = 2;
 
-  get_os_string ();
+        get_os_string ();
 
-  progress_bar->is_hidden = false;
+        progress_bar->is_hidden = false;
 
-  ply_text_progress_bar_draw (progress_bar);
+        ply_text_progress_bar_draw (progress_bar);
 }
 
 void
 ply_text_progress_bar_hide (ply_text_progress_bar_t *progress_bar)
 {
-  progress_bar->display = NULL;
-  progress_bar->is_hidden = true;
+        progress_bar->display = NULL;
+        progress_bar->is_hidden = true;
 }
 
 void
-ply_text_progress_bar_set_percent_done (ply_text_progress_bar_t  *progress_bar,
-                                        double percent_done)
+ply_text_progress_bar_set_percent_done (ply_text_progress_bar_t *progress_bar,
+                                        double                   percent_done)
 {
-  progress_bar->percent_done = percent_done;
+        progress_bar->percent_done = percent_done;
 }
 
 double
-ply_text_progress_bar_get_percent_done (ply_text_progress_bar_t  *progress_bar)
+ply_text_progress_bar_get_percent_done (ply_text_progress_bar_t *progress_bar)
 {
-  return progress_bar->percent_done;
+        return progress_bar->percent_done;
 }
 
 int
 ply_text_progress_bar_get_number_of_columns (ply_text_progress_bar_t *progress_bar)
 {
-  return progress_bar->number_of_columns;
+        return progress_bar->number_of_columns;
 }
 
 int
 ply_text_progress_bar_get_number_of_rows (ply_text_progress_bar_t *progress_bar)
 {
-  return progress_bar->number_of_rows;
+        return progress_bar->number_of_rows;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-core/ply-text-progress-bar.h b/src/libply-splash-core/ply-text-progress-bar.h
index ebf0644..10a127d 100644
--- a/src/libply-splash-core/ply-text-progress-bar.h
+++ b/src/libply-splash-core/ply-text-progress-bar.h
@@ -38,14 +38,14 @@ ply_text_progress_bar_t *ply_text_progress_bar_new (void);
 void ply_text_progress_bar_free (ply_text_progress_bar_t *progress_bar);
 
 void ply_text_progress_bar_draw (ply_text_progress_bar_t *progress_bar);
-void ply_text_progress_bar_show (ply_text_progress_bar_t  *progress_bar,
-                                 ply_text_display_t       *display);
+void ply_text_progress_bar_show (ply_text_progress_bar_t *progress_bar,
+                                 ply_text_display_t      *display);
 void ply_text_progress_bar_hide (ply_text_progress_bar_t *progress_bar);
 
-void ply_text_progress_bar_set_percent_done (ply_text_progress_bar_t  *progress_bar,
-                                             double percent_done);
+void ply_text_progress_bar_set_percent_done (ply_text_progress_bar_t *progress_bar,
+                                             double                   percent_done);
 
-double ply_text_progress_bar_get_percent_done (ply_text_progress_bar_t  *progress_bar);
+double ply_text_progress_bar_get_percent_done (ply_text_progress_bar_t *progress_bar);
 
 int ply_text_progress_bar_get_number_of_rows (ply_text_progress_bar_t *progress_bar);
 int ply_text_progress_bar_get_number_of_columns (ply_text_progress_bar_t *progress_bar);
diff --git a/src/libply-splash-core/ply-text-step-bar.c b/src/libply-splash-core/ply-text-step-bar.c
index 7c77dd5..d070e9a 100644
--- a/src/libply-splash-core/ply-text-step-bar.c
+++ b/src/libply-splash-core/ply-text-step-bar.c
@@ -30,135 +30,130 @@
 
 struct _ply_text_step_bar
 {
-  ply_text_display_t *display;
+        ply_text_display_t *display;
 
-  int column;
-  int row;
-  int number_of_rows;
-  int number_of_columns;
+        int                 column;
+        int                 row;
+        int                 number_of_rows;
+        int                 number_of_columns;
 
-  double percent_done;
-  uint32_t is_hidden : 1;
+        double              percent_done;
+        uint32_t            is_hidden : 1;
 };
 
 ply_text_step_bar_t *
 ply_text_step_bar_new (void)
 {
-  ply_text_step_bar_t *step_bar;
+        ply_text_step_bar_t *step_bar;
 
-  step_bar = calloc (1, sizeof (ply_text_step_bar_t));
+        step_bar = calloc (1, sizeof(ply_text_step_bar_t));
 
-  step_bar->row = 0;
-  step_bar->column = 0;
-  step_bar->number_of_columns = 0;
-  step_bar->number_of_rows = 0;
+        step_bar->row = 0;
+        step_bar->column = 0;
+        step_bar->number_of_columns = 0;
+        step_bar->number_of_rows = 0;
 
-  return step_bar;
+        return step_bar;
 }
 
 void
 ply_text_step_bar_free (ply_text_step_bar_t *step_bar)
 {
-  if (step_bar == NULL)
-    return;
+        if (step_bar == NULL)
+                return;
 
-  free (step_bar);
+        free (step_bar);
 }
 
 void
 ply_text_step_bar_draw (ply_text_step_bar_t *step_bar)
 {
-  int i;
-  int cur;
-
-  if (step_bar->is_hidden)
-    return;
-
-  ply_text_display_set_background_color (step_bar->display,
-                                         PLY_TERMINAL_COLOR_BLACK);
-
-  ply_text_display_set_cursor_position (step_bar->display,
-                                        step_bar->column,
-                                        step_bar->row);
-
-  cur = step_bar->percent_done * step_bar->number_of_columns;
-  for (i = 0; i < step_bar->number_of_columns; i++)
-    {
-      if (i == cur)
-        {
-          ply_text_display_set_foreground_color (step_bar->display,
-                                                 PLY_TERMINAL_COLOR_WHITE);
+        int i;
+        int cur;
+
+        if (step_bar->is_hidden)
+                return;
+
+        ply_text_display_set_background_color (step_bar->display,
+                                               PLY_TERMINAL_COLOR_BLACK);
+
+        ply_text_display_set_cursor_position (step_bar->display,
+                                              step_bar->column,
+                                              step_bar->row);
+
+        cur = step_bar->percent_done * step_bar->number_of_columns;
+        for (i = 0; i < step_bar->number_of_columns; i++) {
+                if (i == cur)
+                        ply_text_display_set_foreground_color (step_bar->display,
+                                                               PLY_TERMINAL_COLOR_WHITE);
+                else
+                        ply_text_display_set_foreground_color (step_bar->display,
+                                                               PLY_TERMINAL_COLOR_BROWN);
+
+                /* U+25A0 BLACK SQUARE */
+                ply_text_display_write (step_bar->display, "%s", "\x25\x96\xa0");
+                ply_text_display_write (step_bar->display, "%c", ' ');
         }
-      else
-        {
-          ply_text_display_set_foreground_color (step_bar->display,
-                                                 PLY_TERMINAL_COLOR_BROWN);
-        }
-
-      /* U+25A0 BLACK SQUARE */
-      ply_text_display_write (step_bar->display, "%s", "\x25\x96\xa0");
-      ply_text_display_write (step_bar->display, "%c", ' ');
-    }
 
-  ply_text_display_set_foreground_color (step_bar->display,
-                                         PLY_TERMINAL_COLOR_DEFAULT);
+        ply_text_display_set_foreground_color (step_bar->display,
+                                               PLY_TERMINAL_COLOR_DEFAULT);
 }
 
 void
-ply_text_step_bar_show (ply_text_step_bar_t  *step_bar,
-                        ply_text_display_t       *display)
+ply_text_step_bar_show (ply_text_step_bar_t *step_bar,
+                        ply_text_display_t  *display)
 {
-  int screen_rows;
-  int screen_cols;
+        int screen_rows;
+        int screen_cols;
 
-  assert (step_bar != NULL);
+        assert (step_bar != NULL);
 
-  step_bar->display = display;
+        step_bar->display = display;
 
 
-  screen_rows = ply_text_display_get_number_of_rows (display);
-  screen_cols = ply_text_display_get_number_of_columns (display);
+        screen_rows = ply_text_display_get_number_of_rows (display);
+        screen_cols = ply_text_display_get_number_of_columns (display);
 
-  step_bar->number_of_rows = 1;
-  step_bar->row = screen_rows * .66;
-  step_bar->number_of_columns = 3;
-  step_bar->column = screen_cols / 2.0 - step_bar->number_of_columns / 2.0;
+        step_bar->number_of_rows = 1;
+        step_bar->row = screen_rows * .66;
+        step_bar->number_of_columns = 3;
+        step_bar->column = screen_cols / 2.0 - step_bar->number_of_columns / 2.0;
 
-  step_bar->is_hidden = false;
+        step_bar->is_hidden = false;
 
-  ply_text_step_bar_draw (step_bar);
+        ply_text_step_bar_draw (step_bar);
 }
 
 void
 ply_text_step_bar_hide (ply_text_step_bar_t *step_bar)
 {
-  step_bar->display = NULL;
-  step_bar->is_hidden = true;
+        step_bar->display = NULL;
+        step_bar->is_hidden = true;
 }
 
 void
-ply_text_step_bar_set_percent_done (ply_text_step_bar_t  *step_bar,
-                                    double percent_done)
+ply_text_step_bar_set_percent_done (ply_text_step_bar_t *step_bar,
+                                    double               percent_done)
 {
-  step_bar->percent_done = percent_done;
+        step_bar->percent_done = percent_done;
 }
 
 double
-ply_text_step_bar_get_percent_done (ply_text_step_bar_t  *step_bar)
+ply_text_step_bar_get_percent_done (ply_text_step_bar_t *step_bar)
 {
-  return step_bar->percent_done;
+        return step_bar->percent_done;
 }
 
 int
 ply_text_step_bar_get_number_of_columns (ply_text_step_bar_t *step_bar)
 {
-  return step_bar->number_of_columns;
+        return step_bar->number_of_columns;
 }
 
 int
 ply_text_step_bar_get_number_of_rows (ply_text_step_bar_t *step_bar)
 {
-  return step_bar->number_of_rows;
+        return step_bar->number_of_rows;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-core/ply-text-step-bar.h b/src/libply-splash-core/ply-text-step-bar.h
index 0a4733f..e5dce91 100644
--- a/src/libply-splash-core/ply-text-step-bar.h
+++ b/src/libply-splash-core/ply-text-step-bar.h
@@ -33,11 +33,11 @@ void ply_text_step_bar_free (ply_text_step_bar_t *step_bar);
 
 void ply_text_step_bar_draw (ply_text_step_bar_t *step_bar);
 void ply_text_step_bar_show (ply_text_step_bar_t *step_bar,
-                             ply_text_display_t *display);
+                             ply_text_display_t  *display);
 void ply_text_step_bar_hide (ply_text_step_bar_t *step_bar);
 
 void ply_text_step_bar_set_percent_done (ply_text_step_bar_t *step_bar,
-                                         double percent_done);
+                                         double               percent_done);
 
 double ply_text_step_bar_get_percent_done (ply_text_step_bar_t *step_bar);
 
diff --git a/src/libply-splash-graphics/ply-animation.c b/src/libply-splash-graphics/ply-animation.c
index bba8490..0d9561e 100644
--- a/src/libply-splash-graphics/ply-animation.c
+++ b/src/libply-splash-graphics/ply-animation.c
@@ -56,21 +56,21 @@
 
 struct _ply_animation
 {
-  ply_array_t *frames;
-  ply_event_loop_t *loop;
-  char *image_dir;
-  char *frames_prefix;
-
-  ply_pixel_display_t     *display;
-  ply_rectangle_t          frame_area;
-  ply_trigger_t *stop_trigger;
-
-  int frame_number;
-  long x, y;
-  long width, height;
-  double start_time, previous_time, now;
-  uint32_t is_stopped : 1;
-  uint32_t stop_requested : 1;
+        ply_array_t         *frames;
+        ply_event_loop_t    *loop;
+        char                *image_dir;
+        char                *frames_prefix;
+
+        ply_pixel_display_t *display;
+        ply_rectangle_t      frame_area;
+        ply_trigger_t       *stop_trigger;
+
+        int                  frame_number;
+        long                 x, y;
+        long                 width, height;
+        double               start_time, previous_time, now;
+        uint32_t             is_stopped : 1;
+        uint32_t             stop_requested : 1;
 };
 
 static void ply_animation_stop_now (ply_animation_t *animation);
@@ -80,315 +80,298 @@ ply_animation_t *
 ply_animation_new (const char *image_dir,
                    const char *frames_prefix)
 {
-  ply_animation_t *animation;
-
-  assert (image_dir != NULL);
-  assert (frames_prefix != NULL);
-
-  animation = calloc (1, sizeof (ply_animation_t));
-
-  animation->frames = ply_array_new (PLY_ARRAY_ELEMENT_TYPE_POINTER);
-  animation->frames_prefix = strdup (frames_prefix);
-  animation->image_dir = strdup (image_dir);
-  animation->frame_number = 0;
-  animation->is_stopped = true;
-  animation->stop_requested = false;
-  animation->width = 0;
-  animation->height = 0;
-  animation->frame_area.width = 0;
-  animation->frame_area.height = 0;
-  animation->frame_area.x = 0;
-  animation->frame_area.y = 0;
-
-  return animation;
+        ply_animation_t *animation;
+
+        assert (image_dir != NULL);
+        assert (frames_prefix != NULL);
+
+        animation = calloc (1, sizeof(ply_animation_t));
+
+        animation->frames = ply_array_new (PLY_ARRAY_ELEMENT_TYPE_POINTER);
+        animation->frames_prefix = strdup (frames_prefix);
+        animation->image_dir = strdup (image_dir);
+        animation->frame_number = 0;
+        animation->is_stopped = true;
+        animation->stop_requested = false;
+        animation->width = 0;
+        animation->height = 0;
+        animation->frame_area.width = 0;
+        animation->frame_area.height = 0;
+        animation->frame_area.x = 0;
+        animation->frame_area.y = 0;
+
+        return animation;
 }
 
 static void
 ply_animation_remove_frames (ply_animation_t *animation)
 {
-  int i;
-  ply_pixel_buffer_t **frames;
+        int i;
+        ply_pixel_buffer_t **frames;
 
-  frames = (ply_pixel_buffer_t **) ply_array_steal_pointer_elements (animation->frames);
-  for (i = 0; frames[i] != NULL; i++)
-    ply_pixel_buffer_free (frames[i]);
-  free (frames);
+        frames = (ply_pixel_buffer_t **) ply_array_steal_pointer_elements (animation->frames);
+        for (i = 0; frames[i] != NULL; i++) {
+                ply_pixel_buffer_free (frames[i]);
+        }
+        free (frames);
 }
 
 void
 ply_animation_free (ply_animation_t *animation)
 {
-  if (animation == NULL)
-    return;
+        if (animation == NULL)
+                return;
 
-  if (!animation->is_stopped)
-    ply_animation_stop_now (animation);
+        if (!animation->is_stopped)
+                ply_animation_stop_now (animation);
 
-  ply_animation_remove_frames (animation);
-  ply_array_free (animation->frames);
+        ply_animation_remove_frames (animation);
+        ply_array_free (animation->frames);
 
-  free (animation->frames_prefix);
-  free (animation->image_dir);
-  free (animation);
+        free (animation->frames_prefix);
+        free (animation->image_dir);
+        free (animation);
 }
 
 static bool
 animate_at_time (ply_animation_t *animation,
                  double           time)
 {
-  int number_of_frames;
-  ply_pixel_buffer_t * const * frames;
-  bool should_continue;
+        int number_of_frames;
+        ply_pixel_buffer_t *const *frames;
+        bool should_continue;
 
-  number_of_frames = ply_array_get_size (animation->frames);
+        number_of_frames = ply_array_get_size (animation->frames);
 
-  if (number_of_frames == 0)
-    return false;
+        if (number_of_frames == 0)
+                return false;
 
-  should_continue = true;
+        should_continue = true;
 
-  if (animation->frame_number > number_of_frames - 1)
-    {
-      ply_trace ("reached last frame of animation");
-      return false;
-    }
+        if (animation->frame_number > number_of_frames - 1) {
+                ply_trace ("reached last frame of animation");
+                return false;
+        }
 
-  if (animation->stop_requested)
-    {
-      ply_trace ("stopping animation in the middle of sequence");
-      should_continue = false;
-    }
+        if (animation->stop_requested) {
+                ply_trace ("stopping animation in the middle of sequence");
+                should_continue = false;
+        }
 
-  frames = (ply_pixel_buffer_t * const *) ply_array_get_pointer_elements (animation->frames);
-  ply_pixel_buffer_get_size (frames[animation->frame_number], &animation->frame_area);
-  animation->frame_area.x = animation->x;
-  animation->frame_area.y = animation->y;
+        frames = (ply_pixel_buffer_t *const *) ply_array_get_pointer_elements (animation->frames);
+        ply_pixel_buffer_get_size (frames[animation->frame_number], &animation->frame_area);
+        animation->frame_area.x = animation->x;
+        animation->frame_area.y = animation->y;
 
-  ply_pixel_display_draw_area (animation->display,
-                               animation->x, animation->y,
-                               animation->frame_area.width,
-                               animation->frame_area.height);
+        ply_pixel_display_draw_area (animation->display,
+                                     animation->x, animation->y,
+                                     animation->frame_area.width,
+                                     animation->frame_area.height);
 
-  animation->frame_number++;
+        animation->frame_number++;
 
-  return should_continue;
+        return should_continue;
 }
 
 static void
 on_timeout (ply_animation_t *animation)
 {
-  double sleep_time;
-  bool should_continue;
-  animation->previous_time = animation->now;
-  animation->now = ply_get_timestamp ();
-
-  should_continue = animate_at_time (animation,
-                                     animation->now - animation->start_time);
-
-  sleep_time = 1.0 / FRAMES_PER_SECOND;
-  sleep_time = MAX (sleep_time - (ply_get_timestamp () - animation->now),
-                    0.005);
-
-  if (!should_continue)
-    {
-      if (animation->stop_trigger != NULL)
-        {
-          ply_trace ("firing off stop trigger");
-          ply_trigger_pull (animation->stop_trigger, NULL);
-          animation->stop_trigger = NULL;
+        double sleep_time;
+        bool should_continue;
+
+        animation->previous_time = animation->now;
+        animation->now = ply_get_timestamp ();
+
+        should_continue = animate_at_time (animation,
+                                           animation->now - animation->start_time);
+
+        sleep_time = 1.0 / FRAMES_PER_SECOND;
+        sleep_time = MAX (sleep_time - (ply_get_timestamp () - animation->now),
+                          0.005);
+
+        if (!should_continue) {
+                if (animation->stop_trigger != NULL) {
+                        ply_trace ("firing off stop trigger");
+                        ply_trigger_pull (animation->stop_trigger, NULL);
+                        animation->stop_trigger = NULL;
+                }
+        } else {
+                ply_event_loop_watch_for_timeout (animation->loop,
+                                                  sleep_time,
+                                                  (ply_event_loop_timeout_handler_t)
+                                                  on_timeout, animation);
         }
-    }
-  else
-    {
-      ply_event_loop_watch_for_timeout (animation->loop,
-                                        sleep_time,
-                                        (ply_event_loop_timeout_handler_t)
-                                        on_timeout, animation);
-    }
 }
 
 static bool
 ply_animation_add_frame (ply_animation_t *animation,
                          const char      *filename)
 {
-  ply_image_t *image;
-  ply_pixel_buffer_t *frame;
+        ply_image_t *image;
+        ply_pixel_buffer_t *frame;
 
-  image = ply_image_new (filename);
+        image = ply_image_new (filename);
 
-  if (!ply_image_load (image))
-    {
-      ply_image_free (image);
-      return false;
-    }
+        if (!ply_image_load (image)) {
+                ply_image_free (image);
+                return false;
+        }
 
-  frame = ply_image_convert_to_pixel_buffer (image);
+        frame = ply_image_convert_to_pixel_buffer (image);
 
-  ply_array_add_pointer_element (animation->frames, frame);
+        ply_array_add_pointer_element (animation->frames, frame);
 
-  animation->width = MAX (animation->width, (long) ply_pixel_buffer_get_width (frame));
-  animation->height = MAX (animation->height,  (long) ply_pixel_buffer_get_height (frame));
+        animation->width = MAX (animation->width, (long) ply_pixel_buffer_get_width (frame));
+        animation->height = MAX (animation->height, (long) ply_pixel_buffer_get_height (frame));
 
-  return true;
+        return true;
 }
 
 static bool
 ply_animation_add_frames (ply_animation_t *animation)
 {
-  struct dirent **entries;
-  int number_of_entries;
-  int number_of_frames;
-  int i;
-  bool load_finished;
+        struct dirent **entries;
+        int number_of_entries;
+        int number_of_frames;
+        int i;
+        bool load_finished;
 
-  entries = NULL;
+        entries = NULL;
 
-  number_of_entries = scandir (animation->image_dir, &entries, NULL, versionsort);
+        number_of_entries = scandir (animation->image_dir, &entries, NULL, versionsort);
 
-  if (number_of_entries <= 0)
-    return false;
+        if (number_of_entries <= 0)
+                return false;
 
-  load_finished = false;
-  for (i = 0; i < number_of_entries; i++)
-    {
-      if (strncmp (entries[i]->d_name,
-                   animation->frames_prefix,
-                   strlen (animation->frames_prefix)) == 0
-          && (strlen (entries[i]->d_name) > 4)
-          && strcmp (entries[i]->d_name + strlen (entries[i]->d_name) - 4, ".png") == 0)
-        {
-          char *filename;
+        load_finished = false;
+        for (i = 0; i < number_of_entries; i++) {
+                if (strncmp (entries[i]->d_name,
+                             animation->frames_prefix,
+                             strlen (animation->frames_prefix)) == 0
+                    && (strlen (entries[i]->d_name) > 4)
+                    && strcmp (entries[i]->d_name + strlen (entries[i]->d_name) - 4, ".png") == 0) {
+                        char *filename;
 
-          filename = NULL;
-          asprintf (&filename, "%s/%s", animation->image_dir, entries[i]->d_name);
+                        filename = NULL;
+                        asprintf (&filename, "%s/%s", animation->image_dir, entries[i]->d_name);
 
-          if (!ply_animation_add_frame (animation, filename))
-            goto out;
+                        if (!ply_animation_add_frame (animation, filename))
+                                goto out;
 
-          free (filename);
-        }
+                        free (filename);
+                }
 
-      free (entries[i]);
-      entries[i] = NULL;
-    }
+                free (entries[i]);
+                entries[i] = NULL;
+        }
 
-  number_of_frames = ply_array_get_size (animation->frames);
-  if (number_of_frames == 0)
-    {
-      ply_trace ("%s directory had no files starting with %s\n",
-                 animation->image_dir, animation->frames_prefix);
-      goto out;
-    }
-  else
-    {
-      ply_trace ("animation has %d frames\n", number_of_frames);
-    }
+        number_of_frames = ply_array_get_size (animation->frames);
+        if (number_of_frames == 0) {
+                ply_trace ("%s directory had no files starting with %s\n",
+                           animation->image_dir, animation->frames_prefix);
+                goto out;
+        } else {
+                ply_trace ("animation has %d frames\n", number_of_frames);
+        }
 
-  load_finished = true;
+        load_finished = true;
 
 out:
-  if (!load_finished)
-    {
-      ply_animation_remove_frames (animation);
-
-      while (i < number_of_entries)
-        {
-          free (entries[i]);
-          i++;
+        if (!load_finished) {
+                ply_animation_remove_frames (animation);
+
+                while (i < number_of_entries) {
+                        free (entries[i]);
+                        i++;
+                }
         }
-    }
-  free (entries);
+        free (entries);
 
-  return load_finished;
+        return load_finished;
 }
 
 bool
 ply_animation_load (ply_animation_t *animation)
 {
-  if (ply_array_get_size (animation->frames) != 0)
-    {
-      ply_animation_remove_frames (animation);
-      ply_trace ("reloading animation with new set of frames");
-    }
-  else
-    {
-      ply_trace ("loading frames for animation");
-    }
-
-  if (!ply_animation_add_frames (animation))
-    return false;
-
-  return true;
+        if (ply_array_get_size (animation->frames) != 0) {
+                ply_animation_remove_frames (animation);
+                ply_trace ("reloading animation with new set of frames");
+        } else {
+                ply_trace ("loading frames for animation");
+        }
+
+        if (!ply_animation_add_frames (animation))
+                return false;
+
+        return true;
 }
 
 bool
-ply_animation_start (ply_animation_t    *animation,
+ply_animation_start (ply_animation_t     *animation,
                      ply_pixel_display_t *display,
-                     ply_trigger_t      *stop_trigger,
-                     long                x,
-                     long                y)
+                     ply_trigger_t       *stop_trigger,
+                     long                 x,
+                     long                 y)
 {
-  assert (animation != NULL);
+        assert (animation != NULL);
 
-  if (!animation->is_stopped)
-    return true;
+        if (!animation->is_stopped)
+                return true;
 
-  ply_trace ("starting animation");
+        ply_trace ("starting animation");
 
-  animation->loop = ply_event_loop_get_default ();
-  animation->display = display;
-  animation->stop_trigger = stop_trigger;
-  animation->is_stopped = false;
-  animation->stop_requested = false;
+        animation->loop = ply_event_loop_get_default ();
+        animation->display = display;
+        animation->stop_trigger = stop_trigger;
+        animation->is_stopped = false;
+        animation->stop_requested = false;
 
-  animation->x = x;
-  animation->y = y;
+        animation->x = x;
+        animation->y = y;
 
-  animation->start_time = ply_get_timestamp ();
+        animation->start_time = ply_get_timestamp ();
 
-  ply_event_loop_watch_for_timeout (animation->loop,
-                                    1.0 / FRAMES_PER_SECOND,
-                                    (ply_event_loop_timeout_handler_t)
-                                    on_timeout, animation);
+        ply_event_loop_watch_for_timeout (animation->loop,
+                                          1.0 / FRAMES_PER_SECOND,
+                                          (ply_event_loop_timeout_handler_t)
+                                          on_timeout, animation);
 
-  return true;
+        return true;
 }
 
 static void
 ply_animation_stop_now (ply_animation_t *animation)
 {
-  animation->is_stopped = true;
+        animation->is_stopped = true;
 
-  ply_trace ("stopping animation now");
+        ply_trace ("stopping animation now");
 
-  if (animation->loop != NULL)
-    {
-      ply_event_loop_stop_watching_for_timeout (animation->loop,
-                                                (ply_event_loop_timeout_handler_t)
-                                                on_timeout, animation);
-      animation->loop = NULL;
-    }
+        if (animation->loop != NULL) {
+                ply_event_loop_stop_watching_for_timeout (animation->loop,
+                                                          (ply_event_loop_timeout_handler_t)
+                                                          on_timeout, animation);
+                animation->loop = NULL;
+        }
 
-  animation->display = NULL;
+        animation->display = NULL;
 }
 
 void
 ply_animation_stop (ply_animation_t *animation)
 {
-  if (animation->stop_trigger == NULL)
-    {
-      ply_animation_stop_now (animation);
-      return;
-    }
-
-  ply_trace ("stopping animation next time through the loop");
-  animation->stop_requested = true;
+        if (animation->stop_trigger == NULL) {
+                ply_animation_stop_now (animation);
+                return;
+        }
+
+        ply_trace ("stopping animation next time through the loop");
+        animation->stop_requested = true;
 }
 
 bool
 ply_animation_is_stopped (ply_animation_t *animation)
 {
-  return animation->is_stopped;
+        return animation->is_stopped;
 }
 
 void
@@ -399,33 +382,33 @@ ply_animation_draw_area (ply_animation_t    *animation,
                          unsigned long       width,
                          unsigned long       height)
 {
-  ply_pixel_buffer_t * const * frames;
-  int number_of_frames;
-  int frame_index;
-  
-  if (animation->is_stopped)
-    return;
-
-  number_of_frames = ply_array_get_size (animation->frames);
-  frame_index = MIN(animation->frame_number, number_of_frames - 1);
-
-  frames = (ply_pixel_buffer_t * const *) ply_array_get_pointer_elements (animation->frames);
-  ply_pixel_buffer_fill_with_buffer (buffer,
-                                     frames[frame_index],
-                                     animation->frame_area.x,
-                                     animation->frame_area.y);
+        ply_pixel_buffer_t *const *frames;
+        int number_of_frames;
+        int frame_index;
+
+        if (animation->is_stopped)
+                return;
+
+        number_of_frames = ply_array_get_size (animation->frames);
+        frame_index = MIN (animation->frame_number, number_of_frames - 1);
+
+        frames = (ply_pixel_buffer_t *const *) ply_array_get_pointer_elements (animation->frames);
+        ply_pixel_buffer_fill_with_buffer (buffer,
+                                           frames[frame_index],
+                                           animation->frame_area.x,
+                                           animation->frame_area.y);
 }
 
 long
 ply_animation_get_width (ply_animation_t *animation)
 {
-  return animation->width;
+        return animation->width;
 }
 
 long
 ply_animation_get_height (ply_animation_t *animation)
 {
-  return animation->height;
+        return animation->height;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-graphics/ply-animation.h b/src/libply-splash-graphics/ply-animation.h
index 7b90547..e91624b 100644
--- a/src/libply-splash-graphics/ply-animation.h
+++ b/src/libply-splash-graphics/ply-animation.h
@@ -38,11 +38,11 @@ ply_animation_t *ply_animation_new (const char *image_dir,
 void ply_animation_free (ply_animation_t *animation);
 
 bool ply_animation_load (ply_animation_t *animation);
-bool ply_animation_start (ply_animation_t    *animation,
+bool ply_animation_start (ply_animation_t     *animation,
                           ply_pixel_display_t *display,
-                          ply_trigger_t      *stop_trigger,
-                          long                x,
-                          long                y);
+                          ply_trigger_t       *stop_trigger,
+                          long                 x,
+                          long                 y);
 void ply_animation_stop (ply_animation_t *animation);
 bool ply_animation_is_stopped (ply_animation_t *animation);
 
diff --git a/src/libply-splash-graphics/ply-entry.c b/src/libply-splash-graphics/ply-entry.c
index 028866a..29b76a7 100644
--- a/src/libply-splash-graphics/ply-entry.c
+++ b/src/libply-splash-graphics/ply-entry.c
@@ -58,103 +58,102 @@
 
 struct _ply_entry
 {
-  ply_event_loop_t *loop;
+        ply_event_loop_t    *loop;
 
-  ply_pixel_display_t     *display;
-  ply_rectangle_t          area;
-  ply_image_t             *text_field_image;
-  ply_image_t             *bullet_image;
-  ply_label_t             *label;
+        ply_pixel_display_t *display;
+        ply_rectangle_t      area;
+        ply_image_t         *text_field_image;
+        ply_image_t         *bullet_image;
+        ply_label_t         *label;
 
-  char* text;
-  int number_of_bullets;
-  int max_number_of_visible_bullets;
+        char                *text;
+        int                  number_of_bullets;
+        int                  max_number_of_visible_bullets;
 
-  uint32_t is_hidden : 1;
-  uint32_t is_password : 1;
+        uint32_t             is_hidden : 1;
+        uint32_t             is_password : 1;
 };
 
 ply_entry_t *
 ply_entry_new (const char *image_dir)
 {
-  ply_entry_t *entry;
-  char *image_path;
+        ply_entry_t *entry;
+        char *image_path;
 
-  assert (image_dir != NULL);
+        assert (image_dir != NULL);
 
-  entry = calloc (1, sizeof (ply_entry_t));
+        entry = calloc (1, sizeof(ply_entry_t));
 
-  image_path = NULL;
-  asprintf (&image_path, "%s/entry.png", image_dir);
-  entry->text_field_image = ply_image_new (image_path);
-  free (image_path);
+        image_path = NULL;
+        asprintf (&image_path, "%s/entry.png", image_dir);
+        entry->text_field_image = ply_image_new (image_path);
+        free (image_path);
 
-  image_path = NULL;
-  asprintf (&image_path, "%s/bullet.png", image_dir);
-  entry->bullet_image = ply_image_new (image_path);
-  free (image_path);
-  entry->label = ply_label_new ();
-  ply_label_set_color (entry->label, 0, 0, 0, 1);
+        image_path = NULL;
+        asprintf (&image_path, "%s/bullet.png", image_dir);
+        entry->bullet_image = ply_image_new (image_path);
+        free (image_path);
+        entry->label = ply_label_new ();
+        ply_label_set_color (entry->label, 0, 0, 0, 1);
 
-  entry->number_of_bullets = 0;
-  entry->text = strdup("");
-  
-  entry->is_hidden = true;
-  entry->is_password = true;
+        entry->number_of_bullets = 0;
+        entry->text = strdup ("");
 
-  return entry;
+        entry->is_hidden = true;
+        entry->is_password = true;
+
+        return entry;
 }
 
 void
 ply_entry_free (ply_entry_t *entry)
 {
-  if (entry == NULL)
-    return;
-  ply_image_free (entry->text_field_image);
-  ply_image_free (entry->bullet_image);
-  ply_label_free (entry->label);
-  free (entry->text);
-
-  free (entry);
+        if (entry == NULL)
+                return;
+        ply_image_free (entry->text_field_image);
+        ply_image_free (entry->bullet_image);
+        ply_label_free (entry->label);
+        free (entry->text);
+
+        free (entry);
 }
 
 static int
 get_max_number_of_visible_bullets (ply_entry_t *entry)
 {
-  long bullet_width, text_field_width;
+        long bullet_width, text_field_width;
 
-  bullet_width = ply_image_get_width (entry->bullet_image);
-  text_field_width = ply_image_get_width (entry->text_field_image);
+        bullet_width = ply_image_get_width (entry->bullet_image);
+        text_field_width = ply_image_get_width (entry->text_field_image);
 
-  return (int) (text_field_width / bullet_width) - ((text_field_width % bullet_width) < (bullet_width / 2)? 1 : 0);
+        return (int) (text_field_width / bullet_width) - ((text_field_width % bullet_width) < (bullet_width / 2) ? 1 : 0);
 }
 
 bool
 ply_entry_load (ply_entry_t *entry)
 {
+        if (!ply_image_load (entry->text_field_image))
+                return false;
 
-  if (!ply_image_load (entry->text_field_image))
-    return false;
-
-  if (!ply_image_load (entry->bullet_image))
-    return false;
+        if (!ply_image_load (entry->bullet_image))
+                return false;
 
-  entry->area.width = ply_image_get_width (entry->text_field_image);
-  entry->area.height = ply_image_get_height (entry->text_field_image);
+        entry->area.width = ply_image_get_width (entry->text_field_image);
+        entry->area.height = ply_image_get_height (entry->text_field_image);
 
-  entry->max_number_of_visible_bullets = get_max_number_of_visible_bullets (entry);
+        entry->max_number_of_visible_bullets = get_max_number_of_visible_bullets (entry);
 
-  return true;
+        return true;
 }
 
 static void
 ply_entry_draw (ply_entry_t *entry)
 {
-  ply_pixel_display_draw_area (entry->display,
-                               entry->area.x,
-                               entry->area.y,
-                               entry->area.width,
-                               entry->area.height);
+        ply_pixel_display_draw_area (entry->display,
+                                     entry->area.x,
+                                     entry->area.y,
+                                     entry->area.width,
+                                     entry->area.height);
 }
 
 void
@@ -165,118 +164,111 @@ ply_entry_draw_area (ply_entry_t        *entry,
                      unsigned long       width,
                      unsigned long       height)
 {
-  ply_rectangle_t     bullet_area;
-  ply_rectangle_t     clip_area;
-  ply_pixel_buffer_t *bullet_buffer, *text_field_buffer;
-  int i, number_of_visible_bullets;
-
-  if (entry->is_hidden)
-    return;
-
-  text_field_buffer = ply_image_get_buffer (entry->text_field_image);
-
-  ply_pixel_buffer_fill_with_buffer (pixel_buffer,
-                                     text_field_buffer,
-                                     entry->area.x,
-                                     entry->area.y);
-
-  if (entry->is_password)
-    {
-      bullet_buffer = ply_image_get_buffer (entry->bullet_image);
-      ply_pixel_buffer_get_size (bullet_buffer, &bullet_area);
-
-      if (entry->number_of_bullets <= entry->max_number_of_visible_bullets)
-        number_of_visible_bullets = entry->number_of_bullets;
-      else
-        {
-          number_of_visible_bullets = entry->max_number_of_visible_bullets;
-
-          /* We've got more bullets than we can show in the available space, so
-           * draw a little half bullet to indicate some bullets are offscreen
-           */
-          bullet_area.x = entry->area.x - bullet_area.width / 2.0;
-          bullet_area.y = entry->area.y + entry->area.height / 2.0 - bullet_area.height / 2.0;
-          clip_area = bullet_area;
-          clip_area.x = entry->area.x;
-          
-          ply_pixel_buffer_fill_with_buffer_with_clip (pixel_buffer,
-                                                       bullet_buffer,
-                                                       bullet_area.x,
-                                                       bullet_area.y,
-                                                       &clip_area);
-        }
-
-      for (i = 0; i < number_of_visible_bullets; i++)
-        {
-          bullet_area.x = entry->area.x + i * bullet_area.width + bullet_area.width / 2.0;
-          bullet_area.y = entry->area.y + entry->area.height / 2.0 - bullet_area.height / 2.0;
-
-          ply_pixel_buffer_fill_with_buffer (pixel_buffer,
-                                             bullet_buffer,
-                                             bullet_area.x,
-                                             bullet_area.y);
+        ply_rectangle_t bullet_area;
+        ply_rectangle_t clip_area;
+        ply_pixel_buffer_t *bullet_buffer, *text_field_buffer;
+        int i, number_of_visible_bullets;
+
+        if (entry->is_hidden)
+                return;
+
+        text_field_buffer = ply_image_get_buffer (entry->text_field_image);
+
+        ply_pixel_buffer_fill_with_buffer (pixel_buffer,
+                                           text_field_buffer,
+                                           entry->area.x,
+                                           entry->area.y);
+
+        if (entry->is_password) {
+                bullet_buffer = ply_image_get_buffer (entry->bullet_image);
+                ply_pixel_buffer_get_size (bullet_buffer, &bullet_area);
+
+                if (entry->number_of_bullets <= entry->max_number_of_visible_bullets) {
+                        number_of_visible_bullets = entry->number_of_bullets;
+                } else {
+                        number_of_visible_bullets = entry->max_number_of_visible_bullets;
+
+                        /* We've got more bullets than we can show in the available space, so
+                         * draw a little half bullet to indicate some bullets are offscreen
+                         */
+                        bullet_area.x = entry->area.x - bullet_area.width / 2.0;
+                        bullet_area.y = entry->area.y + entry->area.height / 2.0 - bullet_area.height / 2.0;
+                        clip_area = bullet_area;
+                        clip_area.x = entry->area.x;
+
+                        ply_pixel_buffer_fill_with_buffer_with_clip (pixel_buffer,
+                                                                     bullet_buffer,
+                                                                     bullet_area.x,
+                                                                     bullet_area.y,
+                                                                     &clip_area);
+                }
+
+                for (i = 0; i < number_of_visible_bullets; i++) {
+                        bullet_area.x = entry->area.x + i * bullet_area.width + bullet_area.width / 2.0;
+                        bullet_area.y = entry->area.y + entry->area.height / 2.0 - bullet_area.height / 2.0;
+
+                        ply_pixel_buffer_fill_with_buffer (pixel_buffer,
+                                                           bullet_buffer,
+                                                           bullet_area.x,
+                                                           bullet_area.y);
+                }
+        } else {
+                ply_label_set_text (entry->label, entry->text);
+                ply_label_show (entry->label,
+                                NULL,
+                                entry->area.x,
+                                entry->area.y + entry->area.height / 2
+                                - ply_label_get_height (entry->label) / 2);
+                ply_label_draw_area (entry->label, pixel_buffer,
+                                     entry->area.x, entry->area.y,
+                                     entry->area.width, entry->area.height);
         }
-    }
-  else
-    {
-      ply_label_set_text (entry->label, entry->text);
-      ply_label_show (entry->label,
-                      NULL,
-                      entry->area.x,
-                      entry->area.y + entry->area.height / 2
-                       - ply_label_get_height (entry->label) / 2);
-      ply_label_draw_area (entry->label, pixel_buffer,
-                           entry->area.x, entry->area.y,
-                           entry->area.width, entry->area.height);
-    }
 }
 
 void
 ply_entry_set_bullet_count (ply_entry_t *entry, int count)
 {
-  count = MAX(0, count);
-  if (!entry->is_password || entry->number_of_bullets != count)
-    {
-      entry->is_password = true;
-      entry->number_of_bullets = count;
-      ply_entry_draw (entry);
-    }
+        count = MAX (0, count);
+        if (!entry->is_password || entry->number_of_bullets != count) {
+                entry->is_password = true;
+                entry->number_of_bullets = count;
+                ply_entry_draw (entry);
+        }
 }
 
 int
 ply_entry_get_bullet_count (ply_entry_t *entry)
 {
-  return entry->number_of_bullets;
+        return entry->number_of_bullets;
 }
 
 void
 ply_entry_add_bullet (ply_entry_t *entry)
 {
-  ply_entry_set_bullet_count (entry, ply_entry_get_bullet_count (entry)+1);
+        ply_entry_set_bullet_count (entry, ply_entry_get_bullet_count (entry) + 1);
 }
 
 void
 ply_entry_remove_bullet (ply_entry_t *entry)
 {
-  ply_entry_set_bullet_count (entry, ply_entry_get_bullet_count (entry)-1);
+        ply_entry_set_bullet_count (entry, ply_entry_get_bullet_count (entry) - 1);
 }
 
 void
 ply_entry_remove_all_bullets (ply_entry_t *entry)
 {
-  ply_entry_set_bullet_count (entry, 0);
+        ply_entry_set_bullet_count (entry, 0);
 }
 
 void
-ply_entry_set_text (ply_entry_t *entry, const char* text)
+ply_entry_set_text (ply_entry_t *entry, const char *text)
 {
-  if (entry->is_password || strcmp(entry->text, text) != 0)
-    {
-      entry->is_password = false;
-      free(entry->text);
-      entry->text = strdup(text);
-      ply_entry_draw (entry);
-    }
+        if (entry->is_password || strcmp (entry->text, text) != 0) {
+                entry->is_password = false;
+                free (entry->text);
+                entry->text = strdup (text);
+                ply_entry_draw (entry);
+        }
 }
 
 void
@@ -286,7 +278,7 @@ ply_entry_set_text_color (ply_entry_t *entry,
                           float        blue,
                           float        alpha)
 {
-  ply_label_set_color (entry->label, red, green, blue, alpha);
+        ply_label_set_color (entry->label, red, green, blue, alpha);
 }
 
 
@@ -294,49 +286,49 @@ void
 ply_entry_show (ply_entry_t         *entry,
                 ply_event_loop_t    *loop,
                 ply_pixel_display_t *display,
-                long                  x,
-                long                  y)
+                long                 x,
+                long                 y)
 {
-  assert (entry != NULL);
-  assert (entry->loop == NULL);
+        assert (entry != NULL);
+        assert (entry->loop == NULL);
 
-  entry->loop = loop;
-  entry->display = display;
+        entry->loop = loop;
+        entry->display = display;
 
-  entry->area.x = x;
-  entry->area.y = y;
+        entry->area.x = x;
+        entry->area.y = y;
 
-  entry->is_hidden = false;
+        entry->is_hidden = false;
 
-  ply_entry_draw (entry);
+        ply_entry_draw (entry);
 }
 
 void
 ply_entry_hide (ply_entry_t *entry)
 {
-  entry->is_hidden = true;
-  ply_entry_draw (entry);
+        entry->is_hidden = true;
+        ply_entry_draw (entry);
 
-  entry->display = NULL;
-  entry->loop = NULL;
+        entry->display = NULL;
+        entry->loop = NULL;
 }
 
 bool
 ply_entry_is_hidden (ply_entry_t *entry)
 {
-  return entry->is_hidden;
+        return entry->is_hidden;
 }
 
 long
 ply_entry_get_width (ply_entry_t *entry)
 {
-  return entry->area.width;
+        return entry->area.width;
 }
 
 long
 ply_entry_get_height (ply_entry_t *entry)
 {
-  return entry->area.height;
+        return entry->area.height;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-graphics/ply-entry.h b/src/libply-splash-graphics/ply-entry.h
index 8a3e16e..3c03293 100644
--- a/src/libply-splash-graphics/ply-entry.h
+++ b/src/libply-splash-graphics/ply-entry.h
@@ -54,12 +54,14 @@ bool ply_entry_is_hidden (ply_entry_t *entry);
 long ply_entry_get_width (ply_entry_t *entry);
 long ply_entry_get_height (ply_entry_t *entry);
 
-void ply_entry_set_bullet_count (ply_entry_t *entry, int count);
+void ply_entry_set_bullet_count (ply_entry_t *entry,
+                                 int          count);
 int ply_entry_get_bullet_count (ply_entry_t *entry);
 void ply_entry_add_bullet (ply_entry_t *entry);
 void ply_entry_remove_bullet (ply_entry_t *entry);
 void ply_entry_remove_all_bullets (ply_entry_t *entry);
-void ply_entry_set_text (ply_entry_t *entry, const char* text);
+void ply_entry_set_text (ply_entry_t *entry,
+                         const char  *text);
 void ply_entry_set_text_color (ply_entry_t *entry,
                                float        red,
                                float        green,
diff --git a/src/libply-splash-graphics/ply-image.c b/src/libply-splash-graphics/ply-image.c
index 7d21946..f838601 100644
--- a/src/libply-splash-graphics/ply-image.c
+++ b/src/libply-splash-graphics/ply-image.c
@@ -51,36 +51,36 @@
 
 struct _ply_image
 {
-  char  *filename;
-  ply_pixel_buffer_t *buffer;
+        char               *filename;
+        ply_pixel_buffer_t *buffer;
 };
 
 ply_image_t *
 ply_image_new (const char *filename)
 {
-  ply_image_t *image;
+        ply_image_t *image;
 
-  assert (filename != NULL);
+        assert (filename != NULL);
 
-  image = calloc (1, sizeof (ply_image_t));
+        image = calloc (1, sizeof(ply_image_t));
 
-  image->filename = strdup (filename);
-  image->buffer = NULL;
+        image->filename = strdup (filename);
+        image->buffer = NULL;
 
-  return image;
+        return image;
 }
 
 void
 ply_image_free (ply_image_t *image)
 {
-  if (image == NULL)
-    return;
-
-  assert (image->filename != NULL);
-  
-  ply_pixel_buffer_free (image->buffer);
-  free (image->filename);
-  free (image);
+        if (image == NULL)
+                return;
+
+        assert (image->filename != NULL);
+
+        ply_pixel_buffer_free (image->buffer);
+        free (image->filename);
+        free (image);
 }
 
 static void
@@ -88,138 +88,137 @@ transform_to_argb32 (png_struct   *png,
                      png_row_info *row_info,
                      png_byte     *data)
 {
-  unsigned int i;
-
-  for (i = 0; i < row_info->rowbytes; i += 4) 
-  {
-    uint8_t  red, green, blue, alpha;
-    uint32_t pixel_value;
-
-    red = data[i + 0];
-    green = data[i + 1];
-    blue = data[i + 2];
-    alpha = data[i + 3];
-
-    red = (uint8_t) CLAMP (((red / 255.0) * (alpha / 255.0)) * 255.0, 0, 255.0);
-    green = (uint8_t) CLAMP (((green / 255.0) * (alpha / 255.0)) * 255.0,
-                             0, 255.0);
-    blue = (uint8_t) CLAMP (((blue / 255.0) * (alpha / 255.0)) * 255.0, 0, 255.0);
-
-    pixel_value = (alpha << 24) | (red << 16) | (green << 8) | (blue << 0);
-    memcpy (data + i, &pixel_value, sizeof (uint32_t));
-  }
+        unsigned int i;
+
+        for (i = 0; i < row_info->rowbytes; i += 4) {
+                uint8_t red, green, blue, alpha;
+                uint32_t pixel_value;
+
+                red = data[i + 0];
+                green = data[i + 1];
+                blue = data[i + 2];
+                alpha = data[i + 3];
+
+                red = (uint8_t) CLAMP (((red / 255.0) * (alpha / 255.0)) * 255.0, 0, 255.0);
+                green = (uint8_t) CLAMP (((green / 255.0) * (alpha / 255.0)) * 255.0,
+                                         0, 255.0);
+                blue = (uint8_t) CLAMP (((blue / 255.0) * (alpha / 255.0)) * 255.0, 0, 255.0);
+
+                pixel_value = (alpha << 24) | (red << 16) | (green << 8) | (blue << 0);
+                memcpy (data + i, &pixel_value, sizeof(uint32_t));
+        }
 }
 
 bool
 ply_image_load (ply_image_t *image)
 {
-  png_struct *png;
-  png_info *info;
-  png_uint_32 width, height, row;
-  int bits_per_pixel, color_type, interlace_method;
-  png_byte **rows;
-  uint32_t *bytes;
-  FILE *fp;
-  
-  assert (image != NULL);
-  
-  fp = fopen (image->filename, "re");
-  if (fp == NULL)
-    return false;
-  
-  png = png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-  assert (png != NULL);
+        png_struct *png;
+        png_info *info;
+        png_uint_32 width, height, row;
+        int bits_per_pixel, color_type, interlace_method;
+        png_byte **rows;
+        uint32_t *bytes;
+        FILE *fp;
+
+        assert (image != NULL);
+
+        fp = fopen (image->filename, "re");
+        if (fp == NULL)
+                return false;
+
+        png = png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+        assert (png != NULL);
 
-  info = png_create_info_struct (png);
-  assert (info != NULL);
+        info = png_create_info_struct (png);
+        assert (info != NULL);
 
-  png_init_io (png, fp);
+        png_init_io (png, fp);
 
-  if (setjmp (png_jmpbuf (png)) != 0)
-    {
-      fclose (fp);
-      return false;
-    }
+        if (setjmp (png_jmpbuf (png)) != 0) {
+                fclose (fp);
+                return false;
+        }
 
-  png_read_info (png, info);
-  png_get_IHDR (png, info,
-                &width, &height, &bits_per_pixel,
-                &color_type, &interlace_method, NULL, NULL);
+        png_read_info (png, info);
+        png_get_IHDR (png, info,
+                      &width, &height, &bits_per_pixel,
+                      &color_type, &interlace_method, NULL, NULL);
 
-  if (color_type == PNG_COLOR_TYPE_PALETTE)
-    png_set_palette_to_rgb (png);
+        if (color_type == PNG_COLOR_TYPE_PALETTE)
+                png_set_palette_to_rgb (png);
 
-  if ((color_type == PNG_COLOR_TYPE_GRAY) && (bits_per_pixel < 8))
-    png_set_expand_gray_1_2_4_to_8 (png);
+        if ((color_type == PNG_COLOR_TYPE_GRAY) && (bits_per_pixel < 8))
+                png_set_expand_gray_1_2_4_to_8 (png);
 
-  if (png_get_valid (png, info, PNG_INFO_tRNS))
-    png_set_tRNS_to_alpha (png);
+        if (png_get_valid (png, info, PNG_INFO_tRNS))
+                png_set_tRNS_to_alpha (png);
 
-  if (bits_per_pixel == 16)
-    png_set_strip_16 (png);
+        if (bits_per_pixel == 16)
+                png_set_strip_16 (png);
 
-  if (bits_per_pixel < 8)
-    png_set_packing (png);
+        if (bits_per_pixel < 8)
+                png_set_packing (png);
 
-  if ((color_type == PNG_COLOR_TYPE_GRAY)
-      || (color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
-    png_set_gray_to_rgb (png);
+        if ((color_type == PNG_COLOR_TYPE_GRAY)
+            || (color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
+                png_set_gray_to_rgb (png);
 
-  if (interlace_method != PNG_INTERLACE_NONE)
-    png_set_interlace_handling (png);
+        if (interlace_method != PNG_INTERLACE_NONE)
+                png_set_interlace_handling (png);
 
-  png_set_filler (png, 0xff, PNG_FILLER_AFTER);
+        png_set_filler (png, 0xff, PNG_FILLER_AFTER);
 
-  png_set_read_user_transform_fn (png, transform_to_argb32);
+        png_set_read_user_transform_fn (png, transform_to_argb32);
 
-  png_read_update_info (png, info);
+        png_read_update_info (png, info);
 
-  rows = malloc (height * sizeof (png_byte *));
-  image->buffer = ply_pixel_buffer_new (width, height);
-  
-  bytes = ply_pixel_buffer_get_argb32_data (image->buffer);
+        rows = malloc (height * sizeof(png_byte *));
+        image->buffer = ply_pixel_buffer_new (width, height);
 
-  for (row = 0; row < height; row++)
-    rows[row] = (png_byte*) &bytes[row * width];
+        bytes = ply_pixel_buffer_get_argb32_data (image->buffer);
 
-  png_read_image (png, rows);
+        for (row = 0; row < height; row++) {
+                rows[row] = (png_byte *) &bytes[row * width];
+        }
 
-  free (rows);
-  png_read_end (png, info);
-  fclose (fp);
-  png_destroy_read_struct (&png, &info, NULL);
+        png_read_image (png, rows);
 
-  return true;
+        free (rows);
+        png_read_end (png, info);
+        fclose (fp);
+        png_destroy_read_struct (&png, &info, NULL);
+
+        return true;
 }
 
 uint32_t *
 ply_image_get_data (ply_image_t *image)
 {
-  assert (image != NULL);
+        assert (image != NULL);
 
-  return ply_pixel_buffer_get_argb32_data (image->buffer);
+        return ply_pixel_buffer_get_argb32_data (image->buffer);
 }
 
 long
 ply_image_get_width (ply_image_t *image)
 {
-  ply_rectangle_t size;
-  
-  assert (image != NULL);
-  ply_pixel_buffer_get_size (image->buffer, &size);
+        ply_rectangle_t size;
+
+        assert (image != NULL);
+        ply_pixel_buffer_get_size (image->buffer, &size);
 
-  return size.width;
+        return size.width;
 }
 
 long
 ply_image_get_height (ply_image_t *image)
 {
-  ply_rectangle_t size;
-  
-  assert (image != NULL);
-  ply_pixel_buffer_get_size (image->buffer, &size);
+        ply_rectangle_t size;
 
-  return size.height;
+        assert (image != NULL);
+        ply_pixel_buffer_get_size (image->buffer, &size);
+
+        return size.height;
 }
 
 ply_image_t *
@@ -227,14 +226,14 @@ ply_image_resize (ply_image_t *image,
                   long         width,
                   long         height)
 {
-  ply_image_t *new_image;
-  
-  new_image = ply_image_new (image->filename);
-
-  new_image->buffer = ply_pixel_buffer_resize (image->buffer,
-                                               width,
-                                               height);
-  return new_image;
+        ply_image_t *new_image;
+
+        new_image = ply_image_new (image->filename);
+
+        new_image->buffer = ply_pixel_buffer_resize (image->buffer,
+                                                     width,
+                                                     height);
+        return new_image;
 }
 
 ply_image_t *
@@ -243,15 +242,15 @@ ply_image_rotate (ply_image_t *image,
                   long         center_y,
                   double       theta_offset)
 {
-  ply_image_t *new_image;
-  
-  new_image = ply_image_new (image->filename);
-  
-  new_image->buffer = ply_pixel_buffer_rotate (image->buffer,
-                                               center_x,
-                                               center_y,
-                                               theta_offset);
-  return new_image;
+        ply_image_t *new_image;
+
+        new_image = ply_image_new (image->filename);
+
+        new_image->buffer = ply_pixel_buffer_rotate (image->buffer,
+                                                     center_x,
+                                                     center_y,
+                                                     theta_offset);
+        return new_image;
 }
 
 ply_image_t *
@@ -259,36 +258,36 @@ ply_image_tile (ply_image_t *image,
                 long         width,
                 long         height)
 {
-  ply_image_t *new_image;
+        ply_image_t *new_image;
 
-  new_image = ply_image_new (image->filename);
+        new_image = ply_image_new (image->filename);
 
-  new_image->buffer = ply_pixel_buffer_tile (image->buffer,
-                                             width,
-                                             height);
-  return new_image;
+        new_image->buffer = ply_pixel_buffer_tile (image->buffer,
+                                                   width,
+                                                   height);
+        return new_image;
 }
 
 ply_pixel_buffer_t *
 ply_image_get_buffer (ply_image_t *image)
 {
-  assert (image != NULL);
+        assert (image != NULL);
 
-  return image->buffer;
+        return image->buffer;
 }
 
 ply_pixel_buffer_t *
 ply_image_convert_to_pixel_buffer (ply_image_t *image)
 {
-  ply_pixel_buffer_t *buffer;
+        ply_pixel_buffer_t *buffer;
+
+        assert (image != NULL);
 
-  assert (image != NULL);
+        buffer = image->buffer;
+        image->buffer = NULL;
+        ply_image_free (image);
 
-  buffer = image->buffer;
-  image->buffer = NULL;
-  ply_image_free (image);
-  
-  return buffer;
+        return buffer;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-graphics/ply-image.h b/src/libply-splash-graphics/ply-image.h
index 5bda567..fc2f45f 100644
--- a/src/libply-splash-graphics/ply-image.h
+++ b/src/libply-splash-graphics/ply-image.h
@@ -1,4 +1,4 @@
-/* ply-image.h - png file loader 
+/* ply-image.h - png file loader
  *
  * Copyright (C) 2007 Red Hat, Inc.
  *
@@ -37,9 +37,16 @@ bool ply_image_load (ply_image_t *image);
 uint32_t *ply_image_get_data (ply_image_t *image);
 long ply_image_get_width (ply_image_t *image);
 long ply_image_get_height (ply_image_t *image);
-ply_image_t *ply_image_resize (ply_image_t *image, long width, long height);
-ply_image_t *ply_image_rotate (ply_image_t *oldimage, long center_x, long center_y, double theta_offset);
-ply_image_t *ply_image_tile (ply_image_t *image, long width, long height);
+ply_image_t *ply_image_resize (ply_image_t *image,
+                               long         width,
+                               long         height);
+ply_image_t *ply_image_rotate (ply_image_t *oldimage,
+                               long         center_x,
+                               long         center_y,
+                               double       theta_offset);
+ply_image_t *ply_image_tile (ply_image_t *image,
+                             long         width,
+                             long         height);
 ply_pixel_buffer_t *ply_image_get_buffer (ply_image_t *image);
 ply_pixel_buffer_t *ply_image_convert_to_pixel_buffer (ply_image_t *image);
 
diff --git a/src/libply-splash-graphics/ply-label-plugin.h b/src/libply-splash-graphics/ply-label-plugin.h
index 9692d02..75bb9d7 100644
--- a/src/libply-splash-graphics/ply-label-plugin.h
+++ b/src/libply-splash-graphics/ply-label-plugin.h
@@ -36,38 +36,38 @@ typedef struct _ply_label_plugin_control ply_label_plugin_control_t;
 
 typedef struct
 {
-  ply_label_plugin_control_t * (* create_control) (void);
-  void (* destroy_control) (ply_label_plugin_control_t        *label);
-  bool (* show_control) (ply_label_plugin_control_t        *label,
-                         ply_pixel_display_t               *display,
-                         long                               x,
-                         long                               y);
-  void (* hide_control) (ply_label_plugin_control_t        *label);
-  void (* draw_control) (ply_label_plugin_control_t        *label,
-                         ply_pixel_buffer_t                *pixel_buffer,
-                         long                               x,
-                         long                               y,
-                         unsigned long                      width,
-                         unsigned long                      height);
-  bool (* is_control_hidden) (ply_label_plugin_control_t        *label);
+        ply_label_plugin_control_t * (*create_control)(void);
+        void (*destroy_control)(ply_label_plugin_control_t *label);
+        bool (*show_control)(ply_label_plugin_control_t *label,
+                             ply_pixel_display_t        *display,
+                             long                        x,
+                             long                        y);
+        void (*hide_control)(ply_label_plugin_control_t *label);
+        void (*draw_control)(ply_label_plugin_control_t *label,
+                             ply_pixel_buffer_t         *pixel_buffer,
+                             long                        x,
+                             long                        y,
+                             unsigned long               width,
+                             unsigned long               height);
+        bool (*is_control_hidden)(ply_label_plugin_control_t *label);
 
-  void (* set_text_for_control) (ply_label_plugin_control_t *label,
-                                 const char                 *text);
-  void (* set_font_for_control) (ply_label_plugin_control_t *label,
-                                 const char                 *fontdesc);
-  void (* set_color_for_control) (ply_label_plugin_control_t *label,
-                                  float                       red,
-                                  float                       green,
-                                  float                       blue,
-                                  float                       alpha);
+        void (*set_text_for_control)(ply_label_plugin_control_t *label,
+                                     const char                 *text);
+        void (*set_font_for_control)(ply_label_plugin_control_t *label,
+                                     const char                 *fontdesc);
+        void (*set_color_for_control)(ply_label_plugin_control_t *label,
+                                      float                       red,
+                                      float                       green,
+                                      float                       blue,
+                                      float                       alpha);
 
-  long (* get_width_of_control) (ply_label_plugin_control_t        *label);
-  long (* get_height_of_control) (ply_label_plugin_control_t        *label);
+        long (*get_width_of_control)(ply_label_plugin_control_t *label);
+        long (*get_height_of_control)(ply_label_plugin_control_t *label);
 
-  void (* set_alignment_for_control) (ply_label_plugin_control_t  *label,
-                                      ply_label_alignment_t alignment);
-  void (* set_width_for_control) (ply_label_plugin_control_t  *label,
-                                  long                        width);
+        void (*set_alignment_for_control)(ply_label_plugin_control_t *label,
+                                          ply_label_alignment_t       alignment);
+        void (*set_width_for_control)(ply_label_plugin_control_t *label,
+                                      long                        width);
 } ply_label_plugin_interface_t;
 
 #endif /* PLY_LABEL_PLUGIN_H */
diff --git a/src/libply-splash-graphics/ply-label.c b/src/libply-splash-graphics/ply-label.c
index c82a9d2..cfc8098 100644
--- a/src/libply-splash-graphics/ply-label.c
+++ b/src/libply-splash-graphics/ply-label.c
@@ -40,147 +40,141 @@
 
 struct _ply_label
 {
-  ply_event_loop_t *loop;
-  ply_module_handle_t *module_handle;
-  const ply_label_plugin_interface_t *plugin_interface;
-  ply_label_plugin_control_t *control;
-
-  char *text;
-  ply_label_alignment_t alignment;
-  long width;
-  char *fontdesc;
-  float red;
-  float green;
-  float blue;
-  float alpha;
+        ply_event_loop_t                   *loop;
+        ply_module_handle_t                *module_handle;
+        const ply_label_plugin_interface_t *plugin_interface;
+        ply_label_plugin_control_t         *control;
+
+        char                               *text;
+        ply_label_alignment_t               alignment;
+        long                                width;
+        char                               *fontdesc;
+        float                               red;
+        float                               green;
+        float                               blue;
+        float                               alpha;
 };
 
 typedef const ply_label_plugin_interface_t *
-        (* get_plugin_interface_function_t) (void);
+(*get_plugin_interface_function_t) (void);
 
 static void ply_label_unload_plugin (ply_label_t *label);
 
 ply_label_t *
 ply_label_new (void)
 {
-  ply_label_t *label;
-
-  label = calloc (1, sizeof (struct _ply_label));
-  label->red = 1;
-  label->green = 1;
-  label->blue = 1;
-  label->alpha = 1;
-  label->alignment = PLY_LABEL_ALIGN_LEFT;
-  label->width = -1;
-  return label;
+        ply_label_t *label;
+
+        label = calloc (1, sizeof(struct _ply_label));
+        label->red = 1;
+        label->green = 1;
+        label->blue = 1;
+        label->alpha = 1;
+        label->alignment = PLY_LABEL_ALIGN_LEFT;
+        label->width = -1;
+        return label;
 }
 
 void
 ply_label_free (ply_label_t *label)
 {
-  if (label == NULL)
-    return;
+        if (label == NULL)
+                return;
 
-  if (label->plugin_interface != NULL)
-    {
-      ply_trace ("Unloading label control plugin");
-      ply_label_unload_plugin (label);
-    }
-
-  free (label);
+        if (label->plugin_interface != NULL) {
+                ply_trace ("Unloading label control plugin");
+                ply_label_unload_plugin (label);
+        }
 
+        free (label);
 }
 
 static bool
 ply_label_load_plugin (ply_label_t *label)
 {
-  assert (label != NULL);
-
-  get_plugin_interface_function_t get_label_plugin_interface;
-
-  label->module_handle = ply_open_module (PLYMOUTH_PLUGIN_PATH "label.so");
-
-  if (label->module_handle == NULL)
-    return false;
-
-  get_label_plugin_interface = (get_plugin_interface_function_t)
-      ply_module_look_up_function (label->module_handle,
-                                   "ply_label_plugin_get_interface");
-
-  if (get_label_plugin_interface == NULL)
-    {
-      ply_save_errno ();
-      ply_close_module (label->module_handle);
-      label->module_handle = NULL;
-      ply_restore_errno ();
-      return false;
-    }
-
-  label->plugin_interface = get_label_plugin_interface ();
-
-  if (label->plugin_interface == NULL)
-    {
-      ply_save_errno ();
-      ply_close_module (label->module_handle);
-      label->module_handle = NULL;
-      ply_restore_errno ();
-      return false;
-    }
-
-  label->control = label->plugin_interface->create_control ();
-
-  if (label->text != NULL)
-    label->plugin_interface->set_text_for_control (label->control,
-                                                   label->text);
-  label->plugin_interface->set_alignment_for_control (label->control,
-                                                      label->alignment);
-  label->plugin_interface->set_width_for_control (label->control,
-                                                  label->width);
-  if (label->fontdesc != NULL)
-    label->plugin_interface->set_font_for_control (label->control,
-                                                   label->fontdesc);
-
-  label->plugin_interface->set_color_for_control (label->control,
-                                                  label->red,
-                                                  label->green,
-                                                  label->blue,
-                                                  label->alpha);
-  return true;
+        assert (label != NULL);
+
+        get_plugin_interface_function_t get_label_plugin_interface;
+
+        label->module_handle = ply_open_module (PLYMOUTH_PLUGIN_PATH "label.so");
+
+        if (label->module_handle == NULL)
+                return false;
+
+        get_label_plugin_interface = (get_plugin_interface_function_t)
+                                     ply_module_look_up_function (label->module_handle,
+                                                                  "ply_label_plugin_get_interface");
+
+        if (get_label_plugin_interface == NULL) {
+                ply_save_errno ();
+                ply_close_module (label->module_handle);
+                label->module_handle = NULL;
+                ply_restore_errno ();
+                return false;
+        }
+
+        label->plugin_interface = get_label_plugin_interface ();
+
+        if (label->plugin_interface == NULL) {
+                ply_save_errno ();
+                ply_close_module (label->module_handle);
+                label->module_handle = NULL;
+                ply_restore_errno ();
+                return false;
+        }
+
+        label->control = label->plugin_interface->create_control ();
+
+        if (label->text != NULL)
+                label->plugin_interface->set_text_for_control (label->control,
+                                                               label->text);
+        label->plugin_interface->set_alignment_for_control (label->control,
+                                                            label->alignment);
+        label->plugin_interface->set_width_for_control (label->control,
+                                                        label->width);
+        if (label->fontdesc != NULL)
+                label->plugin_interface->set_font_for_control (label->control,
+                                                               label->fontdesc);
+
+        label->plugin_interface->set_color_for_control (label->control,
+                                                        label->red,
+                                                        label->green,
+                                                        label->blue,
+                                                        label->alpha);
+        return true;
 }
 
 static void
 ply_label_unload_plugin (ply_label_t *label)
 {
-  assert (label != NULL);
-  assert (label->plugin_interface != NULL);
-  assert (label->module_handle != NULL);
+        assert (label != NULL);
+        assert (label->plugin_interface != NULL);
+        assert (label->module_handle != NULL);
 
-  ply_close_module (label->module_handle);
-  label->plugin_interface = NULL;
-  label->module_handle = NULL;
+        ply_close_module (label->module_handle);
+        label->plugin_interface = NULL;
+        label->module_handle = NULL;
 }
 
 bool
-ply_label_show (ply_label_t        *label,
+ply_label_show (ply_label_t         *label,
                 ply_pixel_display_t *display,
-                long                x,
-                long                y)
+                long                 x,
+                long                 y)
 {
-  if (label->plugin_interface == NULL)
-    {
-      if (!ply_label_load_plugin (label))
-        return false;
-    }
-
-  return label->plugin_interface->show_control (label->control,
-                                                display, x, y);
+        if (label->plugin_interface == NULL)
+                if (!ply_label_load_plugin (label))
+                        return false;
+
+        return label->plugin_interface->show_control (label->control,
+                                                      display, x, y);
 }
 
 void
 ply_label_draw (ply_label_t *label)
 {
-  if (label->plugin_interface == NULL)
-    return;
+        if (label->plugin_interface == NULL)
+                return;
 }
 
 void
@@ -191,71 +185,70 @@ ply_label_draw_area (ply_label_t        *label,
                      unsigned long       width,
                      unsigned long       height)
 {
-  if (label->plugin_interface == NULL)
-    return;
+        if (label->plugin_interface == NULL)
+                return;
 
-  label->plugin_interface->draw_control (label->control,
-                                         buffer,
-                                         x, y, width, height);
+        label->plugin_interface->draw_control (label->control,
+                                               buffer,
+                                               x, y, width, height);
 }
 
 void
 ply_label_hide (ply_label_t *label)
 {
-  if (label->plugin_interface == NULL)
-    return;
+        if (label->plugin_interface == NULL)
+                return;
 
-  label->plugin_interface->hide_control (label->control);
+        label->plugin_interface->hide_control (label->control);
 }
 
 bool
 ply_label_is_hidden (ply_label_t *label)
 {
-  if (label->plugin_interface == NULL)
-    return true;
+        if (label->plugin_interface == NULL)
+                return true;
 
-  return label->plugin_interface->is_control_hidden (label->control);
+        return label->plugin_interface->is_control_hidden (label->control);
 }
 
 void
 ply_label_set_text (ply_label_t *label,
                     const char  *text)
 {
+        free (label->text);
+        label->text = strdup (text);
 
-  free (label->text);
-  label->text = strdup (text);
+        if (label->plugin_interface == NULL)
+                return;
 
-  if (label->plugin_interface == NULL)
-    return;
-
-  label->plugin_interface->set_text_for_control (label->control,
-                                                 text);
+        label->plugin_interface->set_text_for_control (label->control,
+                                                       text);
 }
 
 void
-ply_label_set_alignment (ply_label_t           *label,
-                         ply_label_alignment_t  alignment)
+ply_label_set_alignment (ply_label_t          *label,
+                         ply_label_alignment_t alignment)
 {
-  label->alignment = alignment;
+        label->alignment = alignment;
 
-  if (label->plugin_interface == NULL)
-    return;
+        if (label->plugin_interface == NULL)
+                return;
 
-  label->plugin_interface->set_alignment_for_control (label->control,
-                                                      alignment);
+        label->plugin_interface->set_alignment_for_control (label->control,
+                                                            alignment);
 }
 
 void
-ply_label_set_width (ply_label_t  *label,
-                     long          width)
+ply_label_set_width (ply_label_t *label,
+                     long         width)
 {
-  label->width = width;
+        label->width = width;
 
-  if (label->plugin_interface == NULL)
-    return;
+        if (label->plugin_interface == NULL)
+                return;
 
-  label->plugin_interface->set_width_for_control (label->control,
-                                                  width);
+        label->plugin_interface->set_width_for_control (label->control,
+                                                        width);
 }
 
 /*
@@ -267,18 +260,17 @@ void
 ply_label_set_font (ply_label_t *label,
                     const char  *fontdesc)
 {
+        free (label->fontdesc);
+        if (fontdesc)
+                label->fontdesc = strdup (fontdesc);
+        else
+                label->fontdesc = NULL;
 
-  free (label->fontdesc);
-  if (fontdesc)
-    label->fontdesc = strdup (fontdesc);
-  else
-    label->fontdesc = NULL;
-
-  if (label->plugin_interface == NULL)
-    return;
+        if (label->plugin_interface == NULL)
+                return;
 
-  label->plugin_interface->set_font_for_control (label->control,
-                                                 fontdesc);
+        label->plugin_interface->set_font_for_control (label->control,
+                                                       fontdesc);
 }
 
 void
@@ -288,36 +280,36 @@ ply_label_set_color (ply_label_t *label,
                      float        blue,
                      float        alpha)
 {
-  label->red = red;
-  label->green = green;
-  label->blue = blue;
-  label->alpha = alpha;
-
-  if (label->plugin_interface == NULL)
-    return;
-
-  label->plugin_interface->set_color_for_control (label->control,
-                                                  red,
-                                                  green,
-                                                  blue,
-                                                  alpha);
+        label->red = red;
+        label->green = green;
+        label->blue = blue;
+        label->alpha = alpha;
+
+        if (label->plugin_interface == NULL)
+                return;
+
+        label->plugin_interface->set_color_for_control (label->control,
+                                                        red,
+                                                        green,
+                                                        blue,
+                                                        alpha);
 }
 
 long
 ply_label_get_width (ply_label_t *label)
 {
-  if (label->plugin_interface == NULL)
-    return 0;
+        if (label->plugin_interface == NULL)
+                return 0;
 
-  return label->plugin_interface->get_width_of_control (label->control);
+        return label->plugin_interface->get_width_of_control (label->control);
 }
 
 long
 ply_label_get_height (ply_label_t *label)
 {
-  if (label->plugin_interface == NULL)
-    return 0;
+        if (label->plugin_interface == NULL)
+                return 0;
 
-  return label->plugin_interface->get_height_of_control (label->control);
+        return label->plugin_interface->get_height_of_control (label->control);
 }
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-graphics/ply-label.h b/src/libply-splash-graphics/ply-label.h
index ecafb71..05061bb 100644
--- a/src/libply-splash-graphics/ply-label.h
+++ b/src/libply-splash-graphics/ply-label.h
@@ -32,23 +32,24 @@
 
 typedef struct _ply_label ply_label_t;
 
-typedef enum {
-  PLY_LABEL_ALIGN_LEFT,
-  PLY_LABEL_ALIGN_CENTER,
-  PLY_LABEL_ALIGN_RIGHT
+typedef enum
+{
+        PLY_LABEL_ALIGN_LEFT,
+        PLY_LABEL_ALIGN_CENTER,
+        PLY_LABEL_ALIGN_RIGHT
 } ply_label_alignment_t;
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_label_t *ply_label_new (void);
 void ply_label_free (ply_label_t *label);
 
-bool ply_label_show (ply_label_t        *label,
+bool ply_label_show (ply_label_t         *label,
                      ply_pixel_display_t *display,
-                     long                x,
-                     long                y);
+                     long                 x,
+                     long                 y);
 
 void ply_label_hide (ply_label_t *label);
-void ply_label_draw (ply_label_t      *label);
+void ply_label_draw (ply_label_t *label);
 void ply_label_draw_area (ply_label_t        *label,
                           ply_pixel_buffer_t *buffer,
                           long                x,
@@ -59,10 +60,10 @@ bool ply_label_is_hidden (ply_label_t *label);
 
 void ply_label_set_text (ply_label_t *label,
                          const char  *text);
-void ply_label_set_alignment (ply_label_t           *label,
-                              ply_label_alignment_t  alignment);
-void ply_label_set_width (ply_label_t   *label,
-                          long          width);
+void ply_label_set_alignment (ply_label_t          *label,
+                              ply_label_alignment_t alignment);
+void ply_label_set_width (ply_label_t *label,
+                          long         width);
 void ply_label_set_font (ply_label_t *label,
                          const char  *fontdesc);
 void ply_label_set_color (ply_label_t *label,
diff --git a/src/libply-splash-graphics/ply-progress-animation.c b/src/libply-splash-graphics/ply-progress-animation.c
index 2605f6d..bcbca3f 100644
--- a/src/libply-splash-graphics/ply-progress-animation.c
+++ b/src/libply-splash-graphics/ply-progress-animation.c
@@ -51,138 +51,136 @@
 
 struct _ply_progress_animation
 {
-  ply_array_t *frames;
-  char *image_dir;
-  char *frames_prefix;
+        ply_array_t                        *frames;
+        char                               *image_dir;
+        char                               *frames_prefix;
 
-  ply_progress_animation_transition_t transition;
-  double transition_duration;
+        ply_progress_animation_transition_t transition;
+        double                              transition_duration;
 
-  ply_pixel_display_t *display;
-  ply_rectangle_t  area;
-  ply_rectangle_t  frame_area;
+        ply_pixel_display_t                *display;
+        ply_rectangle_t                     area;
+        ply_rectangle_t                     frame_area;
 
-  double percent_done;
-  int previous_frame_number;
+        double                              percent_done;
+        int                                 previous_frame_number;
 
-  double transition_start_time;
+        double                              transition_start_time;
 
-  ply_pixel_buffer_t *last_rendered_frame;
+        ply_pixel_buffer_t                 *last_rendered_frame;
 
-  uint32_t is_hidden : 1;
-  uint32_t is_transitioning : 1;
+        uint32_t                            is_hidden : 1;
+        uint32_t                            is_transitioning : 1;
 };
 
 ply_progress_animation_t *
 ply_progress_animation_new (const char *image_dir,
                             const char *frames_prefix)
 {
-  ply_progress_animation_t *progress_animation;
-
-  assert (image_dir != NULL);
-  assert (frames_prefix != NULL);
-
-  progress_animation = calloc (1, sizeof (ply_progress_animation_t));
-
-  progress_animation->frames = ply_array_new (PLY_ARRAY_ELEMENT_TYPE_POINTER);
-  progress_animation->frames_prefix = strdup (frames_prefix);
-  progress_animation->image_dir = strdup (image_dir);
-  progress_animation->is_hidden = true;
-  progress_animation->percent_done = 0.0;
-  progress_animation->area.x = 0;
-  progress_animation->area.y = 0;
-  progress_animation->area.width = 0;
-  progress_animation->area.height = 0;
-  progress_animation->frame_area.x = 0;
-  progress_animation->frame_area.y = 0;
-  progress_animation->frame_area.width = 0;
-  progress_animation->frame_area.height = 0;
-  progress_animation->previous_frame_number = 0;
-  progress_animation->last_rendered_frame = NULL;
-
-  return progress_animation;
+        ply_progress_animation_t *progress_animation;
+
+        assert (image_dir != NULL);
+        assert (frames_prefix != NULL);
+
+        progress_animation = calloc (1, sizeof(ply_progress_animation_t));
+
+        progress_animation->frames = ply_array_new (PLY_ARRAY_ELEMENT_TYPE_POINTER);
+        progress_animation->frames_prefix = strdup (frames_prefix);
+        progress_animation->image_dir = strdup (image_dir);
+        progress_animation->is_hidden = true;
+        progress_animation->percent_done = 0.0;
+        progress_animation->area.x = 0;
+        progress_animation->area.y = 0;
+        progress_animation->area.width = 0;
+        progress_animation->area.height = 0;
+        progress_animation->frame_area.x = 0;
+        progress_animation->frame_area.y = 0;
+        progress_animation->frame_area.width = 0;
+        progress_animation->frame_area.height = 0;
+        progress_animation->previous_frame_number = 0;
+        progress_animation->last_rendered_frame = NULL;
+
+        return progress_animation;
 }
 
 void
-ply_progress_animation_set_transition (ply_progress_animation_t *progress_animation,
+ply_progress_animation_set_transition (ply_progress_animation_t           *progress_animation,
                                        ply_progress_animation_transition_t transition,
-                                       double                    duration)
+                                       double                              duration)
 {
-  progress_animation->transition = transition;
-  progress_animation->transition_duration = duration;
+        progress_animation->transition = transition;
+        progress_animation->transition_duration = duration;
 }
 
 static void
 ply_progress_animation_remove_frames (ply_progress_animation_t *progress_animation)
 {
-  int i;
-  ply_image_t **frames;
+        int i;
+        ply_image_t **frames;
 
-  frames = (ply_image_t **) ply_array_steal_pointer_elements (progress_animation->frames);
-  for (i = 0; frames[i] != NULL; i++)
-    ply_image_free (frames[i]);
-  free (frames);
+        frames = (ply_image_t **) ply_array_steal_pointer_elements (progress_animation->frames);
+        for (i = 0; frames[i] != NULL; i++) {
+                ply_image_free (frames[i]);
+        }
+        free (frames);
 }
 
 void
 ply_progress_animation_free (ply_progress_animation_t *progress_animation)
 {
-  if (progress_animation == NULL)
-    return;
+        if (progress_animation == NULL)
+                return;
 
-  ply_progress_animation_remove_frames (progress_animation);
-  ply_array_free (progress_animation->frames);
+        ply_progress_animation_remove_frames (progress_animation);
+        ply_array_free (progress_animation->frames);
 
-  free (progress_animation->frames_prefix);
-  free (progress_animation->image_dir);
-  free (progress_animation);
+        free (progress_animation->frames_prefix);
+        free (progress_animation->image_dir);
+        free (progress_animation);
 }
 
 static void
-image_fade_merge (ply_image_t* frame0,
-                  ply_image_t* frame1,
+image_fade_merge (ply_image_t *frame0,
+                  ply_image_t *frame1,
                   float        fade,
                   int          width,
                   int          height,
                   uint32_t    *reply_data)
 {
-  int frame0_width = ply_image_get_width (frame0);
-  int frame0_height = ply_image_get_height (frame0);
-  int frame1_width = ply_image_get_width (frame1);
-  int frame1_height = ply_image_get_height (frame1);
-
-  uint32_t *frame0_data = ply_image_get_data (frame0);
-  uint32_t *frame1_data = ply_image_get_data (frame1);
-
-  int x, y, i;
-
-  for (y = 0; y < height; y++)
-    {
-      for (x = 0; x < width; x++)
-        {
-          uint32_t pixel0, pixel1, pixelout;
-          
-          if (y < frame0_height && x < frame0_width)
-            pixel0 = frame0_data[y*frame0_width+x];
-          else 
-            pixel0 = 0;
-          
-          if (y < frame1_height && x < frame1_width)
-            pixel1 = frame1_data[y*frame1_width+x];
-          else 
-            pixel1 = 0;
-            
-          pixelout = 0;
-          for (i = 0; i < 4; i++)
-            {
-              int subval0 = (pixel0 >> (i * 8)) & 0xFF;
-              int subval1 = (pixel1 >> (i * 8)) & 0xFF;
-              int subvalout = subval0 * (1-fade) + subval1 * fade;
-              pixelout |= (subvalout & 0xFF) << (i * 8);
-            }
-          reply_data[y*width+x] = pixelout;
+        int frame0_width = ply_image_get_width (frame0);
+        int frame0_height = ply_image_get_height (frame0);
+        int frame1_width = ply_image_get_width (frame1);
+        int frame1_height = ply_image_get_height (frame1);
+
+        uint32_t *frame0_data = ply_image_get_data (frame0);
+        uint32_t *frame1_data = ply_image_get_data (frame1);
+
+        int x, y, i;
+
+        for (y = 0; y < height; y++) {
+                for (x = 0; x < width; x++) {
+                        uint32_t pixel0, pixel1, pixelout;
+
+                        if (y < frame0_height && x < frame0_width)
+                                pixel0 = frame0_data[y * frame0_width + x];
+                        else
+                                pixel0 = 0;
+
+                        if (y < frame1_height && x < frame1_width)
+                                pixel1 = frame1_data[y * frame1_width + x];
+                        else
+                                pixel1 = 0;
+
+                        pixelout = 0;
+                        for (i = 0; i < 4; i++) {
+                                int subval0 = (pixel0 >> (i * 8)) & 0xFF;
+                                int subval1 = (pixel1 >> (i * 8)) & 0xFF;
+                                int subvalout = subval0 * (1 - fade) + subval1 * fade;
+                                pixelout |= (subvalout & 0xFF) << (i * 8);
+                        }
+                        reply_data[y * width + x] = pixelout;
+                }
         }
-    }
 }
 
 void
@@ -193,234 +191,216 @@ ply_progress_animation_draw_area (ply_progress_animation_t *progress_animation,
                                   unsigned long             width,
                                   unsigned long             height)
 {
-  if (progress_animation->is_hidden)
-    return;
+        if (progress_animation->is_hidden)
+                return;
 
-  ply_pixel_buffer_fill_with_buffer (buffer,
-                                     progress_animation->last_rendered_frame,
-                                     progress_animation->frame_area.x,
-                                     progress_animation->frame_area.y);
+        ply_pixel_buffer_fill_with_buffer (buffer,
+                                           progress_animation->last_rendered_frame,
+                                           progress_animation->frame_area.x,
+                                           progress_animation->frame_area.y);
 }
 
 void
 ply_progress_animation_draw (ply_progress_animation_t *progress_animation)
 {
-  int number_of_frames;
-  int frame_number;
-  ply_image_t * const * frames;
-  ply_pixel_buffer_t *previous_frame_buffer, *current_frame_buffer;
-
-  if (progress_animation->is_hidden)
-    return;
-
-  number_of_frames = ply_array_get_size (progress_animation->frames);
-
-  if (number_of_frames == 0)
-    return;
-
-  frame_number = progress_animation->percent_done * (number_of_frames - 1);
-
-  if (progress_animation->previous_frame_number != frame_number &&
-      progress_animation->transition != PLY_PROGRESS_ANIMATION_TRANSITION_NONE &&
-      progress_animation->transition_duration > 0.0)
-    {
-      progress_animation->is_transitioning = true;
-      progress_animation->transition_start_time = ply_get_timestamp ();
-    }
-
-  frames = (ply_image_t * const *) ply_array_get_pointer_elements (progress_animation->frames);
-
-  progress_animation->frame_area.x = progress_animation->area.x;
-  progress_animation->frame_area.y = progress_animation->area.y;
-  current_frame_buffer = ply_image_get_buffer (frames[frame_number]);
-
-  if (progress_animation->is_transitioning)
-    {
-      double now;
-      double fade_percentage;
-      double fade_out_opacity;
-      int width, height;
-      uint32_t* faded_data;
-      now = ply_get_timestamp ();
-
-      fade_percentage = (now - progress_animation->transition_start_time) / progress_animation->transition_duration;
-
-      if (fade_percentage >= 1.0)
-        progress_animation->is_transitioning = false;
-      fade_percentage = CLAMP (fade_percentage, 0.0, 1.0);
-
-      if (progress_animation->transition == PLY_PROGRESS_ANIMATION_TRANSITION_MERGE_FADE)
-        {
-          width = MAX(ply_image_get_width (frames[frame_number]), ply_image_get_width (frames[frame_number - 1]));
-          height = MAX(ply_image_get_height (frames[frame_number]), ply_image_get_height (frames[frame_number - 1]));
-          progress_animation->frame_area.width = width;
-          progress_animation->frame_area.height = height;
-
-          ply_pixel_buffer_free (progress_animation->last_rendered_frame);
-          progress_animation->last_rendered_frame = ply_pixel_buffer_new (width, height);
-          faded_data = ply_pixel_buffer_get_argb32_data (progress_animation->last_rendered_frame);
-
-          image_fade_merge (frames[frame_number - 1], frames[frame_number], fade_percentage, width, height, faded_data);
+        int number_of_frames;
+        int frame_number;
+        ply_image_t *const *frames;
+        ply_pixel_buffer_t *previous_frame_buffer, *current_frame_buffer;
+
+        if (progress_animation->is_hidden)
+                return;
+
+        number_of_frames = ply_array_get_size (progress_animation->frames);
+
+        if (number_of_frames == 0)
+                return;
+
+        frame_number = progress_animation->percent_done * (number_of_frames - 1);
+
+        if (progress_animation->previous_frame_number != frame_number &&
+            progress_animation->transition != PLY_PROGRESS_ANIMATION_TRANSITION_NONE &&
+            progress_animation->transition_duration > 0.0) {
+                progress_animation->is_transitioning = true;
+                progress_animation->transition_start_time = ply_get_timestamp ();
         }
-      else
-        {
-          previous_frame_buffer = ply_image_get_buffer (frames[frame_number - 1]);
-          if (progress_animation->transition == PLY_PROGRESS_ANIMATION_TRANSITION_FADE_OVER)
-            {
-              ply_pixel_buffer_free (progress_animation->last_rendered_frame);
-              progress_animation->last_rendered_frame = ply_pixel_buffer_new (ply_image_get_width (frames[frame_number - 1]),
-                                                                              ply_image_get_height (frames[frame_number - 1]));
-              ply_pixel_buffer_fill_with_buffer (progress_animation->last_rendered_frame,
-                                                 previous_frame_buffer,
-                                                 0,
-                                                 0);
-            }
-          else
-            {
-              fade_out_opacity = 1.0 - fade_percentage;
-              ply_pixel_buffer_fill_with_buffer_at_opacity (progress_animation->last_rendered_frame,
-                                                            previous_frame_buffer,
-                                                            0,
-                                                            0,
-                                                            fade_out_opacity);
-            }
-
-          ply_pixel_buffer_fill_with_buffer_at_opacity (progress_animation->last_rendered_frame,
-                                                        current_frame_buffer,
-                                                        0,
-                                                        0,
-                                                        fade_percentage);
-
-          width = MAX(ply_image_get_width (frames[frame_number]), ply_image_get_width (frames[frame_number - 1]));
-          height = MAX(ply_image_get_height (frames[frame_number]), ply_image_get_height (frames[frame_number - 1]));
-          progress_animation->frame_area.width = width;
-          progress_animation->frame_area.height = height;
+
+        frames = (ply_image_t *const *) ply_array_get_pointer_elements (progress_animation->frames);
+
+        progress_animation->frame_area.x = progress_animation->area.x;
+        progress_animation->frame_area.y = progress_animation->area.y;
+        current_frame_buffer = ply_image_get_buffer (frames[frame_number]);
+
+        if (progress_animation->is_transitioning) {
+                double now;
+                double fade_percentage;
+                double fade_out_opacity;
+                int width, height;
+                uint32_t *faded_data;
+                now = ply_get_timestamp ();
+
+                fade_percentage = (now - progress_animation->transition_start_time) / progress_animation->transition_duration;
+
+                if (fade_percentage >= 1.0)
+                        progress_animation->is_transitioning = false;
+                fade_percentage = CLAMP (fade_percentage, 0.0, 1.0);
+
+                if (progress_animation->transition == PLY_PROGRESS_ANIMATION_TRANSITION_MERGE_FADE) {
+                        width = MAX (ply_image_get_width (frames[frame_number]), ply_image_get_width (frames[frame_number - 1]));
+                        height = MAX (ply_image_get_height (frames[frame_number]), ply_image_get_height (frames[frame_number - 1]));
+                        progress_animation->frame_area.width = width;
+                        progress_animation->frame_area.height = height;
+
+                        ply_pixel_buffer_free (progress_animation->last_rendered_frame);
+                        progress_animation->last_rendered_frame = ply_pixel_buffer_new (width, height);
+                        faded_data = ply_pixel_buffer_get_argb32_data (progress_animation->last_rendered_frame);
+
+                        image_fade_merge (frames[frame_number - 1], frames[frame_number], fade_percentage, width, height, faded_data);
+                } else {
+                        previous_frame_buffer = ply_image_get_buffer (frames[frame_number - 1]);
+                        if (progress_animation->transition == PLY_PROGRESS_ANIMATION_TRANSITION_FADE_OVER) {
+                                ply_pixel_buffer_free (progress_animation->last_rendered_frame);
+                                progress_animation->last_rendered_frame = ply_pixel_buffer_new (ply_image_get_width (frames[frame_number - 1]),
+                                                                                                ply_image_get_height (frames[frame_number - 1]));
+                                ply_pixel_buffer_fill_with_buffer (progress_animation->last_rendered_frame,
+                                                                   previous_frame_buffer,
+                                                                   0,
+                                                                   0);
+                        } else {
+                                fade_out_opacity = 1.0 - fade_percentage;
+                                ply_pixel_buffer_fill_with_buffer_at_opacity (progress_animation->last_rendered_frame,
+                                                                              previous_frame_buffer,
+                                                                              0,
+                                                                              0,
+                                                                              fade_out_opacity);
+                        }
+
+                        ply_pixel_buffer_fill_with_buffer_at_opacity (progress_animation->last_rendered_frame,
+                                                                      current_frame_buffer,
+                                                                      0,
+                                                                      0,
+                                                                      fade_percentage);
+
+                        width = MAX (ply_image_get_width (frames[frame_number]), ply_image_get_width (frames[frame_number - 1]));
+                        height = MAX (ply_image_get_height (frames[frame_number]), ply_image_get_height (frames[frame_number - 1]));
+                        progress_animation->frame_area.width = width;
+                        progress_animation->frame_area.height = height;
+                }
+        } else {
+                ply_pixel_buffer_free (progress_animation->last_rendered_frame);
+                progress_animation->frame_area.width = ply_image_get_width (frames[frame_number]);
+                progress_animation->frame_area.height = ply_image_get_height (frames[frame_number]);
+                progress_animation->last_rendered_frame = ply_pixel_buffer_new (progress_animation->frame_area.width,
+                                                                                progress_animation->frame_area.height);
+
+                ply_pixel_buffer_fill_with_buffer (progress_animation->last_rendered_frame,
+                                                   current_frame_buffer,
+                                                   0,
+                                                   0);
         }
-    }
-  else
-    {
-      ply_pixel_buffer_free (progress_animation->last_rendered_frame);
-      progress_animation->frame_area.width = ply_image_get_width (frames[frame_number]);
-      progress_animation->frame_area.height = ply_image_get_height (frames[frame_number]);
-      progress_animation->last_rendered_frame = ply_pixel_buffer_new (progress_animation->frame_area.width,
-                                                                      progress_animation->frame_area.height);
-
-      ply_pixel_buffer_fill_with_buffer (progress_animation->last_rendered_frame,
-                                         current_frame_buffer,
-                                         0,
-                                         0);
-    }
-
-  progress_animation->previous_frame_number = frame_number;
-
-  ply_pixel_display_draw_area (progress_animation->display,
-                               progress_animation->frame_area.x,
-                               progress_animation->frame_area.y,
-                               progress_animation->frame_area.width,
-                               progress_animation->frame_area.height);
+
+        progress_animation->previous_frame_number = frame_number;
+
+        ply_pixel_display_draw_area (progress_animation->display,
+                                     progress_animation->frame_area.x,
+                                     progress_animation->frame_area.y,
+                                     progress_animation->frame_area.width,
+                                     progress_animation->frame_area.height);
 }
 
 static bool
 ply_progress_animation_add_frame (ply_progress_animation_t *progress_animation,
                                   const char               *filename)
 {
-  ply_image_t *image;
+        ply_image_t *image;
 
-  image = ply_image_new (filename);
+        image = ply_image_new (filename);
 
-  if (!ply_image_load (image))
-    {
-      ply_image_free (image);
-      return false;
-    }
+        if (!ply_image_load (image)) {
+                ply_image_free (image);
+                return false;
+        }
 
-  ply_array_add_pointer_element (progress_animation->frames, image);
+        ply_array_add_pointer_element (progress_animation->frames, image);
 
-  progress_animation->area.width = MAX (progress_animation->area.width, (size_t) ply_image_get_width (image));
-  progress_animation->area.height = MAX (progress_animation->area.height, (size_t) ply_image_get_height (image));
+        progress_animation->area.width = MAX (progress_animation->area.width, (size_t) ply_image_get_width (image));
+        progress_animation->area.height = MAX (progress_animation->area.height, (size_t) ply_image_get_height (image));
 
-  return true;
+        return true;
 }
 
 static bool
 ply_progress_animation_add_frames (ply_progress_animation_t *progress_animation)
 {
-  struct dirent **entries;
-  int number_of_entries;
-  int number_of_frames;
-  int i;
-  bool load_finished;
-
-  entries = NULL;
-
-  number_of_entries = scandir (progress_animation->image_dir, &entries, NULL, versionsort);
-
-  if (number_of_entries < 0)
-    return false;
-
-  load_finished = false;
-  for (i = 0; i < number_of_entries; i++)
-    {
-      if (strncmp (entries[i]->d_name,
-                   progress_animation->frames_prefix,
-                   strlen (progress_animation->frames_prefix)) == 0
-          && (strlen (entries[i]->d_name) > 4)
-          && strcmp (entries[i]->d_name + strlen (entries[i]->d_name) - 4, ".png") == 0)
-        {
-          char *filename;
-          bool r;
-
-          filename = NULL;
-          asprintf (&filename, "%s/%s", progress_animation->image_dir, entries[i]->d_name);
-
-          r = ply_progress_animation_add_frame (progress_animation, filename);
-          free (filename);
-          if (!r)
-            goto out;
+        struct dirent **entries;
+        int number_of_entries;
+        int number_of_frames;
+        int i;
+        bool load_finished;
+
+        entries = NULL;
+
+        number_of_entries = scandir (progress_animation->image_dir, &entries, NULL, versionsort);
+
+        if (number_of_entries < 0)
+                return false;
+
+        load_finished = false;
+        for (i = 0; i < number_of_entries; i++) {
+                if (strncmp (entries[i]->d_name,
+                             progress_animation->frames_prefix,
+                             strlen (progress_animation->frames_prefix)) == 0
+                    && (strlen (entries[i]->d_name) > 4)
+                    && strcmp (entries[i]->d_name + strlen (entries[i]->d_name) - 4, ".png") == 0) {
+                        char *filename;
+                        bool r;
+
+                        filename = NULL;
+                        asprintf (&filename, "%s/%s", progress_animation->image_dir, entries[i]->d_name);
+
+                        r = ply_progress_animation_add_frame (progress_animation, filename);
+                        free (filename);
+                        if (!r)
+                                goto out;
+                }
+
+                free (entries[i]);
+                entries[i] = NULL;
         }
 
-      free (entries[i]);
-      entries[i] = NULL;
-    }
-
-  number_of_frames = ply_array_get_size (progress_animation->frames);
-  if (number_of_frames == 0)
-    {
-      ply_trace ("could not find any progress animation frames");
-      load_finished = false;
-    }
-  else
-    {
-      ply_trace ("found %d progress animation frames", number_of_frames);
-      load_finished = true;
-    }
+        number_of_frames = ply_array_get_size (progress_animation->frames);
+        if (number_of_frames == 0) {
+                ply_trace ("could not find any progress animation frames");
+                load_finished = false;
+        } else {
+                ply_trace ("found %d progress animation frames", number_of_frames);
+                load_finished = true;
+        }
 
 out:
-  if (!load_finished)
-    {
-      ply_progress_animation_remove_frames (progress_animation);
-
-      while (i < number_of_entries)
-        {
-          free (entries[i]);
-          i++;
+        if (!load_finished) {
+                ply_progress_animation_remove_frames (progress_animation);
+
+                while (i < number_of_entries) {
+                        free (entries[i]);
+                        i++;
+                }
         }
-    }
-  free (entries);
+        free (entries);
 
-  return load_finished;
+        return load_finished;
 }
 
 bool
 ply_progress_animation_load (ply_progress_animation_t *progress_animation)
 {
-  if (ply_array_get_size (progress_animation->frames) != 0)
-    ply_progress_animation_remove_frames (progress_animation);
+        if (ply_array_get_size (progress_animation->frames) != 0)
+                ply_progress_animation_remove_frames (progress_animation);
 
-  if (!ply_progress_animation_add_frames (progress_animation))
-    return false;
+        if (!ply_progress_animation_add_frames (progress_animation))
+                return false;
 
-  return true;
+        return true;
 }
 
 void
@@ -429,65 +409,64 @@ ply_progress_animation_show (ply_progress_animation_t *progress_animation,
                              long                      x,
                              long                      y)
 {
-  assert (progress_animation != NULL);
+        assert (progress_animation != NULL);
 
-  progress_animation->display = display;
+        progress_animation->display = display;
 
-  progress_animation->area.x = x;
-  progress_animation->area.y = y;
+        progress_animation->area.x = x;
+        progress_animation->area.y = y;
 
-  progress_animation->is_hidden = false;
-  ply_progress_animation_draw (progress_animation);
+        progress_animation->is_hidden = false;
+        ply_progress_animation_draw (progress_animation);
 }
 
 void
 ply_progress_animation_hide (ply_progress_animation_t *progress_animation)
 {
-  if (progress_animation->is_hidden)
-    return;
-
-  progress_animation->is_hidden = true;
-  if (progress_animation->frame_area.width > 0)
-    {
-      ply_pixel_display_draw_area (progress_animation->display,
-                                   progress_animation->area.x, progress_animation->area.y,
-                                   progress_animation->frame_area.width,
-                                   progress_animation->frame_area.height);
-    }
-
-  progress_animation->display = NULL;
+        if (progress_animation->is_hidden)
+                return;
+
+        progress_animation->is_hidden = true;
+        if (progress_animation->frame_area.width > 0) {
+                ply_pixel_display_draw_area (progress_animation->display,
+                                             progress_animation->area.x, progress_animation->area.y,
+                                             progress_animation->frame_area.width,
+                                             progress_animation->frame_area.height);
+        }
+
+        progress_animation->display = NULL;
 }
 
 bool
 ply_progress_animation_is_hidden (ply_progress_animation_t *progress_animation)
 {
-  return progress_animation->is_hidden;
+        return progress_animation->is_hidden;
 }
 
 long
 ply_progress_animation_get_width (ply_progress_animation_t *progress_animation)
 {
-  return progress_animation->area.width;
+        return progress_animation->area.width;
 }
 
 long
 ply_progress_animation_get_height (ply_progress_animation_t *progress_animation)
 {
-  return progress_animation->area.height;
+        return progress_animation->area.height;
 }
 
 void
 ply_progress_animation_set_percent_done (ply_progress_animation_t *progress_animation,
-                                         double            percent_done)
+                                         double                    percent_done)
 {
-  progress_animation->percent_done = percent_done;
-  ply_progress_animation_draw (progress_animation);
+        progress_animation->percent_done = percent_done;
+        ply_progress_animation_draw (progress_animation);
 }
 
 double
 ply_progress_animation_get_percent_done (ply_progress_animation_t *progress_animation)
 {
-  return progress_animation->percent_done;
+        return progress_animation->percent_done;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-graphics/ply-progress-animation.h b/src/libply-splash-graphics/ply-progress-animation.h
index 274bd1c..d10c517 100644
--- a/src/libply-splash-graphics/ply-progress-animation.h
+++ b/src/libply-splash-graphics/ply-progress-animation.h
@@ -32,10 +32,10 @@ typedef struct _ply_progress_animation ply_progress_animation_t;
 
 typedef enum
 {
-  PLY_PROGRESS_ANIMATION_TRANSITION_NONE,
-  PLY_PROGRESS_ANIMATION_TRANSITION_FADE_OVER,
-  PLY_PROGRESS_ANIMATION_TRANSITION_CROSS_FADE,
-  PLY_PROGRESS_ANIMATION_TRANSITION_MERGE_FADE,
+        PLY_PROGRESS_ANIMATION_TRANSITION_NONE,
+        PLY_PROGRESS_ANIMATION_TRANSITION_FADE_OVER,
+        PLY_PROGRESS_ANIMATION_TRANSITION_CROSS_FADE,
+        PLY_PROGRESS_ANIMATION_TRANSITION_MERGE_FADE,
 } ply_progress_animation_transition_t;
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
@@ -44,9 +44,9 @@ ply_progress_animation_t *ply_progress_animation_new (const char *image_dir,
 void ply_progress_animation_free (ply_progress_animation_t *progress_animation);
 
 bool ply_progress_animation_load (ply_progress_animation_t *progress_animation);
-void ply_progress_animation_set_transition (ply_progress_animation_t *progress_animation,
+void ply_progress_animation_set_transition (ply_progress_animation_t           *progress_animation,
                                             ply_progress_animation_transition_t transition,
-                                            double                    duration);
+                                            double                              duration);
 void ply_progress_animation_show (ply_progress_animation_t *progress_animation,
                                   ply_pixel_display_t      *display,
                                   long                      x,
diff --git a/src/libply-splash-graphics/ply-progress-bar.c b/src/libply-splash-graphics/ply-progress-bar.c
index 12ca46a..c0b5f9a 100644
--- a/src/libply-splash-graphics/ply-progress-bar.c
+++ b/src/libply-splash-graphics/ply-progress-bar.c
@@ -60,37 +60,37 @@
 
 struct _ply_progress_bar
 {
-  ply_pixel_display_t    *display;
-  ply_rectangle_t  area;
+        ply_pixel_display_t *display;
+        ply_rectangle_t      area;
 
-  double percent_done;
+        double               percent_done;
 
-  uint32_t is_hidden : 1;
+        uint32_t             is_hidden : 1;
 };
 
 ply_progress_bar_t *
 ply_progress_bar_new (void)
 {
-  ply_progress_bar_t *progress_bar;
+        ply_progress_bar_t *progress_bar;
 
-  progress_bar = calloc (1, sizeof (ply_progress_bar_t));
+        progress_bar = calloc (1, sizeof(ply_progress_bar_t));
 
-  progress_bar->is_hidden = true;
-  progress_bar->percent_done = 0.0;
-  progress_bar->area.x = 0;
-  progress_bar->area.y = 0;
-  progress_bar->area.width = 0;
-  progress_bar->area.height = BAR_HEIGHT;
+        progress_bar->is_hidden = true;
+        progress_bar->percent_done = 0.0;
+        progress_bar->area.x = 0;
+        progress_bar->area.y = 0;
+        progress_bar->area.width = 0;
+        progress_bar->area.height = BAR_HEIGHT;
 
-  return progress_bar;
+        return progress_bar;
 }
 
 void
 ply_progress_bar_free (ply_progress_bar_t *progress_bar)
 {
-  if (progress_bar == NULL)
-    return;
-  free (progress_bar);
+        if (progress_bar == NULL)
+                return;
+        free (progress_bar);
 }
 
 static void
@@ -98,14 +98,14 @@ ply_progress_bar_update_area (ply_progress_bar_t *progress_bar,
                               long                x,
                               long                y)
 {
-  unsigned long display_width;
+        unsigned long display_width;
 
-  progress_bar->area.x = x;
-  progress_bar->area.y = y;
-  progress_bar->area.height = BAR_HEIGHT;
+        progress_bar->area.x = x;
+        progress_bar->area.y = y;
+        progress_bar->area.height = BAR_HEIGHT;
 
-  display_width = ply_pixel_display_get_width (progress_bar->display);
-  progress_bar->area.width = (long) (display_width * progress_bar->percent_done);
+        display_width = ply_pixel_display_get_width (progress_bar->display);
+        progress_bar->area.width = (long) (display_width * progress_bar->percent_done);
 }
 
 void
@@ -116,34 +116,34 @@ ply_progress_bar_draw_area (ply_progress_bar_t *progress_bar,
                             unsigned long       width,
                             unsigned long       height)
 {
-  ply_rectangle_t paint_area;
+        ply_rectangle_t paint_area;
 
-  if (progress_bar->is_hidden)
-    return;
+        if (progress_bar->is_hidden)
+                return;
 
-  paint_area.x = x;
-  paint_area.y = y;
-  paint_area.width = width;
-  paint_area.height = height;
+        paint_area.x = x;
+        paint_area.y = y;
+        paint_area.width = width;
+        paint_area.height = height;
 
-  ply_rectangle_intersect (&progress_bar->area, &paint_area, &paint_area);
-  ply_pixel_buffer_fill_with_hex_color (buffer,
-                                        &paint_area,
-                                        0xffffff); /* white */
+        ply_rectangle_intersect (&progress_bar->area, &paint_area, &paint_area);
+        ply_pixel_buffer_fill_with_hex_color (buffer,
+                                              &paint_area,
+                                              0xffffff); /* white */
 }
 
 void
 ply_progress_bar_draw (ply_progress_bar_t *progress_bar)
 {
-  if (progress_bar->is_hidden)
-    return;
-
-  ply_progress_bar_update_area (progress_bar, progress_bar->area.x, progress_bar->area.y);
-  ply_pixel_display_draw_area (progress_bar->display,
-                               progress_bar->area.x,
-                               progress_bar->area.y,
-                               progress_bar->area.width,
-                               progress_bar->area.height);
+        if (progress_bar->is_hidden)
+                return;
+
+        ply_progress_bar_update_area (progress_bar, progress_bar->area.x, progress_bar->area.y);
+        ply_pixel_display_draw_area (progress_bar->display,
+                                     progress_bar->area.x,
+                                     progress_bar->area.y,
+                                     progress_bar->area.width,
+                                     progress_bar->area.height);
 }
 
 void
@@ -152,60 +152,59 @@ ply_progress_bar_show (ply_progress_bar_t  *progress_bar,
                        long                 x,
                        long                 y)
 {
-  assert (progress_bar != NULL);
+        assert (progress_bar != NULL);
 
-  progress_bar->display = display;
+        progress_bar->display = display;
 
-  ply_progress_bar_update_area (progress_bar, x, y);
+        ply_progress_bar_update_area (progress_bar, x, y);
 
-  progress_bar->is_hidden = false;
-  ply_progress_bar_draw (progress_bar);
+        progress_bar->is_hidden = false;
+        ply_progress_bar_draw (progress_bar);
 }
 
 void
 ply_progress_bar_hide (ply_progress_bar_t *progress_bar)
 {
-  if (progress_bar->is_hidden)
-    return;
+        if (progress_bar->is_hidden)
+                return;
 
-  progress_bar->is_hidden = true;
-  ply_pixel_display_draw_area (progress_bar->display,
-                               progress_bar->area.x, progress_bar->area.y,
-                               progress_bar->area.width, progress_bar->area.height);
-
-  progress_bar->display = NULL;
+        progress_bar->is_hidden = true;
+        ply_pixel_display_draw_area (progress_bar->display,
+                                     progress_bar->area.x, progress_bar->area.y,
+                                     progress_bar->area.width, progress_bar->area.height);
 
+        progress_bar->display = NULL;
 }
 
 bool
 ply_progress_bar_is_hidden (ply_progress_bar_t *progress_bar)
 {
-  return progress_bar->is_hidden;
+        return progress_bar->is_hidden;
 }
 
 long
 ply_progress_bar_get_width (ply_progress_bar_t *progress_bar)
 {
-  return progress_bar->area.width;
+        return progress_bar->area.width;
 }
 
 long
 ply_progress_bar_get_height (ply_progress_bar_t *progress_bar)
 {
-  return progress_bar->area.height;
+        return progress_bar->area.height;
 }
 
 void
 ply_progress_bar_set_percent_done (ply_progress_bar_t *progress_bar,
                                    double              percent_done)
 {
-  progress_bar->percent_done = percent_done;
+        progress_bar->percent_done = percent_done;
 }
 
 double
 ply_progress_bar_get_percent_done (ply_progress_bar_t *progress_bar)
 {
-  return progress_bar->percent_done;
+        return progress_bar->percent_done;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-graphics/ply-throbber.c b/src/libply-splash-graphics/ply-throbber.c
index 42044ba..64537fb 100644
--- a/src/libply-splash-graphics/ply-throbber.c
+++ b/src/libply-splash-graphics/ply-throbber.c
@@ -61,306 +61,294 @@
 
 struct _ply_throbber
 {
-  ply_array_t *frames;
-  ply_event_loop_t *loop;
-  char *image_dir;
-  char *frames_prefix;
+        ply_array_t         *frames;
+        ply_event_loop_t    *loop;
+        char                *image_dir;
+        char                *frames_prefix;
 
-  ply_pixel_display_t    *display;
-  ply_rectangle_t  frame_area;
-  ply_trigger_t *stop_trigger;
+        ply_pixel_display_t *display;
+        ply_rectangle_t      frame_area;
+        ply_trigger_t       *stop_trigger;
 
-  long x, y;
-  long width, height;
-  double start_time, now;
+        long                 x, y;
+        long                 width, height;
+        double               start_time, now;
 
-  int frame_number;
-  uint32_t is_stopped : 1;
+        int                  frame_number;
+        uint32_t             is_stopped : 1;
 };
 
 static void ply_throbber_stop_now (ply_throbber_t *throbber);
 
 ply_throbber_t *
 ply_throbber_new (const char *image_dir,
-              const char *frames_prefix)
+                  const char *frames_prefix)
 {
-  ply_throbber_t *throbber;
-
-  assert (image_dir != NULL);
-  assert (frames_prefix != NULL);
-
-  throbber = calloc (1, sizeof (ply_throbber_t));
-
-  throbber->frames = ply_array_new (PLY_ARRAY_ELEMENT_TYPE_POINTER);
-  throbber->frames_prefix = strdup (frames_prefix);
-  throbber->image_dir = strdup (image_dir);
-  throbber->is_stopped = true;
-  throbber->width = 0;
-  throbber->height = 0;
-  throbber->frame_area.width = 0;
-  throbber->frame_area.height = 0;
-  throbber->frame_area.x = 0;
-  throbber->frame_area.y = 0;
-  throbber->frame_number = 0;
-
-  return throbber;
+        ply_throbber_t *throbber;
+
+        assert (image_dir != NULL);
+        assert (frames_prefix != NULL);
+
+        throbber = calloc (1, sizeof(ply_throbber_t));
+
+        throbber->frames = ply_array_new (PLY_ARRAY_ELEMENT_TYPE_POINTER);
+        throbber->frames_prefix = strdup (frames_prefix);
+        throbber->image_dir = strdup (image_dir);
+        throbber->is_stopped = true;
+        throbber->width = 0;
+        throbber->height = 0;
+        throbber->frame_area.width = 0;
+        throbber->frame_area.height = 0;
+        throbber->frame_area.x = 0;
+        throbber->frame_area.y = 0;
+        throbber->frame_number = 0;
+
+        return throbber;
 }
 
 static void
 ply_throbber_remove_frames (ply_throbber_t *throbber)
 {
-  int i;
-  ply_pixel_buffer_t **frames;
+        int i;
+        ply_pixel_buffer_t **frames;
 
-  frames = (ply_pixel_buffer_t **) ply_array_steal_pointer_elements (throbber->frames);
-  for (i = 0; frames[i] != NULL; i++)
-    ply_pixel_buffer_free (frames[i]);
-  free (frames);
+        frames = (ply_pixel_buffer_t **) ply_array_steal_pointer_elements (throbber->frames);
+        for (i = 0; frames[i] != NULL; i++) {
+                ply_pixel_buffer_free (frames[i]);
+        }
+        free (frames);
 }
 
 void
 ply_throbber_free (ply_throbber_t *throbber)
 {
-  if (throbber == NULL)
-    return;
+        if (throbber == NULL)
+                return;
 
-  if (!throbber->is_stopped)
-    ply_throbber_stop_now (throbber);
+        if (!throbber->is_stopped)
+                ply_throbber_stop_now (throbber);
 
-  ply_throbber_remove_frames (throbber);
-  ply_array_free (throbber->frames);
+        ply_throbber_remove_frames (throbber);
+        ply_array_free (throbber->frames);
 
-  free (throbber->frames_prefix);
-  free (throbber->image_dir);
-  free (throbber);
+        free (throbber->frames_prefix);
+        free (throbber->image_dir);
+        free (throbber);
 }
 
 static bool
 animate_at_time (ply_throbber_t *throbber,
-                 double      time)
+                 double          time)
 {
-  int number_of_frames;
-  ply_pixel_buffer_t * const * frames;
-  bool should_continue;
-  double percent_in_sequence;
-
-  number_of_frames = ply_array_get_size (throbber->frames);
-
-  if (number_of_frames == 0)
-    return true;
-
-  should_continue = true;
-  percent_in_sequence = fmod (time, THROBBER_DURATION) / THROBBER_DURATION;
-  throbber->frame_number = (int) (number_of_frames * percent_in_sequence);
-
-  if (throbber->stop_trigger != NULL)
-    {
-      if (throbber->frame_number == number_of_frames - 1)
-        should_continue = false;
-    }
-
-  frames = (ply_pixel_buffer_t * const *) ply_array_get_pointer_elements (throbber->frames);
-  ply_pixel_buffer_get_size (frames[throbber->frame_number], &throbber->frame_area);
-  throbber->frame_area.x = throbber->x;
-  throbber->frame_area.y = throbber->y;
-  ply_pixel_display_draw_area (throbber->display,
-                               throbber->x, throbber->y,
-                               throbber->frame_area.width,
-                               throbber->frame_area.height);
-
-  return should_continue;
+        int number_of_frames;
+        ply_pixel_buffer_t *const *frames;
+        bool should_continue;
+        double percent_in_sequence;
+
+        number_of_frames = ply_array_get_size (throbber->frames);
+
+        if (number_of_frames == 0)
+                return true;
+
+        should_continue = true;
+        percent_in_sequence = fmod (time, THROBBER_DURATION) / THROBBER_DURATION;
+        throbber->frame_number = (int) (number_of_frames * percent_in_sequence);
+
+        if (throbber->stop_trigger != NULL)
+                if (throbber->frame_number == number_of_frames - 1)
+                        should_continue = false;
+
+        frames = (ply_pixel_buffer_t *const *) ply_array_get_pointer_elements (throbber->frames);
+        ply_pixel_buffer_get_size (frames[throbber->frame_number], &throbber->frame_area);
+        throbber->frame_area.x = throbber->x;
+        throbber->frame_area.y = throbber->y;
+        ply_pixel_display_draw_area (throbber->display,
+                                     throbber->x, throbber->y,
+                                     throbber->frame_area.width,
+                                     throbber->frame_area.height);
+
+        return should_continue;
 }
 
 static void
 on_timeout (ply_throbber_t *throbber)
 {
-  double sleep_time;
-  bool should_continue;
-  throbber->now = ply_get_timestamp ();
-
-  should_continue = animate_at_time (throbber,
-                                     throbber->now - throbber->start_time);
-
-  sleep_time = 1.0 / FRAMES_PER_SECOND;
-  sleep_time = MAX (sleep_time - (ply_get_timestamp () - throbber->now),
-                    0.005);
-
-  if (!should_continue)
-    {
-      throbber->is_stopped = true;
-      if (throbber->stop_trigger != NULL)
-        {
-          ply_trigger_pull (throbber->stop_trigger, NULL);
-          throbber->stop_trigger = NULL;
+        double sleep_time;
+        bool should_continue;
+
+        throbber->now = ply_get_timestamp ();
+
+        should_continue = animate_at_time (throbber,
+                                           throbber->now - throbber->start_time);
+
+        sleep_time = 1.0 / FRAMES_PER_SECOND;
+        sleep_time = MAX (sleep_time - (ply_get_timestamp () - throbber->now),
+                          0.005);
+
+        if (!should_continue) {
+                throbber->is_stopped = true;
+                if (throbber->stop_trigger != NULL) {
+                        ply_trigger_pull (throbber->stop_trigger, NULL);
+                        throbber->stop_trigger = NULL;
+                }
+        } else {
+                ply_event_loop_watch_for_timeout (throbber->loop,
+                                                  sleep_time,
+                                                  (ply_event_loop_timeout_handler_t)
+                                                  on_timeout, throbber);
         }
-    }
-  else
-    {
-      ply_event_loop_watch_for_timeout (throbber->loop,
-                                        sleep_time,
-                                        (ply_event_loop_timeout_handler_t)
-                                        on_timeout, throbber);
-    }
 }
 
 static bool
 ply_throbber_add_frame (ply_throbber_t *throbber,
                         const char     *filename)
 {
-  ply_image_t *image;
-  ply_pixel_buffer_t *frame;
+        ply_image_t *image;
+        ply_pixel_buffer_t *frame;
 
-  image = ply_image_new (filename);
+        image = ply_image_new (filename);
 
-  if (!ply_image_load (image))
-    {
-      ply_image_free (image);
-      return false;
-    }
+        if (!ply_image_load (image)) {
+                ply_image_free (image);
+                return false;
+        }
 
-  frame = ply_image_convert_to_pixel_buffer (image);
+        frame = ply_image_convert_to_pixel_buffer (image);
 
-  ply_array_add_pointer_element (throbber->frames, frame);
+        ply_array_add_pointer_element (throbber->frames, frame);
 
-  throbber->width = MAX (throbber->width, (long) ply_pixel_buffer_get_width (frame));
-  throbber->height = MAX (throbber->height, (long)ply_pixel_buffer_get_height (frame));
+        throbber->width = MAX (throbber->width, (long) ply_pixel_buffer_get_width (frame));
+        throbber->height = MAX (throbber->height, (long) ply_pixel_buffer_get_height (frame));
 
-  return true;
+        return true;
 }
 
 static bool
 ply_throbber_add_frames (ply_throbber_t *throbber)
 {
-  struct dirent **entries;
-  int number_of_entries;
-  int i;
-  bool load_finished;
+        struct dirent **entries;
+        int number_of_entries;
+        int i;
+        bool load_finished;
 
-  entries = NULL;
+        entries = NULL;
 
-  number_of_entries = scandir (throbber->image_dir, &entries, NULL, versionsort);
+        number_of_entries = scandir (throbber->image_dir, &entries, NULL, versionsort);
 
-  if (number_of_entries < 0)
-    return false;
+        if (number_of_entries < 0)
+                return false;
 
-  load_finished = false;
-  for (i = 0; i < number_of_entries; i++)
-    {
-      if (strncmp (entries[i]->d_name,
-                   throbber->frames_prefix,
-                   strlen (throbber->frames_prefix)) == 0
-          && (strlen (entries[i]->d_name) > 4)
-          && strcmp (entries[i]->d_name + strlen (entries[i]->d_name) - 4, ".png") == 0)
-        {
-          char *filename;
+        load_finished = false;
+        for (i = 0; i < number_of_entries; i++) {
+                if (strncmp (entries[i]->d_name,
+                             throbber->frames_prefix,
+                             strlen (throbber->frames_prefix)) == 0
+                    && (strlen (entries[i]->d_name) > 4)
+                    && strcmp (entries[i]->d_name + strlen (entries[i]->d_name) - 4, ".png") == 0) {
+                        char *filename;
 
-          filename = NULL;
-          asprintf (&filename, "%s/%s", throbber->image_dir, entries[i]->d_name);
+                        filename = NULL;
+                        asprintf (&filename, "%s/%s", throbber->image_dir, entries[i]->d_name);
 
-          if (!ply_throbber_add_frame (throbber, filename))
-            goto out;
+                        if (!ply_throbber_add_frame (throbber, filename))
+                                goto out;
 
-          free (filename);
-        }
+                        free (filename);
+                }
 
-      free (entries[i]);
-      entries[i] = NULL;
-    }
-  load_finished = true;
+                free (entries[i]);
+                entries[i] = NULL;
+        }
+        load_finished = true;
 
 out:
-  if (!load_finished)
-    {
-      ply_throbber_remove_frames (throbber);
-
-      while (entries[i] != NULL)
-        {
-          free (entries[i]);
-          i++;
+        if (!load_finished) {
+                ply_throbber_remove_frames (throbber);
+
+                while (entries[i] != NULL) {
+                        free (entries[i]);
+                        i++;
+                }
         }
-    }
-  free (entries);
+        free (entries);
 
-  return load_finished;
+        return load_finished;
 }
 
 bool
 ply_throbber_load (ply_throbber_t *throbber)
 {
-  if (ply_array_get_size (throbber->frames) != 0)
-    ply_throbber_remove_frames (throbber);
+        if (ply_array_get_size (throbber->frames) != 0)
+                ply_throbber_remove_frames (throbber);
 
-  if (!ply_throbber_add_frames (throbber))
-    return false;
+        if (!ply_throbber_add_frames (throbber))
+                return false;
 
-  return true;
+        return true;
 }
 
 bool
-ply_throbber_start (ply_throbber_t       *throbber,
-                    ply_event_loop_t     *loop,
-                    ply_pixel_display_t  *display,
-                    long                  x,
-                    long                  y)
+ply_throbber_start (ply_throbber_t      *throbber,
+                    ply_event_loop_t    *loop,
+                    ply_pixel_display_t *display,
+                    long                 x,
+                    long                 y)
 {
-  assert (throbber != NULL);
-  assert (throbber->loop == NULL);
+        assert (throbber != NULL);
+        assert (throbber->loop == NULL);
 
-  throbber->loop = loop;
-  throbber->display = display;
-  throbber->is_stopped = false;
+        throbber->loop = loop;
+        throbber->display = display;
+        throbber->is_stopped = false;
 
-  throbber->x = x;
-  throbber->y = y;
+        throbber->x = x;
+        throbber->y = y;
 
-  throbber->start_time = ply_get_timestamp ();
+        throbber->start_time = ply_get_timestamp ();
 
-  ply_event_loop_watch_for_timeout (throbber->loop,
-                                    1.0 / FRAMES_PER_SECOND,
-                                    (ply_event_loop_timeout_handler_t)
-                                    on_timeout, throbber);
+        ply_event_loop_watch_for_timeout (throbber->loop,
+                                          1.0 / FRAMES_PER_SECOND,
+                                          (ply_event_loop_timeout_handler_t)
+                                          on_timeout, throbber);
 
-  return true;
+        return true;
 }
 
 static void
 ply_throbber_stop_now (ply_throbber_t *throbber)
 {
-  throbber->is_stopped = true;
-
-  ply_pixel_display_draw_area (throbber->display,
-                               throbber->x,
-                               throbber->y,
-                               throbber->frame_area.width,
-                               throbber->frame_area.height);
-  if (throbber->loop != NULL)
-    {
-      ply_event_loop_stop_watching_for_timeout (throbber->loop,
-                                                (ply_event_loop_timeout_handler_t)
-                                                on_timeout, throbber);
-      throbber->loop = NULL;
-    }
-  throbber->display = NULL;
+        throbber->is_stopped = true;
+
+        ply_pixel_display_draw_area (throbber->display,
+                                     throbber->x,
+                                     throbber->y,
+                                     throbber->frame_area.width,
+                                     throbber->frame_area.height);
+        if (throbber->loop != NULL) {
+                ply_event_loop_stop_watching_for_timeout (throbber->loop,
+                                                          (ply_event_loop_timeout_handler_t)
+                                                          on_timeout, throbber);
+                throbber->loop = NULL;
+        }
+        throbber->display = NULL;
 }
 
 void
 ply_throbber_stop (ply_throbber_t *throbber,
                    ply_trigger_t  *stop_trigger)
 {
+        if (stop_trigger == NULL) {
+                ply_throbber_stop_now (throbber);
+                return;
+        }
 
-  if (stop_trigger == NULL)
-    {
-      ply_throbber_stop_now (throbber);
-      return;
-    }
-
-  throbber->stop_trigger = stop_trigger;
+        throbber->stop_trigger = stop_trigger;
 }
 
 bool
 ply_throbber_is_stopped (ply_throbber_t *throbber)
 {
-  return throbber->is_stopped;
+        return throbber->is_stopped;
 }
 
 void
@@ -371,28 +359,28 @@ ply_throbber_draw_area (ply_throbber_t     *throbber,
                         unsigned long       width,
                         unsigned long       height)
 {
-  ply_pixel_buffer_t * const * frames;
+        ply_pixel_buffer_t *const *frames;
 
-  if (throbber->is_stopped)
-    return;
+        if (throbber->is_stopped)
+                return;
 
-  frames = (ply_pixel_buffer_t * const *) ply_array_get_pointer_elements (throbber->frames);
-  ply_pixel_buffer_fill_with_buffer (buffer,
-                                     frames[throbber->frame_number],
-                                     throbber->x,
-                                     throbber->y);
+        frames = (ply_pixel_buffer_t *const *) ply_array_get_pointer_elements (throbber->frames);
+        ply_pixel_buffer_fill_with_buffer (buffer,
+                                           frames[throbber->frame_number],
+                                           throbber->x,
+                                           throbber->y);
 }
 
 long
 ply_throbber_get_width (ply_throbber_t *throbber)
 {
-  return throbber->width;
+        return throbber->width;
 }
 
 long
 ply_throbber_get_height (ply_throbber_t *throbber)
 {
-  return throbber->height;
+        return throbber->height;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply-splash-graphics/ply-throbber.h b/src/libply-splash-graphics/ply-throbber.h
index 272a7d9..2123333 100644
--- a/src/libply-splash-graphics/ply-throbber.h
+++ b/src/libply-splash-graphics/ply-throbber.h
@@ -39,7 +39,7 @@ ply_throbber_t *ply_throbber_new (const char *image_dir,
 void ply_throbber_free (ply_throbber_t *throbber);
 
 bool ply_throbber_load (ply_throbber_t *throbber);
-bool ply_throbber_start (ply_throbber_t         *throbber,
+bool ply_throbber_start (ply_throbber_t      *throbber,
                          ply_event_loop_t    *loop,
                          ply_pixel_display_t *display,
                          long                 x,
diff --git a/src/libply/ply-array.c b/src/libply/ply-array.c
index 999c86e..7d23953 100644
--- a/src/libply/ply-array.c
+++ b/src/libply/ply-array.c
@@ -34,141 +34,139 @@ static const uint32_t uint32_terminator = 0;
 
 struct _ply_array
 {
-  ply_buffer_t *buffer;
-  ply_array_element_type_t element_type;
+        ply_buffer_t            *buffer;
+        ply_array_element_type_t element_type;
 };
 
 ply_array_t *
 ply_array_new (ply_array_element_type_t element_type)
 {
-  ply_array_t *array;
+        ply_array_t *array;
 
-  array = calloc (1, sizeof (ply_array_t));
+        array = calloc (1, sizeof(ply_array_t));
 
-  array->buffer = ply_buffer_new ();
-  array->element_type = element_type;
+        array->buffer = ply_buffer_new ();
+        array->element_type = element_type;
 
-  switch (array->element_type)
-    {
-      case PLY_ARRAY_ELEMENT_TYPE_POINTER:
-        ply_buffer_append_bytes (array->buffer, &pointer_terminator, sizeof (pointer_terminator));
-      break;
+        switch (array->element_type) {
+        case PLY_ARRAY_ELEMENT_TYPE_POINTER:
+                ply_buffer_append_bytes (array->buffer, &pointer_terminator, sizeof(pointer_terminator));
+                break;
 
-      case PLY_ARRAY_ELEMENT_TYPE_UINT32:
-        ply_buffer_append_bytes (array->buffer, &uint32_terminator, sizeof (uint32_terminator));
-      break;
-    }
+        case PLY_ARRAY_ELEMENT_TYPE_UINT32:
+                ply_buffer_append_bytes (array->buffer, &uint32_terminator, sizeof(uint32_terminator));
+                break;
+        }
 
-  return array;
+        return array;
 }
 
 void
 ply_array_free (ply_array_t *array)
 {
-  if (array == NULL)
-    return;
+        if (array == NULL)
+                return;
 
-  ply_buffer_free (array->buffer);
+        ply_buffer_free (array->buffer);
 
-  free (array);
+        free (array);
 }
 
 int
 ply_array_get_size (ply_array_t *array)
 {
-  int size;
+        int size;
 
-  assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_POINTER ||
-          array->element_type == PLY_ARRAY_ELEMENT_TYPE_UINT32);
+        assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_POINTER ||
+                array->element_type == PLY_ARRAY_ELEMENT_TYPE_UINT32);
 
-  switch (array->element_type)
-    {
-      case PLY_ARRAY_ELEMENT_TYPE_POINTER:
-        size = (ply_buffer_get_size (array->buffer) / sizeof (const void *)) - 1;
-      break;
+        switch (array->element_type) {
+        case PLY_ARRAY_ELEMENT_TYPE_POINTER:
+                size = (ply_buffer_get_size (array->buffer) / sizeof(const void *)) - 1;
+                break;
 
-      case PLY_ARRAY_ELEMENT_TYPE_UINT32:
-        size = (ply_buffer_get_size (array->buffer) / sizeof (const uint32_t)) - 1;
-      break;
-    }
+        case PLY_ARRAY_ELEMENT_TYPE_UINT32:
+                size = (ply_buffer_get_size (array->buffer) / sizeof(const uint32_t)) - 1;
+                break;
+        }
 
-  return size;
+        return size;
 }
 
 void
 ply_array_add_pointer_element (ply_array_t *array,
                                const void  *data)
 {
-  assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_POINTER);
+        assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_POINTER);
 
-  /* Temporarily remove NULL terminator
-   */
-  ply_buffer_remove_bytes_at_end (array->buffer, sizeof (pointer_terminator));
+        /* Temporarily remove NULL terminator
+         */
+        ply_buffer_remove_bytes_at_end (array->buffer, sizeof(pointer_terminator));
 
-  ply_buffer_append_bytes (array->buffer, &data, sizeof (const void *));
+        ply_buffer_append_bytes (array->buffer, &data, sizeof(const void *));
 
-  /* Add NULL terminator back
-   */
-  ply_buffer_append_bytes (array->buffer, &pointer_terminator, sizeof (pointer_terminator));
+        /* Add NULL terminator back
+         */
+        ply_buffer_append_bytes (array->buffer, &pointer_terminator, sizeof(pointer_terminator));
 }
 
 void
-ply_array_add_uint32_element (ply_array_t    *array,
-                              const uint32_t  data)
+ply_array_add_uint32_element (ply_array_t   *array,
+                              const uint32_t data)
 {
-  assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_UINT32);
+        assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_UINT32);
 
-  /* Temporarily remove 0 terminator
-   */
-  ply_buffer_remove_bytes_at_end (array->buffer, sizeof (uint32_terminator));
+        /* Temporarily remove 0 terminator
+         */
+        ply_buffer_remove_bytes_at_end (array->buffer, sizeof(uint32_terminator));
 
-  ply_buffer_append_bytes (array->buffer, &data, sizeof (const uint32_t));
+        ply_buffer_append_bytes (array->buffer, &data, sizeof(const uint32_t));
 
-  /* Add 0 terminator back
-   */
-  ply_buffer_append_bytes (array->buffer, &uint32_terminator, sizeof (uint32_terminator));
+        /* Add 0 terminator back
+         */
+        ply_buffer_append_bytes (array->buffer, &uint32_terminator, sizeof(uint32_terminator));
 }
 
-void * const *
+void *const *
 ply_array_get_pointer_elements (ply_array_t *array)
 {
-  assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_POINTER);
-  return (void * const *) ply_buffer_get_bytes (array->buffer);
+        assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_POINTER);
+        return (void *const *) ply_buffer_get_bytes (array->buffer);
 }
 
 uint32_t const *
 ply_array_get_uint32_elements (ply_array_t *array)
 {
-  assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_UINT32);
-  return (uint32_t const *) ply_buffer_get_bytes (array->buffer);
+        assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_UINT32);
+        return (uint32_t const *) ply_buffer_get_bytes (array->buffer);
 }
 
 void **
 ply_array_steal_pointer_elements (ply_array_t *array)
 {
-  void **data;
+        void **data;
 
-  assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_POINTER);
+        assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_POINTER);
 
-  data = (void **) ply_buffer_steal_bytes (array->buffer);
+        data = (void **) ply_buffer_steal_bytes (array->buffer);
 
-  ply_buffer_append_bytes (array->buffer, &pointer_terminator, sizeof (const void *));
+        ply_buffer_append_bytes (array->buffer, &pointer_terminator, sizeof(const void *));
 
-  return data;
+        return data;
 }
 
 uint32_t *
 ply_array_steal_uint32_elements (ply_array_t *array)
 {
-  uint32_t *data;
+        uint32_t *data;
 
-  assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_UINT32);
+        assert (array->element_type == PLY_ARRAY_ELEMENT_TYPE_UINT32);
 
-  data = (uint32_t *) ply_buffer_steal_bytes (array->buffer);
+        data = (uint32_t *) ply_buffer_steal_bytes (array->buffer);
 
-  ply_buffer_append_bytes (array->buffer, &uint32_terminator, sizeof (const uint32_t));
+        ply_buffer_append_bytes (array->buffer, &uint32_terminator, sizeof(const uint32_t));
 
-  return data;
+        return data;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-array.h b/src/libply/ply-array.h
index 4e3635d..777485c 100644
--- a/src/libply/ply-array.h
+++ b/src/libply/ply-array.h
@@ -29,8 +29,8 @@ typedef enum _ply_array_element_type ply_array_element_type_t;
 
 enum _ply_array_element_type
 {
-  PLY_ARRAY_ELEMENT_TYPE_POINTER,
-  PLY_ARRAY_ELEMENT_TYPE_UINT32
+        PLY_ARRAY_ELEMENT_TYPE_POINTER,
+        PLY_ARRAY_ELEMENT_TYPE_UINT32
 };
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
@@ -39,9 +39,9 @@ void ply_array_free (ply_array_t *array);
 int ply_array_get_size (ply_array_t *array);
 void ply_array_add_pointer_element (ply_array_t *array,
                                     const void  *element);
-void ply_array_add_uint32_element (ply_array_t    *array,
-                                   const uint32_t  element);
-void * const *ply_array_get_pointer_elements (ply_array_t *array);
+void ply_array_add_uint32_element (ply_array_t   *array,
+                                   const uint32_t element);
+void *const *ply_array_get_pointer_elements (ply_array_t *array);
 uint32_t const *ply_array_get_uint32_elements (ply_array_t *array);
 void **ply_array_steal_pointer_elements (ply_array_t *array);
 
diff --git a/src/libply/ply-bitarray.c b/src/libply/ply-bitarray.c
index 3d0cdd0..a988e92 100644
--- a/src/libply/ply-bitarray.c
+++ b/src/libply/ply-bitarray.c
@@ -34,12 +34,13 @@ int
 ply_bitarray_count (ply_bitarray_t *bitarray,
                     int             size)
 {
-  int count = 0;
-  int i;
-  for (i = 0; i < size; i++){
-    count += ply_bitarray_lookup(bitarray, i);
-    }
-  return count;
+        int count = 0;
+        int i;
+
+        for (i = 0; i < size; i++) {
+                count += ply_bitarray_lookup (bitarray, i);
+        }
+        return count;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-bitarray.h b/src/libply/ply-bitarray.h
index 4cdf03a..9c3b129 100644
--- a/src/libply/ply-bitarray.h
+++ b/src/libply/ply-bitarray.h
@@ -26,12 +26,12 @@
 #include <stdbool.h>
 
 #define PLY_BITARRAY_BASE_SIZE 32
-#define PLY_BITARRAY_BASE_MASK (PLY_BITARRAY_BASE_SIZE-1)
+#define PLY_BITARRAY_BASE_MASK (PLY_BITARRAY_BASE_SIZE - 1)
 
 typedef uint32_t ply_bitarray_t;
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
-#define ply_bitarray_new(size) calloc ((size + PLY_BITARRAY_BASE_SIZE - 1) / PLY_BITARRAY_BASE_SIZE, sizeof (ply_bitarray_t))
+#define ply_bitarray_new(size) calloc ((size + PLY_BITARRAY_BASE_SIZE - 1) / PLY_BITARRAY_BASE_SIZE, sizeof(ply_bitarray_t))
 #define ply_bitarray_free(bitarray) free (bitarray)
 #define ply_bitarray_lookup(bitarray, index) ((bitarray[index / PLY_BITARRAY_BASE_SIZE] >> (index & PLY_BITARRAY_BASE_MASK)) & 1)
 #define ply_bitarray_set(bitarray, index) (bitarray[index / PLY_BITARRAY_BASE_SIZE] |= 1 << (index & PLY_BITARRAY_BASE_MASK))
diff --git a/src/libply/ply-buffer.c b/src/libply/ply-buffer.c
index 0d0406f..26eaaa0 100644
--- a/src/libply/ply-buffer.c
+++ b/src/libply/ply-buffer.c
@@ -48,132 +48,130 @@
 
 struct _ply_buffer
 {
-  char   *data;
-  size_t  size;
-  size_t  capacity;
+        char  *data;
+        size_t size;
+        size_t capacity;
 };
 
 static bool
 ply_buffer_increase_capacity (ply_buffer_t *buffer)
 {
-  assert (buffer != NULL);
+        assert (buffer != NULL);
 
-  if ((buffer->capacity * 2) > PLY_BUFFER_MAX_BUFFER_CAPACITY)
-    return false;
+        if ((buffer->capacity * 2) > PLY_BUFFER_MAX_BUFFER_CAPACITY)
+                return false;
 
-  buffer->capacity *= 2;
+        buffer->capacity *= 2;
 
-  buffer->data = realloc (buffer->data, buffer->capacity);
-  return true;
+        buffer->data = realloc (buffer->data, buffer->capacity);
+        return true;
 }
 
 void
 ply_buffer_remove_bytes (ply_buffer_t *buffer,
                          size_t        bytes_to_remove)
 {
-  assert (buffer != NULL);
-
-  bytes_to_remove = MIN (buffer->size, bytes_to_remove);
-
-  if (bytes_to_remove == buffer->size)
-    buffer->size = 0;
-  else
-    {
-      memmove (buffer->data, buffer->data + bytes_to_remove,
-               buffer->size - bytes_to_remove);
-      buffer->size -= bytes_to_remove;
-    }
-  buffer->data[buffer->size] = '\0';
+        assert (buffer != NULL);
+
+        bytes_to_remove = MIN (buffer->size, bytes_to_remove);
+
+        if (bytes_to_remove == buffer->size) {
+                buffer->size = 0;
+        } else {
+                memmove (buffer->data, buffer->data + bytes_to_remove,
+                         buffer->size - bytes_to_remove);
+                buffer->size -= bytes_to_remove;
+        }
+        buffer->data[buffer->size] = '\0';
 }
 
 void
 ply_buffer_remove_bytes_at_end (ply_buffer_t *buffer,
                                 size_t        bytes_to_remove)
 {
-  assert (buffer != NULL);
+        assert (buffer != NULL);
 
-  bytes_to_remove = MIN (buffer->size, bytes_to_remove);
+        bytes_to_remove = MIN (buffer->size, bytes_to_remove);
 
-  buffer->size -= bytes_to_remove;
-  buffer->data[buffer->size] = '\0';
+        buffer->size -= bytes_to_remove;
+        buffer->data[buffer->size] = '\0';
 }
 
 ply_buffer_t *
 ply_buffer_new (void)
 {
-  ply_buffer_t *buffer;
+        ply_buffer_t *buffer;
 
-  buffer = calloc (1, sizeof (ply_buffer_t));
+        buffer = calloc (1, sizeof(ply_buffer_t));
 
-  buffer->capacity = 4096;
-  buffer->data = calloc (1, buffer->capacity);
-  buffer->size = 0;
+        buffer->capacity = 4096;
+        buffer->data = calloc (1, buffer->capacity);
+        buffer->size = 0;
 
-  return buffer;
+        return buffer;
 }
 
 void
 ply_buffer_free (ply_buffer_t *buffer)
 {
-  if (buffer == NULL)
-    return;
+        if (buffer == NULL)
+                return;
 
-  free (buffer->data);
-  free (buffer);
+        free (buffer->data);
+        free (buffer);
 }
 
 static bool
-ply_buffer_validate_format_string (ply_buffer_t   *buffer,
-                                   const char     *format)
+ply_buffer_validate_format_string (ply_buffer_t *buffer,
+                                   const char   *format)
 {
-  char *n, *p;
+        char *n, *p;
 
-  p = (char *) format;
+        p = (char *) format;
 
-  /* lame checks to limit the damage
-   * of some potential exploits.
-   */
-  while ((n = strstr (p, "%n")) != NULL)
-    {
-      if (n == format)
-          return false;
+        /* lame checks to limit the damage
+         * of some potential exploits.
+         */
+        while ((n = strstr (p, "%n")) != NULL) {
+                if (n == format)
+                        return false;
 
-      if (n[-1] != '%')
-          return false;
+                if (n[-1] != '%')
+                        return false;
 
-      p = n + 1;
-    }
+                p = n + 1;
+        }
 
-  return true;
+        return true;
 }
 
 void
-ply_buffer_append_with_non_literal_format_string (ply_buffer_t   *buffer,
-                                                  const char     *format,
+ply_buffer_append_with_non_literal_format_string (ply_buffer_t *buffer,
+                                                  const char   *format,
                                                   ...)
 {
-  va_list args;
-  size_t string_size;
-  char write_buffer[PLY_BUFFER_MAX_APPEND_SIZE] = "";
+        va_list args;
+        size_t string_size;
+        char write_buffer[PLY_BUFFER_MAX_APPEND_SIZE] = "";
 
-  assert (buffer != NULL);
+        assert (buffer != NULL);
 
-  if (!ply_buffer_validate_format_string (buffer, format))
-    return;
+        if (!ply_buffer_validate_format_string (buffer, format))
+                return;
 
-  va_start (args, format);
-  string_size = vsnprintf (write_buffer, 0, format, args) + 1;
-  va_end (args);
+        va_start (args, format);
+        string_size = vsnprintf (write_buffer, 0, format, args) + 1;
+        va_end (args);
 
-  if (string_size > PLY_BUFFER_MAX_APPEND_SIZE)
-    return;
+        if (string_size > PLY_BUFFER_MAX_APPEND_SIZE)
+                return;
 
-  va_start (args, format);
-  vsnprintf (write_buffer, PLY_BUFFER_MAX_APPEND_SIZE,
-             format, args);
-  va_end (args);
+        va_start (args, format);
+        vsnprintf (write_buffer, PLY_BUFFER_MAX_APPEND_SIZE,
+                   format, args);
+        va_end (args);
 
-  ply_buffer_append_bytes (buffer, write_buffer, string_size - 1);
+        ply_buffer_append_bytes (buffer, write_buffer, string_size - 1);
 }
 
 void
@@ -181,86 +179,83 @@ ply_buffer_append_bytes (ply_buffer_t *buffer,
                          const void   *bytes_in,
                          size_t        length)
 {
-  assert (buffer != NULL);
-  assert (bytes_in != NULL);
-  assert (length != 0);
-  
-  const uint8_t *bytes = bytes_in;
-  
-  if (length >PLY_BUFFER_MAX_BUFFER_CAPACITY){
-    bytes += length - (PLY_BUFFER_MAX_BUFFER_CAPACITY-1);
-    length = (PLY_BUFFER_MAX_BUFFER_CAPACITY-1);
-    }
-  
-  while ((buffer->size + length) >= buffer->capacity)
-    {
-      if (!ply_buffer_increase_capacity (buffer))
-        {
-          ply_buffer_remove_bytes (buffer, length);
+        assert (buffer != NULL);
+        assert (bytes_in != NULL);
+        assert (length != 0);
+
+        const uint8_t *bytes = bytes_in;
+
+        if (length > PLY_BUFFER_MAX_BUFFER_CAPACITY) {
+                bytes += length - (PLY_BUFFER_MAX_BUFFER_CAPACITY - 1);
+                length = (PLY_BUFFER_MAX_BUFFER_CAPACITY - 1);
+        }
+
+        while ((buffer->size + length) >= buffer->capacity) {
+                if (!ply_buffer_increase_capacity (buffer))
+                        ply_buffer_remove_bytes (buffer, length);
         }
-    }
 
-  assert (buffer->size + length < buffer->capacity);
+        assert (buffer->size + length < buffer->capacity);
 
-  memcpy (buffer->data + buffer->size,
-          bytes, length);
+        memcpy (buffer->data + buffer->size,
+                bytes, length);
 
-  buffer->size += length;
-  buffer->data[buffer->size] = '\0';
+        buffer->size += length;
+        buffer->data[buffer->size] = '\0';
 }
 
 void
 ply_buffer_append_from_fd (ply_buffer_t *buffer,
                            int           fd)
 {
+        char bytes[PLY_BUFFER_MAX_APPEND_SIZE] = "";
+        ssize_t bytes_read;
 
-  char bytes[PLY_BUFFER_MAX_APPEND_SIZE] = "";
-  ssize_t bytes_read;
+        assert (buffer != NULL);
+        assert (fd >= 0);
 
-  assert (buffer != NULL);
-  assert (fd >= 0);
+        if (!ply_fd_has_data (fd))
+                return;
 
-  if (!ply_fd_has_data (fd))
-    return;
+        bytes_read = read (fd, bytes, sizeof(bytes));
 
-  bytes_read = read (fd, bytes, sizeof (bytes));
-
-  if (bytes_read > 0)
-    ply_buffer_append_bytes (buffer, bytes, bytes_read);
+        if (bytes_read > 0)
+                ply_buffer_append_bytes (buffer, bytes, bytes_read);
 }
 
 const char *
 ply_buffer_get_bytes (ply_buffer_t *buffer)
 {
-  assert (buffer != NULL);
-  return buffer->data;
+        assert (buffer != NULL);
+        return buffer->data;
 }
 
 char *
 ply_buffer_steal_bytes (ply_buffer_t *buffer)
 {
-  char *bytes;
-  assert (buffer != NULL);
+        char *bytes;
+
+        assert (buffer != NULL);
 
-  bytes = buffer->data;
+        bytes = buffer->data;
 
-  buffer->data = calloc (1, buffer->capacity);
-  buffer->size = 0;
+        buffer->data = calloc (1, buffer->capacity);
+        buffer->size = 0;
 
-  return bytes;
+        return bytes;
 }
 
 size_t
 ply_buffer_get_size (ply_buffer_t *buffer)
 {
-  return buffer->size;
+        return buffer->size;
 }
 
 void
 ply_buffer_clear (ply_buffer_t *buffer)
 {
-  memset (buffer->data, '\0', buffer->capacity);
-  buffer->size = 0;
+        memset (buffer->data, '\0', buffer->capacity);
+        buffer->size = 0;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-buffer.h b/src/libply/ply-buffer.h
index cfda236..3d848db 100644
--- a/src/libply/ply-buffer.h
+++ b/src/libply/ply-buffer.h
@@ -33,16 +33,17 @@ ply_buffer_t *ply_buffer_new (void);
 void ply_buffer_free (ply_buffer_t *buffer);
 void ply_buffer_append_bytes (ply_buffer_t *buffer,
                               const void   *bytes,
-                              size_t number_of_bytes);
+                              size_t        number_of_bytes);
 
 void ply_buffer_append_from_fd (ply_buffer_t *buffer,
                                 int           fd);
-#define ply_buffer_append(buffer, format, args...)                             \
+#define ply_buffer_append(buffer, format, args ...)                             \
         ply_buffer_append_with_non_literal_format_string (buffer,              \
-                                                          format "", ##args)
+                                                          format "", ## args)
 __attribute__((__format__ (__printf__, 2, 3)))
-void ply_buffer_append_with_non_literal_format_string (ply_buffer_t   *buffer,
-                                                       const char *format, ...);
+void ply_buffer_append_with_non_literal_format_string (ply_buffer_t *buffer,
+                                                       const char   *format,
+                                                       ...);
 void ply_buffer_remove_bytes (ply_buffer_t *buffer,
                               size_t        number_of_bytes);
 void ply_buffer_remove_bytes_at_end (ply_buffer_t *buffer,
diff --git a/src/libply/ply-command-parser.c b/src/libply/ply-command-parser.c
index 2768668..f1ddcff 100644
--- a/src/libply/ply-command-parser.c
+++ b/src/libply/ply-command-parser.c
@@ -35,383 +35,372 @@
 
 typedef union
 {
-  bool as_boolean;
-  char *as_string;
-  int as_integer;
+        bool  as_boolean;
+        char *as_string;
+        int   as_integer;
 } ply_command_option_result_t;
 
 typedef struct
 {
-  char *name;
-  char *description;
-  ply_command_option_type_t type;
-  uint32_t was_set : 1;
-  ply_command_option_result_t result;
+        char                       *name;
+        char                       *description;
+        ply_command_option_type_t   type;
+        uint32_t                    was_set : 1;
+        ply_command_option_result_t result;
 } ply_command_option_t;
 
 typedef struct
 {
-  char *name;
-  ply_list_t *aliases;
-  char *description;
-  ply_list_t *options;
+        char                 *name;
+        ply_list_t           *aliases;
+        char                 *description;
+        ply_list_t           *options;
 
-  size_t longest_option_length;
+        size_t                longest_option_length;
 
-  ply_command_handler_t handler;
-  void       *handler_data;
+        ply_command_handler_t handler;
+        void                 *handler_data;
 } ply_command_t;
 
 struct _ply_command_parser
 {
-  ply_event_loop_t *loop;
-  ply_command_t *main_command;
+        ply_event_loop_t *loop;
+        ply_command_t    *main_command;
 
-  ply_list_t *available_subcommands;
-  ply_list_t *read_subcommands;
+        ply_list_t       *available_subcommands;
+        ply_list_t       *read_subcommands;
 
-  ply_list_t *arguments;
-  size_t longest_command_length;
+        ply_list_t       *arguments;
+        size_t            longest_command_length;
 
-  uint32_t dispatch_is_queued : 1;
+        uint32_t          dispatch_is_queued : 1;
 };
 
 static ply_command_option_t *
-ply_command_option_new (const char                *name,
-                        const char                *description,
-                        ply_command_option_type_t  type)
+ply_command_option_new (const char               *name,
+                        const char               *description,
+                        ply_command_option_type_t type)
 {
-  ply_command_option_t *option;
+        ply_command_option_t *option;
 
-  option = calloc (1, sizeof (ply_command_option_t));
+        option = calloc (1, sizeof(ply_command_option_t));
 
-  option->name = strdup (name);
-  option->description = strdup (description);
-  option->type = type;
+        option->name = strdup (name);
+        option->description = strdup (description);
+        option->type = type;
 
-  return option;
+        return option;
 }
 
 static void
 ply_command_option_free (ply_command_option_t *option)
 {
-  if (option == NULL)
-    return;
+        if (option == NULL)
+                return;
 
-  free (option->name);
-  free (option->description);
-  free (option);
+        free (option->name);
+        free (option->description);
+        free (option);
 }
 
 static ply_command_t *
-ply_command_new (const char *name,
-                 const char *description,
+ply_command_new (const char           *name,
+                 const char           *description,
                  ply_command_handler_t handler,
-                 void       *data)
+                 void                 *data)
 {
-  ply_command_t *command;
+        ply_command_t *command;
 
-  command = calloc (1, sizeof (ply_command_t));
+        command = calloc (1, sizeof(ply_command_t));
 
-  command->options = ply_list_new ();
-  command->name = strdup (name);
-  command->aliases = ply_list_new ();
-  command->description = strdup (description);
-  command->handler = handler;
-  command->handler_data = data;
+        command->options = ply_list_new ();
+        command->name = strdup (name);
+        command->aliases = ply_list_new ();
+        command->description = strdup (description);
+        command->handler = handler;
+        command->handler_data = data;
 
-  return command;
+        return command;
 }
 
 static void
 ply_command_free (ply_command_t *command)
 {
-  ply_list_node_t *option_node;
-  ply_list_node_t *alias_node;
+        ply_list_node_t *option_node;
+        ply_list_node_t *alias_node;
 
-  if (command == NULL)
-    return;
+        if (command == NULL)
+                return;
 
-  while ((alias_node = ply_list_get_first_node (command->aliases)) != NULL)
-    {
-      free (ply_list_node_get_data (alias_node));
-      ply_list_remove_node (command->aliases, alias_node);
-    }
+        while ((alias_node = ply_list_get_first_node (command->aliases)) != NULL) {
+                free (ply_list_node_get_data (alias_node));
+                ply_list_remove_node (command->aliases, alias_node);
+        }
 
-  option_node = ply_list_get_first_node (command->options);
-  while (option_node != NULL)
-    {
-      ply_command_option_t *option;
+        option_node = ply_list_get_first_node (command->options);
+        while (option_node != NULL) {
+                ply_command_option_t *option;
 
-      option = (ply_command_option_t *) ply_list_node_get_data (option_node);
-      ply_command_option_free (option);
+                option = (ply_command_option_t *) ply_list_node_get_data (option_node);
+                ply_command_option_free (option);
 
-      option_node = ply_list_get_next_node (command->options, option_node);
-    }
-  ply_list_free (command->options);
-  free (command);
+                option_node = ply_list_get_next_node (command->options, option_node);
+        }
+        ply_list_free (command->options);
+        free (command);
 }
 
 static void
 append_usage_line_to_buffer (ply_command_parser_t *parser,
-                             ply_buffer_t *buffer)
+                             ply_buffer_t         *buffer)
 {
-  ply_buffer_append (buffer, "%s\n",
-                     parser->main_command->description);
-  ply_buffer_append (buffer, "USAGE: %s [OPTION...]", parser->main_command->name);
+        ply_buffer_append (buffer, "%s\n",
+                           parser->main_command->description);
+        ply_buffer_append (buffer, "USAGE: %s [OPTION...]", parser->main_command->name);
 
-  if (ply_list_get_length (parser->available_subcommands) > 0)
-    ply_buffer_append (buffer, " [COMMAND [OPTION...]...]\n");
+        if (ply_list_get_length (parser->available_subcommands) > 0)
+                ply_buffer_append (buffer, " [COMMAND [OPTION...]...]\n");
 }
 
 static const char *
 get_type_string (int type)
 {
-  const char *option_type_string;
-
-  switch (type)
-    {
-    case PLY_COMMAND_OPTION_TYPE_FLAG:
-      option_type_string = "";
-      break;
-    case PLY_COMMAND_OPTION_TYPE_BOOLEAN:
-      option_type_string = "={true|false}";
-      break;
-    case PLY_COMMAND_OPTION_TYPE_STRING:
-      option_type_string = "=<string>";
-      break;
-    case PLY_COMMAND_OPTION_TYPE_INTEGER:
-      option_type_string = "=<integer>";
-      break;
-    default:
-      option_type_string = "";
-      break;
-    }
-
-  return option_type_string;
+        const char *option_type_string;
+
+        switch (type) {
+        case PLY_COMMAND_OPTION_TYPE_FLAG:
+                option_type_string = "";
+                break;
+        case PLY_COMMAND_OPTION_TYPE_BOOLEAN:
+                option_type_string = "={true|false}";
+                break;
+        case PLY_COMMAND_OPTION_TYPE_STRING:
+                option_type_string = "=<string>";
+                break;
+        case PLY_COMMAND_OPTION_TYPE_INTEGER:
+                option_type_string = "=<integer>";
+                break;
+        default:
+                option_type_string = "";
+                break;
+        }
+
+        return option_type_string;
 }
 
 static void
 append_command_options_to_buffer (ply_command_parser_t *parser,
-                               ply_command_t *command,
-                               ply_buffer_t *buffer)
+                                  ply_command_t        *command,
+                                  ply_buffer_t         *buffer)
 {
-  ply_list_node_t *option_node;
+        ply_list_node_t *option_node;
 
-  option_node = ply_list_get_first_node (command->options);
+        option_node = ply_list_get_first_node (command->options);
 
-  while (option_node != NULL)
-    {
-      ply_command_option_t *option;
-      int option_width;
-      const char *option_type_string;
+        while (option_node != NULL) {
+                ply_command_option_t *option;
+                int option_width;
+                const char *option_type_string;
 
-      option = (ply_command_option_t *) ply_list_node_get_data (option_node);
+                option = (ply_command_option_t *) ply_list_node_get_data (option_node);
 
-      option_type_string = get_type_string (option->type);
+                option_type_string = get_type_string (option->type);
 
-      option_width = command->longest_option_length + 2 -
-        (strlen(option->name) + strlen(option_type_string));
+                option_width = command->longest_option_length + 2 -
+                               (strlen (option->name) + strlen (option_type_string));
 
-      ply_buffer_append (buffer,
-                         "  --%s%s",
-                         option->name,
-                         option_type_string);
+                ply_buffer_append (buffer,
+                                   "  --%s%s",
+                                   option->name,
+                                   option_type_string);
 
-      ply_buffer_append (buffer, "%*s %s\n",
-                         option_width,
-                         "",
-                         option->description ? option->description : "");
+                ply_buffer_append (buffer, "%*s %s\n",
+                                   option_width,
+                                   "",
+                                   option->description ? option->description : "");
 
-      option_node = ply_list_get_next_node (command->options, option_node);
-    }
+                option_node = ply_list_get_next_node (command->options, option_node);
+        }
 }
 
 char *
 ply_command_parser_get_help_string (ply_command_parser_t *parser)
 {
-  ply_buffer_t *buffer;
-  ply_list_node_t *command_node;
-  char *help_string;
-  int longest_subcommand;
-
-  buffer = ply_buffer_new ();
-
-  append_usage_line_to_buffer (parser, buffer);
-  ply_buffer_append (buffer, "\n");
-  ply_buffer_append (buffer, "Options:\n");
-  append_command_options_to_buffer (parser, parser->main_command, buffer);
-  ply_buffer_append (buffer, "\n");
-
-  if (ply_list_get_length (parser->available_subcommands) > 0)
-    ply_buffer_append (buffer, "Available commands:\n");
-
-  /* get longest subcommand */
-  longest_subcommand = -1;
-  command_node = ply_list_get_first_node (parser->available_subcommands);
-  while (command_node != NULL)
-    {
-      ply_command_t *command;
-      command = (ply_command_t *) ply_list_node_get_data (command_node);
-      longest_subcommand = MAX (longest_subcommand, (int)strlen (command->name));
-      command_node = ply_list_get_next_node (parser->available_subcommands,
-                                             command_node);
-    }
-  command_node = ply_list_get_first_node (parser->available_subcommands);
-  while (command_node != NULL)
-    {
-      ply_command_t *command;
-
-      command = (ply_command_t *) ply_list_node_get_data (command_node);
-
-      ply_buffer_append (buffer, "  %s%*s %s\n",
-                         command->name,
-                         (int) (longest_subcommand + 2 - strlen (command->name)),
-                         "",
-                         command->description);
-
-      command_node = ply_list_get_next_node (parser->available_subcommands,
-                                             command_node);
-    }
-
-  command_node = ply_list_get_first_node (parser->available_subcommands);
-  while (command_node != NULL)
-    {
-      ply_command_t *command;
-
-      command = (ply_command_t *) ply_list_node_get_data (command_node);
-
-      if (ply_list_get_first_node (command->options) != NULL)
-        {
-          ply_buffer_append (buffer, "\nOptions for %s command:\n", command->name);
+        ply_buffer_t *buffer;
+        ply_list_node_t *command_node;
+        char *help_string;
+        int longest_subcommand;
+
+        buffer = ply_buffer_new ();
+
+        append_usage_line_to_buffer (parser, buffer);
+        ply_buffer_append (buffer, "\n");
+        ply_buffer_append (buffer, "Options:\n");
+        append_command_options_to_buffer (parser, parser->main_command, buffer);
+        ply_buffer_append (buffer, "\n");
+
+        if (ply_list_get_length (parser->available_subcommands) > 0)
+                ply_buffer_append (buffer, "Available commands:\n");
+
+        /* get longest subcommand */
+        longest_subcommand = -1;
+        command_node = ply_list_get_first_node (parser->available_subcommands);
+        while (command_node != NULL) {
+                ply_command_t *command;
+                command = (ply_command_t *) ply_list_node_get_data (command_node);
+                longest_subcommand = MAX (longest_subcommand, (int) strlen (command->name));
+                command_node = ply_list_get_next_node (parser->available_subcommands,
+                                                       command_node);
+        }
+        command_node = ply_list_get_first_node (parser->available_subcommands);
+        while (command_node != NULL) {
+                ply_command_t *command;
+
+                command = (ply_command_t *) ply_list_node_get_data (command_node);
 
-          append_command_options_to_buffer (parser, command, buffer);
+                ply_buffer_append (buffer, "  %s%*s %s\n",
+                                   command->name,
+                                   (int) (longest_subcommand + 2 - strlen (command->name)),
+                                   "",
+                                   command->description);
+
+                command_node = ply_list_get_next_node (parser->available_subcommands,
+                                                       command_node);
         }
 
-      command_node = ply_list_get_next_node (parser->available_subcommands,
-                                             command_node);
-    }
+        command_node = ply_list_get_first_node (parser->available_subcommands);
+        while (command_node != NULL) {
+                ply_command_t *command;
+
+                command = (ply_command_t *) ply_list_node_get_data (command_node);
 
-  help_string = ply_buffer_steal_bytes (buffer);
-  ply_buffer_free (buffer);
+                if (ply_list_get_first_node (command->options) != NULL) {
+                        ply_buffer_append (buffer, "\nOptions for %s command:\n", command->name);
 
-  return help_string;
+                        append_command_options_to_buffer (parser, command, buffer);
+                }
+
+                command_node = ply_list_get_next_node (parser->available_subcommands,
+                                                       command_node);
+        }
+
+        help_string = ply_buffer_steal_bytes (buffer);
+        ply_buffer_free (buffer);
+
+        return help_string;
 }
 
 static void
-ply_command_add_option (ply_command_t *command,
-                        const char    *name,
-                        const char    *description,
+ply_command_add_option (ply_command_t            *command,
+                        const char               *name,
+                        const char               *description,
                         ply_command_option_type_t type)
 {
-  ply_command_option_t *option;
+        ply_command_option_t *option;
 
-  option = ply_command_option_new (name, description, type);
+        option = ply_command_option_new (name, description, type);
 
-  ply_list_append_data (command->options, option);
+        ply_list_append_data (command->options, option);
 
-  command->longest_option_length = MAX (command->longest_option_length,
-                                        strlen (name)
-                                        + 1
-                                        + strlen (get_type_string (type)));
+        command->longest_option_length = MAX (command->longest_option_length,
+                                              strlen (name)
+                                              + 1
+                                              + strlen (get_type_string (type)));
 }
 
 static ply_command_option_t *
 ply_command_get_option (ply_command_t *command,
                         const char    *option_name)
 {
-  ply_command_option_t *option;
-  ply_list_node_t *node;
+        ply_command_option_t *option;
+        ply_list_node_t *node;
 
-  option = NULL;
-  node = ply_list_get_first_node (command->options);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
+        option = NULL;
+        node = ply_list_get_first_node (command->options);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
 
-      option = (ply_command_option_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (command->options, node);
+                option = (ply_command_option_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (command->options, node);
 
-      if (strcmp (option_name, option->name) == 0)
-        break;
+                if (strcmp (option_name, option->name) == 0)
+                        break;
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  if (node == NULL)
-      return NULL;
+        if (node == NULL)
+                return NULL;
 
-  return option;
+        return option;
 }
 
 ply_command_parser_t *
 ply_command_parser_new (const char *name,
                         const char *description)
 {
-  ply_command_parser_t *command_parser;
+        ply_command_parser_t *command_parser;
 
-  command_parser = calloc (1, sizeof (ply_command_parser_t));
+        command_parser = calloc (1, sizeof(ply_command_parser_t));
 
-  command_parser->main_command = ply_command_new (name, description, NULL, NULL);
-  command_parser->available_subcommands = ply_list_new ();
-  command_parser->read_subcommands = ply_list_new ();
+        command_parser->main_command = ply_command_new (name, description, NULL, NULL);
+        command_parser->available_subcommands = ply_list_new ();
+        command_parser->read_subcommands = ply_list_new ();
 
-  return command_parser;
+        return command_parser;
 }
 
 void
 ply_command_parser_free (ply_command_parser_t *command_parser)
 {
-  ply_list_node_t *command_node;
+        ply_list_node_t *command_node;
 
-  if (command_parser == NULL)
-    return;
+        if (command_parser == NULL)
+                return;
 
-  command_node = ply_list_get_first_node (command_parser->available_subcommands);
-  while (command_node != NULL)
-    {
-      ply_command_t *command;
+        command_node = ply_list_get_first_node (command_parser->available_subcommands);
+        while (command_node != NULL) {
+                ply_command_t *command;
 
-      command = (ply_command_t *) ply_list_node_get_data (command_node);
-      ply_command_free (command);
+                command = (ply_command_t *) ply_list_node_get_data (command_node);
+                ply_command_free (command);
 
-      command_node = ply_list_get_next_node (command_parser->available_subcommands, command_node);
-    }
-  ply_list_free (command_parser->available_subcommands);
-  ply_list_free (command_parser->read_subcommands);
+                command_node = ply_list_get_next_node (command_parser->available_subcommands, command_node);
+        }
+        ply_list_free (command_parser->available_subcommands);
+        ply_list_free (command_parser->read_subcommands);
 
-  ply_command_free (command_parser->main_command);
+        ply_command_free (command_parser->main_command);
 
-  free (command_parser);
+        free (command_parser);
 }
 
 void
 ply_command_parser_add_options (ply_command_parser_t *parser,
-                                const char *first_variadic_argument, /*
-                                const char *option_description,
-                                ply_option_argument_type_t option_type */
+                                const char           *first_variadic_argument, /*
+                                                                                * const char *option_description,
+                                                                                * ply_option_argument_type_t option_type */
                                 ...)
 {
-  va_list args;
-  const char *option_name;
-  const char *option_description;
-  ply_command_option_type_t option_type;
+        va_list args;
+        const char *option_name;
+        const char *option_description;
+        ply_command_option_type_t option_type;
 
-  assert (parser != NULL);
+        assert (parser != NULL);
 
-  option_name = first_variadic_argument;
-  va_start (args, first_variadic_argument);
-  while (option_name != NULL)
-    {
-      option_description = va_arg (args, const char *);
-      option_type = va_arg (args, ply_command_option_type_t);
+        option_name = first_variadic_argument;
+        va_start (args, first_variadic_argument);
+        while (option_name != NULL) {
+                option_description = va_arg (args, const char *);
+                option_type = va_arg (args, ply_command_option_type_t);
 
-      ply_command_add_option (parser->main_command,
-                              option_name, option_description, option_type);
+                ply_command_add_option (parser->main_command,
+                                        option_name, option_description, option_type);
 
-      option_name = va_arg (args, const char *);
-    }
-  va_end (args);
+                option_name = va_arg (args, const char *);
+        }
+        va_end (args);
 }
 
 void
@@ -420,104 +409,102 @@ ply_command_parser_add_command (ply_command_parser_t *parser,
                                 ply_command_handler_t handler,
                                 void *handler_data,
                                 const char *first_variadic_argument, /*
-                                const char *option_description,
-                                ply_command_option_type_t option_type */
+                                                                      * const char *option_description,
+                                                                      * ply_command_option_type_t option_type */
                                 ...)
 {
-  ply_command_t *command;
-  va_list args;
-  const char *option_name;
-  const char *option_description;
-  ply_command_option_type_t option_type;
+        ply_command_t *command;
+        va_list args;
+        const char *option_name;
+        const char *option_description;
+        ply_command_option_type_t option_type;
 
-  assert (parser != NULL);
-  assert (name != NULL);
+        assert (parser != NULL);
+        assert (name != NULL);
 
-  command = ply_command_new (name, description, handler, handler_data);
+        command = ply_command_new (name, description, handler, handler_data);
 
-  option_name = first_variadic_argument;
-  va_start (args, first_variadic_argument);
-  while (option_name != NULL)
-    {
-      option_description = va_arg (args, const char *);
-      option_type = va_arg (args, ply_command_option_type_t);
+        option_name = first_variadic_argument;
+        va_start (args, first_variadic_argument);
+        while (option_name != NULL) {
+                option_description = va_arg (args, const char *);
+                option_type = va_arg (args, ply_command_option_type_t);
 
-      ply_command_add_option (command, option_name, option_description, option_type);
+                ply_command_add_option (command, option_name, option_description, option_type);
 
-      option_name = va_arg (args, const char *);
-    }
-  va_end (args);
+                option_name = va_arg (args, const char *);
+        }
+        va_end (args);
 
-  ply_list_append_data (parser->available_subcommands, command);
+        ply_list_append_data (parser->available_subcommands, command);
 
-  parser->longest_command_length = MAX (parser->longest_command_length, strlen (name));
+        parser->longest_command_length = MAX (parser->longest_command_length, strlen (name));
 }
 
 static void
 ply_command_parser_set_arguments (ply_command_parser_t *parser,
-                                  char * const         *arguments,
+                                  char *const          *arguments,
                                   int                   number_of_arguments)
 {
-  int i;
+        int i;
 
-  assert (parser != NULL);
-  assert (arguments != NULL);
+        assert (parser != NULL);
+        assert (arguments != NULL);
 
-  ply_list_free (parser->arguments);
-  parser->arguments = ply_list_new ();
+        ply_list_free (parser->arguments);
+        parser->arguments = ply_list_new ();
 
-  for (i = 0; arguments[i] != NULL; i++)
-    ply_list_append_data (parser->arguments, arguments[i]);
+        for (i = 0; arguments[i] != NULL; i++) {
+                ply_list_append_data (parser->arguments, arguments[i]);
+        }
 }
 
 static ply_command_t *
 ply_command_parser_get_command (ply_command_parser_t *parser,
                                 const char           *command_name)
 {
-  ply_command_t *command;
-  ply_list_node_t *node;
+        ply_command_t *command;
+        ply_list_node_t *node;
 
-  command = NULL;
-  node = ply_list_get_first_node (parser->available_subcommands);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_list_node_t *alias_node;
-      char *alias_name;
+        command = NULL;
+        node = ply_list_get_first_node (parser->available_subcommands);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_list_node_t *alias_node;
+                char *alias_name;
 
-      command = (ply_command_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (parser->available_subcommands, node);
+                command = (ply_command_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (parser->available_subcommands, node);
 
-      if (strcmp (command_name, command->name) == 0)
-        return command;
-      alias_node = ply_list_get_first_node (command->aliases);
-      while (alias_node)
-        {
-          alias_name = (char *) ply_list_node_get_data (alias_node);
-          if (strcmp (command_name, alias_name) == 0)
-            return command;
-          
-          alias_node = ply_list_get_next_node (command->aliases, alias_node);
-        }
+                if (strcmp (command_name, command->name) == 0)
+                        return command;
+                alias_node = ply_list_get_first_node (command->aliases);
+                while (alias_node) {
+                        alias_name = (char *) ply_list_node_get_data (alias_node);
+                        if (strcmp (command_name, alias_name) == 0)
+                                return command;
+
+                        alias_node = ply_list_get_next_node (command->aliases, alias_node);
+                }
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  return NULL;
+        return NULL;
 }
 
 void ply_command_parser_add_command_alias (ply_command_parser_t *parser,
                                            const char           *name,
                                            const char           *alias)
 {
-  ply_command_t *command;
+        ply_command_t *command;
 
-  assert (parser != NULL);
-  assert (name != NULL);
-  assert (alias != NULL);
+        assert (parser != NULL);
+        assert (name != NULL);
+        assert (alias != NULL);
 
-  command = ply_command_parser_get_command (parser, name);
-  ply_list_append_data (command->aliases, strdup(alias));
+        command = ply_command_parser_get_command (parser, name);
+        ply_list_append_data (command->aliases, strdup (alias));
 }
 
 static void
@@ -527,70 +514,66 @@ ply_command_parser_get_option_for_command (ply_command_parser_t *parser,
                                            void                 *option_result,
                                            bool                 *option_is_set)
 {
-  ply_command_option_t *option;
-
-  option = ply_command_get_option (command, option_name);
-
-  if (option == NULL)
-    return;
-
-  if (option_result != NULL)
-    {
-      switch (option->type)
-        {
-        case PLY_COMMAND_OPTION_TYPE_FLAG:
-        case PLY_COMMAND_OPTION_TYPE_BOOLEAN:
-          {
-            *(bool *)option_result = option->result.as_boolean;
-          }
-          break;
-
-        case PLY_COMMAND_OPTION_TYPE_STRING:
-          {
-            if (option->result.as_string != NULL)
-              *(char **)option_result = strdup (option->result.as_string);
-            else
-              *(char **)option_result = NULL;
-          }
-          break;
-
-        case PLY_COMMAND_OPTION_TYPE_INTEGER:
-          {
-            *(int *)option_result = option->result.as_integer;
-          }
-          break;
+        ply_command_option_t *option;
+
+        option = ply_command_get_option (command, option_name);
+
+        if (option == NULL)
+                return;
+
+        if (option_result != NULL) {
+                switch (option->type) {
+                case PLY_COMMAND_OPTION_TYPE_FLAG:
+                case PLY_COMMAND_OPTION_TYPE_BOOLEAN:
+                {
+                        *(bool *) option_result = option->result.as_boolean;
+                }
+                break;
+
+                case PLY_COMMAND_OPTION_TYPE_STRING:
+                {
+                        if (option->result.as_string != NULL)
+                                *(char **) option_result = strdup (option->result.as_string);
+                        else
+                                *(char **) option_result = NULL;
+                }
+                break;
+
+                case PLY_COMMAND_OPTION_TYPE_INTEGER:
+                {
+                        *(int *) option_result = option->result.as_integer;
+                }
+                break;
+                }
         }
-    }
 
-  if (option_is_set != NULL)
-    *option_is_set = option->was_set;
+        if (option_is_set != NULL)
+                *option_is_set = option->was_set;
 }
 
 static void
 ply_command_parser_get_options_for_command (ply_command_parser_t *parser,
-                                            ply_command_t *command,
-                                            const char *option_name,
-                                            va_list args)
+                                            ply_command_t        *command,
+                                            const char           *option_name,
+                                            va_list               args)
 {
+        assert (parser != NULL);
+        assert (command != NULL);
+        assert (option_name != NULL);
 
-  assert (parser != NULL);
-  assert (command != NULL);
-  assert (option_name != NULL);
-
-  while (option_name != NULL)
-    {
-      void *option_result;
+        while (option_name != NULL) {
+                void *option_result;
 
-      option_result = va_arg (args, void *);
+                option_result = va_arg (args, void *);
 
-      ply_command_parser_get_option_for_command (parser,
-                                                 command,
-                                                 option_name,
-                                                 option_result,
-                                                 NULL);
+                ply_command_parser_get_option_for_command (parser,
+                                                           command,
+                                                           option_name,
+                                                           option_result,
+                                                           NULL);
 
-      option_name = va_arg (args, const char *);
-    }
+                option_name = va_arg (args, const char *);
+        }
 }
 
 void
@@ -599,31 +582,31 @@ ply_command_parser_get_option (ply_command_parser_t *parser,
                                void                 *option_result,
                                bool                 *option_is_set)
 {
-  assert (parser != NULL);
-  assert (option_name != NULL);
+        assert (parser != NULL);
+        assert (option_name != NULL);
 
-  ply_command_parser_get_option_for_command (parser,
-                                             parser->main_command,
-                                             option_name,
-                                             option_result,
-                                             option_is_set);
+        ply_command_parser_get_option_for_command (parser,
+                                                   parser->main_command,
+                                                   option_name,
+                                                   option_result,
+                                                   option_is_set);
 }
 
 void
 ply_command_parser_get_options (ply_command_parser_t *parser,
-                                const char *option_name, /*
-                                void *      option_result,
-                                bool *      option_was_set */
+                                const char           *option_name, /*
+                                                                    * void *      option_result,
+                                                                    * bool *      option_was_set */
                                 ...)
 {
-  va_list args;
+        va_list args;
 
-  assert (parser != NULL);
-  assert (option_name != NULL);
+        assert (parser != NULL);
+        assert (option_name != NULL);
 
-  va_start (args, option_name);
-  ply_command_parser_get_options_for_command (parser, parser->main_command, option_name, args);
-  va_end (args);
+        va_start (args, option_name);
+        ply_command_parser_get_options_for_command (parser, parser->main_command, option_name, args);
+        va_end (args);
 }
 
 void
@@ -633,76 +616,76 @@ ply_command_parser_get_command_option (ply_command_parser_t *parser,
                                        void                 *option_result,
                                        bool                 *option_is_set)
 {
-  ply_command_t *command;
+        ply_command_t *command;
 
-  assert (parser != NULL);
-  assert (command_name != NULL);
-  assert (option_name != NULL);
+        assert (parser != NULL);
+        assert (command_name != NULL);
+        assert (option_name != NULL);
 
-  command = ply_command_parser_get_command (parser, command_name);
+        command = ply_command_parser_get_command (parser, command_name);
 
-  if (command == NULL)
-    return;
+        if (command == NULL)
+                return;
 
-  ply_command_parser_get_option_for_command (parser,
-                                             parser->main_command,
-                                             option_name,
-                                             option_result,
-                                             option_is_set);
+        ply_command_parser_get_option_for_command (parser,
+                                                   parser->main_command,
+                                                   option_name,
+                                                   option_result,
+                                                   option_is_set);
 }
 
 
 void
 ply_command_parser_get_command_options (ply_command_parser_t *parser,
-                                        const char *command_name,
-                                        const char *option_name, /*
-                                        void *      option_result,
-                                        bool *      option_was_set */
+                                        const char           *command_name,
+                                        const char           *option_name, /*
+                                                                            * void *      option_result,
+                                                                            * bool *      option_was_set */
                                         ...)
 {
-  ply_command_t *command;
-  va_list args;
+        ply_command_t *command;
+        va_list args;
 
-  assert (parser != NULL);
-  assert (command_name != NULL);
-  assert (option_name != NULL);
+        assert (parser != NULL);
+        assert (command_name != NULL);
+        assert (option_name != NULL);
 
-  command = ply_command_parser_get_command (parser, command_name);
+        command = ply_command_parser_get_command (parser, command_name);
 
-  if (command == NULL)
-    return;
+        if (command == NULL)
+                return;
 
-  va_start (args, option_name);
-  ply_command_parser_get_options_for_command (parser, command, option_name, args);
-  va_end (args);
+        va_start (args, option_name);
+        ply_command_parser_get_options_for_command (parser, command, option_name, args);
+        va_end (args);
 
-  ply_list_append_data (parser->available_subcommands, command);
+        ply_list_append_data (parser->available_subcommands, command);
 }
 
 static void
 ply_command_parser_detach_from_event_loop (ply_command_parser_t *parser)
 {
-  parser->loop = NULL;
+        parser->loop = NULL;
 }
 
 void
 ply_command_parser_stop_parsing_arguments (ply_command_parser_t *parser)
 {
-  assert (parser != NULL);
+        assert (parser != NULL);
 
-  if (parser->loop == NULL)
-    return;
+        if (parser->loop == NULL)
+                return;
 
-  ply_event_loop_stop_watching_for_exit (parser->loop,
-                                         (ply_event_loop_exit_handler_t)
-                                         ply_command_parser_detach_from_event_loop,
-                                         parser);
+        ply_event_loop_stop_watching_for_exit (parser->loop,
+                                               (ply_event_loop_exit_handler_t)
+                                               ply_command_parser_detach_from_event_loop,
+                                               parser);
 }
 
 static bool
 argument_is_option (const char *argument)
 {
-  return argument[0] == '-' && argument[1] == '-';
+        return argument[0] == '-' && argument[1] == '-';
 }
 
 static bool
@@ -710,262 +693,255 @@ ply_command_option_read_arguments (ply_command_option_t *option,
                                    ply_list_t           *arguments)
 
 {
-  ply_list_node_t *node;
-  const char *argument;
+        ply_list_node_t *node;
+        const char *argument;
 
-  assert (option != NULL);
+        assert (option != NULL);
 
-  node = ply_list_get_first_node (arguments);
+        node = ply_list_get_first_node (arguments);
 
-  if (node == NULL)
-    {
-      if (option->type == PLY_COMMAND_OPTION_TYPE_BOOLEAN ||
-          option->type == PLY_COMMAND_OPTION_TYPE_FLAG)
-        {
-          option->result.as_boolean = true;
-          return true;
+        if (node == NULL) {
+                if (option->type == PLY_COMMAND_OPTION_TYPE_BOOLEAN ||
+                    option->type == PLY_COMMAND_OPTION_TYPE_FLAG) {
+                        option->result.as_boolean = true;
+                        return true;
+                }
+
+                return false;
         }
 
-      return false;
-    }
+        argument = (const char *) ply_list_node_get_data (node);
 
-  argument = (const char *) ply_list_node_get_data (node);
+        assert (argument != NULL);
 
-  assert (argument != NULL);
+        if (argument_is_option (argument)) {
+                if (option->type == PLY_COMMAND_OPTION_TYPE_BOOLEAN ||
+                    option->type == PLY_COMMAND_OPTION_TYPE_FLAG) {
+                        option->result.as_boolean = true;
+                        return true;
+                }
 
-  if (argument_is_option (argument))
-    {
-      if (option->type == PLY_COMMAND_OPTION_TYPE_BOOLEAN ||
-          option->type == PLY_COMMAND_OPTION_TYPE_FLAG)
-        {
-          option->result.as_boolean = true;
-          return true;
+                return false;
         }
 
-      return false;
-    }
-
-  switch (option->type)
-    {
-      case PLY_COMMAND_OPTION_TYPE_FLAG:
-      case PLY_COMMAND_OPTION_TYPE_BOOLEAN:
-
-          /* next argument isn't ours, so treat it like an unqualified
-           * flag
-           */
-          if (rpmatch (argument) < 0)
-            {
-              option->result.as_boolean = true;
-              return true;
-            }
-
-          option->result.as_boolean = (bool) rpmatch (argument);
-          ply_list_remove_node (arguments, node);
-          return true;
-
-      case PLY_COMMAND_OPTION_TYPE_STRING:
-        option->result.as_string = strdup (argument);
-        ply_list_remove_node (arguments, node);
-        return true;
+        switch (option->type) {
+        case PLY_COMMAND_OPTION_TYPE_FLAG:
+        case PLY_COMMAND_OPTION_TYPE_BOOLEAN:
+
+                /* next argument isn't ours, so treat it like an unqualified
+                 * flag
+                 */
+                if (rpmatch (argument) < 0) {
+                        option->result.as_boolean = true;
+                        return true;
+                }
+
+                option->result.as_boolean = (bool) rpmatch (argument);
+                ply_list_remove_node (arguments, node);
+                return true;
+
+        case PLY_COMMAND_OPTION_TYPE_STRING:
+                option->result.as_string = strdup (argument);
+                ply_list_remove_node (arguments, node);
+                return true;
 
-      case PLY_COMMAND_OPTION_TYPE_INTEGER:
+        case PLY_COMMAND_OPTION_TYPE_INTEGER:
         {
-         char *end;
-         long argument_as_long;
+                char *end;
+                long argument_as_long;
 
-         if (argument[0] == '\0')
-           return false;
+                if (argument[0] == '\0')
+                        return false;
 
-         argument_as_long = strtol (argument, &end, 0);
+                argument_as_long = strtol (argument, &end, 0);
 
-         if (*end != '\0')
-           return false;
+                if (*end != '\0')
+                        return false;
 
-         if (argument_as_long == LONG_MIN &&
-             errno == ERANGE)
-           return false; 
+                if (argument_as_long == LONG_MIN &&
+                    errno == ERANGE)
+                        return false;
 
-         if (argument_as_long > INT_MAX)
-           return false;
+                if (argument_as_long > INT_MAX)
+                        return false;
 
-         option->result.as_integer = (int) argument_as_long;
-         ply_list_remove_node (arguments, node);
-         return true;
+                option->result.as_integer = (int) argument_as_long;
+                ply_list_remove_node (arguments, node);
+                return true;
+        }
         }
-    }
 
-  return option;
+        return option;
 }
 
 static ply_command_option_t *
 ply_command_read_option (ply_command_t *command,
                          ply_list_t    *arguments)
 {
-  ply_list_node_t *node;
-  const char *argument;
-  char *option_name;
-  char *option_separator;
-  ply_command_option_t *option;
+        ply_list_node_t *node;
+        const char *argument;
+        char *option_name;
+        char *option_separator;
+        ply_command_option_t *option;
 
-  node = ply_list_get_first_node (arguments);
+        node = ply_list_get_first_node (arguments);
 
-  if (node == NULL)
-    return NULL;
+        if (node == NULL)
+                return NULL;
 
-  argument = (const char *) ply_list_node_get_data (node);
+        argument = (const char *) ply_list_node_get_data (node);
 
-  assert (argument != NULL);
+        assert (argument != NULL);
 
-  if (!argument_is_option (argument))
-    return NULL;
+        if (!argument_is_option (argument))
+                return NULL;
 
-  option_name = strdup (argument + strlen ("--"));
-  option_separator = strchr (option_name, '=');
+        option_name = strdup (argument + strlen ("--"));
+        option_separator = strchr (option_name, '=');
 
-  if (option_separator != NULL)
-    {
-      *option_separator = '\0';
-      ply_list_insert_data (arguments,
-                            (void *) (argument +
-                            ((ptrdiff_t) (option_separator - option_name + 1)) +
-                            strlen ("=") + 1),
-                            node);
-    }
+        if (option_separator != NULL) {
+                *option_separator = '\0';
+                ply_list_insert_data (arguments,
+                                      (void *) (argument +
+                                                ((ptrdiff_t) (option_separator - option_name + 1)) +
+                                                strlen ("=") + 1),
+                                      node);
+        }
 
-  option = ply_command_get_option (command, option_name);
-  free (option_name);
+        option = ply_command_get_option (command, option_name);
+        free (option_name);
 
-  if (option == NULL)
-    return NULL;
+        if (option == NULL)
+                return NULL;
 
-  ply_list_remove_node (arguments, node);
+        ply_list_remove_node (arguments, node);
 
-  if (ply_command_option_read_arguments (option, arguments))
-    option->was_set = true;
+        if (ply_command_option_read_arguments (option, arguments))
+                option->was_set = true;
 
-  return option;
+        return option;
 }
 
 static bool
 argument_is_command (const char *argument)
 {
-  return !argument_is_option (argument);
+        return !argument_is_option (argument);
 }
 
 static ply_command_t *
 ply_command_parser_read_command (ply_command_parser_t *parser)
 {
-  ply_list_node_t *node;
-  const char *argument;
-  ply_command_t *command;
+        ply_list_node_t *node;
+        const char *argument;
+        ply_command_t *command;
 
-  node = ply_list_get_first_node (parser->arguments);
+        node = ply_list_get_first_node (parser->arguments);
 
-  if (node == NULL)
-    return NULL;
+        if (node == NULL)
+                return NULL;
 
-  argument = (const char *) ply_list_node_get_data (node);
+        argument = (const char *) ply_list_node_get_data (node);
 
-  assert (argument != NULL);
+        assert (argument != NULL);
 
-  if (!argument_is_command (argument))
-    return NULL;
+        if (!argument_is_command (argument))
+                return NULL;
 
-  command = ply_command_parser_get_command (parser, argument);
+        command = ply_command_parser_get_command (parser, argument);
 
-  if (command == NULL)
-    return NULL;
+        if (command == NULL)
+                return NULL;
 
-  ply_list_remove_node (parser->arguments, node);
+        ply_list_remove_node (parser->arguments, node);
 
-  while (ply_command_read_option (command, parser->arguments) != NULL);
+        while (ply_command_read_option (command, parser->arguments) != NULL) {
+        }
 
-  return command;
+        return command;
 }
 
 static void
 on_command_dispatch_timeout (ply_command_parser_t *parser)
 {
+        ply_command_t *command;
+        ply_list_node_t *node;
 
-  ply_command_t *command;
-  ply_list_node_t *node;
-
-  command = NULL;
-  node = ply_list_get_first_node (parser->read_subcommands);
+        command = NULL;
+        node = ply_list_get_first_node (parser->read_subcommands);
 
-  if (node == NULL)
-    {
-      parser->dispatch_is_queued = false;
-      return;
-    }
+        if (node == NULL) {
+                parser->dispatch_is_queued = false;
+                return;
+        }
 
-  command = (ply_command_t *) ply_list_node_get_data (node);
+        command = (ply_command_t *) ply_list_node_get_data (node);
 
-  assert (command != NULL);
+        assert (command != NULL);
 
-  ply_event_loop_watch_for_timeout (parser->loop, 0.01,
-                                    (ply_event_loop_timeout_handler_t)
-                                    on_command_dispatch_timeout,
-                                    parser);
+        ply_event_loop_watch_for_timeout (parser->loop, 0.01,
+                                          (ply_event_loop_timeout_handler_t)
+                                          on_command_dispatch_timeout,
+                                          parser);
 
-  if (command->handler != NULL)
-    command->handler (command->handler_data, command->name);
+        if (command->handler != NULL)
+                command->handler (command->handler_data, command->name);
 
-  ply_list_remove_node (parser->read_subcommands, node);
+        ply_list_remove_node (parser->read_subcommands, node);
 }
 
 static void
 ply_command_parser_queue_command_dispatch (ply_command_parser_t *parser)
 {
-  if (parser->dispatch_is_queued)
-    return;
+        if (parser->dispatch_is_queued)
+                return;
 
-  ply_event_loop_watch_for_timeout (parser->loop, 0.01,
-                                    (ply_event_loop_timeout_handler_t)
-                                    on_command_dispatch_timeout,
-                                    parser);
+        ply_event_loop_watch_for_timeout (parser->loop, 0.01,
+                                          (ply_event_loop_timeout_handler_t)
+                                          on_command_dispatch_timeout,
+                                          parser);
 }
 
 bool
 ply_command_parser_parse_arguments (ply_command_parser_t *parser,
                                     ply_event_loop_t     *loop,
-                                    char * const         *arguments,
+                                    char *const          *arguments,
                                     int                   number_of_arguments)
 {
-  ply_command_t *command;
-  bool parsed_arguments;
+        ply_command_t *command;
+        bool parsed_arguments;
 
-  assert (parser != NULL);
-  assert (loop != NULL);
-  assert (parser->loop == NULL);
-  assert (number_of_arguments >= 1);
+        assert (parser != NULL);
+        assert (loop != NULL);
+        assert (parser->loop == NULL);
+        assert (number_of_arguments >= 1);
 
-  parsed_arguments = false;
+        parsed_arguments = false;
 
-  if (number_of_arguments == 1)
-    return true;
+        if (number_of_arguments == 1)
+                return true;
 
-  ply_command_parser_set_arguments (parser, arguments + 1, number_of_arguments - 1);
+        ply_command_parser_set_arguments (parser, arguments + 1, number_of_arguments - 1);
 
-  while (ply_command_read_option (parser->main_command, parser->arguments) != NULL)
-    parsed_arguments = true;
+        while (ply_command_read_option (parser->main_command, parser->arguments) != NULL) {
+                parsed_arguments = true;
+        }
 
-  parser->loop = loop;
+        parser->loop = loop;
 
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
-                                 ply_command_parser_detach_from_event_loop,
-                                 parser);
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       ply_command_parser_detach_from_event_loop,
+                                       parser);
 
-  while ((command = ply_command_parser_read_command (parser)) != NULL)
-    ply_list_append_data (parser->read_subcommands, command);
+        while ((command = ply_command_parser_read_command (parser)) != NULL) {
+                ply_list_append_data (parser->read_subcommands, command);
+        }
 
-  if (ply_list_get_length (parser->read_subcommands) > 0)
-    {
-      ply_command_parser_queue_command_dispatch (parser);
-      parsed_arguments = true;
-    }
+        if (ply_list_get_length (parser->read_subcommands) > 0) {
+                ply_command_parser_queue_command_dispatch (parser);
+                parsed_arguments = true;
+        }
 
-  return parsed_arguments;
+        return parsed_arguments;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-command-parser.h b/src/libply/ply-command-parser.h
index 8af0057..33f2efb 100644
--- a/src/libply/ply-command-parser.h
+++ b/src/libply/ply-command-parser.h
@@ -27,15 +27,15 @@
 #include "ply-event-loop.h"
 
 typedef struct _ply_command_parser ply_command_parser_t;
-typedef void (* ply_command_handler_t) (void *data,
-                                        const char *command);
+typedef void (*ply_command_handler_t) (void       *data,
+                                       const char *command);
 
 typedef enum
 {
-  PLY_COMMAND_OPTION_TYPE_FLAG = 0,
-  PLY_COMMAND_OPTION_TYPE_BOOLEAN,
-  PLY_COMMAND_OPTION_TYPE_STRING,
-  PLY_COMMAND_OPTION_TYPE_INTEGER
+        PLY_COMMAND_OPTION_TYPE_FLAG = 0,
+        PLY_COMMAND_OPTION_TYPE_BOOLEAN,
+        PLY_COMMAND_OPTION_TYPE_STRING,
+        PLY_COMMAND_OPTION_TYPE_INTEGER
 } ply_command_option_type_t;
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
@@ -43,34 +43,35 @@ ply_command_parser_t *ply_command_parser_new (const char *name,
                                               const char *description);
 
 void ply_command_parser_add_options (ply_command_parser_t *parser,
-                                     const char *option_name, /*
-                                     const char *option_description,
-                                     ply_option_argument_type_t option_type */
+                                     const char           *option_name, /*
+                                                                         * const char *option_description,
+                                                                         * ply_option_argument_type_t option_type */
                                      ...);
 void ply_command_parser_add_command (ply_command_parser_t *parser,
-                                     const char *name, const char *description,
+                                     const char           *name,
+                                     const char           *description,
                                      ply_command_handler_t handler,
-                                     void *handler_data,
-                                     const char *option_name, /*
-                                     const char *option_description,
-                                     ply_option_argument_type_t option_type */
+                                     void                 *handler_data,
+                                     const char           *option_name, /*
+                                                                         * const char *option_description,
+                                                                         * ply_option_argument_type_t option_type */
                                      ...);
 void ply_command_parser_add_command_alias (ply_command_parser_t *parser,
                                            const char           *name,
                                            const char           *alias);
 void ply_command_parser_get_options (ply_command_parser_t *parser,
-                                     const char *option_name, /*
-                                     void *      option_result */
+                                     const char           *option_name, /*
+                                                                         * void *      option_result */
                                      ...);
 void ply_command_parser_get_option (ply_command_parser_t *parser,
                                     const char           *option_name,
                                     void                 *option_result,
                                     bool                 *option_is_set);
 void ply_command_parser_get_command_options (ply_command_parser_t *parser,
-                                             const char *command_name,
-                                             const char *option_name, /*
-                                             void *      option_result,
-                                             bool *      option_was_set */
+                                             const char           *command_name,
+                                             const char           *option_name, /*
+                                                                                 * void *      option_result,
+                                                                                 * bool *      option_was_set */
                                              ...);
 void ply_command_parser_get_command_option (ply_command_parser_t *parser,
                                             const char           *command_name,
@@ -83,7 +84,7 @@ char *ply_command_parser_get_help_string (ply_command_parser_t *parser);
 
 bool ply_command_parser_parse_arguments (ply_command_parser_t *parser,
                                          ply_event_loop_t     *loop,
-                                         char * const         *arguments,
+                                         char *const          *arguments,
                                          int                   number_of_arguments);
 void ply_command_parser_free (ply_command_parser_t *command_parser);
 #endif
diff --git a/src/libply/ply-event-loop.c b/src/libply/ply-event-loop.c
index 71ba852..9736dae 100644
--- a/src/libply/ply-event-loop.c
+++ b/src/libply/ply-event-loop.c
@@ -51,36 +51,36 @@
 
 typedef struct
 {
-  int fd;
-  ply_list_t *destinations;
-  ply_list_t *fd_watches;
-  uint32_t is_getting_polled : 1;
-  uint32_t is_disconnected : 1;
-  int reference_count;
+        int         fd;
+        ply_list_t *destinations;
+        ply_list_t *fd_watches;
+        uint32_t    is_getting_polled : 1;
+        uint32_t    is_disconnected : 1;
+        int         reference_count;
 } ply_event_source_t;
 
 typedef struct
 {
-  ply_event_source_t *source;
+        ply_event_source_t        *source;
 
-  ply_event_loop_fd_status_t status;
-  ply_event_handler_t status_met_handler;
-  ply_event_handler_t disconnected_handler;
-  void *user_data;
+        ply_event_loop_fd_status_t status;
+        ply_event_handler_t        status_met_handler;
+        ply_event_handler_t        disconnected_handler;
+        void                      *user_data;
 } ply_event_destination_t;
 
 struct _ply_fd_watch
 {
-  ply_event_destination_t *destination;
+        ply_event_destination_t *destination;
 };
 
 typedef struct
 {
-  int signal_number;
-  ply_event_handler_t handler;
-  void *user_data;
+        int                 signal_number;
+        ply_event_handler_t handler;
+        void               *user_data;
 
-  sighandler_t old_posix_signal_handler;
+        sighandler_t        old_posix_signal_handler;
 } ply_signal_source_t;
 
 static int ply_signal_dispatcher_sender_fd = -1,
@@ -88,38 +88,38 @@ static int ply_signal_dispatcher_sender_fd = -1,
 
 typedef struct
 {
-  ply_list_t *sources;
+        ply_list_t *sources;
 } ply_signal_dispatcher_t;
 
 typedef struct
 {
-  ply_event_loop_exit_handler_t  handler;
-  void                          *user_data;
+        ply_event_loop_exit_handler_t handler;
+        void                         *user_data;
 } ply_event_loop_exit_closure_t;
 
 typedef struct
 {
-  double timeout;
-  ply_event_loop_timeout_handler_t  handler;
-  void                             *user_data;
+        double                           timeout;
+        ply_event_loop_timeout_handler_t handler;
+        void                            *user_data;
 } ply_event_loop_timeout_watch_t;
 
 struct _ply_event_loop
 {
-  int epoll_fd;
-  int exit_code;
-  double wakeup_time;
+        int                      epoll_fd;
+        int                      exit_code;
+        double                   wakeup_time;
 
-  ply_list_t *sources;
-  ply_list_t *exit_closures;
-  ply_list_t *timeout_watches;
+        ply_list_t              *sources;
+        ply_list_t              *exit_closures;
+        ply_list_t              *timeout_watches;
 
-  ply_signal_dispatcher_t *signal_dispatcher;
+        ply_signal_dispatcher_t *signal_dispatcher;
 
-  uint32_t should_exit : 1;
+        uint32_t                 should_exit : 1;
 };
 
-static void ply_event_loop_remove_source (ply_event_loop_t    *loop,
+static void ply_event_loop_remove_source (ply_event_loop_t   *loop,
                                           ply_event_source_t *source);
 static ply_list_node_t *ply_event_loop_find_source_node (ply_event_loop_t *loop,
                                                          int               fd);
@@ -130,292 +130,283 @@ ply_signal_dispatcher_find_source_node (ply_signal_dispatcher_t *dispatcher,
 
 
 static ply_signal_source_t *
-ply_signal_source_new (int                  signal_number,
-                       ply_event_handler_t  signal_handler,
-                       void                *user_data)
+ply_signal_source_new (int                 signal_number,
+                       ply_event_handler_t signal_handler,
+                       void               *user_data)
 {
-  ply_signal_source_t *source;
+        ply_signal_source_t *source;
 
-  source = calloc (1, sizeof (ply_signal_source_t));
-  source->signal_number = signal_number;
-  source->handler = signal_handler;
-  source->user_data = user_data;
-  source->old_posix_signal_handler = NULL;
+        source = calloc (1, sizeof(ply_signal_source_t));
+        source->signal_number = signal_number;
+        source->handler = signal_handler;
+        source->user_data = user_data;
+        source->old_posix_signal_handler = NULL;
 
-  return source;
+        return source;
 }
 
 static void
 ply_signal_source_free (ply_signal_source_t *handler)
 {
-  if (handler == NULL)
-    return;
+        if (handler == NULL)
+                return;
 
-  free (handler);
+        free (handler);
 }
 
 static ply_signal_dispatcher_t *
 ply_signal_dispatcher_new (void)
 {
-  ply_signal_dispatcher_t *dispatcher;
+        ply_signal_dispatcher_t *dispatcher;
 
-  if (!ply_open_unidirectional_pipe (&ply_signal_dispatcher_sender_fd,
-                                     &ply_signal_dispatcher_receiver_fd))
-    return NULL;
+        if (!ply_open_unidirectional_pipe (&ply_signal_dispatcher_sender_fd,
+                                           &ply_signal_dispatcher_receiver_fd))
+                return NULL;
 
-  dispatcher = calloc (1, sizeof (ply_signal_dispatcher_t));
+        dispatcher = calloc (1, sizeof(ply_signal_dispatcher_t));
 
-  dispatcher->sources = ply_list_new ();
+        dispatcher->sources = ply_list_new ();
 
-  return dispatcher;
+        return dispatcher;
 }
 
 static void
 ply_signal_dispatcher_free (ply_signal_dispatcher_t *dispatcher)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (dispatcher == NULL)
-    return;
+        if (dispatcher == NULL)
+                return;
 
-  close (ply_signal_dispatcher_receiver_fd);
-  ply_signal_dispatcher_receiver_fd = -1;
-  close (ply_signal_dispatcher_sender_fd);
-  ply_signal_dispatcher_sender_fd = -1;
+        close (ply_signal_dispatcher_receiver_fd);
+        ply_signal_dispatcher_receiver_fd = -1;
+        close (ply_signal_dispatcher_sender_fd);
+        ply_signal_dispatcher_sender_fd = -1;
 
-  node = ply_list_get_first_node (dispatcher->sources);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_signal_source_t *source;
+        node = ply_list_get_first_node (dispatcher->sources);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_signal_source_t *source;
 
-      source = (ply_signal_source_t *) ply_list_node_get_data (node);
+                source = (ply_signal_source_t *) ply_list_node_get_data (node);
 
-      next_node = ply_list_get_next_node (dispatcher->sources, node);
+                next_node = ply_list_get_next_node (dispatcher->sources, node);
 
-      ply_signal_source_free (source);
+                ply_signal_source_free (source);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  ply_list_free (dispatcher->sources);
+        ply_list_free (dispatcher->sources);
 
-  free (dispatcher);
+        free (dispatcher);
 }
 
 static void
 ply_signal_dispatcher_posix_signal_handler (int signal_number)
 {
-  if (ply_signal_dispatcher_sender_fd < 0)
-    return;
+        if (ply_signal_dispatcher_sender_fd < 0)
+                return;
 
-  ply_write (ply_signal_dispatcher_sender_fd, &signal_number,
-             sizeof (signal_number));
+        ply_write (ply_signal_dispatcher_sender_fd, &signal_number,
+                   sizeof(signal_number));
 }
 
 static int
 ply_signal_dispatcher_get_next_signal_from_pipe (ply_signal_dispatcher_t *dispatcher)
 {
-  int signal_number;
+        int signal_number;
 
-  if (!ply_read (ply_signal_dispatcher_receiver_fd, &signal_number,
-                 sizeof (signal_number)))
-    signal_number = 0;
+        if (!ply_read (ply_signal_dispatcher_receiver_fd, &signal_number,
+                       sizeof(signal_number)))
+                signal_number = 0;
 
-  return signal_number;
+        return signal_number;
 }
 
 static void
 ply_signal_dispatcher_dispatch_signal (ply_signal_dispatcher_t *dispatcher,
                                        int                      fd)
 {
-  ply_list_node_t *node;
-  int signal_number;
+        ply_list_node_t *node;
+        int signal_number;
 
-  assert (fd == ply_signal_dispatcher_receiver_fd);
+        assert (fd == ply_signal_dispatcher_receiver_fd);
 
-  signal_number = ply_signal_dispatcher_get_next_signal_from_pipe (dispatcher);
+        signal_number = ply_signal_dispatcher_get_next_signal_from_pipe (dispatcher);
 
-  node = ply_list_get_first_node (dispatcher->sources);
-  while (node != NULL)
-    {
-      ply_signal_source_t *source;
+        node = ply_list_get_first_node (dispatcher->sources);
+        while (node != NULL) {
+                ply_signal_source_t *source;
 
-      source = (ply_signal_source_t *) ply_list_node_get_data (node);
+                source = (ply_signal_source_t *) ply_list_node_get_data (node);
 
-      if (source->signal_number == signal_number)
-        {
-          if (source->handler != NULL)
-            source->handler (source->user_data, signal_number);
-        }
+                if (source->signal_number == signal_number)
+                        if (source->handler != NULL)
+                                source->handler (source->user_data, signal_number);
 
-      node = ply_list_get_next_node (dispatcher->sources, node);
-    }
+                node = ply_list_get_next_node (dispatcher->sources, node);
+        }
 }
 
 static void
 ply_signal_dispatcher_reset_signal_sources (ply_signal_dispatcher_t *dispatcher,
                                             int                      fd)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (dispatcher->sources);
-  while (node != NULL)
-    {
-      ply_signal_source_t *handler;
+        node = ply_list_get_first_node (dispatcher->sources);
+        while (node != NULL) {
+                ply_signal_source_t *handler;
 
-      handler = (ply_signal_source_t *) ply_list_node_get_data (node);
+                handler = (ply_signal_source_t *) ply_list_node_get_data (node);
 
-      signal (handler->signal_number,
-              handler->old_posix_signal_handler != NULL?
-              handler->old_posix_signal_handler : SIG_DFL);
+                signal (handler->signal_number,
+                        handler->old_posix_signal_handler != NULL ?
+                        handler->old_posix_signal_handler : SIG_DFL);
 
-      node = ply_list_get_next_node (dispatcher->sources, node);
-    }
+                node = ply_list_get_next_node (dispatcher->sources, node);
+        }
 }
 
 static ply_event_destination_t *
-ply_event_destination_new (ply_event_loop_fd_status_t     status,
-                           ply_event_handler_t            status_met_handler,
-                           ply_event_handler_t            disconnected_handler,
-                           void                          *user_data)
+ply_event_destination_new (ply_event_loop_fd_status_t status,
+                           ply_event_handler_t        status_met_handler,
+                           ply_event_handler_t        disconnected_handler,
+                           void                      *user_data)
 {
-  ply_event_destination_t *destination;
+        ply_event_destination_t *destination;
 
-  destination = calloc (1, sizeof (ply_event_destination_t));
+        destination = calloc (1, sizeof(ply_event_destination_t));
 
-  destination->source = NULL;
-  destination->status = status;
-  destination->status_met_handler = status_met_handler;
-  destination->disconnected_handler = disconnected_handler;
-  destination->user_data = user_data;
+        destination->source = NULL;
+        destination->status = status;
+        destination->status_met_handler = status_met_handler;
+        destination->disconnected_handler = disconnected_handler;
+        destination->user_data = user_data;
 
-  return destination;
+        return destination;
 }
 
 static void
 ply_event_destination_free (ply_event_destination_t *destination)
 {
-  if (destination == NULL)
-    return;
+        if (destination == NULL)
+                return;
 
-  free (destination);
+        free (destination);
 }
 
 static ply_fd_watch_t *
 ply_fd_watch_new (ply_event_destination_t *destination)
 {
-  ply_fd_watch_t *watch;
+        ply_fd_watch_t *watch;
 
-  watch = calloc (1, sizeof (ply_fd_watch_t));
-  watch->destination = destination;
+        watch = calloc (1, sizeof(ply_fd_watch_t));
+        watch->destination = destination;
 
-  return watch;
+        return watch;
 }
 
 static void
 ply_fd_watch_free (ply_fd_watch_t *watch)
 {
-  watch->destination = NULL;
-  free (watch);
+        watch->destination = NULL;
+        free (watch);
 }
 
 static void
 ply_event_source_take_reference (ply_event_source_t *source)
 {
-  source->reference_count++;
+        source->reference_count++;
 }
 
 static ply_event_source_t *
 ply_event_source_new (int fd)
 {
-  ply_event_source_t *source;
+        ply_event_source_t *source;
 
-  source = calloc (1, sizeof (ply_event_source_t));
+        source = calloc (1, sizeof(ply_event_source_t));
 
-  source->fd = fd;
-  source->destinations = ply_list_new ();
-  source->fd_watches = ply_list_new ();
-  source->is_getting_polled = false;
-  source->is_disconnected = false;
-  source->reference_count = 0;
+        source->fd = fd;
+        source->destinations = ply_list_new ();
+        source->fd_watches = ply_list_new ();
+        source->is_getting_polled = false;
+        source->is_disconnected = false;
+        source->reference_count = 0;
 
-  return source;
+        return source;
 }
 
 static void
 ply_event_source_free (ply_event_source_t *source)
 {
-  if (source == NULL)
-    return;
+        if (source == NULL)
+                return;
 
-  assert (ply_list_get_length (source->destinations) == 0);
+        assert (ply_list_get_length (source->destinations) == 0);
 
-  ply_list_free (source->destinations);
-  ply_list_free (source->fd_watches);
-  free (source);
+        ply_list_free (source->destinations);
+        ply_list_free (source->fd_watches);
+        free (source);
 }
 
 static void
 ply_event_source_drop_reference (ply_event_source_t *source)
 {
-  if (source == NULL)
-    return;
+        if (source == NULL)
+                return;
 
-  source->reference_count--;
+        source->reference_count--;
 
-  assert (source->reference_count >= 0);
+        assert (source->reference_count >= 0);
 
-  if (source->reference_count == 0)
-    {
-      ply_event_source_free (source);
-    }
+        if (source->reference_count == 0)
+                ply_event_source_free (source);
 }
 
 static void
 ply_event_loop_update_source_event_mask (ply_event_loop_t   *loop,
                                          ply_event_source_t *source)
 {
-  ply_list_node_t *node;
-  struct epoll_event event = { 0 };
+        ply_list_node_t *node;
+        struct epoll_event event = { 0 };
 
-  assert (loop != NULL);
-  assert (source != NULL);
-  assert (source->destinations != NULL);
+        assert (loop != NULL);
+        assert (source != NULL);
+        assert (source->destinations != NULL);
 
-  event.events = EPOLLERR | EPOLLHUP;
+        event.events = EPOLLERR | EPOLLHUP;
 
-  node = ply_list_get_first_node (source->destinations);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_event_destination_t *destination;
+        node = ply_list_get_first_node (source->destinations);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_event_destination_t *destination;
 
-      destination = (ply_event_destination_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (source->destinations, node);
+                destination = (ply_event_destination_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (source->destinations, node);
 
-      if (destination->status & PLY_EVENT_LOOP_FD_STATUS_HAS_DATA)
-          event.events |= EPOLLIN;
+                if (destination->status & PLY_EVENT_LOOP_FD_STATUS_HAS_DATA)
+                        event.events |= EPOLLIN;
 
-      if (destination->status & PLY_EVENT_LOOP_FD_STATUS_HAS_CONTROL_DATA)
-          event.events |= EPOLLPRI;
+                if (destination->status & PLY_EVENT_LOOP_FD_STATUS_HAS_CONTROL_DATA)
+                        event.events |= EPOLLPRI;
 
-      if (destination->status & PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA)
-          event.events |= EPOLLOUT;
+                if (destination->status & PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA)
+                        event.events |= EPOLLOUT;
 
-      node = next_node;
-    }
-  event.data.ptr = source;
+                node = next_node;
+        }
+        event.data.ptr = source;
 
-  if (source->is_getting_polled)
-    {
-      int status;
+        if (source->is_getting_polled) {
+                int status;
 
-      status = epoll_ctl (loop->epoll_fd, EPOLL_CTL_MOD, source->fd, &event);
+                status = epoll_ctl (loop->epoll_fd, EPOLL_CTL_MOD, source->fd, &event);
 
-      if (status < 0)
-         ply_trace ("failed to modify epoll event mask for fd %d: %m", source->fd);
-    }
+                if (status < 0)
+                        ply_trace ("failed to modify epoll event mask for fd %d: %m", source->fd);
+        }
 }
 
 static ply_fd_watch_t *
@@ -423,948 +414,909 @@ ply_event_loop_add_destination_for_source (ply_event_loop_t        *loop,
                                            ply_event_destination_t *destination,
                                            ply_event_source_t      *source)
 {
-  ply_list_node_t *destination_node;
-  ply_fd_watch_t *watch;
+        ply_list_node_t *destination_node;
+        ply_fd_watch_t *watch;
 
-  assert (loop != NULL);
-  assert (destination != NULL);
-  assert (destination->source == NULL);
-  assert (source != NULL);
+        assert (loop != NULL);
+        assert (destination != NULL);
+        assert (destination->source == NULL);
+        assert (source != NULL);
 
-  destination->source = source;
-  ply_event_source_take_reference (source);
-  destination_node = ply_list_append_data (source->destinations, destination);
-  assert (destination_node != NULL);
-  assert (destination->source == source);
+        destination->source = source;
+        ply_event_source_take_reference (source);
+        destination_node = ply_list_append_data (source->destinations, destination);
+        assert (destination_node != NULL);
+        assert (destination->source == source);
 
-  ply_event_loop_update_source_event_mask (loop, source);
+        ply_event_loop_update_source_event_mask (loop, source);
 
-  watch = ply_fd_watch_new (destination);
+        watch = ply_fd_watch_new (destination);
 
-  ply_event_source_take_reference (source);
-  ply_list_append_data (source->fd_watches, watch);
+        ply_event_source_take_reference (source);
+        ply_list_append_data (source->fd_watches, watch);
 
-  return watch;
+        return watch;
 }
 
 static ply_event_destination_t *
 ply_event_loop_get_destination_from_fd_watch (ply_event_loop_t *loop,
                                               ply_fd_watch_t   *watch)
 {
-   ply_event_destination_t *destination;
+        ply_event_destination_t *destination;
 
-   assert (loop != NULL);
-   assert (watch != NULL);
-   assert (watch->destination != NULL);
+        assert (loop != NULL);
+        assert (watch != NULL);
+        assert (watch->destination != NULL);
 
-   destination = watch->destination;
+        destination = watch->destination;
 
-   return destination;
+        return destination;
 }
 
 static void
 ply_event_loop_remove_destination_by_fd_watch (ply_event_loop_t *loop,
                                                ply_fd_watch_t   *watch)
 {
-  ply_event_destination_t *destination;
-  ply_event_source_t *source;
+        ply_event_destination_t *destination;
+        ply_event_source_t *source;
 
-  assert (loop != NULL);
-  assert (watch != NULL);
+        assert (loop != NULL);
+        assert (watch != NULL);
 
-  destination = ply_event_loop_get_destination_from_fd_watch (loop, watch);
-  assert (destination != NULL);
+        destination = ply_event_loop_get_destination_from_fd_watch (loop, watch);
+        assert (destination != NULL);
 
-  source = destination->source;
-  assert (source != NULL);
+        source = destination->source;
+        assert (source != NULL);
 
-  ply_list_remove_data (source->destinations, destination);
-  ply_event_source_drop_reference (source);
-  assert (ply_list_find_node (source->destinations, destination) == NULL);
-  ply_event_loop_update_source_event_mask (loop, source);
+        ply_list_remove_data (source->destinations, destination);
+        ply_event_source_drop_reference (source);
+        assert (ply_list_find_node (source->destinations, destination) == NULL);
+        ply_event_loop_update_source_event_mask (loop, source);
 }
 
 ply_event_loop_t *
 ply_event_loop_new (void)
 {
-  ply_event_loop_t *loop;
+        ply_event_loop_t *loop;
 
-  loop = calloc (1, sizeof (ply_event_loop_t));
+        loop = calloc (1, sizeof(ply_event_loop_t));
 
-  loop->epoll_fd =  epoll_create1(EPOLL_CLOEXEC);
-  loop->wakeup_time = PLY_EVENT_LOOP_NO_TIMED_WAKEUP;
+        loop->epoll_fd = epoll_create1 (EPOLL_CLOEXEC);
+        loop->wakeup_time = PLY_EVENT_LOOP_NO_TIMED_WAKEUP;
 
-  assert (loop->epoll_fd >= 0);
+        assert (loop->epoll_fd >= 0);
 
-  loop->should_exit = false;
-  loop->exit_code = 0;
+        loop->should_exit = false;
+        loop->exit_code = 0;
 
-  loop->sources = ply_list_new ();
-  loop->exit_closures = ply_list_new ();
-  loop->timeout_watches = ply_list_new ();
+        loop->sources = ply_list_new ();
+        loop->exit_closures = ply_list_new ();
+        loop->timeout_watches = ply_list_new ();
 
-  loop->signal_dispatcher = ply_signal_dispatcher_new ();
+        loop->signal_dispatcher = ply_signal_dispatcher_new ();
 
-  if (loop->signal_dispatcher == NULL)
-    return NULL;
+        if (loop->signal_dispatcher == NULL)
+                return NULL;
 
-  ply_event_loop_watch_fd (loop,
-                           ply_signal_dispatcher_receiver_fd,
-                           PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                           (ply_event_handler_t)
-                           ply_signal_dispatcher_dispatch_signal,
-                           (ply_event_handler_t)
-                           ply_signal_dispatcher_reset_signal_sources,
-                           loop->signal_dispatcher);
+        ply_event_loop_watch_fd (loop,
+                                 ply_signal_dispatcher_receiver_fd,
+                                 PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                 (ply_event_handler_t)
+                                 ply_signal_dispatcher_dispatch_signal,
+                                 (ply_event_handler_t)
+                                 ply_signal_dispatcher_reset_signal_sources,
+                                 loop->signal_dispatcher);
 
-  return loop;
+        return loop;
 }
 
 ply_event_loop_t *
 ply_event_loop_get_default (void)
 {
-  static ply_event_loop_t *loop = NULL;
+        static ply_event_loop_t *loop = NULL;
 
-  if (loop == NULL)
-    loop = ply_event_loop_new ();
+        if (loop == NULL)
+                loop = ply_event_loop_new ();
 
-  return loop;
+        return loop;
 }
 
 static void
 ply_event_loop_free_exit_closures (ply_event_loop_t *loop)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (loop->exit_closures);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_event_loop_exit_closure_t *closure;
+        node = ply_list_get_first_node (loop->exit_closures);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_event_loop_exit_closure_t *closure;
 
-      closure = (ply_event_loop_exit_closure_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (loop->exit_closures, node);
-      free (closure);
+                closure = (ply_event_loop_exit_closure_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (loop->exit_closures, node);
+                free (closure);
 
-      node = next_node;
-    }
-  ply_list_free (loop->exit_closures);
+                node = next_node;
+        }
+        ply_list_free (loop->exit_closures);
 }
 
 static void
 ply_event_loop_run_exit_closures (ply_event_loop_t *loop)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (loop->exit_closures);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_event_loop_exit_closure_t *closure;
+        node = ply_list_get_first_node (loop->exit_closures);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_event_loop_exit_closure_t *closure;
 
-      closure = (ply_event_loop_exit_closure_t *) ply_list_node_get_data (node);
+                closure = (ply_event_loop_exit_closure_t *) ply_list_node_get_data (node);
 
-      assert (closure->handler != NULL);
-      next_node = ply_list_get_next_node (loop->exit_closures, node);
+                assert (closure->handler != NULL);
+                next_node = ply_list_get_next_node (loop->exit_closures, node);
 
-      closure->handler (closure->user_data, loop->exit_code, loop);
+                closure->handler (closure->user_data, loop->exit_code, loop);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 void
 ply_event_loop_free (ply_event_loop_t *loop)
 {
-  if (loop == NULL)
-    return;
+        if (loop == NULL)
+                return;
 
-  assert (ply_list_get_length (loop->sources) == 0);
-  assert (ply_list_get_length (loop->timeout_watches) == 0);
+        assert (ply_list_get_length (loop->sources) == 0);
+        assert (ply_list_get_length (loop->timeout_watches) == 0);
 
-  ply_signal_dispatcher_free (loop->signal_dispatcher);
-  ply_event_loop_free_exit_closures (loop);
+        ply_signal_dispatcher_free (loop->signal_dispatcher);
+        ply_event_loop_free_exit_closures (loop);
 
-  ply_list_free (loop->sources);
-  ply_list_free (loop->timeout_watches);
+        ply_list_free (loop->sources);
+        ply_list_free (loop->timeout_watches);
 
-  close (loop->epoll_fd);
-  free (loop);
+        close (loop->epoll_fd);
+        free (loop);
 }
 
 static ply_list_node_t *
 ply_event_loop_find_source_node (ply_event_loop_t *loop,
                                  int               fd)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (loop->sources);
-  while (node != NULL)
-    {
-      ply_event_source_t *source;
+        node = ply_list_get_first_node (loop->sources);
+        while (node != NULL) {
+                ply_event_source_t *source;
 
-      source = (ply_event_source_t *) ply_list_node_get_data (node);
+                source = (ply_event_source_t *) ply_list_node_get_data (node);
 
-      if (source->fd == fd)
-        break;
+                if (source->fd == fd)
+                        break;
 
-      node = ply_list_get_next_node (loop->sources, node);
-    }
+                node = ply_list_get_next_node (loop->sources, node);
+        }
 
-  return node;
+        return node;
 }
 
 static void
-ply_event_loop_add_source (ply_event_loop_t    *loop,
-                           ply_event_source_t  *source)
+ply_event_loop_add_source (ply_event_loop_t   *loop,
+                           ply_event_source_t *source)
 {
-  struct epoll_event event = { 0 };
-  int status;
+        struct epoll_event event = { 0 };
+        int status;
 
-  assert (ply_event_loop_find_source_node (loop, source->fd) == NULL);
-  assert (source->is_getting_polled == false);
+        assert (ply_event_loop_find_source_node (loop, source->fd) == NULL);
+        assert (source->is_getting_polled == false);
 
-  event.events = EPOLLERR | EPOLLHUP;
-  event.data.ptr = source;
+        event.events = EPOLLERR | EPOLLHUP;
+        event.data.ptr = source;
 
-  status = epoll_ctl (loop->epoll_fd, EPOLL_CTL_ADD, source->fd, &event);
-  assert (status == 0);
+        status = epoll_ctl (loop->epoll_fd, EPOLL_CTL_ADD, source->fd, &event);
+        assert (status == 0);
 
-  source->is_getting_polled = true;
+        source->is_getting_polled = true;
 
-  ply_event_source_take_reference (source);
-  ply_list_append_data (loop->sources, source);
+        ply_event_source_take_reference (source);
+        ply_list_append_data (loop->sources, source);
 }
 
 static void
 ply_event_loop_remove_source_node (ply_event_loop_t *loop,
                                    ply_list_node_t  *source_node)
 {
-  ply_event_source_t *source;
+        ply_event_source_t *source;
 
-  source = (ply_event_source_t *) ply_list_node_get_data (source_node);
+        source = (ply_event_source_t *) ply_list_node_get_data (source_node);
 
-  assert (source != NULL);
+        assert (source != NULL);
 
-  if (source->is_getting_polled)
-    {
-      int status;
+        if (source->is_getting_polled) {
+                int status;
 
-      status = epoll_ctl (loop->epoll_fd, EPOLL_CTL_DEL, source->fd, NULL);
+                status = epoll_ctl (loop->epoll_fd, EPOLL_CTL_DEL, source->fd, NULL);
 
-      if (status < 0)
-        ply_trace ("failed to delete fd %d from epoll watch list: %m", source->fd);
-      source->is_getting_polled = false;
-    }
+                if (status < 0)
+                        ply_trace ("failed to delete fd %d from epoll watch list: %m", source->fd);
+                source->is_getting_polled = false;
+        }
 
-  ply_list_remove_node (loop->sources, source_node);
-  ply_event_source_drop_reference (source);
+        ply_list_remove_node (loop->sources, source_node);
+        ply_event_source_drop_reference (source);
 }
 
 static void
 ply_event_loop_remove_source (ply_event_loop_t   *loop,
                               ply_event_source_t *source)
 {
-  ply_list_node_t *source_node;
-  assert (ply_list_get_length (source->destinations) == 0);
+        ply_list_node_t *source_node;
+
+        assert (ply_list_get_length (source->destinations) == 0);
 
-  source_node = ply_list_find_node (loop->sources, source);
+        source_node = ply_list_find_node (loop->sources, source);
 
-  assert (source_node != NULL);
+        assert (source_node != NULL);
 
-  ply_event_loop_remove_source_node (loop, source_node);
+        ply_event_loop_remove_source_node (loop, source_node);
 }
 
 static void
 ply_event_loop_free_sources (ply_event_loop_t *loop)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (loop->sources);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (loop->sources);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
 
-      next_node = ply_list_get_next_node (loop->sources, node);
-      ply_event_loop_remove_source_node (loop, node);
-      node = next_node;
-    }
+                next_node = ply_list_get_next_node (loop->sources, node);
+                ply_event_loop_remove_source_node (loop, node);
+                node = next_node;
+        }
 }
 
 static bool
 ply_event_loop_fd_status_is_valid (ply_event_loop_fd_status_t status)
 {
-  return (status & ~(PLY_EVENT_LOOP_FD_STATUS_NONE
-                     | PLY_EVENT_LOOP_FD_STATUS_HAS_DATA
-                     | PLY_EVENT_LOOP_FD_STATUS_HAS_CONTROL_DATA
-                     | PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA)) == 0;
-
+        return (status & ~(PLY_EVENT_LOOP_FD_STATUS_NONE
+                           | PLY_EVENT_LOOP_FD_STATUS_HAS_DATA
+                           | PLY_EVENT_LOOP_FD_STATUS_HAS_CONTROL_DATA
+                           | PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA)) == 0;
 }
 
 static ply_event_source_t *
 ply_event_loop_get_source_from_fd (ply_event_loop_t *loop,
                                    int               fd)
 {
-  ply_list_node_t *source_node;
-  ply_event_source_t *source;
+        ply_list_node_t *source_node;
+        ply_event_source_t *source;
 
-  source_node = ply_event_loop_find_source_node (loop, fd);
+        source_node = ply_event_loop_find_source_node (loop, fd);
 
-  if (source_node == NULL)
-    {
-      source = ply_event_source_new (fd);
-      ply_event_loop_add_source (loop, source);
+        if (source_node == NULL) {
+                source = ply_event_source_new (fd);
+                ply_event_loop_add_source (loop, source);
 
-      source_node = ply_list_get_last_node (loop->sources);
-      assert (source_node != NULL);
-    }
+                source_node = ply_list_get_last_node (loop->sources);
+                assert (source_node != NULL);
+        }
 
-  source = (ply_event_source_t *) ply_list_node_get_data (source_node);
-  assert (source->fd == fd);
+        source = (ply_event_source_t *) ply_list_node_get_data (source_node);
+        assert (source->fd == fd);
 
-  return source;
+        return source;
 }
 
 ply_fd_watch_t *
-ply_event_loop_watch_fd (ply_event_loop_t           *loop,
-                         int                         fd,
-                         ply_event_loop_fd_status_t  status,
-                         ply_event_handler_t         status_met_handler,
-                         ply_event_handler_t         disconnected_handler,
-                         void                       *user_data)
+ply_event_loop_watch_fd (ply_event_loop_t          *loop,
+                         int                        fd,
+                         ply_event_loop_fd_status_t status,
+                         ply_event_handler_t        status_met_handler,
+                         ply_event_handler_t        disconnected_handler,
+                         void                      *user_data)
 {
+        ply_event_source_t *source;
+        ply_event_destination_t *destination;
+        ply_fd_watch_t *watch;
 
-  ply_event_source_t *source;
-  ply_event_destination_t *destination;
-  ply_fd_watch_t *watch;
-
-  assert (loop != NULL);
-  assert (fd >= 0);
-  assert (ply_event_loop_fd_status_is_valid (status));
-  assert (status != PLY_EVENT_LOOP_FD_STATUS_NONE || status_met_handler == NULL);
+        assert (loop != NULL);
+        assert (fd >= 0);
+        assert (ply_event_loop_fd_status_is_valid (status));
+        assert (status != PLY_EVENT_LOOP_FD_STATUS_NONE || status_met_handler == NULL);
 
-  source = ply_event_loop_get_source_from_fd (loop, fd);
-  assert (source != NULL);
+        source = ply_event_loop_get_source_from_fd (loop, fd);
+        assert (source != NULL);
 
-  destination = ply_event_destination_new (status, status_met_handler,
-                                           disconnected_handler, user_data);
-  watch = ply_event_loop_add_destination_for_source (loop, destination, source);
+        destination = ply_event_destination_new (status, status_met_handler,
+                                                 disconnected_handler, user_data);
+        watch = ply_event_loop_add_destination_for_source (loop, destination, source);
 
-  return watch;
+        return watch;
 }
 
 void
 ply_event_loop_stop_watching_fd (ply_event_loop_t *loop,
                                  ply_fd_watch_t   *watch)
 {
-  ply_event_destination_t *destination;
-  ply_event_source_t *source;
-
-  assert (loop != NULL);
-  assert (watch != NULL);
-
-  destination = ply_event_loop_get_destination_from_fd_watch (loop, watch);
-
-  assert (destination != NULL);
-
-  source = destination->source;
-
-  if (source == NULL) 
-    ply_trace ("NULL source when stopping watching fd");
-  else
-    ply_trace ("stopping watching fd %d", source->fd);
-
-  assert (source != NULL);
-  assert (source->fd >= 0);
-
-  /* if we're already disconnected then the watch is already scheduled
-   * to be removed by ply_event_loop_disconnect_source
-   */
-  if (source->is_disconnected)
-    {
-      ply_trace ("source for fd %d is already disconnected", source->fd);
-      ply_list_remove_data (source->fd_watches, watch);
-      ply_event_source_drop_reference (source);
-      ply_fd_watch_free (watch);
-      return;
-    }
-
-  ply_trace ("removing destination for fd %d", source->fd);
-  ply_event_loop_remove_destination_by_fd_watch (loop, watch);
-
-  ply_list_remove_data (source->fd_watches, watch);
-  ply_event_source_drop_reference (source);
-  ply_fd_watch_free (watch);
-  ply_event_destination_free (destination);
-
-  if (ply_list_get_length (source->destinations) == 0)
-    {
-      ply_trace ("no more destinations remaing for fd %d, removing source", source->fd);
-      ply_event_loop_remove_source (loop, source);
-    }
+        ply_event_destination_t *destination;
+        ply_event_source_t *source;
+
+        assert (loop != NULL);
+        assert (watch != NULL);
+
+        destination = ply_event_loop_get_destination_from_fd_watch (loop, watch);
+
+        assert (destination != NULL);
+
+        source = destination->source;
+
+        if (source == NULL)
+                ply_trace ("NULL source when stopping watching fd");
+        else
+                ply_trace ("stopping watching fd %d", source->fd);
+
+        assert (source != NULL);
+        assert (source->fd >= 0);
+
+        /* if we're already disconnected then the watch is already scheduled
+         * to be removed by ply_event_loop_disconnect_source
+         */
+        if (source->is_disconnected) {
+                ply_trace ("source for fd %d is already disconnected", source->fd);
+                ply_list_remove_data (source->fd_watches, watch);
+                ply_event_source_drop_reference (source);
+                ply_fd_watch_free (watch);
+                return;
+        }
+
+        ply_trace ("removing destination for fd %d", source->fd);
+        ply_event_loop_remove_destination_by_fd_watch (loop, watch);
+
+        ply_list_remove_data (source->fd_watches, watch);
+        ply_event_source_drop_reference (source);
+        ply_fd_watch_free (watch);
+        ply_event_destination_free (destination);
+
+        if (ply_list_get_length (source->destinations) == 0) {
+                ply_trace ("no more destinations remaing for fd %d, removing source", source->fd);
+                ply_event_loop_remove_source (loop, source);
+        }
 }
 
 static ply_list_node_t *
 ply_signal_dispatcher_find_source_node (ply_signal_dispatcher_t *dispatcher,
-                                        int                 signal_number)
+                                        int                      signal_number)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (dispatcher->sources);
-  while (node != NULL)
-    {
-      ply_signal_source_t *handler;
+        node = ply_list_get_first_node (dispatcher->sources);
+        while (node != NULL) {
+                ply_signal_source_t *handler;
 
-      handler = (ply_signal_source_t *) ply_list_node_get_data (node);
+                handler = (ply_signal_source_t *) ply_list_node_get_data (node);
 
-      assert (handler != NULL);
+                assert (handler != NULL);
 
-      if (handler->signal_number == signal_number)
-        break;
+                if (handler->signal_number == signal_number)
+                        break;
 
-      node = ply_list_get_next_node (dispatcher->sources, node);
-    }
+                node = ply_list_get_next_node (dispatcher->sources, node);
+        }
 
-  return node;
+        return node;
 }
 
 void
 ply_event_loop_watch_signal (ply_event_loop_t   *loop,
-                            int                  signal_number,
-                            ply_event_handler_t  signal_handler,
-                            void                *user_data)
+                             int                 signal_number,
+                             ply_event_handler_t signal_handler,
+                             void               *user_data)
 {
-  ply_signal_source_t *source;
+        ply_signal_source_t *source;
 
-  source = ply_signal_source_new (signal_number,
-                                  signal_handler,
-                                  user_data);
+        source = ply_signal_source_new (signal_number,
+                                        signal_handler,
+                                        user_data);
 
-  source->old_posix_signal_handler =
-      signal (signal_number, ply_signal_dispatcher_posix_signal_handler);
-  ply_list_append_data (loop->signal_dispatcher->sources, source);
+        source->old_posix_signal_handler =
+                signal (signal_number, ply_signal_dispatcher_posix_signal_handler);
+        ply_list_append_data (loop->signal_dispatcher->sources, source);
 }
 
 static void
-ply_signal_dispatcher_remove_source_node (ply_signal_dispatcher_t  *dispatcher,
-                                          ply_list_node_t          *node)
+ply_signal_dispatcher_remove_source_node (ply_signal_dispatcher_t *dispatcher,
+                                          ply_list_node_t         *node)
 {
-  ply_signal_source_t *source;
+        ply_signal_source_t *source;
 
-  source = (ply_signal_source_t *) ply_list_node_get_data (node);
+        source = (ply_signal_source_t *) ply_list_node_get_data (node);
 
-  signal (source->signal_number,
-          source->old_posix_signal_handler != NULL?
-          source->old_posix_signal_handler : SIG_DFL);
+        signal (source->signal_number,
+                source->old_posix_signal_handler != NULL ?
+                source->old_posix_signal_handler : SIG_DFL);
 
-  ply_list_remove_node (dispatcher->sources, node);
+        ply_list_remove_node (dispatcher->sources, node);
 }
 
 void
 ply_event_loop_stop_watching_signal (ply_event_loop_t *loop,
                                      int               signal_number)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_signal_dispatcher_find_source_node (loop->signal_dispatcher,
-                                                 signal_number);
+        node = ply_signal_dispatcher_find_source_node (loop->signal_dispatcher,
+                                                       signal_number);
 
-  if (node == NULL)
-    return;
+        if (node == NULL)
+                return;
 
-  ply_signal_dispatcher_remove_source_node (loop->signal_dispatcher, node);
+        ply_signal_dispatcher_remove_source_node (loop->signal_dispatcher, node);
 }
 
 void
-ply_event_loop_watch_for_exit (ply_event_loop_t              *loop,
-                               ply_event_loop_exit_handler_t  exit_handler,
-                               void                          *user_data)
+ply_event_loop_watch_for_exit (ply_event_loop_t             *loop,
+                               ply_event_loop_exit_handler_t exit_handler,
+                               void                         *user_data)
 {
-  ply_event_loop_exit_closure_t *closure;
+        ply_event_loop_exit_closure_t *closure;
 
-  assert (loop != NULL);
-  assert (exit_handler != NULL);
+        assert (loop != NULL);
+        assert (exit_handler != NULL);
 
-  closure = calloc (1, sizeof (ply_event_loop_exit_closure_t));
-  closure->handler = exit_handler;
-  closure->user_data = user_data;
+        closure = calloc (1, sizeof(ply_event_loop_exit_closure_t));
+        closure->handler = exit_handler;
+        closure->user_data = user_data;
 
-  ply_list_append_data (loop->exit_closures, closure);
+        ply_list_append_data (loop->exit_closures, closure);
 }
 
 void
-ply_event_loop_stop_watching_for_exit (ply_event_loop_t *loop,
+ply_event_loop_stop_watching_for_exit (ply_event_loop_t             *loop,
                                        ply_event_loop_exit_handler_t exit_handler,
-                                       void             *user_data)
+                                       void                         *user_data)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (loop->exit_closures);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_event_loop_exit_closure_t *closure;
+        node = ply_list_get_first_node (loop->exit_closures);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_event_loop_exit_closure_t *closure;
 
-      closure = (ply_event_loop_exit_closure_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (loop->exit_closures, node);
+                closure = (ply_event_loop_exit_closure_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (loop->exit_closures, node);
 
-      if (closure->handler == exit_handler &&
-          closure->user_data == user_data) {
-              ply_list_remove_node (loop->exit_closures, node);
-              free (closure);
-      }
+                if (closure->handler == exit_handler &&
+                    closure->user_data == user_data) {
+                        ply_list_remove_node (loop->exit_closures, node);
+                        free (closure);
+                }
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 void
-ply_event_loop_watch_for_timeout (ply_event_loop_t    *loop,
-                                  double               seconds,
+ply_event_loop_watch_for_timeout (ply_event_loop_t                *loop,
+                                  double                           seconds,
                                   ply_event_loop_timeout_handler_t timeout_handler,
-                                  void                *user_data)
+                                  void                            *user_data)
 {
-  ply_event_loop_timeout_watch_t *timeout_watch;
+        ply_event_loop_timeout_watch_t *timeout_watch;
 
-  assert (loop != NULL);
-  assert (timeout_handler != NULL);
-  assert (seconds > 0.0);
+        assert (loop != NULL);
+        assert (timeout_handler != NULL);
+        assert (seconds > 0.0);
 
-  timeout_watch = calloc (1, sizeof (ply_event_loop_timeout_watch_t));
-  timeout_watch->timeout = ply_get_timestamp () + seconds;
-  timeout_watch->handler = timeout_handler;
-  timeout_watch->user_data = user_data;
+        timeout_watch = calloc (1, sizeof(ply_event_loop_timeout_watch_t));
+        timeout_watch->timeout = ply_get_timestamp () + seconds;
+        timeout_watch->handler = timeout_handler;
+        timeout_watch->user_data = user_data;
 
-  if (fabs (loop->wakeup_time - PLY_EVENT_LOOP_NO_TIMED_WAKEUP) <= 0)
-    loop->wakeup_time = timeout_watch->timeout;
-  else
-    loop->wakeup_time = MIN (loop->wakeup_time, timeout_watch->timeout);
+        if (fabs (loop->wakeup_time - PLY_EVENT_LOOP_NO_TIMED_WAKEUP) <= 0)
+                loop->wakeup_time = timeout_watch->timeout;
+        else
+                loop->wakeup_time = MIN (loop->wakeup_time, timeout_watch->timeout);
 
-  ply_list_append_data (loop->timeout_watches, timeout_watch);
+        ply_list_append_data (loop->timeout_watches, timeout_watch);
 }
 
 void
-ply_event_loop_stop_watching_for_timeout (ply_event_loop_t *loop,
+ply_event_loop_stop_watching_for_timeout (ply_event_loop_t                *loop,
                                           ply_event_loop_timeout_handler_t timeout_handler,
-                                          void             *user_data)
+                                          void                            *user_data)
 {
-  ply_list_node_t *node;
-  bool timeout_removed;
+        ply_list_node_t *node;
+        bool timeout_removed;
 
-  loop->wakeup_time = PLY_EVENT_LOOP_NO_TIMED_WAKEUP;
+        loop->wakeup_time = PLY_EVENT_LOOP_NO_TIMED_WAKEUP;
 
-  timeout_removed = false;
-  node = ply_list_get_first_node (loop->timeout_watches);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_event_loop_timeout_watch_t *timeout_watch;
+        timeout_removed = false;
+        node = ply_list_get_first_node (loop->timeout_watches);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_event_loop_timeout_watch_t *timeout_watch;
 
-      timeout_watch = (ply_event_loop_timeout_watch_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (loop->timeout_watches, node);
+                timeout_watch = (ply_event_loop_timeout_watch_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (loop->timeout_watches, node);
 
-      if (timeout_watch->handler == timeout_handler &&
-          timeout_watch->user_data == user_data)
-        {
-          ply_list_remove_node (loop->timeout_watches, node);
-          free (timeout_watch);
+                if (timeout_watch->handler == timeout_handler &&
+                    timeout_watch->user_data == user_data) {
+                        ply_list_remove_node (loop->timeout_watches, node);
+                        free (timeout_watch);
 
-          if (timeout_removed)
-            ply_trace ("multiple matching timeouts found for removal");
+                        if (timeout_removed)
+                                ply_trace ("multiple matching timeouts found for removal");
 
-          timeout_removed = true;
-        }
-      else
-        {
-          if (fabs (loop->wakeup_time - PLY_EVENT_LOOP_NO_TIMED_WAKEUP) <= 0)
-            loop->wakeup_time = timeout_watch->timeout;
-          else
-            loop->wakeup_time = MIN (loop->wakeup_time, timeout_watch->timeout);
-        }
+                        timeout_removed = true;
+                } else {
+                        if (fabs (loop->wakeup_time - PLY_EVENT_LOOP_NO_TIMED_WAKEUP) <= 0)
+                                loop->wakeup_time = timeout_watch->timeout;
+                        else
+                                loop->wakeup_time = MIN (loop->wakeup_time, timeout_watch->timeout);
+                }
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  if (!timeout_removed)
-    ply_trace ("no matching timeout found for removal");
+        if (!timeout_removed)
+                ply_trace ("no matching timeout found for removal");
 }
 
 static ply_event_loop_fd_status_t
 ply_event_loop_get_fd_status_from_poll_mask (uint32_t mask)
 {
-  ply_event_loop_fd_status_t status;
+        ply_event_loop_fd_status_t status;
 
-  status = PLY_EVENT_LOOP_FD_STATUS_NONE;
+        status = PLY_EVENT_LOOP_FD_STATUS_NONE;
 
-  if (mask & EPOLLIN)
-    status |= PLY_EVENT_LOOP_FD_STATUS_HAS_DATA;
+        if (mask & EPOLLIN)
+                status |= PLY_EVENT_LOOP_FD_STATUS_HAS_DATA;
 
-  if (mask & EPOLLPRI)
-    status |= PLY_EVENT_LOOP_FD_STATUS_HAS_CONTROL_DATA;
+        if (mask & EPOLLPRI)
+                status |= PLY_EVENT_LOOP_FD_STATUS_HAS_CONTROL_DATA;
 
-  if (mask & EPOLLOUT)
-    status |= PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA;
+        if (mask & EPOLLOUT)
+                status |= PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA;
 
-  return status;
+        return status;
 }
 
 static bool
-ply_event_loop_source_has_met_status (ply_event_source_t         *source,
-                                      ply_event_loop_fd_status_t  status)
+ply_event_loop_source_has_met_status (ply_event_source_t        *source,
+                                      ply_event_loop_fd_status_t status)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (source != NULL);
-  assert (ply_event_loop_fd_status_is_valid (status));
+        assert (source != NULL);
+        assert (ply_event_loop_fd_status_is_valid (status));
 
-  node = ply_list_get_first_node (source->destinations);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_event_destination_t *destination;
+        node = ply_list_get_first_node (source->destinations);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_event_destination_t *destination;
 
-      destination = (ply_event_destination_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (source->destinations, node);
+                destination = (ply_event_destination_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (source->destinations, node);
 
-      if (((destination->status & status) != 0)
-          && (destination->status_met_handler != NULL))
-        return true;
+                if (((destination->status & status) != 0)
+                    && (destination->status_met_handler != NULL))
+                        return true;
 
-      node = next_node;
-    }
-  return false;
+                node = next_node;
+        }
+        return false;
 }
 
 static void
-ply_event_loop_handle_met_status_for_source (ply_event_loop_t           *loop,
-                                             ply_event_source_t         *source,
-                                             ply_event_loop_fd_status_t  status)
+ply_event_loop_handle_met_status_for_source (ply_event_loop_t          *loop,
+                                             ply_event_source_t        *source,
+                                             ply_event_loop_fd_status_t status)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (loop != NULL);
-  assert (source != NULL);
-  assert (ply_event_loop_fd_status_is_valid (status));
+        assert (loop != NULL);
+        assert (source != NULL);
+        assert (ply_event_loop_fd_status_is_valid (status));
 
-  node = ply_list_get_first_node (source->destinations);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_event_destination_t *destination;
+        node = ply_list_get_first_node (source->destinations);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_event_destination_t *destination;
 
-      destination = (ply_event_destination_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (source->destinations, node);
+                destination = (ply_event_destination_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (source->destinations, node);
 
-      if (((destination->status & status) != 0)
-          && (destination->status_met_handler != NULL))
-        destination->status_met_handler (destination->user_data, source->fd);
+                if (((destination->status & status) != 0)
+                    && (destination->status_met_handler != NULL))
+                        destination->status_met_handler (destination->user_data, source->fd);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 ply_event_loop_handle_disconnect_for_source (ply_event_loop_t   *loop,
                                              ply_event_source_t *source)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (loop != NULL);
-  assert (source != NULL);
+        assert (loop != NULL);
+        assert (source != NULL);
 
-  source->is_disconnected = true;
-  node = ply_list_get_first_node (source->destinations);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_event_destination_t *destination;
+        source->is_disconnected = true;
+        node = ply_list_get_first_node (source->destinations);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_event_destination_t *destination;
 
-      destination = (ply_event_destination_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (source->destinations, node);
+                destination = (ply_event_destination_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (source->destinations, node);
 
-      if (destination->disconnected_handler != NULL)
-        {
-          ply_trace ("calling disconnected_handler %p for fd %d",
-                     destination->disconnected_handler, source->fd);
-          destination->disconnected_handler (destination->user_data, source->fd);
+                if (destination->disconnected_handler != NULL) {
+                        ply_trace ("calling disconnected_handler %p for fd %d",
+                                   destination->disconnected_handler, source->fd);
+                        destination->disconnected_handler (destination->user_data, source->fd);
 
-          ply_trace ("done calling disconnected_handler %p for fd %d",
-                     destination->disconnected_handler, source->fd);
-        }
+                        ply_trace ("done calling disconnected_handler %p for fd %d",
+                                   destination->disconnected_handler, source->fd);
+                }
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 ply_event_loop_free_watches_for_source (ply_event_loop_t   *loop,
                                         ply_event_source_t *source)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (loop != NULL);
-  assert (source != NULL);
+        assert (loop != NULL);
+        assert (source != NULL);
 
-  node = ply_list_get_first_node (source->fd_watches);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_fd_watch_t *watch;
+        node = ply_list_get_first_node (source->fd_watches);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_fd_watch_t *watch;
 
-      next_node = ply_list_get_next_node (source->fd_watches, node);
+                next_node = ply_list_get_next_node (source->fd_watches, node);
 
-      watch = (ply_fd_watch_t *) ply_list_node_get_data (node);
+                watch = (ply_fd_watch_t *) ply_list_node_get_data (node);
 
-      assert (watch != NULL);
-      ply_fd_watch_free (watch);
-      ply_list_remove_node (source->fd_watches, node);
-      ply_event_source_drop_reference (source);
-      node = next_node;
-    }
+                assert (watch != NULL);
+                ply_fd_watch_free (watch);
+                ply_list_remove_node (source->fd_watches, node);
+                ply_event_source_drop_reference (source);
+                node = next_node;
+        }
 }
 
 static void
 ply_event_loop_free_timeout_watches (ply_event_loop_t *loop)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (loop != NULL);
+        assert (loop != NULL);
 
-  node = ply_list_get_first_node (loop->timeout_watches);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_event_loop_timeout_watch_t *watch;
+        node = ply_list_get_first_node (loop->timeout_watches);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_event_loop_timeout_watch_t *watch;
 
-      watch = (ply_event_loop_timeout_watch_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (loop->timeout_watches, node);
+                watch = (ply_event_loop_timeout_watch_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (loop->timeout_watches, node);
 
-      free (watch);
-      ply_list_remove_node (loop->timeout_watches, node);
+                free (watch);
+                ply_list_remove_node (loop->timeout_watches, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  assert (ply_list_get_length (loop->timeout_watches) == 0);
-  loop->wakeup_time = PLY_EVENT_LOOP_NO_TIMED_WAKEUP;
+        assert (ply_list_get_length (loop->timeout_watches) == 0);
+        loop->wakeup_time = PLY_EVENT_LOOP_NO_TIMED_WAKEUP;
 }
 
 static void
 ply_event_loop_free_destinations_for_source (ply_event_loop_t   *loop,
                                              ply_event_source_t *source)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (loop != NULL);
-  assert (source != NULL);
+        assert (loop != NULL);
+        assert (source != NULL);
 
-  node = ply_list_get_first_node (source->destinations);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_event_destination_t *destination;
+        node = ply_list_get_first_node (source->destinations);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_event_destination_t *destination;
 
-      next_node = ply_list_get_next_node (source->destinations, node);
+                next_node = ply_list_get_next_node (source->destinations, node);
 
-      destination =
-          (ply_event_destination_t *) ply_list_node_get_data (node);
+                destination =
+                        (ply_event_destination_t *) ply_list_node_get_data (node);
 
-      assert (destination != NULL);
-      ply_trace ("freeing destination (%u, %p, %p) of fd %d",
-                 destination->status, destination->status_met_handler,
-                 destination->disconnected_handler, source->fd);
-      ply_event_destination_free (destination);
+                assert (destination != NULL);
+                ply_trace ("freeing destination (%u, %p, %p) of fd %d",
+                           destination->status, destination->status_met_handler,
+                           destination->disconnected_handler, source->fd);
+                ply_event_destination_free (destination);
 
-      ply_list_remove_node (source->destinations, node);
-      ply_event_source_drop_reference (source);
-      node = next_node;
-    }
+                ply_list_remove_node (source->destinations, node);
+                ply_event_source_drop_reference (source);
+                node = next_node;
+        }
 }
 
 static void
-ply_event_loop_disconnect_source (ply_event_loop_t           *loop,
-                                  ply_event_source_t         *source)
+ply_event_loop_disconnect_source (ply_event_loop_t   *loop,
+                                  ply_event_source_t *source)
 {
-  ply_event_loop_handle_disconnect_for_source (loop, source);
-
-  /* at this point, we've told the event loop users about the
-   * fd disconnection, so we can invalidate any outstanding
-   * watches and free the destinations.
-   */
-  ply_event_loop_free_watches_for_source (loop, source);
-  ply_event_loop_free_destinations_for_source (loop, source);
-  assert (ply_list_get_length (source->destinations) == 0);
-  ply_event_loop_remove_source (loop, source);
+        ply_event_loop_handle_disconnect_for_source (loop, source);
+
+        /* at this point, we've told the event loop users about the
+         * fd disconnection, so we can invalidate any outstanding
+         * watches and free the destinations.
+         */
+        ply_event_loop_free_watches_for_source (loop, source);
+        ply_event_loop_free_destinations_for_source (loop, source);
+        assert (ply_list_get_length (source->destinations) == 0);
+        ply_event_loop_remove_source (loop, source);
 }
 
 static void
 ply_event_loop_handle_timeouts (ply_event_loop_t *loop)
 {
-  ply_list_node_t *node;
-  double now;
+        ply_list_node_t *node;
+        double now;
 
-  assert (loop != NULL);
+        assert (loop != NULL);
 
-  now = ply_get_timestamp ();
-  node = ply_list_get_first_node (loop->timeout_watches);
-  loop->wakeup_time = PLY_EVENT_LOOP_NO_TIMED_WAKEUP;
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_event_loop_timeout_watch_t *watch;
+        now = ply_get_timestamp ();
+        node = ply_list_get_first_node (loop->timeout_watches);
+        loop->wakeup_time = PLY_EVENT_LOOP_NO_TIMED_WAKEUP;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_event_loop_timeout_watch_t *watch;
 
-      watch = (ply_event_loop_timeout_watch_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (loop->timeout_watches, node);
+                watch = (ply_event_loop_timeout_watch_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (loop->timeout_watches, node);
 
-      if (watch->timeout <= now)
-        {
-          assert (watch->handler != NULL);
+                if (watch->timeout <= now) {
+                        assert (watch->handler != NULL);
 
-          ply_list_remove_node (loop->timeout_watches, node);
+                        ply_list_remove_node (loop->timeout_watches, node);
 
-          watch->handler (watch->user_data, loop);
-          free (watch);
-
-          /* start over in case the handler invalidated the list
-           */
-          next_node = ply_list_get_first_node (loop->timeout_watches);
-        }
-      else
-        {
-          if (fabs (loop->wakeup_time - PLY_EVENT_LOOP_NO_TIMED_WAKEUP) <= 0)
-            loop->wakeup_time = watch->timeout;
-          else
-            loop->wakeup_time = MIN (loop->wakeup_time, watch->timeout);
-        }
+                        watch->handler (watch->user_data, loop);
+                        free (watch);
 
-      node = next_node;
-    }
+                        /* start over in case the handler invalidated the list
+                         */
+                        next_node = ply_list_get_first_node (loop->timeout_watches);
+                } else {
+                        if (fabs (loop->wakeup_time - PLY_EVENT_LOOP_NO_TIMED_WAKEUP) <= 0)
+                                loop->wakeup_time = watch->timeout;
+                        else
+                                loop->wakeup_time = MIN (loop->wakeup_time, watch->timeout);
+                }
 
+                node = next_node;
+        }
 }
 
 void
 ply_event_loop_process_pending_events (ply_event_loop_t *loop)
 {
-  int number_of_received_events, i;
-  static struct epoll_event events[PLY_EVENT_LOOP_NUM_EVENT_HANDLERS];
-
-  assert (loop != NULL);
-
-  memset (events, -1,
-          PLY_EVENT_LOOP_NUM_EVENT_HANDLERS * sizeof (struct epoll_event));
-
-  do
-   {
-     int timeout;
-
-     if (fabs (loop->wakeup_time - PLY_EVENT_LOOP_NO_TIMED_WAKEUP) <= 0)
-       timeout = -1;
-     else
-       {
-         timeout = (int) ((loop->wakeup_time - ply_get_timestamp ()) * 1000);
-         timeout = MAX (timeout, 0);
-       }
-
-     number_of_received_events = epoll_wait (loop->epoll_fd, events,
-                                             PLY_EVENT_LOOP_NUM_EVENT_HANDLERS,
-                                             timeout);
-     if (number_of_received_events < 0)
-       {
-         if (errno != EINTR && errno != EAGAIN)
-           {
-             ply_event_loop_exit (loop, 255);
-             return;
-           }
-       }
-     else
-       {
-         /* Reference all sources, so they stay alive for the duration of this
-          * iteration of the loop.
-          */
-         for (i = 0; i < number_of_received_events; i++)
-           {
-             ply_event_source_t *source;
-             source = (ply_event_source_t *) (events[i].data.ptr);
-
-             ply_event_source_take_reference (source);
-           }
-       }
-
-     /* First handle timeouts */
-     ply_event_loop_handle_timeouts (loop);
-    }
-  while (number_of_received_events < 0);
-
-  /* Then process the incoming events
-   */
-  for (i = 0; i < number_of_received_events; i++)
-    {
-      ply_event_source_t *source;
-      ply_event_loop_fd_status_t status;
-      bool is_disconnected;
-
-      source = (ply_event_source_t *) (events[i].data.ptr);
-      status = ply_event_loop_get_fd_status_from_poll_mask (events[i].events);
-
-      is_disconnected = false;
-      if ((events[i].events & EPOLLHUP) || (events[i].events & EPOLLERR))
-        {
-          int bytes_ready;
-
-          bytes_ready = 0;
-          if (ioctl (source->fd, FIONREAD, &bytes_ready) < 0)
-            bytes_ready = 0;
-
-          if (bytes_ready <= 0)
-            is_disconnected = true;
-        }
-
-      if (is_disconnected)
-        {
-          ply_event_loop_disconnect_source (loop, source);
+        int number_of_received_events, i;
+        static struct epoll_event events[PLY_EVENT_LOOP_NUM_EVENT_HANDLERS];
+
+        assert (loop != NULL);
+
+        memset (events, -1,
+                PLY_EVENT_LOOP_NUM_EVENT_HANDLERS * sizeof(struct epoll_event));
+
+        do {
+                int timeout;
+
+                if (fabs (loop->wakeup_time - PLY_EVENT_LOOP_NO_TIMED_WAKEUP) <= 0) {
+                        timeout = -1;
+                } else {
+                        timeout = (int) ((loop->wakeup_time - ply_get_timestamp ()) * 1000);
+                        timeout = MAX (timeout, 0);
+                }
+
+                number_of_received_events = epoll_wait (loop->epoll_fd, events,
+                                                        PLY_EVENT_LOOP_NUM_EVENT_HANDLERS,
+                                                        timeout);
+                if (number_of_received_events < 0) {
+                        if (errno != EINTR && errno != EAGAIN) {
+                                ply_event_loop_exit (loop, 255);
+                                return;
+                        }
+                } else {
+                        /* Reference all sources, so they stay alive for the duration of this
+                         * iteration of the loop.
+                         */
+                        for (i = 0; i < number_of_received_events; i++) {
+                                ply_event_source_t *source;
+                                source = (ply_event_source_t *) (events[i].data.ptr);
+
+                                ply_event_source_take_reference (source);
+                        }
+                }
+
+                /* First handle timeouts */
+                ply_event_loop_handle_timeouts (loop);
+        } while (number_of_received_events < 0);
+
+        /* Then process the incoming events
+         */
+        for (i = 0; i < number_of_received_events; i++) {
+                ply_event_source_t *source;
+                ply_event_loop_fd_status_t status;
+                bool is_disconnected;
+
+                source = (ply_event_source_t *) (events[i].data.ptr);
+                status = ply_event_loop_get_fd_status_from_poll_mask (events[i].events);
+
+                is_disconnected = false;
+                if ((events[i].events & EPOLLHUP) || (events[i].events & EPOLLERR)) {
+                        int bytes_ready;
+
+                        bytes_ready = 0;
+                        if (ioctl (source->fd, FIONREAD, &bytes_ready) < 0)
+                                bytes_ready = 0;
+
+                        if (bytes_ready <= 0)
+                                is_disconnected = true;
+                }
+
+                if (is_disconnected)
+                        ply_event_loop_disconnect_source (loop, source);
+                else if (ply_event_loop_source_has_met_status (source, status))
+                        ply_event_loop_handle_met_status_for_source (loop, source, status);
+
+                if (loop->should_exit)
+                        break;
         }
-      else if (ply_event_loop_source_has_met_status (source, status))
-        ply_event_loop_handle_met_status_for_source (loop, source, status);
 
-      if (loop->should_exit)
-        break;
-    }
+        /* Finally, kill off any unused sources
+         */
+        for (i = 0; i < number_of_received_events; i++) {
+                ply_event_source_t *source;
 
-  /* Finally, kill off any unused sources
-   */
-  for (i = 0; i < number_of_received_events; i++)
-    {
-      ply_event_source_t *source;
+                source = (ply_event_source_t *) (events[i].data.ptr);
 
-      source = (ply_event_source_t *) (events[i].data.ptr);
-
-      ply_event_source_drop_reference (source);
-    }
+                ply_event_source_drop_reference (source);
+        }
 }
 
 void
 ply_event_loop_exit (ply_event_loop_t *loop,
                      int               exit_code)
 {
-  assert (loop != NULL);
+        assert (loop != NULL);
 
-  loop->should_exit = true;
-  loop->exit_code = exit_code;
+        loop->should_exit = true;
+        loop->exit_code = exit_code;
 }
 
 int
 ply_event_loop_run (ply_event_loop_t *loop)
 {
-  while (!loop->should_exit)
-    ply_event_loop_process_pending_events (loop);
+        while (!loop->should_exit) {
+                ply_event_loop_process_pending_events (loop);
+        }
 
-  ply_event_loop_run_exit_closures (loop);
-  ply_event_loop_free_sources (loop);
-  ply_event_loop_free_timeout_watches (loop);
+        ply_event_loop_run_exit_closures (loop);
+        ply_event_loop_free_sources (loop);
+        ply_event_loop_free_timeout_watches (loop);
 
-  loop->should_exit = false;
+        loop->should_exit = false;
 
-  return loop->exit_code;
+        return loop->exit_code;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-event-loop.h b/src/libply/ply-event-loop.h
index ae29d28..d26b1ab 100644
--- a/src/libply/ply-event-loop.h
+++ b/src/libply/ply-event-loop.h
@@ -29,55 +29,56 @@
 typedef struct _ply_event_loop ply_event_loop_t;
 typedef struct _ply_fd_watch ply_fd_watch_t;
 
-typedef enum {
-  PLY_EVENT_LOOP_FD_STATUS_NONE = 0,
-  PLY_EVENT_LOOP_FD_STATUS_HAS_DATA = 0x1,
-  PLY_EVENT_LOOP_FD_STATUS_HAS_CONTROL_DATA = 0x2,
-  PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA = 0x4,
+typedef enum
+{
+        PLY_EVENT_LOOP_FD_STATUS_NONE = 0,
+        PLY_EVENT_LOOP_FD_STATUS_HAS_DATA = 0x1,
+        PLY_EVENT_LOOP_FD_STATUS_HAS_CONTROL_DATA = 0x2,
+        PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA = 0x4,
 } ply_event_loop_fd_status_t;
 
-typedef void (* ply_event_handler_t) (void *user_data,
-                                      int   source_fd);
+typedef void (*ply_event_handler_t) (void *user_data,
+                                     int   source_fd);
 
-typedef void (* ply_event_loop_exit_handler_t) (void *user_data,
-                                                int   exit_code,
-                                                ply_event_loop_t *loop);
-typedef void (* ply_event_loop_timeout_handler_t) (void             *user_data,
-                                                   ply_event_loop_t *loop);
+typedef void (*ply_event_loop_exit_handler_t) (void             *user_data,
+                                               int               exit_code,
+                                               ply_event_loop_t *loop);
+typedef void (*ply_event_loop_timeout_handler_t) (void             *user_data,
+                                                  ply_event_loop_t *loop);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_event_loop_t *ply_event_loop_new (void);
 void ply_event_loop_free (ply_event_loop_t *loop);
 ply_event_loop_t *ply_event_loop_get_default (void);
-ply_fd_watch_t *ply_event_loop_watch_fd (ply_event_loop_t *loop,
-                                         int               fd,
+ply_fd_watch_t *ply_event_loop_watch_fd (ply_event_loop_t          *loop,
+                                         int                        fd,
                                          ply_event_loop_fd_status_t status,
-                                         ply_event_handler_t status_met_handler,
-                                         ply_event_handler_t disconnected_handler,
-                                         void             *user_data);
-void ply_event_loop_stop_watching_fd (ply_event_loop_t *loop, 
+                                         ply_event_handler_t        status_met_handler,
+                                         ply_event_handler_t        disconnected_handler,
+                                         void                      *user_data);
+void ply_event_loop_stop_watching_fd (ply_event_loop_t *loop,
                                       ply_fd_watch_t   *watch);
-void ply_event_loop_watch_signal (ply_event_loop_t     *loop,
-                                  int                   signal_number,
-                                  ply_event_handler_t   signal_handler,
-                                  void                 *user_data);
+void ply_event_loop_watch_signal (ply_event_loop_t   *loop,
+                                  int                 signal_number,
+                                  ply_event_handler_t signal_handler,
+                                  void               *user_data);
 void ply_event_loop_stop_watching_signal (ply_event_loop_t *loop,
                                           int               signal_number);
 
-void ply_event_loop_watch_for_exit (ply_event_loop_t              *loop,
-                                    ply_event_loop_exit_handler_t  exit_handler,
-                                    void                          *user_data);
-void ply_event_loop_stop_watching_for_exit (ply_event_loop_t              *loop,
-                                            ply_event_loop_exit_handler_t  exit_handler,
-                                            void                          *user_data);
-void ply_event_loop_watch_for_timeout (ply_event_loop_t    *loop,
-                                       double               seconds,             
+void ply_event_loop_watch_for_exit (ply_event_loop_t             *loop,
+                                    ply_event_loop_exit_handler_t exit_handler,
+                                    void                         *user_data);
+void ply_event_loop_stop_watching_for_exit (ply_event_loop_t             *loop,
+                                            ply_event_loop_exit_handler_t exit_handler,
+                                            void                         *user_data);
+void ply_event_loop_watch_for_timeout (ply_event_loop_t                *loop,
+                                       double                           seconds,
                                        ply_event_loop_timeout_handler_t timeout_handler,
-                                       void                 *user_data);
+                                       void                            *user_data);
 
-void ply_event_loop_stop_watching_for_timeout (ply_event_loop_t    *loop,
+void ply_event_loop_stop_watching_for_timeout (ply_event_loop_t                *loop,
                                                ply_event_loop_timeout_handler_t timeout_handler,
-                                               void                 *user_data);
+                                               void                            *user_data);
 
 int ply_event_loop_run (ply_event_loop_t *loop);
 void ply_event_loop_exit (ply_event_loop_t *loop,
diff --git a/src/libply/ply-hashtable.c b/src/libply/ply-hashtable.c
index 7b03d87..c9aa3d8 100644
--- a/src/libply/ply-hashtable.c
+++ b/src/libply/ply-hashtable.c
@@ -31,95 +31,91 @@
 #include <stdbool.h>
 #include <string.h>
 
-#define MASKGEN(x) {x |= x >> 16; x |= x >> 8; x |= x >> 4; x |= x >> 2;  x |= x >> 1;}
+#define MASKGEN(x) { x |= x >> 16; x |= x >> 8; x |= x >> 4; x |= x >> 2;  x |= x >> 1; }
 
 struct _ply_hashtable_node
 {
-  void   *data;
-  void   *key;
+        void *data;
+        void *key;
 };
 
 struct _ply_hashtable
 {
-  struct _ply_hashtable_node   *nodes;
-  unsigned int                  total_node_count;   /* must be a 2^X */
-  ply_bitarray_t               *dirty_node_bitmap;
-  unsigned int                  dirty_node_count;   /* live + dead nodes */
-  ply_bitarray_t               *live_node_bitmap;
-  unsigned int                  live_node_count;
-  ply_hashtable_compare_func_t *compare_func;
-  ply_hashtable_hash_func_t    *hash_func;
+        struct _ply_hashtable_node   *nodes;
+        unsigned int                  total_node_count; /* must be a 2^X */
+        ply_bitarray_t               *dirty_node_bitmap;
+        unsigned int                  dirty_node_count; /* live + dead nodes */
+        ply_bitarray_t               *live_node_bitmap;
+        unsigned int                  live_node_count;
+        ply_hashtable_compare_func_t *compare_func;
+        ply_hashtable_hash_func_t    *hash_func;
 };
 
 unsigned int
 ply_hashtable_direct_hash (void *element)
 {
-  return (unsigned int) (intptr_t) element;
+        return (unsigned int) (intptr_t) element;
 }
 
 int
 ply_hashtable_direct_compare (void *elementa,
                               void *elementb)
 {
-  return (int) ((intptr_t) elementa - (intptr_t) elementb);
+        return (int) ((intptr_t) elementa - (intptr_t) elementb);
 }
 
 unsigned int
 ply_hashtable_string_hash (void *element)
 {
-  char* strptr;
-  unsigned int hash = 0;
-  for (strptr = element; *strptr; strptr++)
-    {
-      hash ^= *strptr;
-      hash ^= hash << 1;
-    }
-  return hash;
+        char *strptr;
+        unsigned int hash = 0;
+
+        for (strptr = element; *strptr; strptr++) {
+                hash ^= *strptr;
+                hash ^= hash << 1;
+        }
+        return hash;
 }
 
 int
 ply_hashtable_string_compare (void *elementa,
                               void *elementb)
 {
-  return strcmp (elementa, elementb);
+        return strcmp (elementa, elementb);
 }
 
 ply_hashtable_t *
 ply_hashtable_new (ply_hashtable_hash_func_t    *hash_func,
                    ply_hashtable_compare_func_t *compare_func)
 {
-  ply_hashtable_t *hashtable;
-
-  hashtable = malloc (sizeof (ply_hashtable_t));
-  hashtable->total_node_count = 0;
-  hashtable->dirty_node_count = 0;
-  hashtable->live_node_count = 0;
-  hashtable->nodes = NULL;
-  hashtable->dirty_node_bitmap = NULL;
-  hashtable->live_node_bitmap = NULL;
-  hashtable->compare_func = compare_func;
-  hashtable->hash_func = hash_func;
-
-  if (hashtable->compare_func == NULL)
-    {
-      hashtable->compare_func = ply_hashtable_direct_compare;
-    }
-  if (hashtable->hash_func == NULL)
-    {
-      hashtable->hash_func = ply_hashtable_direct_hash;
-    }
-  ply_hashtable_resize (hashtable);
-  return hashtable;
+        ply_hashtable_t *hashtable;
+
+        hashtable = malloc (sizeof(ply_hashtable_t));
+        hashtable->total_node_count = 0;
+        hashtable->dirty_node_count = 0;
+        hashtable->live_node_count = 0;
+        hashtable->nodes = NULL;
+        hashtable->dirty_node_bitmap = NULL;
+        hashtable->live_node_bitmap = NULL;
+        hashtable->compare_func = compare_func;
+        hashtable->hash_func = hash_func;
+
+        if (hashtable->compare_func == NULL)
+                hashtable->compare_func = ply_hashtable_direct_compare;
+        if (hashtable->hash_func == NULL)
+                hashtable->hash_func = ply_hashtable_direct_hash;
+        ply_hashtable_resize (hashtable);
+        return hashtable;
 }
 
 void
 ply_hashtable_free (ply_hashtable_t *hashtable)
 {
-  if (hashtable == NULL) return;
-  ply_bitarray_free (hashtable->dirty_node_bitmap);
-  ply_bitarray_free (hashtable->live_node_bitmap);
-  free(hashtable->nodes);
-  free(hashtable);
+        if (hashtable == NULL) return;
+        ply_bitarray_free (hashtable->dirty_node_bitmap);
+        ply_bitarray_free (hashtable->live_node_bitmap);
+        free (hashtable->nodes);
+        free (hashtable);
 }
 
 
@@ -128,65 +124,63 @@ ply_hashtable_insert_internal (ply_hashtable_t *hashtable,
                                void            *key,
                                void            *data)
 {
-  unsigned int hash_index;
-  int step = 0;
-
-  hash_index = hashtable->hash_func (key);
-  hash_index &= hashtable->total_node_count - 1;
-
-  while (ply_bitarray_lookup (hashtable->dirty_node_bitmap, hash_index))
-    {
-      step++;
-      hash_index += step;
-      hash_index &= hashtable->total_node_count - 1;
-    }
-  ply_bitarray_set (hashtable->dirty_node_bitmap, hash_index);
-  ply_bitarray_set (hashtable->live_node_bitmap, hash_index);
-  hashtable->nodes[hash_index].key = key;
-  hashtable->nodes[hash_index].data = data;
-
-  hashtable->live_node_count++;
-  hashtable->dirty_node_count++;
+        unsigned int hash_index;
+        int step = 0;
+
+        hash_index = hashtable->hash_func (key);
+        hash_index &= hashtable->total_node_count - 1;
+
+        while (ply_bitarray_lookup (hashtable->dirty_node_bitmap, hash_index)) {
+                step++;
+                hash_index += step;
+                hash_index &= hashtable->total_node_count - 1;
+        }
+        ply_bitarray_set (hashtable->dirty_node_bitmap, hash_index);
+        ply_bitarray_set (hashtable->live_node_bitmap, hash_index);
+        hashtable->nodes[hash_index].key = key;
+        hashtable->nodes[hash_index].data = data;
+
+        hashtable->live_node_count++;
+        hashtable->dirty_node_count++;
 }
 
 
 void
 ply_hashtable_resize (ply_hashtable_t *hashtable)
 {
-  unsigned int newsize, oldsize;
-  unsigned int i;
-  struct _ply_hashtable_node *oldnodes;
-  ply_bitarray_t *old_live_node_bitmap;
-
-  newsize = (hashtable->live_node_count + 1) * 4; /* make table 4x to 8x the number of live elements (at least 8) */
-  MASKGEN (newsize);
-  newsize++;
-  oldsize = hashtable->total_node_count;
-  oldnodes = hashtable->nodes;
-
-  hashtable->total_node_count = newsize;
-  hashtable->nodes = malloc (newsize * sizeof (struct _ply_hashtable_node));
-  ply_bitarray_free (hashtable->dirty_node_bitmap);
-  hashtable->dirty_node_bitmap = ply_bitarray_new(newsize);
-  old_live_node_bitmap = hashtable->live_node_bitmap;
-  hashtable->live_node_bitmap = ply_bitarray_new(newsize);
-  hashtable->dirty_node_count = 0;
-  hashtable->live_node_count = 0;
-
-  for (i=0; i<oldsize; i++)
-    {
-      if (ply_bitarray_lookup (old_live_node_bitmap, i))
-        ply_hashtable_insert_internal (hashtable, oldnodes[i].key, oldnodes[i].data);
-    } 
-  ply_bitarray_free (old_live_node_bitmap);
-  free (oldnodes);
+        unsigned int newsize, oldsize;
+        unsigned int i;
+        struct _ply_hashtable_node *oldnodes;
+        ply_bitarray_t *old_live_node_bitmap;
+
+        newsize = (hashtable->live_node_count + 1) * 4; /* make table 4x to 8x the number of live elements (at least 8) */
+        MASKGEN (newsize);
+        newsize++;
+        oldsize = hashtable->total_node_count;
+        oldnodes = hashtable->nodes;
+
+        hashtable->total_node_count = newsize;
+        hashtable->nodes = malloc (newsize * sizeof(struct _ply_hashtable_node));
+        ply_bitarray_free (hashtable->dirty_node_bitmap);
+        hashtable->dirty_node_bitmap = ply_bitarray_new (newsize);
+        old_live_node_bitmap = hashtable->live_node_bitmap;
+        hashtable->live_node_bitmap = ply_bitarray_new (newsize);
+        hashtable->dirty_node_count = 0;
+        hashtable->live_node_count = 0;
+
+        for (i = 0; i < oldsize; i++) {
+                if (ply_bitarray_lookup (old_live_node_bitmap, i))
+                        ply_hashtable_insert_internal (hashtable, oldnodes[i].key, oldnodes[i].data);
+        }
+        ply_bitarray_free (old_live_node_bitmap);
+        free (oldnodes);
 }
 
 static inline void
 ply_hashtable_resize_check (ply_hashtable_t *hashtable)
 {
-  if (hashtable->total_node_count < (hashtable->dirty_node_count * 2))
-    ply_hashtable_resize (hashtable);   /* hash tables work best below 50% occupancy */
+        if (hashtable->total_node_count < (hashtable->dirty_node_count * 2))
+                ply_hashtable_resize (hashtable); /* hash tables work best below 50% occupancy */
 }
 
 void
@@ -194,55 +188,56 @@ ply_hashtable_insert (ply_hashtable_t *hashtable,
                       void            *key,
                       void            *data)
 {
-  ply_hashtable_resize_check (hashtable);
-  ply_hashtable_insert_internal (hashtable, key, data);
+        ply_hashtable_resize_check (hashtable);
+        ply_hashtable_insert_internal (hashtable, key, data);
 }
 
 static int
 ply_hashtable_lookup_index (ply_hashtable_t *hashtable,
                             void            *key)
 {
-  unsigned int hash_index;
-  int step = 0;
-
-  hash_index = hashtable->hash_func (key);
-  while (1)
-    {
-      hash_index &= hashtable->total_node_count - 1;
-      if (!ply_bitarray_lookup (hashtable->dirty_node_bitmap, hash_index))
-        break;
-      if (ply_bitarray_lookup (hashtable->live_node_bitmap, hash_index))
-        if (!hashtable->compare_func (hashtable->nodes[hash_index].key, key))
-          return hash_index;
-      hash_index += step;
-      step++;
-    }
-  return -1;
+        unsigned int hash_index;
+        int step = 0;
+
+        hash_index = hashtable->hash_func (key);
+        while (1) {
+                hash_index &= hashtable->total_node_count - 1;
+                if (!ply_bitarray_lookup (hashtable->dirty_node_bitmap, hash_index))
+                        break;
+                if (ply_bitarray_lookup (hashtable->live_node_bitmap, hash_index))
+                        if (!hashtable->compare_func (hashtable->nodes[hash_index].key, key))
+                                return hash_index;
+                hash_index += step;
+                step++;
+        }
+        return -1;
 }
 
 void *
 ply_hashtable_remove (ply_hashtable_t *hashtable,
                       void            *key)
 {
-  int index;
-  index = ply_hashtable_lookup_index (hashtable, key);
-  if (index < 0)
-    return NULL;
-    
-  ply_bitarray_clear (hashtable->live_node_bitmap, index);
-  hashtable->live_node_count--;
-  return hashtable->nodes[index].data;
+        int index;
+
+        index = ply_hashtable_lookup_index (hashtable, key);
+        if (index < 0)
+                return NULL;
+
+        ply_bitarray_clear (hashtable->live_node_bitmap, index);
+        hashtable->live_node_count--;
+        return hashtable->nodes[index].data;
 }
 
 void *
 ply_hashtable_lookup (ply_hashtable_t *hashtable,
                       void            *key)
 {
-  int index;
-  index = ply_hashtable_lookup_index (hashtable, key);
-  if (index < 0)
-    return NULL;
-  return hashtable->nodes[index].data;
+        int index;
+
+        index = ply_hashtable_lookup_index (hashtable, key);
+        if (index < 0)
+                return NULL;
+        return hashtable->nodes[index].data;
 }
 
 int
@@ -251,32 +246,33 @@ ply_hashtable_lookup_full (ply_hashtable_t *hashtable,
                            void           **reply_key,
                            void           **reply_data)
 {
-  int index;
-  index = ply_hashtable_lookup_index (hashtable, key);
-  if (index < 0)
-    return false;
-  *reply_key = hashtable->nodes[index].key;
-  *reply_data = hashtable->nodes[index].data;
-  return true;
+        int index;
+
+        index = ply_hashtable_lookup_index (hashtable, key);
+        if (index < 0)
+                return false;
+        *reply_key = hashtable->nodes[index].key;
+        *reply_data = hashtable->nodes[index].data;
+        return true;
 }
 
 void
-ply_hashtable_foreach (ply_hashtable_t              *hashtable,
-					   ply_hashtable_foreach_func_t  func,
-					   void                         *user_data)
+ply_hashtable_foreach (ply_hashtable_t             *hashtable,
+                       ply_hashtable_foreach_func_t func,
+                       void                        *user_data)
 {
-  unsigned int i;
-  for (i = 0; i < hashtable->total_node_count; i++)
-    {
-      if (ply_bitarray_lookup (hashtable->live_node_bitmap, i))
-        func(hashtable->nodes[i].key, hashtable->nodes[i].data, user_data);
-    }
+        unsigned int i;
+
+        for (i = 0; i < hashtable->total_node_count; i++) {
+                if (ply_bitarray_lookup (hashtable->live_node_bitmap, i))
+                        func (hashtable->nodes[i].key, hashtable->nodes[i].data, user_data);
+        }
 }
 
 int
 ply_hashtable_get_size (ply_hashtable_t *hashtable)
 {
-  return hashtable->live_node_count;
+        return hashtable->live_node_count;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-hashtable.h b/src/libply/ply-hashtable.h
index e7e1a6e..6ff2004 100644
--- a/src/libply/ply-hashtable.h
+++ b/src/libply/ply-hashtable.h
@@ -34,7 +34,7 @@ typedef void (ply_hashtable_foreach_func_t) (void *key,
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 int ply_hashtable_direct_compare (void *elementa,
-                              	  void *elementb);
+                                  void *elementb);
 unsigned int ply_hashtable_direct_hash (void *element);
 unsigned int ply_hashtable_string_hash (void *element);
 int ply_hashtable_string_compare (void *elementa,
@@ -44,19 +44,19 @@ ply_hashtable_t *ply_hashtable_new (ply_hashtable_hash_func_t    *hash_func,
 void ply_hashtable_free (ply_hashtable_t *hashtable);
 void ply_hashtable_resize (ply_hashtable_t *hashtable);
 void ply_hashtable_insert (ply_hashtable_t *hashtable,
-                    	   void            *key,
-                    	   void            *data);
+                           void            *key,
+                           void            *data);
 void *ply_hashtable_remove (ply_hashtable_t *hashtable,
-                    		void            *key);
+                            void            *key);
 void *ply_hashtable_lookup (ply_hashtable_t *hashtable,
-                    		void            *key);
+                            void            *key);
 int ply_hashtable_lookup_full (ply_hashtable_t *hashtable,
-                        	   void            *key,
-                        	   void           **reply_key,
-                        	   void           **reply_data);
-void ply_hashtable_foreach (ply_hashtable_t              *hashtable,
-							ply_hashtable_foreach_func_t  func,
-							void                         *user_data);
+                               void            *key,
+                               void           **reply_key,
+                               void           **reply_data);
+void ply_hashtable_foreach (ply_hashtable_t             *hashtable,
+                            ply_hashtable_foreach_func_t func,
+                            void                        *user_data);
 
 int ply_hashtable_get_size (ply_hashtable_t *hashtable);
 #endif
diff --git a/src/libply/ply-key-file.c b/src/libply/ply-key-file.c
index c62551e..862d6d5 100644
--- a/src/libply/ply-key-file.c
+++ b/src/libply/ply-key-file.c
@@ -43,29 +43,29 @@
 
 typedef struct
 {
-  char *key;
-  char *value;
+        char *key;
+        char *value;
 } ply_key_file_entry_t;
 
 typedef struct
 {
-  char *name;
-  ply_hashtable_t *entries;
+        char            *name;
+        ply_hashtable_t *entries;
 } ply_key_file_group_t;
 
 struct _ply_key_file
 {
-  char  *filename;
-  FILE  *fp;
+        char            *filename;
+        FILE            *fp;
 
-  ply_hashtable_t *groups;
+        ply_hashtable_t *groups;
 };
 
 typedef struct
 {
-  ply_key_file_foreach_func_t *func;
-  void                        *user_data;
-  char                        *group_name;
+        ply_key_file_foreach_func_t *func;
+        void                        *user_data;
+        char                        *group_name;
 } ply_key_file_foreach_func_data_t;
 
 static bool ply_key_file_open_file (ply_key_file_t *key_file);
@@ -74,249 +74,235 @@ static void ply_key_file_close_file (ply_key_file_t *key_file);
 static bool
 ply_key_file_open_file (ply_key_file_t *key_file)
 {
-  assert (key_file != NULL);
+        assert (key_file != NULL);
 
-  key_file->fp = fopen (key_file->filename, "re");
+        key_file->fp = fopen (key_file->filename, "re");
 
-  if (key_file->fp == NULL)
-    {
-      ply_trace ("Failed to open key file %s: %m",
-                 key_file->filename);
-      return false;
-    }
-  return true;
+        if (key_file->fp == NULL) {
+                ply_trace ("Failed to open key file %s: %m",
+                           key_file->filename);
+                return false;
+        }
+        return true;
 }
 
 static void
 ply_key_file_close_file (ply_key_file_t *key_file)
 {
-  assert (key_file != NULL);
+        assert (key_file != NULL);
 
-  if (key_file->fp == NULL)
-    return;
-  fclose (key_file->fp);
-  key_file->fp = NULL;
+        if (key_file->fp == NULL)
+                return;
+        fclose (key_file->fp);
+        key_file->fp = NULL;
 }
 
 ply_key_file_t *
 ply_key_file_new (const char *filename)
 {
-  ply_key_file_t *key_file;
+        ply_key_file_t *key_file;
 
-  assert (filename != NULL);
+        assert (filename != NULL);
 
-  key_file = calloc (1, sizeof (ply_key_file_t));
+        key_file = calloc (1, sizeof(ply_key_file_t));
 
-  key_file->filename = strdup (filename);
-  key_file->fp = NULL;
-  key_file->groups = ply_hashtable_new (ply_hashtable_string_hash, ply_hashtable_string_compare);
+        key_file->filename = strdup (filename);
+        key_file->fp = NULL;
+        key_file->groups = ply_hashtable_new (ply_hashtable_string_hash, ply_hashtable_string_compare);
 
-  return key_file;
+        return key_file;
 }
 
 static void
-ply_key_file_free_entry_foreach (void *key, 
+ply_key_file_free_entry_foreach (void *key,
                                  void *data,
                                  void *user_data)
 {
-  ply_key_file_entry_t *entry = data;
-  free (entry->key);
-  free (entry->value);
-  free (entry);
+        ply_key_file_entry_t *entry = data;
+
+        free (entry->key);
+        free (entry->value);
+        free (entry);
 }
 
 static void
-ply_key_file_free_group (void *key, 
+ply_key_file_free_group (void *key,
                          void *data,
                          void *user_data)
 {
-  ply_key_file_group_t *group = data;
-  
-  ply_hashtable_foreach (group->entries,
-					     ply_key_file_free_entry_foreach,
-					     NULL);
-  ply_hashtable_free (group->entries);
-  free (group->name);
-  free (group);
+        ply_key_file_group_t *group = data;
+
+        ply_hashtable_foreach (group->entries,
+                               ply_key_file_free_entry_foreach,
+                               NULL);
+        ply_hashtable_free (group->entries);
+        free (group->name);
+        free (group);
 }
 
 void
 ply_key_file_free (ply_key_file_t *key_file)
 {
-  if (key_file == NULL)
-    return;
-
-  assert (key_file->filename != NULL);
-  ply_hashtable_foreach (key_file->groups,
-					     ply_key_file_free_group,
-					     NULL);
-  
-  
-  ply_hashtable_free (key_file->groups);
-  free (key_file->filename);
-  free (key_file);
+        if (key_file == NULL)
+                return;
+
+        assert (key_file->filename != NULL);
+        ply_hashtable_foreach (key_file->groups,
+                               ply_key_file_free_group,
+                               NULL);
+
+
+        ply_hashtable_free (key_file->groups);
+        free (key_file->filename);
+        free (key_file);
 }
 
 static ply_key_file_group_t *
 ply_key_file_load_group (ply_key_file_t *key_file,
                          const char     *group_name)
 {
-  int items_matched;
-  ply_key_file_group_t *group;
-
-  group = calloc (1, sizeof (ply_key_file_group_t));
-  group->name = strdup (group_name);
-  group->entries = ply_hashtable_new (ply_hashtable_string_hash, ply_hashtable_string_compare);
-
-  ply_trace ("trying to load group %s", group_name);
-  do
-    {
-      ply_key_file_entry_t *entry;
-      char *key;
-      char *value;
-      off_t offset;
-      int first_byte;
-
-      key = NULL;
-      value = NULL;
-
-      do
-        {
-          first_byte = fgetc (key_file->fp);
-        }
-      while (isspace (first_byte));
+        int items_matched;
+        ply_key_file_group_t *group;
 
-      if (first_byte == '#')
-        {
-          char *line_to_toss;
-          size_t number_of_bytes;
+        group = calloc (1, sizeof(ply_key_file_group_t));
+        group->name = strdup (group_name);
+        group->entries = ply_hashtable_new (ply_hashtable_string_hash, ply_hashtable_string_compare);
 
-          line_to_toss = NULL;
-          number_of_bytes = 0;
+        ply_trace ("trying to load group %s", group_name);
+        do {
+                ply_key_file_entry_t *entry;
+                char *key;
+                char *value;
+                off_t offset;
+                int first_byte;
 
-          getline (&line_to_toss, &number_of_bytes,
-                   key_file->fp);
-          free (line_to_toss);
-          items_matched = 0;
-          continue;
-        }
-      ungetc (first_byte, key_file->fp);
+                key = NULL;
+                value = NULL;
 
-      offset = ftello (key_file->fp);
-      items_matched = fscanf (key_file->fp, " %m[^= \t\n] = %m[^\n] ", &key, &value);
+                do {
+                        first_byte = fgetc (key_file->fp);
+                } while (isspace (first_byte));
 
-      if (items_matched != 2)
-        {
-          if (items_matched == 1)
-            fseeko (key_file->fp, offset, SEEK_SET);
+                if (first_byte == '#') {
+                        char *line_to_toss;
+                        size_t number_of_bytes;
 
-          free (key);
-          free (value);
-          break;
-        }
+                        line_to_toss = NULL;
+                        number_of_bytes = 0;
+
+                        getline (&line_to_toss, &number_of_bytes,
+                                 key_file->fp);
+                        free (line_to_toss);
+                        items_matched = 0;
+                        continue;
+                }
+                ungetc (first_byte, key_file->fp);
+
+                offset = ftello (key_file->fp);
+                items_matched = fscanf (key_file->fp, " %m[^= \t\n] = %m[^\n] ", &key, &value);
+
+                if (items_matched != 2) {
+                        if (items_matched == 1)
+                                fseeko (key_file->fp, offset, SEEK_SET);
 
-      entry = calloc (1, sizeof (ply_key_file_entry_t));
+                        free (key);
+                        free (value);
+                        break;
+                }
 
-      entry->key = key;
-      entry->value = value;
+                entry = calloc (1, sizeof(ply_key_file_entry_t));
 
-      ply_hashtable_insert (group->entries, entry->key, entry);
-    }
-  while (items_matched != EOF);
+                entry->key = key;
+                entry->value = value;
 
-  return group;
+                ply_hashtable_insert (group->entries, entry->key, entry);
+        } while (items_matched != EOF);
+
+        return group;
 }
 
 static bool
 ply_key_file_load_groups (ply_key_file_t *key_file)
 {
-  int items_matched;
-  bool added_group = false;
-  bool has_comments = false;
-
-  do
-    {
-      char *group_name;
-      int first_byte;
-
-      ply_key_file_group_t *group;
-
-      first_byte = fgetc (key_file->fp);
-      if (first_byte == '#')
-        {
-          char *line_to_toss;
-          size_t number_of_bytes;
-
-          line_to_toss = NULL;
-          number_of_bytes = 0;
-
-          getline (&line_to_toss, &number_of_bytes,
-                   key_file->fp);
-          free (line_to_toss);
-          has_comments = true;
-          items_matched = 0;
-          continue;
-        }
-      ungetc (first_byte, key_file->fp);
+        int items_matched;
+        bool added_group = false;
+        bool has_comments = false;
 
-      group_name = NULL;
-      items_matched = fscanf (key_file->fp, " [ %m[^]] ] ", &group_name);
+        do {
+                char *group_name;
+                int first_byte;
 
-      if (items_matched <= 0)
-        {
-          ply_trace ("key file has no %sgroups",
-                     added_group? "more " : "");
-          break;
-        }
+                ply_key_file_group_t *group;
+
+                first_byte = fgetc (key_file->fp);
+                if (first_byte == '#') {
+                        char *line_to_toss;
+                        size_t number_of_bytes;
+
+                        line_to_toss = NULL;
+                        number_of_bytes = 0;
 
-      assert (group_name != NULL);
-      group = ply_key_file_load_group (key_file, group_name);
+                        getline (&line_to_toss, &number_of_bytes,
+                                 key_file->fp);
+                        free (line_to_toss);
+                        has_comments = true;
+                        items_matched = 0;
+                        continue;
+                }
+                ungetc (first_byte, key_file->fp);
 
-      free (group_name);
+                group_name = NULL;
+                items_matched = fscanf (key_file->fp, " [ %m[^]] ] ", &group_name);
 
-      if (group == NULL)
-        break;
+                if (items_matched <= 0) {
+                        ply_trace ("key file has no %sgroups",
+                                   added_group ? "more " : "");
+                        break;
+                }
 
-      ply_hashtable_insert (key_file->groups, group->name, group);
-      added_group = true;
-    }
-  while (items_matched != EOF);
+                assert (group_name != NULL);
+                group = ply_key_file_load_group (key_file, group_name);
 
-  if (!added_group && has_comments)
-    {
-      ply_trace ("key file has comments but no groups");
-    }
+                free (group_name);
 
-  return added_group;
+                if (group == NULL)
+                        break;
+
+                ply_hashtable_insert (key_file->groups, group->name, group);
+                added_group = true;
+        } while (items_matched != EOF);
+
+        if (!added_group && has_comments)
+                ply_trace ("key file has comments but no groups");
+
+        return added_group;
 }
 
 bool
 ply_key_file_load (ply_key_file_t *key_file)
 {
-  bool was_loaded;
+        bool was_loaded;
 
-  assert (key_file != NULL);
+        assert (key_file != NULL);
 
-  if (!ply_key_file_open_file (key_file))
-    return false;
+        if (!ply_key_file_open_file (key_file))
+                return false;
 
-  was_loaded = ply_key_file_load_groups (key_file);
+        was_loaded = ply_key_file_load_groups (key_file);
 
-  if (!was_loaded)
-    {
-      ply_trace ("was unable to load any groups");
-    }
+        if (!was_loaded)
+                ply_trace ("was unable to load any groups");
 
-  ply_key_file_close_file (key_file);
+        ply_key_file_close_file (key_file);
 
-  return was_loaded;
+        return was_loaded;
 }
 
 static ply_key_file_group_t *
 ply_key_file_find_group (ply_key_file_t *key_file,
                          const char     *group_name)
 {
-  return  ply_hashtable_lookup (key_file->groups, (void *) group_name);
+        return ply_hashtable_lookup (key_file->groups, (void *) group_name);
 }
 
 static ply_key_file_entry_t *
@@ -324,7 +310,7 @@ ply_key_file_find_entry (ply_key_file_t       *key_file,
                          ply_key_file_group_t *group,
                          const char           *key)
 {
-  return  ply_hashtable_lookup (group->entries, (void *) key);
+        return ply_hashtable_lookup (group->entries, (void *) key);
 }
 
 bool
@@ -332,17 +318,17 @@ ply_key_file_has_key (ply_key_file_t *key_file,
                       const char     *group_name,
                       const char     *key)
 {
-  ply_key_file_group_t *group;
-  ply_key_file_entry_t *entry;
+        ply_key_file_group_t *group;
+        ply_key_file_entry_t *entry;
 
-  group = ply_key_file_find_group (key_file, group_name);
+        group = ply_key_file_find_group (key_file, group_name);
 
-  if (group == NULL)
-    return false;
+        if (group == NULL)
+                return false;
 
-  entry = ply_key_file_find_entry (key_file, group, key);
+        entry = ply_key_file_find_entry (key_file, group, key);
 
-  return entry != NULL;
+        return entry != NULL;
 }
 
 char *
@@ -350,26 +336,24 @@ ply_key_file_get_value (ply_key_file_t *key_file,
                         const char     *group_name,
                         const char     *key)
 {
-  ply_key_file_group_t *group;
-  ply_key_file_entry_t *entry;
+        ply_key_file_group_t *group;
+        ply_key_file_entry_t *entry;
 
-  group = ply_key_file_find_group (key_file, group_name);
+        group = ply_key_file_find_group (key_file, group_name);
 
-  if (group == NULL)
-    {
-      ply_trace ("key file does not have group '%s'", group_name);
-      return NULL;
-    }
+        if (group == NULL) {
+                ply_trace ("key file does not have group '%s'", group_name);
+                return NULL;
+        }
 
-  entry = ply_key_file_find_entry (key_file, group, key);
+        entry = ply_key_file_find_entry (key_file, group, key);
 
-  if (entry == NULL)
-    {
-      ply_trace ("key file does not have entry for key '%s'", key);
-      return NULL;
-    }
+        if (entry == NULL) {
+                ply_trace ("key file does not have entry for key '%s'", key);
+                return NULL;
+        }
 
-  return strdup (entry->value);
+        return strdup (entry->value);
 }
 
 static void
@@ -377,16 +361,16 @@ ply_key_file_foreach_entry_entries (void *key,
                                     void *data,
                                     void *user_data)
 {
-  ply_key_file_entry_t *entry;
-  ply_key_file_foreach_func_data_t *func_data;
+        ply_key_file_entry_t *entry;
+        ply_key_file_foreach_func_data_t *func_data;
 
-  func_data = user_data;
-  entry = data;
+        func_data = user_data;
+        entry = data;
 
-  func_data->func(func_data->group_name,
-                  entry->key,
-                  entry->value,
-                  func_data->user_data);
+        func_data->func (func_data->group_name,
+                         entry->key,
+                         entry->value,
+                         func_data->user_data);
 }
 
 static void
@@ -394,30 +378,30 @@ ply_key_file_foreach_entry_groups (void *key,
                                    void *data,
                                    void *user_data)
 {
-  ply_key_file_group_t *group;
-  ply_key_file_foreach_func_data_t *func_data;
+        ply_key_file_group_t *group;
+        ply_key_file_foreach_func_data_t *func_data;
 
-  func_data = user_data;
-  group = data;
-  func_data->group_name = group->name;
+        func_data = user_data;
+        group = data;
+        func_data->group_name = group->name;
 
-  ply_hashtable_foreach (group->entries,
-                         ply_key_file_foreach_entry_entries,
-                         func_data);
+        ply_hashtable_foreach (group->entries,
+                               ply_key_file_foreach_entry_entries,
+                               func_data);
 }
 
 void
-ply_key_file_foreach_entry (ply_key_file_t              *key_file,
-                            ply_key_file_foreach_func_t  func,
-                            void                        *user_data)
+ply_key_file_foreach_entry (ply_key_file_t             *key_file,
+                            ply_key_file_foreach_func_t func,
+                            void                       *user_data)
 {
-  ply_key_file_foreach_func_data_t func_data;
+        ply_key_file_foreach_func_data_t func_data;
 
-  func_data.func = func;
-  func_data.user_data = user_data;
-  ply_hashtable_foreach (key_file->groups,
-                         ply_key_file_foreach_entry_groups,
-                         &func_data);
+        func_data.func = func;
+        func_data.user_data = user_data;
+        ply_hashtable_foreach (key_file->groups,
+                               ply_key_file_foreach_entry_groups,
+                               &func_data);
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-key-file.h b/src/libply/ply-key-file.h
index 8f6c891..e69d14a 100644
--- a/src/libply/ply-key-file.h
+++ b/src/libply/ply-key-file.h
@@ -1,4 +1,4 @@
-/* ply-key-file.h - key file loader 
+/* ply-key-file.h - key file loader
  *
  * Copyright (C) 2009 Red Hat, Inc.
  *
@@ -42,9 +42,9 @@ bool ply_key_file_has_key (ply_key_file_t *key_file,
 char *ply_key_file_get_value (ply_key_file_t *key_file,
                               const char     *group_name,
                               const char     *key);
-void ply_key_file_foreach_entry (ply_key_file_t              *key_file,
-                                 ply_key_file_foreach_func_t  func,
-                                 void                        *user_data);
+void ply_key_file_foreach_entry (ply_key_file_t             *key_file,
+                                 ply_key_file_foreach_func_t func,
+                                 void                       *user_data);
 #endif
 
 #endif /* PLY_KEY_FILE_H */
diff --git a/src/libply/ply-list.c b/src/libply/ply-list.c
index 8c589c2..da90793 100644
--- a/src/libply/ply-list.c
+++ b/src/libply/ply-list.c
@@ -31,83 +31,82 @@
 
 struct _ply_list
 {
-  ply_list_node_t *first_node;
-  ply_list_node_t *last_node;
+        ply_list_node_t *first_node;
+        ply_list_node_t *last_node;
 
-  int number_of_nodes;
+        int              number_of_nodes;
 };
 
 struct _ply_list_node
 {
-  void   *data;
-  struct _ply_list_node *previous;
-  struct _ply_list_node *next;
+        void                  *data;
+        struct _ply_list_node *previous;
+        struct _ply_list_node *next;
 };
 
 ply_list_t *
 ply_list_new (void)
 {
-  ply_list_t *list;
+        ply_list_t *list;
 
-  list = calloc (1, sizeof (ply_list_t));
+        list = calloc (1, sizeof(ply_list_t));
 
-  list->first_node = NULL;
-  list->last_node = NULL;
-  list->number_of_nodes = 0;
+        list->first_node = NULL;
+        list->last_node = NULL;
+        list->number_of_nodes = 0;
 
-  return list;
+        return list;
 }
 
 void
 ply_list_free (ply_list_t *list)
 {
-  ply_list_remove_all_nodes (list);
-  free (list);
+        ply_list_remove_all_nodes (list);
+        free (list);
 }
 
 static ply_list_node_t *
 ply_list_node_new (void *data)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = calloc (1, sizeof (ply_list_node_t));
-  node->data = data;
+        node = calloc (1, sizeof(ply_list_node_t));
+        node->data = data;
 
-  return node;
+        return node;
 }
 
 static void
 ply_list_node_free (ply_list_node_t *node)
 {
-  if (node == NULL)
-    return;
+        if (node == NULL)
+                return;
 
-  assert ((node->previous == NULL) && (node->next == NULL));
+        assert ((node->previous == NULL) && (node->next == NULL));
 
-  free (node);
+        free (node);
 }
 
 int
 ply_list_get_length (ply_list_t *list)
 {
-  return list->number_of_nodes;
+        return list->number_of_nodes;
 }
 
 ply_list_node_t *
 ply_list_find_node (ply_list_t *list,
                     void       *data)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = list->first_node;
-  while (node != NULL)
-    {
-      if (node->data == data)
-        break;
+        node = list->first_node;
+        while (node != NULL) {
+                if (node->data == data)
+                        break;
 
-      node = node->next;
-    }
-  return node;
+                node = node->next;
+        }
+        return node;
 }
 
 static void
@@ -115,39 +114,32 @@ ply_list_insert_node (ply_list_t      *list,
                       ply_list_node_t *node_before,
                       ply_list_node_t *new_node)
 {
-
-  if (new_node == NULL)
-    return;
-
-  if (node_before == NULL)
-    {
-      if (list->first_node == NULL)
-        {
-          assert (list->last_node == NULL);
-
-          list->first_node = new_node;
-          list->last_node = new_node;
+        if (new_node == NULL)
+                return;
+
+        if (node_before == NULL) {
+                if (list->first_node == NULL) {
+                        assert (list->last_node == NULL);
+
+                        list->first_node = new_node;
+                        list->last_node = new_node;
+                } else {
+                        list->first_node->previous = new_node;
+                        new_node->next = list->first_node;
+                        list->first_node = new_node;
+                }
+        } else {
+                new_node->next = node_before->next;
+                if (node_before->next != NULL)
+                        node_before->next->previous = new_node;
+                node_before->next = new_node;
+                new_node->previous = node_before;
+
+                if (node_before == list->last_node)
+                        list->last_node = new_node;
         }
-      else
-        {
-          list->first_node->previous = new_node;
-          new_node->next = list->first_node;
-          list->first_node = new_node;
-        }
-    }
-  else
-    {
-      new_node->next = node_before->next;
-      if (node_before->next != NULL)
-        node_before->next->previous = new_node;
-      node_before->next = new_node;
-      new_node->previous = node_before;
-
-      if (node_before == list->last_node)
-        list->last_node = new_node;
-    }
-
-  list->number_of_nodes++;
+
+        list->number_of_nodes++;
 }
 
 ply_list_node_t *
@@ -155,224 +147,217 @@ ply_list_insert_data (ply_list_t      *list,
                       void            *data,
                       ply_list_node_t *node_before)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_node_new (data);
+        node = ply_list_node_new (data);
 
-  ply_list_insert_node (list, node_before, node);
+        ply_list_insert_node (list, node_before, node);
 
-  return node;
+        return node;
 }
 
 ply_list_node_t *
 ply_list_append_data (ply_list_t *list,
                       void       *data)
 {
-  return ply_list_insert_data (list, data, list->last_node);
+        return ply_list_insert_data (list, data, list->last_node);
 }
 
 ply_list_node_t *
 ply_list_prepend_data (ply_list_t *list,
                        void       *data)
 {
-  return ply_list_insert_data (list, data, NULL);
+        return ply_list_insert_data (list, data, NULL);
 }
 
 void
 ply_list_remove_data (ply_list_t *list,
                       void       *data)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (data == NULL)
-    return;
+        if (data == NULL)
+                return;
 
-  node = ply_list_find_node (list, data);
+        node = ply_list_find_node (list, data);
 
-  if (node != NULL)
-    ply_list_remove_node (list, node);
+        if (node != NULL)
+                ply_list_remove_node (list, node);
 }
 
 static void
 ply_list_unlink_node (ply_list_t      *list,
                       ply_list_node_t *node)
 {
-  ply_list_node_t *node_before, *node_after;
+        ply_list_node_t *node_before, *node_after;
 
-  assert (list != NULL);
+        assert (list != NULL);
 
-  if (node == NULL)
-    return;
+        if (node == NULL)
+                return;
 
-  node_before = node->previous;
-  node_after = node->next;
+        node_before = node->previous;
+        node_after = node->next;
 
-  if (node_before != NULL)
-    node_before->next = node_after;
+        if (node_before != NULL)
+                node_before->next = node_after;
 
-  if (node_after != NULL)
-    node_after->previous = node_before;
+        if (node_after != NULL)
+                node_after->previous = node_before;
 
-  if (list->first_node == node)
-    list->first_node = node_after;
+        if (list->first_node == node)
+                list->first_node = node_after;
 
-  if (list->last_node == node)
-    list->last_node = node_before;
+        if (list->last_node == node)
+                list->last_node = node_before;
 
-  node->previous = NULL;
-  node->next = NULL;
+        node->previous = NULL;
+        node->next = NULL;
 
-  list->number_of_nodes--;
-  assert (ply_list_find_node (list, node->data) != node);
+        list->number_of_nodes--;
+        assert (ply_list_find_node (list, node->data) != node);
 }
 
 void
 ply_list_remove_node (ply_list_t      *list,
                       ply_list_node_t *node)
 {
-  ply_list_unlink_node (list, node);
-  ply_list_node_free (node);
+        ply_list_unlink_node (list, node);
+        ply_list_node_free (node);
 }
 
 void
 ply_list_remove_all_nodes (ply_list_t *list)
 {
-  ply_list_node_t *node;
-
-  if (list == NULL)
-    return;
-
-  node = list->first_node;
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      next_node = node->next;
-      ply_list_remove_node (list, node);
-      node = next_node;
-    }
+        ply_list_node_t *node;
+
+        if (list == NULL)
+                return;
+
+        node = list->first_node;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                next_node = node->next;
+                ply_list_remove_node (list, node);
+                node = next_node;
+        }
 }
 
 ply_list_node_t *
 ply_list_get_first_node (ply_list_t *list)
 {
-  return list->first_node;
+        return list->first_node;
 }
 
 ply_list_node_t *
 ply_list_get_last_node (ply_list_t *list)
 {
-  return list->last_node;
+        return list->last_node;
 }
 
 ply_list_node_t *
 ply_list_get_nth_node (ply_list_t *list,
                        int         index)
 {
-  ply_list_node_t *node;
-  node = list->first_node;
-  if (index < 0)
-    return NULL;
-  if (index >= list->number_of_nodes)
-    return NULL;
-  while (index--)
-    {
-      node = node->next;
-    }
-  return node;
+        ply_list_node_t *node;
+
+        node = list->first_node;
+        if (index < 0)
+                return NULL;
+        if (index >= list->number_of_nodes)
+                return NULL;
+        while (index--) {
+                node = node->next;
+        }
+        return node;
 }
 
 ply_list_node_t *
-ply_list_get_next_node (ply_list_t     *list,
-                       ply_list_node_t *node)
+ply_list_get_next_node (ply_list_t      *list,
+                        ply_list_node_t *node)
 {
-  return node->next;
+        return node->next;
 }
 
-static void 
+static void
 ply_list_sort_swap (void **element_a,
                     void **element_b)
 {
-  void *temp;
-  temp = *element_a;
-  *element_a = *element_b;
-  *element_b = temp;
+        void *temp;
+
+        temp = *element_a;
+        *element_a = *element_b;
+        *element_b = temp;
 }
 
-static void 
+static void
 ply_list_sort_body (ply_list_node_t         *node_start,
                     ply_list_node_t         *node_end,
                     ply_list_compare_func_t *compare)
 {
-  if (node_start == node_end) return;
-  ply_list_node_t *cur_node = node_start;
-  ply_list_node_t *top_node = node_end;
-  ply_list_node_t *next_node = cur_node->next;
-  while (cur_node != top_node)
-    {
-      int diff = compare(cur_node->data, next_node->data);
-      if (diff > 0)
-        {
-          ply_list_sort_swap (&next_node->data,
-                              &cur_node->data);
-          cur_node = next_node;
-          next_node = cur_node->next;
-        }
-      else
-        {
-          ply_list_sort_swap (&next_node->data,
-                              &top_node->data);
-          top_node = top_node->previous;
+        if (node_start == node_end) return;
+        ply_list_node_t *cur_node = node_start;
+        ply_list_node_t *top_node = node_end;
+        ply_list_node_t *next_node = cur_node->next;
+        while (cur_node != top_node) {
+                int diff = compare (cur_node->data, next_node->data);
+                if (diff > 0) {
+                        ply_list_sort_swap (&next_node->data,
+                                            &cur_node->data);
+                        cur_node = next_node;
+                        next_node = cur_node->next;
+                } else {
+                        ply_list_sort_swap (&next_node->data,
+                                            &top_node->data);
+                        top_node = top_node->previous;
+                }
         }
-    }
-
-  if (cur_node != node_end)
-    ply_list_sort_body (cur_node->next,
-                        node_end,
-                        compare);
-  if (cur_node != node_start)
-    ply_list_sort_body (node_start,
-                        cur_node->previous,
-                        compare);
+
+        if (cur_node != node_end)
+                ply_list_sort_body (cur_node->next,
+                                    node_end,
+                                    compare);
+        if (cur_node != node_start)
+                ply_list_sort_body (node_start,
+                                    cur_node->previous,
+                                    compare);
 }
 
 void
 ply_list_sort (ply_list_t              *list,
                ply_list_compare_func_t *compare)
 {
-  ply_list_sort_body (ply_list_get_first_node (list),
-                      ply_list_get_last_node (list),
-                      compare);
+        ply_list_sort_body (ply_list_get_first_node (list),
+                            ply_list_get_last_node (list),
+                            compare);
 }
 
 void
 ply_list_sort_stable (ply_list_t              *list,
                       ply_list_compare_func_t *compare)
 {
-  ply_list_node_t *top_node;
-  ply_list_node_t *cur_node;
-
-  top_node = ply_list_get_first_node (list);
-  if (top_node == NULL) return;
-  top_node = top_node->next;
-
-  while (top_node)
-    {
-      cur_node = top_node->previous;
-      while (cur_node && compare(cur_node->data, cur_node->next->data) > 0)
-        {
-          ply_list_sort_swap (&cur_node->data,
-                              &cur_node->next->data);
-          cur_node = cur_node->previous;
+        ply_list_node_t *top_node;
+        ply_list_node_t *cur_node;
+
+        top_node = ply_list_get_first_node (list);
+        if (top_node == NULL) return;
+        top_node = top_node->next;
+
+        while (top_node) {
+                cur_node = top_node->previous;
+                while (cur_node && compare (cur_node->data, cur_node->next->data) > 0) {
+                        ply_list_sort_swap (&cur_node->data,
+                                            &cur_node->next->data);
+                        cur_node = cur_node->previous;
+                }
+                top_node = top_node->next;
         }
-      top_node = top_node->next;
-    }
-  
 }
 
 void *
 ply_list_node_get_data (ply_list_node_t *node)
 {
-  return node->data;
+        return node->data;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-list.h b/src/libply/ply-list.h
index 4f54bb5..2a3e187 100644
--- a/src/libply/ply-list.h
+++ b/src/libply/ply-list.h
@@ -24,7 +24,8 @@
 
 typedef struct _ply_list_node ply_list_node_t;
 typedef struct _ply_list ply_list_t;
-typedef int (ply_list_compare_func_t) (void *elementa, void *elementb);
+typedef int (ply_list_compare_func_t) (void *elementa,
+                                       void *elementb);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_list_t *ply_list_new (void);
@@ -32,15 +33,15 @@ void ply_list_free (ply_list_t *list);
 int ply_list_get_length (ply_list_t *list);
 ply_list_node_t *ply_list_find_node (ply_list_t *list,
                                      void       *data);
-ply_list_node_t *ply_list_insert_data (ply_list_t *list,
-		                       void       *data,
-		                       ply_list_node_t *node_before);
+ply_list_node_t *ply_list_insert_data (ply_list_t      *list,
+                                       void            *data,
+                                       ply_list_node_t *node_before);
 ply_list_node_t *ply_list_append_data (ply_list_t *list,
                                        void       *data);
 ply_list_node_t *ply_list_prepend_data (ply_list_t *list,
                                         void       *data);
 void ply_list_remove_data (ply_list_t *list,
-                          void        *data);
+                           void       *data);
 void ply_list_remove_node (ply_list_t      *list,
                            ply_list_node_t *node);
 void ply_list_remove_all_nodes (ply_list_t *list);
diff --git a/src/libply/ply-logger.c b/src/libply/ply-logger.c
index 740c30e..789ad4e 100644
--- a/src/libply/ply-logger.c
+++ b/src/libply/ply-logger.c
@@ -53,70 +53,70 @@
 
 typedef struct
 {
-  ply_logger_filter_handler_t  handler;
-  void                        *user_data;
+        ply_logger_filter_handler_t handler;
+        void                       *user_data;
 } ply_logger_filter_t;
 
 struct _ply_logger
 {
-  int output_fd;
-  char *filename;
+        int                       output_fd;
+        char                     *filename;
 
-  char *buffer;
-  size_t buffer_size;
-  size_t buffer_capacity;
+        char                     *buffer;
+        size_t                    buffer_size;
+        size_t                    buffer_capacity;
 
-  ply_logger_flush_policy_t flush_policy;
-  ply_list_t *filters;
+        ply_logger_flush_policy_t flush_policy;
+        ply_list_t               *filters;
 
-  uint32_t is_enabled : 1;
-  uint32_t tracing_is_enabled : 1;
+        uint32_t                  is_enabled : 1;
+        uint32_t                  tracing_is_enabled : 1;
 };
 
 static bool ply_text_is_loggable (const char *string,
                                   ssize_t     length);
-static void ply_logger_write_exception (ply_logger_t   *logger,
-                                        const char     *string);
-static bool ply_logger_write (ply_logger_t   *logger,
-                              const char     *string,
-                              size_t          length,
-                              bool            should_report_failures);
-
-static bool ply_logger_buffer (ply_logger_t   *logger,
-                               const char     *string,
-                               size_t          length);
+static void ply_logger_write_exception (ply_logger_t *logger,
+                                        const char   *string);
+static bool ply_logger_write (ply_logger_t *logger,
+                              const char   *string,
+                              size_t        length,
+                              bool          should_report_failures);
+
+static bool ply_logger_buffer (ply_logger_t *logger,
+                               const char   *string,
+                               size_t        length);
 static bool ply_logger_flush_buffer (ply_logger_t *logger);
 
 static bool
 ply_text_is_loggable (const char *string,
                       ssize_t     length)
 {
-  /* I guess we should let everything through since there
-   * isn't really any specified encoding
-   */
+        /* I guess we should let everything through since there
+         * isn't really any specified encoding
+         */
 
-  return true;
+        return true;
 }
 
 static void
-ply_logger_write_exception (ply_logger_t   *logger,
-                            const char     *string)
+ply_logger_write_exception (ply_logger_t *logger,
+                            const char   *string)
 {
-  char *message;
-  int number_of_bytes;
+        char *message;
+        int number_of_bytes;
 
-  if (!ply_text_is_loggable (string, -1))
-    return;
+        if (!ply_text_is_loggable (string, -1))
+                return;
 
-  message = NULL;
-  asprintf (&message,
-            "[couldn't write a log entry: %s]\n%n",
-            string, &number_of_bytes);
+        message = NULL;
+        asprintf (&message,
+                  "[couldn't write a log entry: %s]\n%n",
+                  string, &number_of_bytes);
 
-  assert (message != NULL);
+        assert (message != NULL);
 
-  ply_logger_write (logger, message, number_of_bytes, false);
-  free (message);
+        ply_logger_write (logger, message, number_of_bytes, false);
+        free (message);
 }
 
 static bool
@@ -125,75 +125,72 @@ ply_logger_write (ply_logger_t *logger,
                   size_t        length,
                   bool          should_report_failures)
 {
-  if (!ply_text_is_loggable (string, length))
-    {
-      if (should_report_failures)
-        ply_logger_write_exception (logger,
-                                    "log text contains unloggable bytes");
-      /* we return true here, because returning false would mean
-       * "you aren't allowed to write to the log file anymore"
-       */
-      return true;
-    }
-
-  if (!ply_write (logger->output_fd, string, length))
-    {
-      if (should_report_failures)
-        ply_logger_write_exception (logger, strerror (errno));
-
-      return false;
-    }
-
-  return true;
+        if (!ply_text_is_loggable (string, length)) {
+                if (should_report_failures)
+                        ply_logger_write_exception (logger,
+                                                    "log text contains unloggable bytes");
+                /* we return true here, because returning false would mean
+                 * "you aren't allowed to write to the log file anymore"
+                 */
+                return true;
+        }
+
+        if (!ply_write (logger->output_fd, string, length)) {
+                if (should_report_failures)
+                        ply_logger_write_exception (logger, strerror (errno));
+
+                return false;
+        }
+
+        return true;
 }
 
 static bool
 ply_logger_flush_buffer (ply_logger_t *logger)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  if (logger->buffer_size == 0)
-    return true;
+        if (logger->buffer_size == 0)
+                return true;
 
-  if (!ply_logger_write (logger, logger->buffer, logger->buffer_size, true))
-    return false;
+        if (!ply_logger_write (logger, logger->buffer, logger->buffer_size, true))
+                return false;
 
-  memset (logger->buffer, '\0', logger->buffer_size);
-  logger->buffer_size = 0;
+        memset (logger->buffer, '\0', logger->buffer_size);
+        logger->buffer_size = 0;
 
-  return true;
+        return true;
 }
 
 static bool
 ply_logger_increase_buffer_size (ply_logger_t *logger)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  if ((logger->buffer_capacity * 2) > PLY_LOGGER_MAX_BUFFER_CAPACITY)
-    return false;
+        if ((logger->buffer_capacity * 2) > PLY_LOGGER_MAX_BUFFER_CAPACITY)
+                return false;
 
-  logger->buffer_capacity *= 2;
+        logger->buffer_capacity *= 2;
 
-  logger->buffer = realloc (logger->buffer, logger->buffer_capacity);
-  return true;
+        logger->buffer = realloc (logger->buffer, logger->buffer_capacity);
+        return true;
 }
 
 static void
 ply_logger_decapitate_buffer (ply_logger_t *logger,
                               size_t        bytes_in_head)
 {
-  assert (logger != NULL);
-
-  bytes_in_head = MIN (logger->buffer_size, bytes_in_head);
-
-  if (bytes_in_head == logger->buffer_size)
-    logger->buffer_size = 0;
-  else
-    {
-      memmove (logger->buffer, logger->buffer + bytes_in_head,
-               logger->buffer_size - bytes_in_head);
-      logger->buffer_size -= bytes_in_head;
-    }
+        assert (logger != NULL);
+
+        bytes_in_head = MIN (logger->buffer_size, bytes_in_head);
+
+        if (bytes_in_head == logger->buffer_size) {
+                logger->buffer_size = 0;
+        } else {
+                memmove (logger->buffer, logger->buffer + bytes_in_head,
+                         logger->buffer_size - bytes_in_head);
+                logger->buffer_size -= bytes_in_head;
+        }
 }
 
 static bool
@@ -201,304 +198,294 @@ ply_logger_buffer (ply_logger_t *logger,
                    const char   *string,
                    size_t        length)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  if ((logger->buffer_size + length) >= logger->buffer_capacity)
-    {
-      if (!ply_logger_increase_buffer_size (logger))
-        {
-          ply_logger_decapitate_buffer (logger, length);
+        if ((logger->buffer_size + length) >= logger->buffer_capacity) {
+                if (!ply_logger_increase_buffer_size (logger)) {
+                        ply_logger_decapitate_buffer (logger, length);
 
-          if ((logger->buffer_size + length) >= logger->buffer_capacity)
-            if (!ply_logger_increase_buffer_size (logger))
-              return false;
+                        if ((logger->buffer_size + length) >= logger->buffer_capacity)
+                                if (!ply_logger_increase_buffer_size (logger))
+                                        return false;
+                }
         }
-    }
 
-  assert (logger->buffer_size + length < logger->buffer_capacity);
+        assert (logger->buffer_size + length < logger->buffer_capacity);
 
-  memcpy (logger->buffer + logger->buffer_size,
-          string, length);
+        memcpy (logger->buffer + logger->buffer_size,
+                string, length);
 
-  logger->buffer_size += length;
+        logger->buffer_size += length;
 
-  return true;
+        return true;
 }
 
 ply_logger_t *
 ply_logger_new (void)
 {
-  ply_logger_t *logger;
+        ply_logger_t *logger;
 
-  logger = calloc (1, sizeof (ply_logger_t));
+        logger = calloc (1, sizeof(ply_logger_t));
 
-  logger->output_fd = -1;
-  logger->filename = NULL;
-  logger->is_enabled = true;
-  logger->tracing_is_enabled = false;
+        logger->output_fd = -1;
+        logger->filename = NULL;
+        logger->is_enabled = true;
+        logger->tracing_is_enabled = false;
 
-  logger->buffer_capacity = 4096;
-  logger->buffer = calloc (1, logger->buffer_capacity);
-  logger->buffer_size = 0;
+        logger->buffer_capacity = 4096;
+        logger->buffer = calloc (1, logger->buffer_capacity);
+        logger->buffer_size = 0;
 
-  logger->filters = ply_list_new ();
+        logger->filters = ply_list_new ();
 
-  return logger;
+        return logger;
 }
 
 ply_logger_t *
 ply_logger_get_default (void)
 {
-  static ply_logger_t *logger = NULL;
+        static ply_logger_t *logger = NULL;
 
-  if (logger == NULL)
-    {
-      logger = ply_logger_new ();
-      ply_logger_set_output_fd (logger, STDOUT_FILENO);
-    }
+        if (logger == NULL) {
+                logger = ply_logger_new ();
+                ply_logger_set_output_fd (logger, STDOUT_FILENO);
+        }
 
-  return logger;
+        return logger;
 }
 
 ply_logger_t *
 ply_logger_get_error_default (void)
 {
-  static ply_logger_t *logger = NULL;
+        static ply_logger_t *logger = NULL;
 
-  if (logger == NULL)
-    {
-      logger = ply_logger_new ();
-      ply_logger_set_output_fd (logger, STDERR_FILENO);
-      ply_logger_set_flush_policy (logger,
-                                   PLY_LOGGER_FLUSH_POLICY_EVERY_TIME);
-    }
+        if (logger == NULL) {
+                logger = ply_logger_new ();
+                ply_logger_set_output_fd (logger, STDERR_FILENO);
+                ply_logger_set_flush_policy (logger,
+                                             PLY_LOGGER_FLUSH_POLICY_EVERY_TIME);
+        }
 
-  return logger;
+        return logger;
 }
 
 static void
 ply_logger_free_filters (ply_logger_t *logger)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (logger->filters);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_logger_filter_t *filter;
+        node = ply_list_get_first_node (logger->filters);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_logger_filter_t *filter;
 
-      filter = (ply_logger_filter_t *) ply_list_node_get_data (node);
+                filter = (ply_logger_filter_t *) ply_list_node_get_data (node);
 
-      next_node = ply_list_get_next_node (logger->filters, node);
-      free (filter);
-      node = next_node;
-    }
+                next_node = ply_list_get_next_node (logger->filters, node);
+                free (filter);
+                node = next_node;
+        }
 
-  ply_list_free (logger->filters);
+        ply_list_free (logger->filters);
 }
 
 void
 ply_logger_free (ply_logger_t *logger)
 {
-  if (logger == NULL)
-    return;
+        if (logger == NULL)
+                return;
 
-  if (logger->output_fd >= 0)
-    {
-      if (ply_logger_is_logging (logger))
-        ply_logger_flush (logger);
-      close (logger->output_fd);
-    }
+        if (logger->output_fd >= 0) {
+                if (ply_logger_is_logging (logger))
+                        ply_logger_flush (logger);
+                close (logger->output_fd);
+        }
 
-  ply_logger_free_filters (logger);
+        ply_logger_free_filters (logger);
 
-  free (logger->filename);
-  free (logger->buffer);
-  free (logger);
+        free (logger->filename);
+        free (logger->buffer);
+        free (logger);
 }
 
 bool
-ply_logger_open_file (ply_logger_t    *logger,
-                      const char      *filename,
-                      bool             world_readable)
+ply_logger_open_file (ply_logger_t *logger,
+                      const char   *filename,
+                      bool          world_readable)
 {
-  int fd;
-  mode_t mode;
+        int fd;
+        mode_t mode;
 
-  assert (logger != NULL);
-  assert (filename != NULL);
+        assert (logger != NULL);
+        assert (filename != NULL);
 
-  if (world_readable)
-    mode = 0644;
-  else
-    mode = 0600;
+        if (world_readable)
+                mode = 0644;
+        else
+                mode = 0600;
 
-  fd = open (filename, PLY_LOGGER_OPEN_FLAGS, mode);
+        fd = open (filename, PLY_LOGGER_OPEN_FLAGS, mode);
 
-  if (fd < 0)
-    return false;
+        if (fd < 0)
+                return false;
 
-  if (fchmod (fd, mode) < 0) {
-    close (fd);
-    return false;
-  }
+        if (fchmod (fd, mode) < 0) {
+                close (fd);
+                return false;
+        }
 
-  ply_logger_set_output_fd (logger, fd);
+        ply_logger_set_output_fd (logger, fd);
 
-  free (logger->filename);
+        free (logger->filename);
 
-  logger->filename = strdup (filename);
+        logger->filename = strdup (filename);
 
-  return true;
+        return true;
 }
 
 void
 ply_logger_close_file (ply_logger_t *logger)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  if (logger->output_fd < 0)
-      return;
+        if (logger->output_fd < 0)
+                return;
 
-  close (logger->output_fd);
-  ply_logger_set_output_fd (logger, -1);
+        close (logger->output_fd);
+        ply_logger_set_output_fd (logger, -1);
 }
 
 void
 ply_logger_set_output_fd (ply_logger_t *logger,
                           int           fd)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  logger->output_fd = fd;
+        logger->output_fd = fd;
 }
 
 int
 ply_logger_get_output_fd (ply_logger_t *logger)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  return logger->output_fd;
+        return logger->output_fd;
 }
 
 bool
 ply_logger_flush (ply_logger_t *logger)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  if (!ply_logger_is_logging (logger))
-    return false;
+        if (!ply_logger_is_logging (logger))
+                return false;
 
-  if (logger->output_fd < 0)
-    return false;
+        if (logger->output_fd < 0)
+                return false;
 
-  if (!ply_logger_flush_buffer (logger))
-    return false;
+        if (!ply_logger_flush_buffer (logger))
+                return false;
 
 #ifdef SYNC_ON_FLUSH
-  if ((fdatasync (logger->output_fd) < 0) &&
-      ((errno != EROFS) && (errno != EINVAL)))
-    return false;
+        if ((fdatasync (logger->output_fd) < 0) &&
+            ((errno != EROFS) && (errno != EINVAL)))
+                return false;
 #endif
 
-  return true;
+        return true;
 }
 
 void
-ply_logger_set_flush_policy (ply_logger_t              *logger,
-                             ply_logger_flush_policy_t  policy)
+ply_logger_set_flush_policy (ply_logger_t             *logger,
+                             ply_logger_flush_policy_t policy)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  logger->flush_policy = policy;
+        logger->flush_policy = policy;
 }
 
 ply_logger_flush_policy_t
 ply_logger_get_flush_policy (ply_logger_t *logger)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  return logger->flush_policy;
+        return logger->flush_policy;
 }
 
 void
 ply_logger_toggle_logging (ply_logger_t *logger)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  logger->is_enabled = !logger->is_enabled;
+        logger->is_enabled = !logger->is_enabled;
 }
 
 bool
 ply_logger_is_logging (ply_logger_t *logger)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  return logger->is_enabled != false;
+        return logger->is_enabled != false;
 }
 
 static bool
-ply_logger_validate_format_string (ply_logger_t   *logger,
-                                   const char     *format)
+ply_logger_validate_format_string (ply_logger_t *logger,
+                                   const char   *format)
 {
-  char *n, *p;
+        char *n, *p;
 
-  p = (char *) format;
+        p = (char *) format;
 
-  /* lame checks to limit the damage
-   * of some potential exploits.
-   */
-  while ((n = strstr (p, "%n")) != NULL)
-    {
-      if (n == format)
-          return false;
+        /* lame checks to limit the damage
+         * of some potential exploits.
+         */
+        while ((n = strstr (p, "%n")) != NULL) {
+                if (n == format)
+                        return false;
 
-      if (n[-1] != '%')
-          return false;
+                if (n[-1] != '%')
+                        return false;
 
-      p = n + 1;
-    }
+                p = n + 1;
+        }
 
-  return true;
+        return true;
 }
 
 void
-ply_logger_inject_with_non_literal_format_string (ply_logger_t   *logger,
-                                                  const char     *format,
+ply_logger_inject_with_non_literal_format_string (ply_logger_t *logger,
+                                                  const char   *format,
                                                   ...)
 {
-  va_list args;
-  size_t string_size;
-  char write_buffer[PLY_LOGGER_MAX_INJECTION_SIZE] = "";
-
-  assert (logger != NULL);
+        va_list args;
+        size_t string_size;
+        char write_buffer[PLY_LOGGER_MAX_INJECTION_SIZE] = "";
 
-  if (!ply_logger_is_logging (logger))
-    return;
+        assert (logger != NULL);
 
-  if (!ply_logger_validate_format_string (logger, format))
-    {
-      ply_logger_write_exception (logger, "log format string invalid");
-      return;
-    }
+        if (!ply_logger_is_logging (logger))
+                return;
 
-  va_start (args, format);
-  string_size = vsnprintf (write_buffer, 0, format, args) + 1;
-  va_end (args);
+        if (!ply_logger_validate_format_string (logger, format)) {
+                ply_logger_write_exception (logger, "log format string invalid");
+                return;
+        }
 
-  if (string_size > PLY_LOGGER_MAX_INJECTION_SIZE)
-    {
-      ply_logger_write_exception (logger, "log text too long");
-      return;
-    }
+        va_start (args, format);
+        string_size = vsnprintf (write_buffer, 0, format, args) + 1;
+        va_end (args);
 
-  va_start (args, format);
-  vsnprintf (write_buffer, PLY_LOGGER_MAX_INJECTION_SIZE,
-             format, args);
-  va_end (args);
+        if (string_size > PLY_LOGGER_MAX_INJECTION_SIZE) {
+                ply_logger_write_exception (logger, "log text too long");
+                return;
+        }
 
-  ply_logger_inject_bytes (logger, write_buffer, string_size - 1);
+        va_start (args, format);
+        vsnprintf (write_buffer, PLY_LOGGER_MAX_INJECTION_SIZE,
+                   format, args);
+        va_end (args);
 
+        ply_logger_inject_bytes (logger, write_buffer, string_size - 1);
 }
 
 void
@@ -506,95 +493,91 @@ ply_logger_inject_bytes (ply_logger_t *logger,
                          const void   *bytes,
                          size_t        number_of_bytes)
 {
-  ply_list_node_t *node;
-  void *filtered_bytes;
-  size_t filtered_size;
-
-  assert (logger != NULL);
-  assert (bytes != NULL);
-  assert (number_of_bytes != 0);
-
-  filtered_bytes = NULL;
-  filtered_size = 0;
-  node = ply_list_get_first_node (logger->filters);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_logger_filter_t *filter;
-
-      filter = (ply_logger_filter_t *) ply_list_node_get_data (node);
-
-      next_node = ply_list_get_next_node (logger->filters, node);
-
-      if (filtered_bytes == NULL)
-        filter->handler (filter->user_data, bytes, number_of_bytes,
-                         &filtered_bytes, &filtered_size, logger);
-      else
-        {
-          void *new_bytes;
-          size_t new_size;
-
-          new_bytes = NULL;
-          new_size = 0;
-          filter->handler (filter->user_data, filtered_bytes, filtered_size,
-                           &new_bytes, &new_size, logger);
-
-          if (new_bytes != NULL)
-            {
-              free (filtered_bytes);
-              filtered_bytes = new_bytes;
-              filtered_size = new_size;
-            }
+        ply_list_node_t *node;
+        void *filtered_bytes;
+        size_t filtered_size;
+
+        assert (logger != NULL);
+        assert (bytes != NULL);
+        assert (number_of_bytes != 0);
+
+        filtered_bytes = NULL;
+        filtered_size = 0;
+        node = ply_list_get_first_node (logger->filters);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_logger_filter_t *filter;
+
+                filter = (ply_logger_filter_t *) ply_list_node_get_data (node);
+
+                next_node = ply_list_get_next_node (logger->filters, node);
+
+                if (filtered_bytes == NULL) {
+                        filter->handler (filter->user_data, bytes, number_of_bytes,
+                                         &filtered_bytes, &filtered_size, logger);
+                } else {
+                        void *new_bytes;
+                        size_t new_size;
+
+                        new_bytes = NULL;
+                        new_size = 0;
+                        filter->handler (filter->user_data, filtered_bytes, filtered_size,
+                                         &new_bytes, &new_size, logger);
+
+                        if (new_bytes != NULL) {
+                                free (filtered_bytes);
+                                filtered_bytes = new_bytes;
+                                filtered_size = new_size;
+                        }
+                }
+
+                node = next_node;
         }
 
-      node = next_node;
-    }
-
-  if (filtered_bytes == NULL)
-    ply_logger_buffer (logger, bytes, number_of_bytes);
-  else
-    {
-      ply_logger_buffer (logger, filtered_bytes, filtered_size);
-      free (filtered_bytes);
-    }
+        if (filtered_bytes == NULL) {
+                ply_logger_buffer (logger, bytes, number_of_bytes);
+        } else {
+                ply_logger_buffer (logger, filtered_bytes, filtered_size);
+                free (filtered_bytes);
+        }
 
-  assert ((logger->flush_policy == PLY_LOGGER_FLUSH_POLICY_WHEN_ASKED)
-          || (logger->flush_policy == PLY_LOGGER_FLUSH_POLICY_EVERY_TIME));
+        assert ((logger->flush_policy == PLY_LOGGER_FLUSH_POLICY_WHEN_ASKED)
+                || (logger->flush_policy == PLY_LOGGER_FLUSH_POLICY_EVERY_TIME));
 
-  if (logger->flush_policy == PLY_LOGGER_FLUSH_POLICY_EVERY_TIME)
-    ply_logger_flush (logger);
+        if (logger->flush_policy == PLY_LOGGER_FLUSH_POLICY_EVERY_TIME)
+                ply_logger_flush (logger);
 }
 
 void
-ply_logger_add_filter (ply_logger_t                *logger,
-                       ply_logger_filter_handler_t  filter_handler,
-                       void                        *user_data)
+ply_logger_add_filter (ply_logger_t               *logger,
+                       ply_logger_filter_handler_t filter_handler,
+                       void                       *user_data)
 {
-  ply_logger_filter_t *filter;
+        ply_logger_filter_t *filter;
 
-  filter = calloc (1, sizeof (ply_logger_filter_t));
+        filter = calloc (1, sizeof(ply_logger_filter_t));
 
-  filter->handler = filter_handler;
-  filter->user_data = user_data;
+        filter->handler = filter_handler;
+        filter->user_data = user_data;
 
-  ply_list_append_data (logger->filters, filter);
+        ply_list_append_data (logger->filters, filter);
 }
 
 #ifdef PLY_ENABLE_TRACING
 void
 ply_logger_toggle_tracing (ply_logger_t *logger)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  logger->tracing_is_enabled = !logger->tracing_is_enabled;
+        logger->tracing_is_enabled = !logger->tracing_is_enabled;
 }
 
 bool
 ply_logger_is_tracing_enabled (ply_logger_t *logger)
 {
-  assert (logger != NULL);
+        assert (logger != NULL);
 
-  return logger->tracing_is_enabled != false;
+        return logger->tracing_is_enabled != false;
 }
 #endif /* PLY_ENABLE_TRACING */
 
diff --git a/src/libply/ply-logger.h b/src/libply/ply-logger.h
index 596bed5..de23181 100644
--- a/src/libply/ply-logger.h
+++ b/src/libply/ply-logger.h
@@ -31,16 +31,16 @@ typedef struct _ply_logger ply_logger_t;
 
 typedef enum
 {
-  PLY_LOGGER_FLUSH_POLICY_WHEN_ASKED = 0,
-  PLY_LOGGER_FLUSH_POLICY_EVERY_TIME
+        PLY_LOGGER_FLUSH_POLICY_WHEN_ASKED = 0,
+        PLY_LOGGER_FLUSH_POLICY_EVERY_TIME
 } ply_logger_flush_policy_t;
 
-typedef void (* ply_logger_filter_handler_t) (void          *user_data,
-                                              const void    *in_bytes,
-                                              size_t         in_size,
-                                              void         **out_bytes,
-                                              size_t        *out_size,
-                                              ply_logger_t  *logger);
+typedef void (*ply_logger_filter_handler_t) (void         *user_data,
+                                             const void   *in_bytes,
+                                             size_t        in_size,
+                                             void        **out_bytes,
+                                             size_t       *out_size,
+                                             ply_logger_t *logger);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_logger_t *ply_logger_new (void);
@@ -48,28 +48,29 @@ void ply_logger_free (ply_logger_t *logger);
 bool ply_logger_open_file (ply_logger_t *logger,
                            const char   *filename,
                            bool          world_readable);
-void ply_logger_close_file (ply_logger_t    *logger);
+void ply_logger_close_file (ply_logger_t *logger);
 void ply_logger_set_output_fd (ply_logger_t *logger,
                                int           fd);
 int ply_logger_get_output_fd (ply_logger_t *logger);
 bool ply_logger_flush (ply_logger_t *logger);
-void ply_logger_set_flush_policy (ply_logger_t              *logger,
-                                  ply_logger_flush_policy_t  policy);
+void ply_logger_set_flush_policy (ply_logger_t             *logger,
+                                  ply_logger_flush_policy_t policy);
 ply_logger_flush_policy_t ply_logger_get_flush_policy (ply_logger_t *logger);
 void ply_logger_toggle_logging (ply_logger_t *logger);
 bool ply_logger_is_logging (ply_logger_t *logger);
 void ply_logger_inject_bytes (ply_logger_t *logger,
                               const void   *bytes,
-                              size_t number_of_bytes);
-void ply_logger_add_filter (ply_logger_t                *logger,
-                            ply_logger_filter_handler_t  filter_handler,
-                            void                        *user_data);
-#define ply_logger_inject(logger, format, args...)                             \
+                              size_t        number_of_bytes);
+void ply_logger_add_filter (ply_logger_t               *logger,
+                            ply_logger_filter_handler_t filter_handler,
+                            void                       *user_data);
+#define ply_logger_inject(logger, format, args ...)                             \
         ply_logger_inject_with_non_literal_format_string (logger,              \
-                                                          format "", ##args)
+                                                          format "", ## args)
 __attribute__((__format__ (__printf__, 2, 3)))
-void ply_logger_inject_with_non_literal_format_string (ply_logger_t   *logger,
-		                                       const char *format, ...);
+void ply_logger_inject_with_non_literal_format_string (ply_logger_t *logger,
+                                                       const char   *format,
+                                                       ...);
 
 ply_logger_t *ply_logger_get_default (void);
 ply_logger_t *ply_logger_get_error_default (void);
@@ -81,25 +82,25 @@ ply_logger_t *ply_logger_get_error_default (void);
 void ply_logger_toggle_tracing (ply_logger_t *logger);
 bool ply_logger_is_tracing_enabled (ply_logger_t *logger);
 
-#define ply_logger_trace(logger, format, args...)                              \
-do                                                                             \
-  {                                                                            \
-    int _old_errno;                                                            \
-    _old_errno = errno;                                                        \
-    if (ply_logger_is_tracing_enabled (logger))                                \
-      {                                                                        \
-        ply_logger_flush (logger);                                             \
-        errno = _old_errno;                                                    \
-        ply_logger_inject (logger,                                             \
-                           "[%s:%d] %45.45s:" format "\r\n",                   \
-                           __FILE__, __LINE__, __func__, ##args);              \
-        ply_logger_flush (logger);                                             \
-        errno = _old_errno;                                                    \
-      }                                                                        \
-  }                                                                            \
-while (0)
+#define ply_logger_trace(logger, format, args ...)                              \
+        do                                                                             \
+        {                                                                            \
+                int _old_errno;                                                            \
+                _old_errno = errno;                                                        \
+                if (ply_logger_is_tracing_enabled (logger))                                \
+                {                                                                        \
+                        ply_logger_flush (logger);                                             \
+                        errno = _old_errno;                                                    \
+                        ply_logger_inject (logger,                                             \
+                                           "[%s:%d] %45.45s:" format "\r\n",                   \
+                                           __FILE__, __LINE__, __func__, ## args);              \
+                        ply_logger_flush (logger);                                             \
+                        errno = _old_errno;                                                    \
+                }                                                                        \
+        }                                                                            \
+        while (0)
 #else
-#define ply_logger_trace(logger, format, args...)
+#define ply_logger_trace(logger, format, args ...)
 #define ply_logger_toggle_tracing(logger)
 #define ply_logger_is_tracing_enabled(logger) (false)
 #endif /* PLY_ENABLE_TRACING */
@@ -114,14 +115,14 @@ while (0)
         ply_logger_flush (ply_logger_get_default ())
 #define ply_free_log()                                                         \
         ply_logger_free (ply_logger_get_default ())
-#define ply_log(format, args...)                                               \
-        ply_logger_inject (ply_logger_get_default (), format "\n", ##args)
-#define ply_log_without_new_line(format, args...)                              \
-        ply_logger_inject (ply_logger_get_default (), format, ##args)
-#define ply_error(format, args...)                                             \
-        ply_logger_inject (ply_logger_get_error_default (), format "\n", ##args)
-#define ply_error_without_new_line(format, args...)                            \
-        ply_logger_inject (ply_logger_get_error_default (), format, ##args)
+#define ply_log(format, args ...)                                               \
+        ply_logger_inject (ply_logger_get_default (), format "\n", ## args)
+#define ply_log_without_new_line(format, args ...)                              \
+        ply_logger_inject (ply_logger_get_default (), format, ## args)
+#define ply_error(format, args ...)                                             \
+        ply_logger_inject (ply_logger_get_error_default (), format "\n", ## args)
+#define ply_error_without_new_line(format, args ...)                            \
+        ply_logger_inject (ply_logger_get_error_default (), format, ## args)
 #define ply_free_error_log()                                                   \
         ply_logger_free (ply_logger_get_error_default ())
 
@@ -129,8 +130,8 @@ while (0)
         ply_logger_toggle_tracing (ply_logger_get_error_default ())
 #define ply_is_tracing()                                                       \
         ply_logger_is_tracing_enabled (ply_logger_get_error_default ())
-#define ply_trace(format, args...)                                             \
-        ply_logger_trace (ply_logger_get_error_default (), format, ##args)
+#define ply_trace(format, args ...)                                             \
+        ply_logger_trace (ply_logger_get_error_default (), format, ## args)
 
 #endif
 
diff --git a/src/libply/ply-progress.c b/src/libply/ply-progress.c
index 4a16556..57967d0 100644
--- a/src/libply/ply-progress.c
+++ b/src/libply/ply-progress.c
@@ -1,4 +1,4 @@
-/* ply-progress.c - calculats boot progress 
+/* ply-progress.c - calculats boot progress
  *
  * Copyright (C) 2007 Red Hat, Inc.
  *
@@ -53,287 +53,274 @@
 
 struct _ply_progress
 {
-  double start_time;
-  double pause_time;
-  double scalar;
-  double last_percentage;
-  double last_percentage_time;
-  double dead_time;
-  double next_message_percentage;
-  ply_list_t *current_message_list;
-  ply_list_t *previous_message_list;
-  uint32_t paused : 1;
+        double      start_time;
+        double      pause_time;
+        double      scalar;
+        double      last_percentage;
+        double      last_percentage_time;
+        double      dead_time;
+        double      next_message_percentage;
+        ply_list_t *current_message_list;
+        ply_list_t *previous_message_list;
+        uint32_t    paused : 1;
 };
 
-typedef struct 
+typedef struct
 {
-  double time;
-  char* string;
-  uint32_t disabled : 1;
+        double   time;
+        char    *string;
+        uint32_t disabled : 1;
 } ply_progress_message_t;
 
-ply_progress_t*
+ply_progress_t *
 ply_progress_new (void)
 {
-  ply_progress_t *progress = calloc (1, sizeof (ply_progress_t));
-  
-  progress->start_time = ply_get_timestamp();
-  progress->pause_time=0;
-  progress->scalar=1.0/DEFAULT_BOOT_DURATION;
-  progress->pause_time=0.0;
-  progress->last_percentage=0.0;
-  progress->last_percentage_time=0.0;
-  progress->dead_time=0.0;
-  progress->next_message_percentage=0.25;
-  progress->current_message_list = ply_list_new ();
-  progress->previous_message_list = ply_list_new ();
-  progress->paused = false;
-  return progress;
+        ply_progress_t *progress = calloc (1, sizeof(ply_progress_t));
+
+        progress->start_time = ply_get_timestamp ();
+        progress->pause_time = 0;
+        progress->scalar = 1.0 / DEFAULT_BOOT_DURATION;
+        progress->pause_time = 0.0;
+        progress->last_percentage = 0.0;
+        progress->last_percentage_time = 0.0;
+        progress->dead_time = 0.0;
+        progress->next_message_percentage = 0.25;
+        progress->current_message_list = ply_list_new ();
+        progress->previous_message_list = ply_list_new ();
+        progress->paused = false;
+        return progress;
 }
 
 void
-ply_progress_free (ply_progress_t* progress)
+ply_progress_free (ply_progress_t *progress)
 {
-  ply_list_node_t *node;
-  node = ply_list_get_first_node (progress->current_message_list);
-
-  while (node)
-   {
-      ply_list_node_t *next_node;
-      ply_progress_message_t *message = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (progress->current_message_list, node);
-
-      free (message->string);
-      free (message);
-      node = next_node;
-    }
-  ply_list_free (progress->current_message_list);
-
-  node = ply_list_get_first_node (progress->previous_message_list);
-
-  while (node)
-   {
-      ply_list_node_t *next_node;
-      ply_progress_message_t *message = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (progress->previous_message_list, node);
-
-      free (message->string);
-      free (message);
-      node = next_node;
-    }
-  ply_list_free (progress->previous_message_list);
-  free(progress);
-  return;
+        ply_list_node_t *node;
+
+        node = ply_list_get_first_node (progress->current_message_list);
+
+        while (node) {
+                ply_list_node_t *next_node;
+                ply_progress_message_t *message = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (progress->current_message_list, node);
+
+                free (message->string);
+                free (message);
+                node = next_node;
+        }
+        ply_list_free (progress->current_message_list);
+
+        node = ply_list_get_first_node (progress->previous_message_list);
+
+        while (node) {
+                ply_list_node_t *next_node;
+                ply_progress_message_t *message = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (progress->previous_message_list, node);
+
+                free (message->string);
+                free (message);
+                node = next_node;
+        }
+        ply_list_free (progress->previous_message_list);
+        free (progress);
+        return;
 }
 
 
-static ply_progress_message_t*
-ply_progress_message_search (ply_list_t *message_list, const char* string)
+static ply_progress_message_t *
+ply_progress_message_search (ply_list_t *message_list, const char *string)
 {
-  ply_list_node_t *node;
-  node = ply_list_get_first_node (message_list);
-
-  while (node)
-    {
-      ply_progress_message_t *message = ply_list_node_get_data (node);
-      if (strcmp(string, message->string)==0)
-          return message;
-      node = ply_list_get_next_node (message_list, node);
-    }
-  return NULL;
+        ply_list_node_t *node;
+
+        node = ply_list_get_first_node (message_list);
+
+        while (node) {
+                ply_progress_message_t *message = ply_list_node_get_data (node);
+                if (strcmp (string, message->string) == 0)
+                        return message;
+                node = ply_list_get_next_node (message_list, node);
+        }
+        return NULL;
 }
 
 
-static ply_progress_message_t*
+static ply_progress_message_t *
 ply_progress_message_search_next (ply_list_t *message_list, double time)
 {
-  ply_list_node_t *node;
-  node = ply_list_get_first_node (message_list);
-  ply_progress_message_t *best=NULL;
-  while (node)
-    {
-      ply_progress_message_t *message = ply_list_node_get_data (node);
-      if (message->time > time && (!best || message->time < best->time))
-          best = message;
-      node = ply_list_get_next_node (message_list, node);
-    }
-  return best;
+        ply_list_node_t *node;
+
+        node = ply_list_get_first_node (message_list);
+        ply_progress_message_t *best = NULL;
+        while (node) {
+                ply_progress_message_t *message = ply_list_node_get_data (node);
+                if (message->time > time && (!best || message->time < best->time))
+                        best = message;
+                node = ply_list_get_next_node (message_list, node);
+        }
+        return best;
 }
 
 void
-ply_progress_load_cache (ply_progress_t* progress,
-                         const char *filename)
+ply_progress_load_cache (ply_progress_t *progress,
+                         const char     *filename)
 {
-  FILE *fp;
-
-  fp = fopen (filename,"r");
-  if (fp == NULL)
-    return;
-
-  while (1)
-    {
-      int items_matched;
-      double time;
-      int string_size=81;
-      char *string;
-      char colon;
-      int i=0;
-
-      items_matched = fscanf (fp, "%lf", &time);
-      if (items_matched<1) break;
-      items_matched = fscanf (fp, "%c", &colon);
-      if (items_matched<1 || colon != ':') break;
-
-      string = malloc(sizeof(char)*string_size);
-      while (1)
-        {
-          if (i>=string_size)
-            {
-              string_size*=2;
-              string = realloc(string, sizeof(char)*string_size);
-            }
-          items_matched = fscanf (fp, "%c", &string[i]);
-          if (items_matched<1 || string[i] == '\n')
-            {
-              string[i] = '\0';
-              break;
-            }
-          i++;
+        FILE *fp;
+
+        fp = fopen (filename, "r");
+        if (fp == NULL)
+                return;
+
+        while (1) {
+                int items_matched;
+                double time;
+                int string_size = 81;
+                char *string;
+                char colon;
+                int i = 0;
+
+                items_matched = fscanf (fp, "%lf", &time);
+                if (items_matched < 1) break;
+                items_matched = fscanf (fp, "%c", &colon);
+                if (items_matched < 1 || colon != ':') break;
+
+                string = malloc (sizeof(char) * string_size);
+                while (1) {
+                        if (i >= string_size) {
+                                string_size *= 2;
+                                string = realloc (string, sizeof(char) * string_size);
+                        }
+                        items_matched = fscanf (fp, "%c", &string[i]);
+                        if (items_matched < 1 || string[i] == '\n') {
+                                string[i] = '\0';
+                                break;
+                        }
+                        i++;
+                }
+                ply_progress_message_t *message = malloc (sizeof(ply_progress_message_t));
+                message->time = time;
+                message->string = string;
+                ply_list_append_data (progress->previous_message_list, message);
         }
-      ply_progress_message_t* message = malloc(sizeof(ply_progress_message_t));
-      message->time = time;
-      message->string = string;
-      ply_list_append_data(progress->previous_message_list, message);
-    }
-  fclose (fp);
+        fclose (fp);
 }
 
 void
-ply_progress_save_cache (ply_progress_t* progress,
-                         const char *filename)
+ply_progress_save_cache (ply_progress_t *progress,
+                         const char     *filename)
 {
-  FILE *fp;
-  ply_list_node_t *node;
-  double cur_time = ply_progress_get_time(progress);
-
-  ply_trace ("saving progress cache to %s", filename);
-
-  fp = fopen (filename,"w");
-  if (fp == NULL)
-    {
-      ply_trace ("failed to save cache: %m");
-      return;
-    }
-
-  node = ply_list_get_first_node (progress->current_message_list);
-
-  while (node)
-    {
-      ply_progress_message_t *message = ply_list_node_get_data (node);
-      double percentage = message->time / cur_time;
-      if (!message->disabled)
-          fprintf (fp, "%.3lf:%s\n", percentage, message->string);
-      node = ply_list_get_next_node (progress->current_message_list, node);
-    }
-  fclose (fp);
+        FILE *fp;
+        ply_list_node_t *node;
+        double cur_time = ply_progress_get_time (progress);
+
+        ply_trace ("saving progress cache to %s", filename);
+
+        fp = fopen (filename, "w");
+        if (fp == NULL) {
+                ply_trace ("failed to save cache: %m");
+                return;
+        }
+
+        node = ply_list_get_first_node (progress->current_message_list);
+
+        while (node) {
+                ply_progress_message_t *message = ply_list_node_get_data (node);
+                double percentage = message->time / cur_time;
+                if (!message->disabled)
+                        fprintf (fp, "%.3lf:%s\n", percentage, message->string);
+                node = ply_list_get_next_node (progress->current_message_list, node);
+        }
+        fclose (fp);
 }
 
 
 double
-ply_progress_get_percentage (ply_progress_t* progress)
+ply_progress_get_percentage (ply_progress_t *progress)
 {
-  double percentage;
-  double cur_time = ply_progress_get_time (progress);
-  
-  if ((progress->last_percentage_time-progress->dead_time)*progress->scalar<0.999)
-    {
-      percentage = progress->last_percentage
-                + (((cur_time - progress->last_percentage_time)*progress->scalar)
-                / (1 - (progress->last_percentage_time-progress->dead_time)*progress->scalar))
-                * (1 - progress->last_percentage);
-      
-      if ((percentage - progress->next_message_percentage)/progress->scalar > 1){
-          percentage = progress->last_percentage
-                     + (cur_time - progress->last_percentage_time) / (DEFAULT_BOOT_DURATION * 10);
-          progress->dead_time += cur_time - progress->last_percentage_time;
+        double percentage;
+        double cur_time = ply_progress_get_time (progress);
+
+        if ((progress->last_percentage_time - progress->dead_time) * progress->scalar < 0.999) {
+                percentage = progress->last_percentage
+                             + (((cur_time - progress->last_percentage_time) * progress->scalar)
+                                / (1 - (progress->last_percentage_time - progress->dead_time) * progress->scalar))
+                             * (1 - progress->last_percentage);
+
+                if ((percentage - progress->next_message_percentage) / progress->scalar > 1) {
+                        percentage = progress->last_percentage
+                                     + (cur_time - progress->last_percentage_time) / (DEFAULT_BOOT_DURATION * 10);
+                        progress->dead_time += cur_time - progress->last_percentage_time;
+                }
+                percentage = CLAMP (percentage, 0.0, 1.0);
+        } else {
+                percentage = 1.0;
         }
-      percentage = CLAMP(percentage, 0.0, 1.0);
-    }
-  else 
-    percentage = 1.0;
-  
-  progress->last_percentage_time = cur_time;
-  progress->last_percentage = percentage;
-  return percentage;
+
+        progress->last_percentage_time = cur_time;
+        progress->last_percentage = percentage;
+        return percentage;
 }
 
 void
-ply_progress_set_percentage (ply_progress_t* progress, double percentage)
+ply_progress_set_percentage (ply_progress_t *progress, double percentage)
 {
-  progress->next_message_percentage = 1;
-  progress->scalar += percentage / (ply_progress_get_time(progress)-progress->dead_time);
-  progress->scalar /= 2;
-  return;
+        progress->next_message_percentage = 1;
+        progress->scalar += percentage / (ply_progress_get_time (progress) - progress->dead_time);
+        progress->scalar /= 2;
+        return;
 }
 
 double
-ply_progress_get_time (ply_progress_t* progress)
+ply_progress_get_time (ply_progress_t *progress)
 {
-  if (progress->paused)
-    {
-      return progress->pause_time - progress->start_time;
-    }
-  return ply_get_timestamp() - progress->start_time;
+        if (progress->paused)
+                return progress->pause_time - progress->start_time;
+        return ply_get_timestamp () - progress->start_time;
 }
 
 void
-ply_progress_pause (ply_progress_t* progress)
+ply_progress_pause (ply_progress_t *progress)
 {
-  progress->pause_time = ply_get_timestamp ();
-  progress->paused = true;
-  return;
+        progress->pause_time = ply_get_timestamp ();
+        progress->paused = true;
+        return;
 }
 
 
 void
-ply_progress_unpause (ply_progress_t* progress)
+ply_progress_unpause (ply_progress_t *progress)
 {
-  progress->start_time += ply_get_timestamp() - progress->pause_time;
-  progress->paused = false;
-  return;
+        progress->start_time += ply_get_timestamp () - progress->pause_time;
+        progress->paused = false;
+        return;
 }
 
 void
-ply_progress_status_update (ply_progress_t* progress,
-                             const char  *status)
+ply_progress_status_update (ply_progress_t *progress,
+                            const char     *status)
 {
-  ply_progress_message_t *message, *message_next;
-  message = ply_progress_message_search(progress->current_message_list, status);
-  if (message)
-    {
-      message->disabled = true;
-    }                                                   /* Remove duplicates as they confuse things*/
-  else
-    {
-      message = ply_progress_message_search(progress->previous_message_list, status);
-      if (message)
-        {
-          message_next = ply_progress_message_search_next(progress->previous_message_list, message->time);
-          if (message_next)
-              progress->next_message_percentage = message_next->time;
-          else
-              progress->next_message_percentage = 1;
-              
-          progress->scalar += message->time / (ply_progress_get_time(progress)-progress->dead_time);
-          progress->scalar /= 2;
+        ply_progress_message_t *message, *message_next;
+
+        message = ply_progress_message_search (progress->current_message_list, status);
+        if (message) {
+                message->disabled = true;
+        }                                               /* Remove duplicates as they confuse things*/
+        else {
+                message = ply_progress_message_search (progress->previous_message_list, status);
+                if (message) {
+                        message_next = ply_progress_message_search_next (progress->previous_message_list, message->time);
+                        if (message_next)
+                                progress->next_message_percentage = message_next->time;
+                        else
+                                progress->next_message_percentage = 1;
+
+                        progress->scalar += message->time / (ply_progress_get_time (progress) - progress->dead_time);
+                        progress->scalar /= 2;
+                }
+                message = malloc (sizeof(ply_progress_message_t));
+                message->time = ply_progress_get_time (progress);
+                message->string = strdup (status);
+                message->disabled = false;
+                ply_list_append_data (progress->current_message_list, message);
         }
-      message = malloc(sizeof(ply_progress_message_t));
-      message->time = ply_progress_get_time (progress);
-      message->string = strdup(status);
-      message->disabled = false;
-      ply_list_append_data(progress->current_message_list, message);
-    }
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
-    
diff --git a/src/libply/ply-progress.h b/src/libply/ply-progress.h
index 434636a..1d2bce8 100644
--- a/src/libply/ply-progress.h
+++ b/src/libply/ply-progress.h
@@ -1,4 +1,4 @@
-/* ply-progress.h - calculats boot progress 
+/* ply-progress.h - calculats boot progress
  *
  * Copyright (C) 2007 Red Hat, Inc.
  *
@@ -28,15 +28,19 @@
 typedef struct _ply_progress ply_progress_t;
 
 ply_progress_t *ply_progress_new (void);
-void ply_progress_free (ply_progress_t* progress);
-void ply_progress_load_cache (ply_progress_t* progress, const char *filename);
-double ply_progress_get_percentage (ply_progress_t* progress);
-void ply_progress_set_percentage (ply_progress_t* progress, double percentage);
-double ply_progress_get_time (ply_progress_t* progress);
-void ply_progress_pause (ply_progress_t* progress);
-void ply_progress_unpause (ply_progress_t* progress);
-void ply_progress_save_cache (ply_progress_t* progress, const char *filename);
-void ply_progress_status_update (ply_progress_t* progress, const char  *status);
+void ply_progress_free (ply_progress_t *progress);
+void ply_progress_load_cache (ply_progress_t *progress,
+                              const char     *filename);
+double ply_progress_get_percentage (ply_progress_t *progress);
+void ply_progress_set_percentage (ply_progress_t *progress,
+                                  double          percentage);
+double ply_progress_get_time (ply_progress_t *progress);
+void ply_progress_pause (ply_progress_t *progress);
+void ply_progress_unpause (ply_progress_t *progress);
+void ply_progress_save_cache (ply_progress_t *progress,
+                              const char     *filename);
+void ply_progress_status_update (ply_progress_t *progress,
+                                 const char     *status);
 
 #endif /* PLY_PROGRESS_H */
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-rectangle.c b/src/libply/ply-rectangle.c
index 8f5203a..a79a21d 100644
--- a/src/libply/ply-rectangle.c
+++ b/src/libply/ply-rectangle.c
@@ -32,180 +32,165 @@ ply_rectangle_contains_point (ply_rectangle_t *rectangle,
                               long             x,
                               long             y)
 {
-  long top_edge;
-  long left_edge;
-  long right_edge;
-  long bottom_edge;
+        long top_edge;
+        long left_edge;
+        long right_edge;
+        long bottom_edge;
 
-  top_edge = rectangle->y;
-  left_edge = rectangle->x;
-  right_edge = rectangle->x + rectangle->width - 1;
-  bottom_edge = rectangle->y + rectangle->height - 1;
+        top_edge = rectangle->y;
+        left_edge = rectangle->x;
+        right_edge = rectangle->x + rectangle->width - 1;
+        bottom_edge = rectangle->y + rectangle->height - 1;
 
-  if (x < left_edge)
-    return false;
+        if (x < left_edge)
+                return false;
 
-  if (y < top_edge)
-    return false;
+        if (y < top_edge)
+                return false;
 
-  if (x > right_edge)
-    return false;
+        if (x > right_edge)
+                return false;
 
-  if (y > bottom_edge)
-    return false;
+        if (y > bottom_edge)
+                return false;
 
-  return true;
+        return true;
 }
 
 bool
 ply_rectangle_is_empty (ply_rectangle_t *rectangle)
 {
-  return rectangle->width == 0 || rectangle->height == 0;
+        return rectangle->width == 0 || rectangle->height == 0;
 }
 
 ply_rectangle_overlap_t
 ply_rectangle_find_overlap (ply_rectangle_t *rectangle1,
                             ply_rectangle_t *rectangle2)
 {
-  enum {H_COLLISION_NONE, H_COLLISION_LEFT, H_COLLISION_RIGHT, H_COLLISION_BOTH, H_COLLISION_CONTAINED, H_COLLISION_EXACT}
+        enum { H_COLLISION_NONE, H_COLLISION_LEFT, H_COLLISION_RIGHT, H_COLLISION_BOTH, H_COLLISION_CONTAINED, H_COLLISION_EXACT }
         h_collision = H_COLLISION_NONE;
-  enum {V_COLLISION_NONE, V_COLLISION_TOP, V_COLLISION_BOTTOM, V_COLLISION_BOTH, V_COLLISION_CONTAINED, V_COLLISION_EXACT}
+        enum { V_COLLISION_NONE, V_COLLISION_TOP, V_COLLISION_BOTTOM, V_COLLISION_BOTH, V_COLLISION_CONTAINED, V_COLLISION_EXACT }
         v_collision = V_COLLISION_NONE;
 
-  if (rectangle2->x >= rectangle1->x && (rectangle2->x + (int)rectangle2->width) <= (rectangle1->x + (int)rectangle1->width))
-    {
-      if (rectangle2->x == rectangle1->x && rectangle2->width == rectangle1->width)
-        h_collision = H_COLLISION_EXACT;
-      else
-        h_collision = H_COLLISION_CONTAINED;
-    }
-  else
-    {                                       /* Remember: x+width points to the first pixel outside the rectangle*/
-      if (rectangle2->x < rectangle1->x &&
-          (rectangle2->x + (int)rectangle2->width) > rectangle1->x)
-        h_collision = H_COLLISION_LEFT;         /* rectangle2 colllided with the left edge of rectangle1 */
+        if (rectangle2->x >= rectangle1->x && (rectangle2->x + (int) rectangle2->width) <= (rectangle1->x + (int) rectangle1->width)) {
+                if (rectangle2->x == rectangle1->x && rectangle2->width == rectangle1->width)
+                        h_collision = H_COLLISION_EXACT;
+                else
+                        h_collision = H_COLLISION_CONTAINED;
+        } else {                            /* Remember: x+width points to the first pixel outside the rectangle*/
+                if (rectangle2->x < rectangle1->x &&
+                    (rectangle2->x + (int) rectangle2->width) > rectangle1->x)
+                        h_collision = H_COLLISION_LEFT; /* rectangle2 colllided with the left edge of rectangle1 */
 
-      if (rectangle2->x < (rectangle1->x + (int)rectangle1->width) &&
-          (rectangle2->x + (int)rectangle2->width) >= (rectangle1->x + (int)rectangle1->width))
-        {                                       /* rectangle2 colllided with the right edge of rectangle1 */
-          if (h_collision == H_COLLISION_LEFT)
-            h_collision = H_COLLISION_BOTH;
-          else
-            h_collision = H_COLLISION_RIGHT;
+                if (rectangle2->x < (rectangle1->x + (int) rectangle1->width) &&
+                    (rectangle2->x + (int) rectangle2->width) >= (rectangle1->x + (int) rectangle1->width)) { /* rectangle2 colllided with the right edge of rectangle1 */
+                        if (h_collision == H_COLLISION_LEFT)
+                                h_collision = H_COLLISION_BOTH;
+                        else
+                                h_collision = H_COLLISION_RIGHT;
+                }
         }
-    }
 
-  if (h_collision != H_COLLISION_NONE)
-    {
-      if (rectangle2->y >= rectangle1->y && (rectangle2->y + (int)rectangle2->height) <= (rectangle1->y + (int)rectangle1->height))
-        {
-          if (rectangle2->y == rectangle1->y && rectangle2->height == rectangle1->height)
-            v_collision = V_COLLISION_EXACT;
-          else
-            v_collision = V_COLLISION_CONTAINED;
+        if (h_collision != H_COLLISION_NONE) {
+                if (rectangle2->y >= rectangle1->y && (rectangle2->y + (int) rectangle2->height) <= (rectangle1->y + (int) rectangle1->height)) {
+                        if (rectangle2->y == rectangle1->y && rectangle2->height == rectangle1->height)
+                                v_collision = V_COLLISION_EXACT;
+                        else
+                                v_collision = V_COLLISION_CONTAINED;
+                } else {
+                        if (rectangle2->y < rectangle1->y &&
+                            (rectangle2->y + (int) rectangle2->height) > rectangle1->y)
+                                v_collision = V_COLLISION_TOP;
+                        if (rectangle2->y < (rectangle1->y + (int) rectangle1->height) &&
+                            (rectangle2->y + (int) rectangle2->height) >= (rectangle1->y + (int) rectangle1->height)) {
+                                if (v_collision == V_COLLISION_TOP)
+                                        v_collision = V_COLLISION_BOTH;
+                                else
+                                        v_collision = V_COLLISION_BOTTOM;
+                        }
+                }
         }
-      else
-        {
-          if (rectangle2->y < rectangle1->y &&
-              (rectangle2->y + (int)rectangle2->height) > rectangle1->y)
-            v_collision = V_COLLISION_TOP;
-          if (rectangle2->y < (rectangle1->y + (int)rectangle1->height) &&
-              (rectangle2->y + (int)rectangle2->height) >= (rectangle1->y + (int)rectangle1->height))
-            {
-              if (v_collision == V_COLLISION_TOP)
-                v_collision = V_COLLISION_BOTH;
-              else
-                v_collision = V_COLLISION_BOTTOM;
-            }
-        }
-    }
 
-  switch (h_collision)
-    {
-      case H_COLLISION_NONE:
-        return PLY_RECTANGLE_OVERLAP_NONE;
-      case H_COLLISION_LEFT:
-        switch (v_collision)
-          {
-            case V_COLLISION_NONE:
-                return PLY_RECTANGLE_OVERLAP_NONE;
-            case V_COLLISION_TOP:
-                return PLY_RECTANGLE_OVERLAP_TOP_AND_LEFT_EDGES;
-            case V_COLLISION_BOTTOM:
-                return PLY_RECTANGLE_OVERLAP_BOTTOM_AND_LEFT_EDGES;
-            case V_COLLISION_BOTH:
-                return PLY_RECTANGLE_OVERLAP_TOP_LEFT_AND_BOTTOM_EDGES;
-            case V_COLLISION_CONTAINED:
-                return PLY_RECTANGLE_OVERLAP_LEFT_EDGE;
-            case V_COLLISION_EXACT:
-                return PLY_RECTANGLE_OVERLAP_EXACT_LEFT_EDGE;
-          }
-      case H_COLLISION_RIGHT:
-        switch (v_collision)
-          {
-            case V_COLLISION_NONE:
-                return PLY_RECTANGLE_OVERLAP_NONE;
-            case V_COLLISION_TOP:
-                return PLY_RECTANGLE_OVERLAP_TOP_AND_RIGHT_EDGES;
-            case V_COLLISION_BOTTOM:
-                return PLY_RECTANGLE_OVERLAP_BOTTOM_AND_RIGHT_EDGES;
-            case V_COLLISION_BOTH:
-                return PLY_RECTANGLE_OVERLAP_TOP_RIGHT_AND_BOTTOM_EDGES;
-            case V_COLLISION_CONTAINED:
-                return PLY_RECTANGLE_OVERLAP_RIGHT_EDGE;
-            case V_COLLISION_EXACT:
-                return PLY_RECTANGLE_OVERLAP_EXACT_RIGHT_EDGE;
-          }
-      case H_COLLISION_BOTH:
-        switch (v_collision)
-          {
-            case V_COLLISION_NONE:
-                return PLY_RECTANGLE_OVERLAP_NONE;
-            case V_COLLISION_TOP:
-                return PLY_RECTANGLE_OVERLAP_TOP_AND_SIDE_EDGES;
-            case V_COLLISION_BOTTOM:
-                return PLY_RECTANGLE_OVERLAP_BOTTOM_AND_SIDE_EDGES;
-            case V_COLLISION_BOTH:
-                return PLY_RECTANGLE_OVERLAP_ALL_EDGES;
-            case V_COLLISION_CONTAINED:
-                return PLY_RECTANGLE_OVERLAP_SIDE_EDGES;
-            case V_COLLISION_EXACT:
-                return PLY_RECTANGLE_OVERLAP_ALL_EDGES;
-          }
-      case H_COLLISION_CONTAINED:
-        switch (v_collision)
-          {
-            case V_COLLISION_NONE:
-                return PLY_RECTANGLE_OVERLAP_NONE;
-            case V_COLLISION_TOP:
-                return PLY_RECTANGLE_OVERLAP_TOP_EDGE;
-            case V_COLLISION_BOTTOM:
-                return PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE;
-            case V_COLLISION_BOTH:
-                return PLY_RECTANGLE_OVERLAP_TOP_AND_BOTTOM_EDGES;
-            case V_COLLISION_CONTAINED:
-                return PLY_RECTANGLE_OVERLAP_NO_EDGES;
-            case V_COLLISION_EXACT:
-                return PLY_RECTANGLE_OVERLAP_NO_EDGES;
-          }
-      case H_COLLISION_EXACT:
-        switch (v_collision)
-          {
-            case V_COLLISION_NONE:
+        switch (h_collision) {
+        case H_COLLISION_NONE:
                 return PLY_RECTANGLE_OVERLAP_NONE;
-            case V_COLLISION_TOP:
-                return PLY_RECTANGLE_OVERLAP_EXACT_TOP_EDGE;
-            case V_COLLISION_BOTTOM:
-                return PLY_RECTANGLE_OVERLAP_EXACT_BOTTOM_EDGE;
-            case V_COLLISION_BOTH:
-                return PLY_RECTANGLE_OVERLAP_ALL_EDGES;
-            case V_COLLISION_CONTAINED:
-                return PLY_RECTANGLE_OVERLAP_NO_EDGES;
-            case V_COLLISION_EXACT:
-                return PLY_RECTANGLE_OVERLAP_NO_EDGES;
-          }
-    }
-  return PLY_RECTANGLE_OVERLAP_NONE;
+        case H_COLLISION_LEFT:
+                switch (v_collision) {
+                case V_COLLISION_NONE:
+                        return PLY_RECTANGLE_OVERLAP_NONE;
+                case V_COLLISION_TOP:
+                        return PLY_RECTANGLE_OVERLAP_TOP_AND_LEFT_EDGES;
+                case V_COLLISION_BOTTOM:
+                        return PLY_RECTANGLE_OVERLAP_BOTTOM_AND_LEFT_EDGES;
+                case V_COLLISION_BOTH:
+                        return PLY_RECTANGLE_OVERLAP_TOP_LEFT_AND_BOTTOM_EDGES;
+                case V_COLLISION_CONTAINED:
+                        return PLY_RECTANGLE_OVERLAP_LEFT_EDGE;
+                case V_COLLISION_EXACT:
+                        return PLY_RECTANGLE_OVERLAP_EXACT_LEFT_EDGE;
+                }
+        case H_COLLISION_RIGHT:
+                switch (v_collision) {
+                case V_COLLISION_NONE:
+                        return PLY_RECTANGLE_OVERLAP_NONE;
+                case V_COLLISION_TOP:
+                        return PLY_RECTANGLE_OVERLAP_TOP_AND_RIGHT_EDGES;
+                case V_COLLISION_BOTTOM:
+                        return PLY_RECTANGLE_OVERLAP_BOTTOM_AND_RIGHT_EDGES;
+                case V_COLLISION_BOTH:
+                        return PLY_RECTANGLE_OVERLAP_TOP_RIGHT_AND_BOTTOM_EDGES;
+                case V_COLLISION_CONTAINED:
+                        return PLY_RECTANGLE_OVERLAP_RIGHT_EDGE;
+                case V_COLLISION_EXACT:
+                        return PLY_RECTANGLE_OVERLAP_EXACT_RIGHT_EDGE;
+                }
+        case H_COLLISION_BOTH:
+                switch (v_collision) {
+                case V_COLLISION_NONE:
+                        return PLY_RECTANGLE_OVERLAP_NONE;
+                case V_COLLISION_TOP:
+                        return PLY_RECTANGLE_OVERLAP_TOP_AND_SIDE_EDGES;
+                case V_COLLISION_BOTTOM:
+                        return PLY_RECTANGLE_OVERLAP_BOTTOM_AND_SIDE_EDGES;
+                case V_COLLISION_BOTH:
+                        return PLY_RECTANGLE_OVERLAP_ALL_EDGES;
+                case V_COLLISION_CONTAINED:
+                        return PLY_RECTANGLE_OVERLAP_SIDE_EDGES;
+                case V_COLLISION_EXACT:
+                        return PLY_RECTANGLE_OVERLAP_ALL_EDGES;
+                }
+        case H_COLLISION_CONTAINED:
+                switch (v_collision) {
+                case V_COLLISION_NONE:
+                        return PLY_RECTANGLE_OVERLAP_NONE;
+                case V_COLLISION_TOP:
+                        return PLY_RECTANGLE_OVERLAP_TOP_EDGE;
+                case V_COLLISION_BOTTOM:
+                        return PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE;
+                case V_COLLISION_BOTH:
+                        return PLY_RECTANGLE_OVERLAP_TOP_AND_BOTTOM_EDGES;
+                case V_COLLISION_CONTAINED:
+                        return PLY_RECTANGLE_OVERLAP_NO_EDGES;
+                case V_COLLISION_EXACT:
+                        return PLY_RECTANGLE_OVERLAP_NO_EDGES;
+                }
+        case H_COLLISION_EXACT:
+                switch (v_collision) {
+                case V_COLLISION_NONE:
+                        return PLY_RECTANGLE_OVERLAP_NONE;
+                case V_COLLISION_TOP:
+                        return PLY_RECTANGLE_OVERLAP_EXACT_TOP_EDGE;
+                case V_COLLISION_BOTTOM:
+                        return PLY_RECTANGLE_OVERLAP_EXACT_BOTTOM_EDGE;
+                case V_COLLISION_BOTH:
+                        return PLY_RECTANGLE_OVERLAP_ALL_EDGES;
+                case V_COLLISION_CONTAINED:
+                        return PLY_RECTANGLE_OVERLAP_NO_EDGES;
+                case V_COLLISION_EXACT:
+                        return PLY_RECTANGLE_OVERLAP_NO_EDGES;
+                }
+        }
+        return PLY_RECTANGLE_OVERLAP_NONE;
 }
 
 void
@@ -213,65 +198,61 @@ ply_rectangle_intersect (ply_rectangle_t *rectangle1,
                          ply_rectangle_t *rectangle2,
                          ply_rectangle_t *result)
 {
+        long rectangle1_top_edge;
+        long rectangle1_left_edge;
+        long rectangle1_right_edge;
+        long rectangle1_bottom_edge;
+        long rectangle2_top_edge;
+        long rectangle2_left_edge;
+        long rectangle2_right_edge;
+        long rectangle2_bottom_edge;
+        long result_top_edge;
+        long result_left_edge;
+        long result_right_edge;
+        long result_bottom_edge;
 
-  long rectangle1_top_edge;
-  long rectangle1_left_edge;
-  long rectangle1_right_edge;
-  long rectangle1_bottom_edge;
-  long rectangle2_top_edge;
-  long rectangle2_left_edge;
-  long rectangle2_right_edge;
-  long rectangle2_bottom_edge;
-  long result_top_edge;
-  long result_left_edge;
-  long result_right_edge;
-  long result_bottom_edge;
-
-  if (ply_rectangle_is_empty (rectangle1))
-    {
-      *result = *rectangle1;
-      return;
-    }
+        if (ply_rectangle_is_empty (rectangle1)) {
+                *result = *rectangle1;
+                return;
+        }
 
-  if (ply_rectangle_is_empty (rectangle2))
-    {
-      *result = *rectangle2;
-      return;
-    }
+        if (ply_rectangle_is_empty (rectangle2)) {
+                *result = *rectangle2;
+                return;
+        }
 
-  rectangle1_top_edge = rectangle1->y;
-  rectangle1_left_edge = rectangle1->x;
-  rectangle1_right_edge = rectangle1->x + rectangle1->width - 1;
-  rectangle1_bottom_edge = rectangle1->y + rectangle1->height - 1;
+        rectangle1_top_edge = rectangle1->y;
+        rectangle1_left_edge = rectangle1->x;
+        rectangle1_right_edge = rectangle1->x + rectangle1->width - 1;
+        rectangle1_bottom_edge = rectangle1->y + rectangle1->height - 1;
 
-  rectangle2_top_edge = rectangle2->y;
-  rectangle2_left_edge = rectangle2->x;
-  rectangle2_right_edge = rectangle2->x + rectangle2->width - 1;
-  rectangle2_bottom_edge = rectangle2->y + rectangle2->height - 1;
+        rectangle2_top_edge = rectangle2->y;
+        rectangle2_left_edge = rectangle2->x;
+        rectangle2_right_edge = rectangle2->x + rectangle2->width - 1;
+        rectangle2_bottom_edge = rectangle2->y + rectangle2->height - 1;
 
-  result_top_edge = MAX (rectangle1_top_edge, rectangle2_top_edge);
-  result_left_edge = MAX (rectangle1_left_edge, rectangle2_left_edge);
-  result_right_edge = MIN (rectangle1_right_edge, rectangle2_right_edge);
-  result_bottom_edge = MIN (rectangle1_bottom_edge, rectangle2_bottom_edge);
+        result_top_edge = MAX (rectangle1_top_edge, rectangle2_top_edge);
+        result_left_edge = MAX (rectangle1_left_edge, rectangle2_left_edge);
+        result_right_edge = MIN (rectangle1_right_edge, rectangle2_right_edge);
+        result_bottom_edge = MIN (rectangle1_bottom_edge, rectangle2_bottom_edge);
 
-  result->x = result_left_edge;
-  result->y = result_top_edge;
+        result->x = result_left_edge;
+        result->y = result_top_edge;
 
-  if (result_right_edge >= result_left_edge)
-    result->width = result_right_edge - result_left_edge + 1;
-  else
-    result->width = 0;
+        if (result_right_edge >= result_left_edge)
+                result->width = result_right_edge - result_left_edge + 1;
+        else
+                result->width = 0;
 
-  if (result_bottom_edge >= result_top_edge)
-    result->height = result_bottom_edge - result_top_edge + 1;
-  else
-    result->height = 0;
+        if (result_bottom_edge >= result_top_edge)
+                result->height = result_bottom_edge - result_top_edge + 1;
+        else
+                result->height = 0;
 
-  if (ply_rectangle_is_empty (result))
-    {
-      result->width = 0;
-      result->height = 0;
-    }
+        if (ply_rectangle_is_empty (result)) {
+                result->width = 0;
+                result->height = 0;
+        }
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-rectangle.h b/src/libply/ply-rectangle.h
index 85ee711..d7504da 100644
--- a/src/libply/ply-rectangle.h
+++ b/src/libply/ply-rectangle.h
@@ -31,64 +31,63 @@ typedef struct _ply_rectangle ply_rectangle_t;
 
 struct _ply_rectangle
 {
-  long x;
-  long y;
-  unsigned long width;
-  unsigned long height;
+        long          x;
+        long          y;
+        unsigned long width;
+        unsigned long height;
 };
 
 typedef enum
 {
-  PLY_RECTANGLE_OVERLAP_NONE                       = 0,
-  PLY_RECTANGLE_OVERLAP_TOP_EDGE                   = 1 << 0,
-  PLY_RECTANGLE_OVERLAP_LEFT_EDGE                  = 1 << 1,
-  PLY_RECTANGLE_OVERLAP_RIGHT_EDGE                 = 1 << 2,
-  PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE                = 1 << 3,
-  PLY_RECTANGLE_OVERLAP_TOP_AND_LEFT_EDGES         =
-      PLY_RECTANGLE_OVERLAP_TOP_EDGE |
-      PLY_RECTANGLE_OVERLAP_LEFT_EDGE,
-  PLY_RECTANGLE_OVERLAP_TOP_AND_RIGHT_EDGES        =
-      PLY_RECTANGLE_OVERLAP_TOP_EDGE |
-      PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
-  PLY_RECTANGLE_OVERLAP_TOP_AND_SIDE_EDGES         =
-      PLY_RECTANGLE_OVERLAP_TOP_EDGE  |
-      PLY_RECTANGLE_OVERLAP_LEFT_EDGE |
-      PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
-  PLY_RECTANGLE_OVERLAP_BOTTOM_AND_LEFT_EDGES      =
-      PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE |
-      PLY_RECTANGLE_OVERLAP_LEFT_EDGE,
-  PLY_RECTANGLE_OVERLAP_BOTTOM_AND_RIGHT_EDGES     =
-      PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE |
-      PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
-  PLY_RECTANGLE_OVERLAP_BOTTOM_AND_SIDE_EDGES      =
-      PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE |
-      PLY_RECTANGLE_OVERLAP_LEFT_EDGE   |
-      PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
-  PLY_RECTANGLE_OVERLAP_SIDE_EDGES                 =
-      PLY_RECTANGLE_OVERLAP_LEFT_EDGE   |
-      PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
-  PLY_RECTANGLE_OVERLAP_TOP_AND_BOTTOM_EDGES       =
-      PLY_RECTANGLE_OVERLAP_TOP_EDGE    |
-      PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE,
-  PLY_RECTANGLE_OVERLAP_TOP_LEFT_AND_BOTTOM_EDGES  =
-      PLY_RECTANGLE_OVERLAP_TOP_EDGE    |
-      PLY_RECTANGLE_OVERLAP_LEFT_EDGE   |
-      PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE,
-  PLY_RECTANGLE_OVERLAP_TOP_RIGHT_AND_BOTTOM_EDGES =
-      PLY_RECTANGLE_OVERLAP_TOP_EDGE    |
-      PLY_RECTANGLE_OVERLAP_RIGHT_EDGE  |
-      PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE,
-  PLY_RECTANGLE_OVERLAP_ALL_EDGES                  =
-      PLY_RECTANGLE_OVERLAP_TOP_EDGE    |
-      PLY_RECTANGLE_OVERLAP_LEFT_EDGE   |
-      PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE |
-      PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
-  PLY_RECTANGLE_OVERLAP_NO_EDGES                    = 1 << 4,
-  PLY_RECTANGLE_OVERLAP_EXACT_TOP_EDGE,
-  PLY_RECTANGLE_OVERLAP_EXACT_LEFT_EDGE,
-  PLY_RECTANGLE_OVERLAP_EXACT_RIGHT_EDGE,
-  PLY_RECTANGLE_OVERLAP_EXACT_BOTTOM_EDGE,
-  
+        PLY_RECTANGLE_OVERLAP_NONE = 0,
+        PLY_RECTANGLE_OVERLAP_TOP_EDGE = 1 << 0,
+                PLY_RECTANGLE_OVERLAP_LEFT_EDGE = 1 << 1,
+                PLY_RECTANGLE_OVERLAP_RIGHT_EDGE = 1 << 2,
+                PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE = 1 << 3,
+                PLY_RECTANGLE_OVERLAP_TOP_AND_LEFT_EDGES =
+                PLY_RECTANGLE_OVERLAP_TOP_EDGE |
+                PLY_RECTANGLE_OVERLAP_LEFT_EDGE,
+                PLY_RECTANGLE_OVERLAP_TOP_AND_RIGHT_EDGES =
+                PLY_RECTANGLE_OVERLAP_TOP_EDGE |
+                PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
+                PLY_RECTANGLE_OVERLAP_TOP_AND_SIDE_EDGES =
+                PLY_RECTANGLE_OVERLAP_TOP_EDGE |
+                PLY_RECTANGLE_OVERLAP_LEFT_EDGE |
+                PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
+                PLY_RECTANGLE_OVERLAP_BOTTOM_AND_LEFT_EDGES =
+                PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE |
+                PLY_RECTANGLE_OVERLAP_LEFT_EDGE,
+                PLY_RECTANGLE_OVERLAP_BOTTOM_AND_RIGHT_EDGES =
+                PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE |
+                PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
+                PLY_RECTANGLE_OVERLAP_BOTTOM_AND_SIDE_EDGES =
+                PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE |
+                PLY_RECTANGLE_OVERLAP_LEFT_EDGE |
+                PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
+                PLY_RECTANGLE_OVERLAP_SIDE_EDGES =
+                PLY_RECTANGLE_OVERLAP_LEFT_EDGE |
+                PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
+                PLY_RECTANGLE_OVERLAP_TOP_AND_BOTTOM_EDGES =
+                PLY_RECTANGLE_OVERLAP_TOP_EDGE |
+                PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE,
+                PLY_RECTANGLE_OVERLAP_TOP_LEFT_AND_BOTTOM_EDGES =
+                PLY_RECTANGLE_OVERLAP_TOP_EDGE |
+                PLY_RECTANGLE_OVERLAP_LEFT_EDGE |
+                PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE,
+                PLY_RECTANGLE_OVERLAP_TOP_RIGHT_AND_BOTTOM_EDGES =
+                PLY_RECTANGLE_OVERLAP_TOP_EDGE |
+                PLY_RECTANGLE_OVERLAP_RIGHT_EDGE |
+                PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE,
+                PLY_RECTANGLE_OVERLAP_ALL_EDGES =
+                PLY_RECTANGLE_OVERLAP_TOP_EDGE |
+                PLY_RECTANGLE_OVERLAP_LEFT_EDGE |
+                PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE |
+                PLY_RECTANGLE_OVERLAP_RIGHT_EDGE,
+                PLY_RECTANGLE_OVERLAP_NO_EDGES = 1 << 4,
+                PLY_RECTANGLE_OVERLAP_EXACT_TOP_EDGE,
+                PLY_RECTANGLE_OVERLAP_EXACT_LEFT_EDGE,
+                PLY_RECTANGLE_OVERLAP_EXACT_RIGHT_EDGE,
+                PLY_RECTANGLE_OVERLAP_EXACT_BOTTOM_EDGE,
 } ply_rectangle_overlap_t;
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
diff --git a/src/libply/ply-region.c b/src/libply/ply-region.c
index 92d3574..6756fe7 100644
--- a/src/libply/ply-region.c
+++ b/src/libply/ply-region.c
@@ -34,61 +34,59 @@
 
 struct _ply_region
 {
-  ply_list_t *rectangle_list;
+        ply_list_t *rectangle_list;
 };
 
 ply_region_t *
 ply_region_new (void)
 {
-  ply_region_t *region;
+        ply_region_t *region;
 
-  region = calloc (1, sizeof (ply_region_t));
+        region = calloc (1, sizeof(ply_region_t));
 
-  region->rectangle_list = ply_list_new ();
+        region->rectangle_list = ply_list_new ();
 
-  return region;
+        return region;
 }
 
 void
 ply_region_clear (ply_region_t *region)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (region->rectangle_list);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_rectangle_t *rectangle;
+        node = ply_list_get_first_node (region->rectangle_list);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_rectangle_t *rectangle;
 
-      rectangle = (ply_rectangle_t *) ply_list_node_get_data (node);
+                rectangle = (ply_rectangle_t *) ply_list_node_get_data (node);
 
-      next_node = ply_list_get_next_node (region->rectangle_list, node);
+                next_node = ply_list_get_next_node (region->rectangle_list, node);
 
-      free (rectangle);
-      ply_list_remove_node (region->rectangle_list, node);
+                free (rectangle);
+                ply_list_remove_node (region->rectangle_list, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 void
 ply_region_free (ply_region_t *region)
 {
-
-  ply_region_clear (region);
-  ply_list_free (region->rectangle_list);
-  free (region);
+        ply_region_clear (region);
+        ply_list_free (region->rectangle_list);
+        free (region);
 }
 
 static ply_rectangle_t *
 copy_rectangle (ply_rectangle_t *rectangle)
 {
-  ply_rectangle_t *new_rectangle;
+        ply_rectangle_t *new_rectangle;
 
-  new_rectangle = malloc (sizeof (*rectangle));
-  *new_rectangle = *rectangle;
+        new_rectangle = malloc (sizeof(*rectangle));
+        *new_rectangle = *rectangle;
 
-  return new_rectangle;
+        return new_rectangle;
 }
 
 static void
@@ -96,375 +94,370 @@ merge_rectangle_with_sub_list (ply_region_t    *region,
                                ply_rectangle_t *new_area,
                                ply_list_node_t *node)
 {
-
-  if (ply_rectangle_is_empty (new_area))
-    {
-      free (new_area);
-      return;
-    }
-
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_rectangle_t *old_area;
-      ply_rectangle_overlap_t overlap;
-
-      old_area = (ply_rectangle_t *) ply_list_node_get_data (node);
-
-      next_node = ply_list_get_next_node (region->rectangle_list, node);
-
-      if (ply_rectangle_is_empty (new_area))
-        overlap = PLY_RECTANGLE_OVERLAP_NO_EDGES;
-      else if (ply_rectangle_is_empty (old_area))
-        overlap = PLY_RECTANGLE_OVERLAP_ALL_EDGES;
-      else
-        overlap = ply_rectangle_find_overlap (old_area, new_area);
-
-      switch (overlap)
-        {
-          /* NNNN      The new rectangle and node rectangle don't touch,
-           * NNNN OOOO so let's move on to the next one.
-           *      OOOO
-           */
-          case PLY_RECTANGLE_OVERLAP_NONE:
-          break;
-
-          /* NNNNN   We need to split the new rectangle into
-           * NNOOOOO two rectangles:  The top row of Ns and
-           * NNOOOOO the left side of Ns.
-           *   OOOOO
-           */
-          case PLY_RECTANGLE_OVERLAP_TOP_AND_LEFT_EDGES:
-            {
-              ply_rectangle_t *rectangle;
-
-              rectangle = copy_rectangle (new_area);
-              rectangle->y = old_area->y;
-              rectangle->width = old_area->x - new_area->x;
-              rectangle->height = (new_area->y + new_area->height) - old_area->y;
-
-              merge_rectangle_with_sub_list (region, rectangle, next_node);
-
-              new_area->height = old_area->y - new_area->y;
-            }
-          break;
-
-          /*   NNNNN We need to split the new rectangle into
-           * OOOOONN two rectangles:  The top row of Ns and
-           * OOOOONN the right side of Ns.
-           * OOOOO
-           */
-          case PLY_RECTANGLE_OVERLAP_TOP_AND_RIGHT_EDGES:
-            {
-              ply_rectangle_t *rectangle;
-
-              rectangle = copy_rectangle (new_area);
-              rectangle->x = old_area->x + old_area->width;
-              rectangle->y = old_area->y;
-              rectangle->width = (new_area->x + new_area->width) - (old_area->x + old_area->width);
-              rectangle->height = (new_area->y + new_area->height) - old_area->y;
-
-              merge_rectangle_with_sub_list (region, rectangle, next_node);
-
-              new_area->height = old_area->y - new_area->y;
-            }
-          break;
-
-          /* NNNNNNN We need to trim out the part of
-           * NOOOOON old rectangle that overlaps the new
-           * NOOOOON rectangle by shrinking and moving it
-           *  OOOOO  and then we need to add the new rectangle.
-           */
-          case PLY_RECTANGLE_OVERLAP_TOP_AND_SIDE_EDGES:
-            {
-              old_area->height = (old_area->y + old_area->height)
-                                 - (new_area->y + new_area->height);
-              old_area->y = new_area->y + new_area->height;
-            }
-          break;
-
-          /*   NNN  We only care about the top row of Ns,
-           *  ONNNO everything below that is already handled by
-           *  ONNNO the old rectangle.
-           *  OOOOO
-           */
-          case PLY_RECTANGLE_OVERLAP_TOP_EDGE:
-            new_area->height = old_area->y - new_area->y;
-          break;
-
-          /*   OOOOO We need to split the new rectangle into
-           * NNOOOOO two rectangles:  The left side of Ns and
-           * NNOOOOO the bottom row of Ns.
-           * NNOOOOO
-           * NNNNN
-           */
-          case PLY_RECTANGLE_OVERLAP_BOTTOM_AND_LEFT_EDGES:
-            {
-              ply_rectangle_t *rectangle;
-
-              rectangle = copy_rectangle (new_area);
-
-              rectangle->width = old_area->x - new_area->x;
-              rectangle->height = (old_area->y + old_area->height) - new_area->y;
-
-              merge_rectangle_with_sub_list (region, rectangle, next_node);
-
-              new_area->height = (new_area->y + new_area->height) - (old_area->y + old_area->height);
-              new_area->y = old_area->y + old_area->height;
-            }
-          break;
-
-          /*   OOOOO   We need to split the new rectangle into
-           *   OOOOONN two rectangles:  The right side of Ns and
-           *   OOOOONN the bottom row of Ns.
-           *   OOOOONN
-           *     NNNNN
-           */
-          case PLY_RECTANGLE_OVERLAP_BOTTOM_AND_RIGHT_EDGES:
-            {
-              ply_rectangle_t *rectangle;
-
-              rectangle = copy_rectangle (new_area);
-
-              rectangle->x = old_area->x + old_area->width;
-              rectangle->width = (new_area->x + new_area->width) - (old_area->x + old_area->width);
-              rectangle->height = (old_area->y + old_area->height) - new_area->y;
-
-              merge_rectangle_with_sub_list (region, rectangle, next_node);
-
-              new_area->height = (new_area->y + new_area->height) - (old_area->y + old_area->height);
-              new_area->y = old_area->y + old_area->height;
-            }
-          break;
-
-          /*  OOOOO  We need to trim out the part of
-           * NOOOOON old rectangle that overlaps the new
-           * NOOOOON rectangle by shrinking it
-           * NNNNNNN and then we need to add the new rectangle.
-           */
-          case PLY_RECTANGLE_OVERLAP_BOTTOM_AND_SIDE_EDGES:
-            {
-              old_area->height = new_area->y - old_area->y;
-            }
-          break;
-
-          /*  OOOOO We only care about the bottom row of Ns,
-           *  ONNNO everything above that is already handled by
-           *  ONNNO the old rectangle.
-           *   NNN
-           */
-          case PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE:
-            {
-              new_area->height = (new_area->y + new_area->height) - (old_area->y + old_area->height);
-              new_area->y = old_area->y + old_area->height;
-            }
-          break;
-
-          /*  NNNN   We need to trim out the part of
-           *  NNNNO  old rectangle that overlaps the new
-           *  NNNNO  rectangle by shrinking it and moving it
-           *  NNNN   and then we need to add the new rectangle.
-           */
-          case PLY_RECTANGLE_OVERLAP_TOP_LEFT_AND_BOTTOM_EDGES:
-            {
-              old_area->width = (old_area->x + old_area->width)
-                                 - (new_area->x + new_area->width);
-              old_area->x = new_area->x + new_area->width;
-            }
-          break;
-
-          /*  NNNN  We need to trim out the part of
-           * ONNNN  old rectangle that overlaps the new
-           * ONNNN  rectangle by shrinking it and then we
-           *  NNNN  need to add the new rectangle.
-           */
-          case PLY_RECTANGLE_OVERLAP_TOP_RIGHT_AND_BOTTOM_EDGES:
-            old_area->width = new_area->x - old_area->x;
-          break;
-
-          /* NNNNNNN The old rectangle is completely inside the new rectangle
-           * NOOOOON so replace the old rectangle with the new rectangle.
-           * NOOOOON
-           * NNNNNNN
-           */
-          case PLY_RECTANGLE_OVERLAP_ALL_EDGES:
-            merge_rectangle_with_sub_list (region, new_area, next_node);
-            free (old_area);
-            ply_list_remove_node (region->rectangle_list, node);
-          return;
-
-          /*  NNN  We need to split the new rectangle into
-           * ONNNO two rectangles: the top and bottom row of Ns
-           * ONNNO
-           *  NNN
-           */
-          case PLY_RECTANGLE_OVERLAP_TOP_AND_BOTTOM_EDGES:
-            {
-              ply_rectangle_t *rectangle;
-
-              rectangle = copy_rectangle (new_area);
-              rectangle->y = old_area->y + old_area->height;
-              rectangle->width = new_area->width;
-              rectangle->height = (new_area->y + new_area->height) - (old_area->y + old_area->height);
-              merge_rectangle_with_sub_list (region, rectangle, next_node);
-
-              new_area->height = old_area->y - new_area->y;
-            }
-          break;
-
-          /*  OOOOO We only care about the side row of Ns,
-           * NNNNOO everything rigth of that is already handled by
-           * NNNNOO the old rectangle.
-           *  OOOOO
-           */
-          case PLY_RECTANGLE_OVERLAP_LEFT_EDGE:
-            new_area->width = old_area->x - new_area->x;
-          break;
-
-          /* OOOOO  We only care about the side row of Ns,
-           * NNNNNN everything left of that is already handled by
-           * NNNNNN the old rectangle.
-           * OOOOO
-           */
-          case PLY_RECTANGLE_OVERLAP_RIGHT_EDGE:
-            {
-              long temp = new_area->x;
-              new_area->x = old_area->x + old_area->width;
-              new_area->width = (temp + new_area->width) - (old_area->x + old_area->width);
-            }
-          break;
-
-          /*  OOOOO  We need to split the new rectangle into
-           * NNNNNNN two rectangles: the side columns of Ns
-           * NNNNNNN
-           *  OOOOO
-           */
-          case PLY_RECTANGLE_OVERLAP_SIDE_EDGES:
-            {
-              ply_rectangle_t *rectangle;
-
-              rectangle = copy_rectangle (new_area);
-
-              rectangle->x = old_area->x + old_area->width;
-              rectangle->width = (new_area->x + new_area->width) - (old_area->x + old_area->width);
-
-              merge_rectangle_with_sub_list (region, rectangle, next_node);
-
-              new_area->width = old_area->x - new_area->x;
-            }
-          break;
-
-          /* OOOOOOO The new rectangle is completely inside an old rectangle
-           * ONNNNNO so return early without adding the new rectangle.
-           * ONNNNNO
-           * OOOOOOO
-           */
-          case PLY_RECTANGLE_OVERLAP_NO_EDGES:
-            free (new_area);
-          return;
-
-          /*  NNNNN We expand the old rectangle up and throw away the new.
-           *  NNNNN We must merge it because the new region may have overlapped
-           *  NNNNN something further down the list.
-           *  OOOOO
-           */
-          case PLY_RECTANGLE_OVERLAP_EXACT_TOP_EDGE:
-            {
-              old_area->height = (old_area->y + old_area->height) - new_area->y;
-              old_area->y = new_area->y;
-              free (new_area);
-              merge_rectangle_with_sub_list (region, old_area, next_node);
-              ply_list_remove_node (region->rectangle_list, node);
-            }
-          return;
-
-          /*  OOOOO We expand the old rectangle down and throw away the new.
-           *  NNNNN We must merge it because the new region may have overlapped
-           *  NNNNN something further down the list.
-           *  NNNNN
-           */
-          case PLY_RECTANGLE_OVERLAP_EXACT_BOTTOM_EDGE:
-            {
-              old_area->height = (new_area->y + new_area->height) - old_area->y;
-              free (new_area);
-              merge_rectangle_with_sub_list (region, old_area, next_node);
-              ply_list_remove_node (region->rectangle_list, node);
-            }
-          return;
-
-          /*  NNNNNO We expand the old rectangle left and throw away the new.
-           *  NNNNNO We must merge it because the new region may have overlapped
-           *  NNNNNO something further down the list.
-           */
-          case PLY_RECTANGLE_OVERLAP_EXACT_LEFT_EDGE:
-            {
-              old_area->width = (old_area->x + old_area->width) - new_area->x;
-              old_area->x = new_area->x;
-              free (new_area);
-              merge_rectangle_with_sub_list (region, old_area, next_node);
-              ply_list_remove_node (region->rectangle_list, node);
-            }
-          return;
-
-          /*  ONNNNN We expand the old rectangle right and throw away the new.
-           *  ONNNNN We must merge it because the new region may have overlapped
-           *  ONNNNN something further down the list.
-           */
-          case PLY_RECTANGLE_OVERLAP_EXACT_RIGHT_EDGE:
-            {
-              old_area->width = (new_area->x + new_area->width) - old_area->x;
-              free (new_area);
-              merge_rectangle_with_sub_list (region, old_area, next_node);
-              ply_list_remove_node (region->rectangle_list, node);
-            }
-          return;
-
-
+        if (ply_rectangle_is_empty (new_area)) {
+                free (new_area);
+                return;
         }
 
-      node = ply_list_get_next_node (region->rectangle_list, node);
-    }
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_rectangle_t *old_area;
+                ply_rectangle_overlap_t overlap;
+
+                old_area = (ply_rectangle_t *) ply_list_node_get_data (node);
+
+                next_node = ply_list_get_next_node (region->rectangle_list, node);
+
+                if (ply_rectangle_is_empty (new_area))
+                        overlap = PLY_RECTANGLE_OVERLAP_NO_EDGES;
+                else if (ply_rectangle_is_empty (old_area))
+                        overlap = PLY_RECTANGLE_OVERLAP_ALL_EDGES;
+                else
+                        overlap = ply_rectangle_find_overlap (old_area, new_area);
+
+                switch (overlap) {
+                /* NNNN      The new rectangle and node rectangle don't touch,
+                 * NNNN OOOO so let's move on to the next one.
+                 *      OOOO
+                 */
+                case PLY_RECTANGLE_OVERLAP_NONE:
+                        break;
+
+                /* NNNNN   We need to split the new rectangle into
+                 * NNOOOOO two rectangles:  The top row of Ns and
+                 * NNOOOOO the left side of Ns.
+                 *   OOOOO
+                 */
+                case PLY_RECTANGLE_OVERLAP_TOP_AND_LEFT_EDGES:
+                {
+                        ply_rectangle_t *rectangle;
+
+                        rectangle = copy_rectangle (new_area);
+                        rectangle->y = old_area->y;
+                        rectangle->width = old_area->x - new_area->x;
+                        rectangle->height = (new_area->y + new_area->height) - old_area->y;
+
+                        merge_rectangle_with_sub_list (region, rectangle, next_node);
+
+                        new_area->height = old_area->y - new_area->y;
+                }
+                break;
+
+                /*   NNNNN We need to split the new rectangle into
+                 * OOOOONN two rectangles:  The top row of Ns and
+                 * OOOOONN the right side of Ns.
+                 * OOOOO
+                 */
+                case PLY_RECTANGLE_OVERLAP_TOP_AND_RIGHT_EDGES:
+                {
+                        ply_rectangle_t *rectangle;
+
+                        rectangle = copy_rectangle (new_area);
+                        rectangle->x = old_area->x + old_area->width;
+                        rectangle->y = old_area->y;
+                        rectangle->width = (new_area->x + new_area->width) - (old_area->x + old_area->width);
+                        rectangle->height = (new_area->y + new_area->height) - old_area->y;
+
+                        merge_rectangle_with_sub_list (region, rectangle, next_node);
+
+                        new_area->height = old_area->y - new_area->y;
+                }
+                break;
+
+                /* NNNNNNN We need to trim out the part of
+                 * NOOOOON old rectangle that overlaps the new
+                 * NOOOOON rectangle by shrinking and moving it
+                 *  OOOOO  and then we need to add the new rectangle.
+                 */
+                case PLY_RECTANGLE_OVERLAP_TOP_AND_SIDE_EDGES:
+                {
+                        old_area->height = (old_area->y + old_area->height)
+                                           - (new_area->y + new_area->height);
+                        old_area->y = new_area->y + new_area->height;
+                }
+                break;
+
+                /*   NNN  We only care about the top row of Ns,
+                 *  ONNNO everything below that is already handled by
+                 *  ONNNO the old rectangle.
+                 *  OOOOO
+                 */
+                case PLY_RECTANGLE_OVERLAP_TOP_EDGE:
+                        new_area->height = old_area->y - new_area->y;
+                        break;
+
+                /*   OOOOO We need to split the new rectangle into
+                 * NNOOOOO two rectangles:  The left side of Ns and
+                 * NNOOOOO the bottom row of Ns.
+                 * NNOOOOO
+                 * NNNNN
+                 */
+                case PLY_RECTANGLE_OVERLAP_BOTTOM_AND_LEFT_EDGES:
+                {
+                        ply_rectangle_t *rectangle;
+
+                        rectangle = copy_rectangle (new_area);
+
+                        rectangle->width = old_area->x - new_area->x;
+                        rectangle->height = (old_area->y + old_area->height) - new_area->y;
+
+                        merge_rectangle_with_sub_list (region, rectangle, next_node);
+
+                        new_area->height = (new_area->y + new_area->height) - (old_area->y + old_area->height);
+                        new_area->y = old_area->y + old_area->height;
+                }
+                break;
+
+                /*   OOOOO   We need to split the new rectangle into
+                 *   OOOOONN two rectangles:  The right side of Ns and
+                 *   OOOOONN the bottom row of Ns.
+                 *   OOOOONN
+                 *     NNNNN
+                 */
+                case PLY_RECTANGLE_OVERLAP_BOTTOM_AND_RIGHT_EDGES:
+                {
+                        ply_rectangle_t *rectangle;
+
+                        rectangle = copy_rectangle (new_area);
+
+                        rectangle->x = old_area->x + old_area->width;
+                        rectangle->width = (new_area->x + new_area->width) - (old_area->x + old_area->width);
+                        rectangle->height = (old_area->y + old_area->height) - new_area->y;
+
+                        merge_rectangle_with_sub_list (region, rectangle, next_node);
+
+                        new_area->height = (new_area->y + new_area->height) - (old_area->y + old_area->height);
+                        new_area->y = old_area->y + old_area->height;
+                }
+                break;
+
+                /*  OOOOO  We need to trim out the part of
+                 * NOOOOON old rectangle that overlaps the new
+                 * NOOOOON rectangle by shrinking it
+                 * NNNNNNN and then we need to add the new rectangle.
+                 */
+                case PLY_RECTANGLE_OVERLAP_BOTTOM_AND_SIDE_EDGES:
+                {
+                        old_area->height = new_area->y - old_area->y;
+                }
+                break;
+
+                /*  OOOOO We only care about the bottom row of Ns,
+                 *  ONNNO everything above that is already handled by
+                 *  ONNNO the old rectangle.
+                 *   NNN
+                 */
+                case PLY_RECTANGLE_OVERLAP_BOTTOM_EDGE:
+                {
+                        new_area->height = (new_area->y + new_area->height) - (old_area->y + old_area->height);
+                        new_area->y = old_area->y + old_area->height;
+                }
+                break;
+
+                /*  NNNN   We need to trim out the part of
+                 *  NNNNO  old rectangle that overlaps the new
+                 *  NNNNO  rectangle by shrinking it and moving it
+                 *  NNNN   and then we need to add the new rectangle.
+                 */
+                case PLY_RECTANGLE_OVERLAP_TOP_LEFT_AND_BOTTOM_EDGES:
+                {
+                        old_area->width = (old_area->x + old_area->width)
+                                          - (new_area->x + new_area->width);
+                        old_area->x = new_area->x + new_area->width;
+                }
+                break;
+
+                /*  NNNN  We need to trim out the part of
+                 * ONNNN  old rectangle that overlaps the new
+                 * ONNNN  rectangle by shrinking it and then we
+                 *  NNNN  need to add the new rectangle.
+                 */
+                case PLY_RECTANGLE_OVERLAP_TOP_RIGHT_AND_BOTTOM_EDGES:
+                        old_area->width = new_area->x - old_area->x;
+                        break;
+
+                /* NNNNNNN The old rectangle is completely inside the new rectangle
+                 * NOOOOON so replace the old rectangle with the new rectangle.
+                 * NOOOOON
+                 * NNNNNNN
+                 */
+                case PLY_RECTANGLE_OVERLAP_ALL_EDGES:
+                        merge_rectangle_with_sub_list (region, new_area, next_node);
+                        free (old_area);
+                        ply_list_remove_node (region->rectangle_list, node);
+                        return;
+
+                /*  NNN  We need to split the new rectangle into
+                 * ONNNO two rectangles: the top and bottom row of Ns
+                 * ONNNO
+                 *  NNN
+                 */
+                case PLY_RECTANGLE_OVERLAP_TOP_AND_BOTTOM_EDGES:
+                {
+                        ply_rectangle_t *rectangle;
+
+                        rectangle = copy_rectangle (new_area);
+                        rectangle->y = old_area->y + old_area->height;
+                        rectangle->width = new_area->width;
+                        rectangle->height = (new_area->y + new_area->height) - (old_area->y + old_area->height);
+                        merge_rectangle_with_sub_list (region, rectangle, next_node);
+
+                        new_area->height = old_area->y - new_area->y;
+                }
+                break;
+
+                /*  OOOOO We only care about the side row of Ns,
+                 * NNNNOO everything rigth of that is already handled by
+                 * NNNNOO the old rectangle.
+                 *  OOOOO
+                 */
+                case PLY_RECTANGLE_OVERLAP_LEFT_EDGE:
+                        new_area->width = old_area->x - new_area->x;
+                        break;
+
+                /* OOOOO  We only care about the side row of Ns,
+                 * NNNNNN everything left of that is already handled by
+                 * NNNNNN the old rectangle.
+                 * OOOOO
+                 */
+                case PLY_RECTANGLE_OVERLAP_RIGHT_EDGE:
+                {
+                        long temp = new_area->x;
+                        new_area->x = old_area->x + old_area->width;
+                        new_area->width = (temp + new_area->width) - (old_area->x + old_area->width);
+                }
+                break;
+
+                /*  OOOOO  We need to split the new rectangle into
+                 * NNNNNNN two rectangles: the side columns of Ns
+                 * NNNNNNN
+                 *  OOOOO
+                 */
+                case PLY_RECTANGLE_OVERLAP_SIDE_EDGES:
+                {
+                        ply_rectangle_t *rectangle;
+
+                        rectangle = copy_rectangle (new_area);
+
+                        rectangle->x = old_area->x + old_area->width;
+                        rectangle->width = (new_area->x + new_area->width) - (old_area->x + old_area->width);
+
+                        merge_rectangle_with_sub_list (region, rectangle, next_node);
+
+                        new_area->width = old_area->x - new_area->x;
+                }
+                break;
+
+                /* OOOOOOO The new rectangle is completely inside an old rectangle
+                 * ONNNNNO so return early without adding the new rectangle.
+                 * ONNNNNO
+                 * OOOOOOO
+                 */
+                case PLY_RECTANGLE_OVERLAP_NO_EDGES:
+                        free (new_area);
+                        return;
+
+                /*  NNNNN We expand the old rectangle up and throw away the new.
+                 *  NNNNN We must merge it because the new region may have overlapped
+                 *  NNNNN something further down the list.
+                 *  OOOOO
+                 */
+                case PLY_RECTANGLE_OVERLAP_EXACT_TOP_EDGE:
+                {
+                        old_area->height = (old_area->y + old_area->height) - new_area->y;
+                        old_area->y = new_area->y;
+                        free (new_area);
+                        merge_rectangle_with_sub_list (region, old_area, next_node);
+                        ply_list_remove_node (region->rectangle_list, node);
+                }
+                        return;
+
+                /*  OOOOO We expand the old rectangle down and throw away the new.
+                 *  NNNNN We must merge it because the new region may have overlapped
+                 *  NNNNN something further down the list.
+                 *  NNNNN
+                 */
+                case PLY_RECTANGLE_OVERLAP_EXACT_BOTTOM_EDGE:
+                {
+                        old_area->height = (new_area->y + new_area->height) - old_area->y;
+                        free (new_area);
+                        merge_rectangle_with_sub_list (region, old_area, next_node);
+                        ply_list_remove_node (region->rectangle_list, node);
+                }
+                        return;
+
+                /*  NNNNNO We expand the old rectangle left and throw away the new.
+                 *  NNNNNO We must merge it because the new region may have overlapped
+                 *  NNNNNO something further down the list.
+                 */
+                case PLY_RECTANGLE_OVERLAP_EXACT_LEFT_EDGE:
+                {
+                        old_area->width = (old_area->x + old_area->width) - new_area->x;
+                        old_area->x = new_area->x;
+                        free (new_area);
+                        merge_rectangle_with_sub_list (region, old_area, next_node);
+                        ply_list_remove_node (region->rectangle_list, node);
+                }
+                        return;
+
+                /*  ONNNNN We expand the old rectangle right and throw away the new.
+                 *  ONNNNN We must merge it because the new region may have overlapped
+                 *  ONNNNN something further down the list.
+                 */
+                case PLY_RECTANGLE_OVERLAP_EXACT_RIGHT_EDGE:
+                {
+                        old_area->width = (new_area->x + new_area->width) - old_area->x;
+                        free (new_area);
+                        merge_rectangle_with_sub_list (region, old_area, next_node);
+                        ply_list_remove_node (region->rectangle_list, node);
+                }
+                        return;
+                }
+
+                node = ply_list_get_next_node (region->rectangle_list, node);
+        }
 
-  ply_list_append_data (region->rectangle_list, new_area);
+        ply_list_append_data (region->rectangle_list, new_area);
 }
 
 void
 ply_region_add_rectangle (ply_region_t    *region,
                           ply_rectangle_t *rectangle)
 {
-  ply_list_node_t *first_node;
-  ply_rectangle_t *rectangle_copy;
+        ply_list_node_t *first_node;
+        ply_rectangle_t *rectangle_copy;
 
-  assert (region != NULL);
-  assert (rectangle != NULL);
+        assert (region != NULL);
+        assert (rectangle != NULL);
 
-  first_node = ply_list_get_first_node (region->rectangle_list);
+        first_node = ply_list_get_first_node (region->rectangle_list);
 
-  rectangle_copy = copy_rectangle (rectangle);
-  merge_rectangle_with_sub_list (region,
-                                 rectangle_copy,
-                                 first_node);
+        rectangle_copy = copy_rectangle (rectangle);
+        merge_rectangle_with_sub_list (region,
+                                       rectangle_copy,
+                                       first_node);
 }
 
 ply_list_t *
 ply_region_get_rectangle_list (ply_region_t *region)
 {
-  return region->rectangle_list;
+        return region->rectangle_list;
 }
 
 static int
 rectangle_compare_y (void *element_a, void *element_b)
 {
-  ply_rectangle_t *rectangle_a = element_a;
-  ply_rectangle_t *rectangle_b = element_b;
-  return rectangle_a->y - rectangle_b->y;
+        ply_rectangle_t *rectangle_a = element_a;
+        ply_rectangle_t *rectangle_b = element_b;
+
+        return rectangle_a->y - rectangle_b->y;
 }
 
 ply_list_t *
 ply_region_get_sorted_rectangle_list (ply_region_t *region)
 {
-  ply_list_sort (region->rectangle_list, &rectangle_compare_y);
-  return region->rectangle_list;
+        ply_list_sort (region->rectangle_list, &rectangle_compare_y);
+        return region->rectangle_list;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-terminal-session.c b/src/libply/ply-terminal-session.c
index 379035c..a697b8f 100644
--- a/src/libply/ply-terminal-session.c
+++ b/src/libply/ply-terminal-session.c
@@ -43,20 +43,20 @@
 
 struct _ply_terminal_session
 {
-  int pseudoterminal_master_fd;
-  ply_logger_t *logger;
-  ply_event_loop_t *loop;
-  char **argv;
-  ply_fd_watch_t   *fd_watch;
-  ply_terminal_session_flags_t attach_flags;
-
-  ply_terminal_session_output_handler_t output_handler;
-  ply_terminal_session_hangup_handler_t hangup_handler;
-  void                                 *user_data;
-
-  uint32_t is_running : 1;
-  uint32_t console_is_redirected : 1;
-  uint32_t created_terminal_device : 1;
+        int                                   pseudoterminal_master_fd;
+        ply_logger_t                         *logger;
+        ply_event_loop_t                     *loop;
+        char                                **argv;
+        ply_fd_watch_t                       *fd_watch;
+        ply_terminal_session_flags_t          attach_flags;
+
+        ply_terminal_session_output_handler_t output_handler;
+        ply_terminal_session_hangup_handler_t hangup_handler;
+        void                                 *user_data;
+
+        uint32_t                              is_running : 1;
+        uint32_t                              console_is_redirected : 1;
+        uint32_t                              created_terminal_device : 1;
 };
 
 static bool ply_terminal_session_open_console (ply_terminal_session_t *session);
@@ -68,375 +68,361 @@ static void ply_terminal_session_stop_logging (ply_terminal_session_t *session);
 static bool
 ply_terminal_session_open_console (ply_terminal_session_t *session)
 {
-  int fd;
-  const char *terminal_name;
+        int fd;
+        const char *terminal_name;
 
-  terminal_name = ptsname (session->pseudoterminal_master_fd);
+        terminal_name = ptsname (session->pseudoterminal_master_fd);
 
-  fd = open (terminal_name, O_RDONLY); 
+        fd = open (terminal_name, O_RDONLY);
 
-  if (fd < 0)
-    return false;
+        if (fd < 0)
+                return false;
 
-  assert (fd == STDIN_FILENO);
-  assert (ttyname (fd) != NULL);
-  assert (strcmp (ttyname (fd), terminal_name) == 0);
+        assert (fd == STDIN_FILENO);
+        assert (ttyname (fd) != NULL);
+        assert (strcmp (ttyname (fd), terminal_name) == 0);
 
-  fd = open (terminal_name, O_WRONLY); 
+        fd = open (terminal_name, O_WRONLY);
 
-  if (fd < 0)
-    return false;
+        if (fd < 0)
+                return false;
 
-  assert (fd == STDOUT_FILENO);
-  assert (ttyname (fd) != NULL);
-  assert (strcmp (ttyname (fd), terminal_name) == 0);
+        assert (fd == STDOUT_FILENO);
+        assert (ttyname (fd) != NULL);
+        assert (strcmp (ttyname (fd), terminal_name) == 0);
 
-  fd = open (terminal_name, O_WRONLY); 
+        fd = open (terminal_name, O_WRONLY);
 
-  if (fd < 0)
-    return false;
+        if (fd < 0)
+                return false;
 
-  assert (fd == STDERR_FILENO);
-  assert (ttyname (fd) != NULL);
-  assert (strcmp (ttyname (fd), terminal_name) == 0);
+        assert (fd == STDERR_FILENO);
+        assert (ttyname (fd) != NULL);
+        assert (strcmp (ttyname (fd), terminal_name) == 0);
 
-  return true;
+        return true;
 }
 
 static bool
 ply_terminal_session_execute (ply_terminal_session_t *session,
                               bool                    look_in_path)
 {
-  ply_close_all_fds ();
+        ply_close_all_fds ();
 
-  if (!ply_terminal_session_open_console (session))
-    return false;
+        if (!ply_terminal_session_open_console (session))
+                return false;
 
-  if (look_in_path)
-    execvp (session->argv[0], session->argv);
-  else
-    execv (session->argv[0], session->argv);
+        if (look_in_path)
+                execvp (session->argv[0], session->argv);
+        else
+                execv (session->argv[0], session->argv);
 
-  return false;
+        return false;
 }
 
 ply_terminal_session_t *
-ply_terminal_session_new (const char * const *argv) 
+ply_terminal_session_new (const char *const *argv)
 {
-  ply_terminal_session_t *session;
+        ply_terminal_session_t *session;
 
-  assert (argv == NULL || argv[0] != NULL);
+        assert (argv == NULL || argv[0] != NULL);
 
-  session = calloc (1, sizeof (ply_terminal_session_t));
-  session->pseudoterminal_master_fd = -1;
-  session->argv = argv == NULL ? NULL : ply_copy_string_array (argv);
-  session->logger = ply_logger_new ();
-  session->is_running = false;
-  session->console_is_redirected = false;
+        session = calloc (1, sizeof(ply_terminal_session_t));
+        session->pseudoterminal_master_fd = -1;
+        session->argv = argv == NULL ? NULL : ply_copy_string_array (argv);
+        session->logger = ply_logger_new ();
+        session->is_running = false;
+        session->console_is_redirected = false;
 
-  return session;
+        return session;
 }
 
 void
 ply_terminal_session_free (ply_terminal_session_t *session)
 {
-  if (session == NULL)
-    return;
+        if (session == NULL)
+                return;
 
-  ply_terminal_session_stop_logging (session);
-  ply_logger_free (session->logger);
+        ply_terminal_session_stop_logging (session);
+        ply_logger_free (session->logger);
 
-  ply_free_string_array (session->argv);
+        ply_free_string_array (session->argv);
 
-  if (session->pseudoterminal_master_fd >= 0)
-    close (session->pseudoterminal_master_fd);
-  free (session);
+        if (session->pseudoterminal_master_fd >= 0)
+                close (session->pseudoterminal_master_fd);
+        free (session);
 }
 
 static void
 ply_terminal_session_detach_from_event_loop (ply_terminal_session_t *session)
 {
-  assert (session != NULL);
-  session->loop = NULL;
+        assert (session != NULL);
+        session->loop = NULL;
 }
 
-void 
+void
 ply_terminal_session_attach_to_event_loop (ply_terminal_session_t *session,
                                            ply_event_loop_t       *loop)
 {
-  assert (session != NULL);
-  assert (loop != NULL);
-  assert (session->loop == NULL);
+        assert (session != NULL);
+        assert (loop != NULL);
+        assert (session->loop == NULL);
 
-  session->loop = loop;
+        session->loop = loop;
 
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t) 
-                                 ply_terminal_session_detach_from_event_loop,
-                                 session); 
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       ply_terminal_session_detach_from_event_loop,
+                                       session);
 }
 
 static bool
 ply_terminal_session_redirect_console (ply_terminal_session_t *session)
 {
-  const char *terminal_name;
-  int fd;
+        const char *terminal_name;
+        int fd;
 
-  assert (session != NULL);
+        assert (session != NULL);
 
-  terminal_name = ptsname (session->pseudoterminal_master_fd);
+        terminal_name = ptsname (session->pseudoterminal_master_fd);
 
-  assert (terminal_name != NULL);
+        assert (terminal_name != NULL);
 
-  fd = open (terminal_name, O_RDWR | O_NOCTTY); 
+        fd = open (terminal_name, O_RDWR | O_NOCTTY);
 
-  if (fd < 0)
-    return false;
+        if (fd < 0)
+                return false;
 
-  if (ioctl (fd, TIOCCONS) < 0)
-    {
-      ply_save_errno ();
-      close (fd);
-      ply_restore_errno ();
-      return false;
-    }
+        if (ioctl (fd, TIOCCONS) < 0) {
+                ply_save_errno ();
+                close (fd);
+                ply_restore_errno ();
+                return false;
+        }
 
-  close (fd);
-  session->console_is_redirected = true;
-  return true;
+        close (fd);
+        session->console_is_redirected = true;
+        return true;
 }
 
 static void
 ply_terminal_session_unredirect_console (ply_terminal_session_t *session)
 {
-  int fd;
+        int fd;
 
-  assert (session != NULL);
-  assert (session->console_is_redirected);
+        assert (session != NULL);
+        assert (session->console_is_redirected);
 
-  fd = open ("/dev/console", O_RDWR | O_NOCTTY);
-  if (fd >= 0) {
-    ioctl (fd, TIOCCONS);
-    close (fd);
-  } else {
-    ply_trace ("couldn't open /dev/console to stop redirecting it: %m");
-  }
+        fd = open ("/dev/console", O_RDWR | O_NOCTTY);
+        if (fd >= 0) {
+                ioctl (fd, TIOCCONS);
+                close (fd);
+        } else {
+                ply_trace ("couldn't open /dev/console to stop redirecting it: %m");
+        }
 
-  session->console_is_redirected = false;
+        session->console_is_redirected = false;
 }
 
 static void
 close_pseudoterminal (ply_terminal_session_t *session)
 {
-  close (session->pseudoterminal_master_fd);
-  session->pseudoterminal_master_fd = -1;
+        close (session->pseudoterminal_master_fd);
+        session->pseudoterminal_master_fd = -1;
 }
 
 static bool
 open_pseudoterminal (ply_terminal_session_t *session)
 {
-  ply_trace ("opening device '/dev/ptmx'");
-  session->pseudoterminal_master_fd = posix_openpt (O_RDWR | O_NOCTTY);
-
-  if (session->pseudoterminal_master_fd < 0)
-    return false;
-
-  ply_trace (" opened device '/dev/ptmx'");
-
-  ply_trace ("creating pseudoterminal");
-  if (grantpt (session->pseudoterminal_master_fd) < 0)
-    {
-      ply_save_errno ();
-      ply_trace ("could not create psuedoterminal: %m");
-      close_pseudoterminal (session);
-      ply_restore_errno ();
-      return false;
-    }
-  ply_trace ("done creating pseudoterminal");
-
-  ply_trace ("unlocking pseudoterminal");
-  if (unlockpt (session->pseudoterminal_master_fd) < 0)
-    {
-      ply_save_errno ();
-      close_pseudoterminal (session);
-      ply_restore_errno ();
-      return false;
-    }
-  ply_trace ("unlocked pseudoterminal");
-
-  return true;
+        ply_trace ("opening device '/dev/ptmx'");
+        session->pseudoterminal_master_fd = posix_openpt (O_RDWR | O_NOCTTY);
+
+        if (session->pseudoterminal_master_fd < 0)
+                return false;
+
+        ply_trace (" opened device '/dev/ptmx'");
+
+        ply_trace ("creating pseudoterminal");
+        if (grantpt (session->pseudoterminal_master_fd) < 0) {
+                ply_save_errno ();
+                ply_trace ("could not create psuedoterminal: %m");
+                close_pseudoterminal (session);
+                ply_restore_errno ();
+                return false;
+        }
+        ply_trace ("done creating pseudoterminal");
+
+        ply_trace ("unlocking pseudoterminal");
+        if (unlockpt (session->pseudoterminal_master_fd) < 0) {
+                ply_save_errno ();
+                close_pseudoterminal (session);
+                ply_restore_errno ();
+                return false;
+        }
+        ply_trace ("unlocked pseudoterminal");
+
+        return true;
 }
 
 
-bool 
-ply_terminal_session_run (ply_terminal_session_t              *session,
-                          ply_terminal_session_flags_t         flags,
-                          ply_terminal_session_begin_handler_t begin_handler,
+bool
+ply_terminal_session_run (ply_terminal_session_t               *session,
+                          ply_terminal_session_flags_t          flags,
+                          ply_terminal_session_begin_handler_t  begin_handler,
                           ply_terminal_session_output_handler_t output_handler,
                           ply_terminal_session_hangup_handler_t hangup_handler,
-                          void                                *user_data)
+                          void                                 *user_data)
 {
-  pid_t pid;
-  bool run_in_parent, look_in_path, should_redirect_console;
-
-  assert (session != NULL);
-  assert (session->loop != NULL);
-  assert (!session->is_running);
-  assert (session->hangup_handler == NULL);
-
-  run_in_parent = (flags & PLY_TERMINAL_SESSION_FLAGS_RUN_IN_PARENT) != 0;
-  look_in_path = (flags & PLY_TERMINAL_SESSION_FLAGS_LOOK_IN_PATH) != 0;
-  should_redirect_console = 
-    (flags & PLY_TERMINAL_SESSION_FLAGS_REDIRECT_CONSOLE) != 0;
-
-  ply_trace ("creating terminal device");
-  if (!open_pseudoterminal (session))
-    return false;
-  ply_trace ("done creating terminal device");
-
-  if (should_redirect_console)
-    ply_trace ("redirecting system console to terminal device");
-  if (should_redirect_console && 
-      !ply_terminal_session_redirect_console (session))
-    {
-      ply_save_errno ();
-      close_pseudoterminal (session);
-      ply_restore_errno ();
-      return false;
-    }
-  if (should_redirect_console)
-    ply_trace ("done redirecting system console to terminal device");
-
-  ply_trace ("creating subprocess");
-  pid = fork ();
-
-  if (pid < 0)
-    {
-      ply_save_errno ();
-      ply_terminal_session_unredirect_console (session);
-      close_pseudoterminal (session);
-      ply_restore_errno ();
-      return false;
-    }
-
-  if (((pid == 0) && run_in_parent) ||
-      ((pid != 0) && !run_in_parent))
-    {
-      session->is_running = true;
-      session->output_handler = output_handler;
-      session->hangup_handler = hangup_handler;
-      session->user_data = user_data;
-      ply_terminal_session_start_logging (session);
-
-      return true;
-    }
-
-  if (begin_handler != NULL)
-    {
-      ply_trace ("running 'begin handler'");
-      begin_handler (user_data, session);
-      ply_trace ("ran 'begin handler'");
-    }
-
-  ply_trace ("beginning session");
-  ply_terminal_session_execute (session, look_in_path);
-
-  _exit (errno);
-  return false;
+        pid_t pid;
+        bool run_in_parent, look_in_path, should_redirect_console;
+
+        assert (session != NULL);
+        assert (session->loop != NULL);
+        assert (!session->is_running);
+        assert (session->hangup_handler == NULL);
+
+        run_in_parent = (flags & PLY_TERMINAL_SESSION_FLAGS_RUN_IN_PARENT) != 0;
+        look_in_path = (flags & PLY_TERMINAL_SESSION_FLAGS_LOOK_IN_PATH) != 0;
+        should_redirect_console =
+                (flags & PLY_TERMINAL_SESSION_FLAGS_REDIRECT_CONSOLE) != 0;
+
+        ply_trace ("creating terminal device");
+        if (!open_pseudoterminal (session))
+                return false;
+        ply_trace ("done creating terminal device");
+
+        if (should_redirect_console)
+                ply_trace ("redirecting system console to terminal device");
+        if (should_redirect_console &&
+            !ply_terminal_session_redirect_console (session)) {
+                ply_save_errno ();
+                close_pseudoterminal (session);
+                ply_restore_errno ();
+                return false;
+        }
+        if (should_redirect_console)
+                ply_trace ("done redirecting system console to terminal device");
+
+        ply_trace ("creating subprocess");
+        pid = fork ();
+
+        if (pid < 0) {
+                ply_save_errno ();
+                ply_terminal_session_unredirect_console (session);
+                close_pseudoterminal (session);
+                ply_restore_errno ();
+                return false;
+        }
+
+        if (((pid == 0) && run_in_parent) ||
+            ((pid != 0) && !run_in_parent)) {
+                session->is_running = true;
+                session->output_handler = output_handler;
+                session->hangup_handler = hangup_handler;
+                session->user_data = user_data;
+                ply_terminal_session_start_logging (session);
+
+                return true;
+        }
+
+        if (begin_handler != NULL) {
+                ply_trace ("running 'begin handler'");
+                begin_handler (user_data, session);
+                ply_trace ("ran 'begin handler'");
+        }
+
+        ply_trace ("beginning session");
+        ply_terminal_session_execute (session, look_in_path);
+
+        _exit (errno);
+        return false;
 }
 
 bool
 ply_terminal_session_attach (ply_terminal_session_t               *session,
                              ply_terminal_session_flags_t          flags,
                              ply_terminal_session_output_handler_t output_handler,
-                             ply_terminal_session_hangup_handler_t   hangup_handler,
+                             ply_terminal_session_hangup_handler_t hangup_handler,
                              int                                   ptmx,
                              void                                 *user_data)
 {
-  bool should_redirect_console;
-
-  assert (session != NULL);
-  assert (session->loop != NULL);
-  assert (!session->is_running);
-  assert (session->hangup_handler == NULL);
-
-  should_redirect_console = 
-    (flags & PLY_TERMINAL_SESSION_FLAGS_REDIRECT_CONSOLE) != 0;
-
-  if (ptmx >= 0)
-    {
-      ply_trace ("ptmx passed in, using it");
-      session->pseudoterminal_master_fd = ptmx;
-    }
-  else
-    {
-      ply_trace ("ptmx not passed in, creating one");
-      if (!open_pseudoterminal (session))
-        {
-          ply_trace ("could not create pseudo-terminal: %m");
-          return false;
+        bool should_redirect_console;
+
+        assert (session != NULL);
+        assert (session->loop != NULL);
+        assert (!session->is_running);
+        assert (session->hangup_handler == NULL);
+
+        should_redirect_console =
+                (flags & PLY_TERMINAL_SESSION_FLAGS_REDIRECT_CONSOLE) != 0;
+
+        if (ptmx >= 0) {
+                ply_trace ("ptmx passed in, using it");
+                session->pseudoterminal_master_fd = ptmx;
+        } else {
+                ply_trace ("ptmx not passed in, creating one");
+                if (!open_pseudoterminal (session)) {
+                        ply_trace ("could not create pseudo-terminal: %m");
+                        return false;
+                }
+
+                session->created_terminal_device = true;
+        }
+
+        if (should_redirect_console)
+                ply_trace ("redirecting system console to terminal device");
+        if (should_redirect_console &&
+            !ply_terminal_session_redirect_console (session)) {
+                ply_save_errno ();
+                close_pseudoterminal (session);
+                ply_restore_errno ();
+                return false;
         }
+        if (should_redirect_console)
+                ply_trace ("done redirecting system console to terminal device");
 
-      session->created_terminal_device = true;
-    }
-
-  if (should_redirect_console)
-    ply_trace ("redirecting system console to terminal device");
-  if (should_redirect_console && 
-      !ply_terminal_session_redirect_console (session))
-    {
-      ply_save_errno ();
-      close_pseudoterminal (session);
-      ply_restore_errno ();
-      return false;
-    }
-  if (should_redirect_console)
-    ply_trace ("done redirecting system console to terminal device");
-
-  session->is_running = true;
-  session->output_handler = output_handler;
-  session->hangup_handler = hangup_handler;
-  session->user_data = user_data;
-  session->attach_flags = flags;
-  ply_terminal_session_start_logging (session);
-
-  return true;
+        session->is_running = true;
+        session->output_handler = output_handler;
+        session->hangup_handler = hangup_handler;
+        session->user_data = user_data;
+        session->attach_flags = flags;
+        ply_terminal_session_start_logging (session);
+
+        return true;
 }
 
 void
-ply_terminal_session_detach (ply_terminal_session_t       *session)
+ply_terminal_session_detach (ply_terminal_session_t *session)
 {
-  assert (session != NULL);
+        assert (session != NULL);
 
-  ply_trace ("stopping terminal logger");
+        ply_trace ("stopping terminal logger");
 
-  ply_terminal_session_stop_logging (session);
+        ply_terminal_session_stop_logging (session);
 
-  if (session->console_is_redirected)
-    {
-      ply_trace ("unredirecting console messages");
-      ply_terminal_session_unredirect_console (session);
-    }
+        if (session->console_is_redirected) {
+                ply_trace ("unredirecting console messages");
+                ply_terminal_session_unredirect_console (session);
+        }
 
-  if (session->created_terminal_device)
-    {
-      ply_trace ("ptmx wasn't originally passed in, destroying created one");
-      close_pseudoterminal (session);
-      session->created_terminal_device = false;
-    }
+        if (session->created_terminal_device) {
+                ply_trace ("ptmx wasn't originally passed in, destroying created one");
+                close_pseudoterminal (session);
+                session->created_terminal_device = false;
+        }
 
-  session->output_handler = NULL;
-  session->hangup_handler = NULL;
-  session->user_data = NULL;
+        session->output_handler = NULL;
+        session->hangup_handler = NULL;
+        session->user_data = NULL;
 
-  session->is_running = false;
+        session->is_running = false;
 }
 
 int
 ply_terminal_session_get_fd (ply_terminal_session_t *session)
 {
-  assert (session != NULL);
+        assert (session != NULL);
 
-  return session->pseudoterminal_master_fd;
+        return session->pseudoterminal_master_fd;
 }
 
 static void
@@ -444,147 +430,146 @@ ply_terminal_session_log_bytes (ply_terminal_session_t *session,
                                 const uint8_t          *bytes,
                                 size_t                  number_of_bytes)
 {
-  assert (session != NULL);
-  assert (session->logger != NULL);
-  assert (bytes != NULL);
-  assert (number_of_bytes != 0);
+        assert (session != NULL);
+        assert (session->logger != NULL);
+        assert (bytes != NULL);
+        assert (number_of_bytes != 0);
 
-  ply_logger_inject_bytes (session->logger, bytes, number_of_bytes);
+        ply_logger_inject_bytes (session->logger, bytes, number_of_bytes);
 
-  if (session->output_handler != NULL)
-    session->output_handler (session->user_data,
-                             bytes, number_of_bytes, session);
+        if (session->output_handler != NULL)
+                session->output_handler (session->user_data,
+                                         bytes, number_of_bytes, session);
 }
 
 static void
 ply_terminal_session_on_new_data (ply_terminal_session_t *session,
                                   int                     session_fd)
 {
-  uint8_t buffer[4096];
-  ssize_t bytes_read;
+        uint8_t buffer[4096];
+        ssize_t bytes_read;
 
-  assert (session != NULL);
-  assert (session_fd >= 0);
+        assert (session != NULL);
+        assert (session_fd >= 0);
 
-  bytes_read = read (session_fd, buffer, sizeof (buffer));
+        bytes_read = read (session_fd, buffer, sizeof(buffer));
 
-  if (bytes_read > 0)
-    ply_terminal_session_log_bytes (session, buffer, bytes_read);
+        if (bytes_read > 0)
+                ply_terminal_session_log_bytes (session, buffer, bytes_read);
 
-  ply_logger_flush (session->logger);
+        ply_logger_flush (session->logger);
 }
 
 static void
 ply_terminal_session_on_hangup (ply_terminal_session_t *session)
 {
-  ply_terminal_session_hangup_handler_t  hangup_handler;
-  ply_terminal_session_output_handler_t  output_handler;
-  void                                  *user_data;
-  ply_terminal_session_flags_t           attach_flags;
-  bool                                   created_terminal_device;
-
-  assert (session != NULL);
-
-  ply_trace ("got hang up on terminal session fd");
-  hangup_handler = session->hangup_handler;
-  output_handler = session->output_handler;
-  user_data = session->user_data;
-  attach_flags = session->attach_flags;
-  created_terminal_device = session->created_terminal_device;
-
-  ply_logger_flush (session->logger);
-
-  session->is_running = false;
-  ply_trace ("stopping terminal logging");
-  ply_terminal_session_stop_logging (session);
-  session->hangup_handler = NULL;
-
-  if (hangup_handler != NULL)
-    hangup_handler (session->user_data, session);
-
-  ply_terminal_session_detach (session);
-
-  /* session ripped away, try to take it back
-   */
-  if (created_terminal_device)
-    {
-      ply_trace ("Attempting to reattach to console");
-      ply_terminal_session_attach (session, attach_flags,
-                                   output_handler, hangup_handler,
-                                   -1, user_data);
-    }
+        ply_terminal_session_hangup_handler_t hangup_handler;
+        ply_terminal_session_output_handler_t output_handler;
+        void *user_data;
+        ply_terminal_session_flags_t attach_flags;
+        bool created_terminal_device;
+
+        assert (session != NULL);
+
+        ply_trace ("got hang up on terminal session fd");
+        hangup_handler = session->hangup_handler;
+        output_handler = session->output_handler;
+        user_data = session->user_data;
+        attach_flags = session->attach_flags;
+        created_terminal_device = session->created_terminal_device;
+
+        ply_logger_flush (session->logger);
+
+        session->is_running = false;
+        ply_trace ("stopping terminal logging");
+        ply_terminal_session_stop_logging (session);
+        session->hangup_handler = NULL;
+
+        if (hangup_handler != NULL)
+                hangup_handler (session->user_data, session);
+
+        ply_terminal_session_detach (session);
+
+        /* session ripped away, try to take it back
+         */
+        if (created_terminal_device) {
+                ply_trace ("Attempting to reattach to console");
+                ply_terminal_session_attach (session, attach_flags,
+                                             output_handler, hangup_handler,
+                                             -1, user_data);
+        }
 }
 
-static void 
+static void
 ply_terminal_session_start_logging (ply_terminal_session_t *session)
 {
-  int session_fd;
+        int session_fd;
 
-  assert (session != NULL);
-  assert (session->logger != NULL);
+        assert (session != NULL);
+        assert (session->logger != NULL);
 
-  ply_trace ("logging incoming console messages");
-  if (!ply_logger_is_logging (session->logger))
-    ply_logger_toggle_logging (session->logger);
+        ply_trace ("logging incoming console messages");
+        if (!ply_logger_is_logging (session->logger))
+                ply_logger_toggle_logging (session->logger);
 
-  session_fd = ply_terminal_session_get_fd (session);
+        session_fd = ply_terminal_session_get_fd (session);
 
-  assert (session_fd >= 0);
+        assert (session_fd >= 0);
 
-  session->fd_watch = ply_event_loop_watch_fd (session->loop,
-                                               session_fd,
-                                               PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                                               (ply_event_handler_t)
-                                               ply_terminal_session_on_new_data, 
-                                               (ply_event_handler_t)
-                                               ply_terminal_session_on_hangup,
-                                               session);
+        session->fd_watch = ply_event_loop_watch_fd (session->loop,
+                                                     session_fd,
+                                                     PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                                     (ply_event_handler_t)
+                                                     ply_terminal_session_on_new_data,
+                                                     (ply_event_handler_t)
+                                                     ply_terminal_session_on_hangup,
+                                                     session);
 }
 
 static void
 ply_terminal_session_stop_logging (ply_terminal_session_t *session)
 {
-  assert (session != NULL);
-  assert (session->logger != NULL);
-
-  ply_trace ("stopping logging of incoming console messages");
-  if (ply_logger_is_logging (session->logger))
-    ply_logger_toggle_logging (session->logger);
-
-  if (session->loop != NULL &&
-      session->fd_watch != NULL)
-    ply_event_loop_stop_watching_fd (session->loop,
-                                     session->fd_watch);
-  session->fd_watch = NULL;
+        assert (session != NULL);
+        assert (session->logger != NULL);
+
+        ply_trace ("stopping logging of incoming console messages");
+        if (ply_logger_is_logging (session->logger))
+                ply_logger_toggle_logging (session->logger);
+
+        if (session->loop != NULL &&
+            session->fd_watch != NULL)
+                ply_event_loop_stop_watching_fd (session->loop,
+                                                 session->fd_watch);
+        session->fd_watch = NULL;
 }
 
-bool 
+bool
 ply_terminal_session_open_log (ply_terminal_session_t *session,
                                const char             *filename)
 {
-  bool log_is_opened;
+        bool log_is_opened;
 
-  assert (session != NULL);
-  assert (filename != NULL);
-  assert (session->logger != NULL);
+        assert (session != NULL);
+        assert (filename != NULL);
+        assert (session->logger != NULL);
 
-  ply_save_errno ();
-  unlink (filename);
-  log_is_opened = ply_logger_open_file (session->logger, filename, true);
-  if (log_is_opened)
-    ply_logger_flush (session->logger);
-  ply_restore_errno ();
+        ply_save_errno ();
+        unlink (filename);
+        log_is_opened = ply_logger_open_file (session->logger, filename, true);
+        if (log_is_opened)
+                ply_logger_flush (session->logger);
+        ply_restore_errno ();
 
-  return log_is_opened;
+        return log_is_opened;
 }
 
-void 
+void
 ply_terminal_session_close_log (ply_terminal_session_t *session)
 {
-  assert (session != NULL);
-  assert (session->logger != NULL);
+        assert (session != NULL);
+        assert (session->logger != NULL);
 
-  return ply_logger_close_file (session->logger);
+        return ply_logger_close_file (session->logger);
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-terminal-session.h b/src/libply/ply-terminal-session.h
index 7fee891..26a47c9 100644
--- a/src/libply/ply-terminal-session.h
+++ b/src/libply/ply-terminal-session.h
@@ -31,42 +31,44 @@
 
 typedef struct _ply_terminal_session ply_terminal_session_t;
 
-typedef void (* ply_terminal_session_begin_handler_t) 
-    (void *user_data, ply_terminal_session_t *session);
+typedef void (*ply_terminal_session_begin_handler_t)(void                   *user_data,
+                                                     ply_terminal_session_t *session);
 
-typedef void (* ply_terminal_session_output_handler_t)
-    (void *user_data, const uint8_t *output, size_t size, ply_terminal_session_t *session);
-typedef void (* ply_terminal_session_hangup_handler_t) 
-    (void *user_data, ply_terminal_session_t *session);
+typedef void (*ply_terminal_session_output_handler_t)(void                   *user_data,
+                                                      const uint8_t          *output,
+                                                      size_t                  size,
+                                                      ply_terminal_session_t *session);
+typedef void (*ply_terminal_session_hangup_handler_t)(void                   *user_data,
+                                                      ply_terminal_session_t *session);
 
 typedef enum
 {
-  PLY_TERMINAL_SESSION_FLAGS_NONE = 0x0,
-  PLY_TERMINAL_SESSION_FLAGS_RUN_IN_PARENT = 0x1,
-  PLY_TERMINAL_SESSION_FLAGS_LOOK_IN_PATH = 0x2,
-  PLY_TERMINAL_SESSION_FLAGS_REDIRECT_CONSOLE = 0x4,
+        PLY_TERMINAL_SESSION_FLAGS_NONE = 0x0,
+        PLY_TERMINAL_SESSION_FLAGS_RUN_IN_PARENT = 0x1,
+        PLY_TERMINAL_SESSION_FLAGS_LOOK_IN_PATH = 0x2,
+        PLY_TERMINAL_SESSION_FLAGS_REDIRECT_CONSOLE = 0x4,
 } ply_terminal_session_flags_t;
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
-ply_terminal_session_t *ply_terminal_session_new (const char * const *argv);
+ply_terminal_session_t *ply_terminal_session_new (const char *const *argv);
 void ply_terminal_session_free (ply_terminal_session_t *session);
 void ply_terminal_session_attach_to_event_loop (ply_terminal_session_t *session,
                                                 ply_event_loop_t       *loop);
-bool ply_terminal_session_run (ply_terminal_session_t       *session,
-                               ply_terminal_session_flags_t  flags,
-                               ply_terminal_session_begin_handler_t begin_handler,
+bool ply_terminal_session_run (ply_terminal_session_t               *session,
+                               ply_terminal_session_flags_t          flags,
+                               ply_terminal_session_begin_handler_t  begin_handler,
                                ply_terminal_session_output_handler_t output_handler,
-                               ply_terminal_session_hangup_handler_t  done_handler,
-                               void                                *user_data);
+                               ply_terminal_session_hangup_handler_t done_handler,
+                               void                                 *user_data);
 
-bool ply_terminal_session_attach (ply_terminal_session_t       *session,
-                                  ply_terminal_session_flags_t  flags,
+bool ply_terminal_session_attach (ply_terminal_session_t               *session,
+                                  ply_terminal_session_flags_t          flags,
                                   ply_terminal_session_output_handler_t output_handler,
                                   ply_terminal_session_hangup_handler_t hangup_handler,
-                                  int                                  ptmx,
-                                  void                                *user_data);
+                                  int                                   ptmx,
+                                  void                                 *user_data);
 
-void ply_terminal_session_detach (ply_terminal_session_t       *session);
+void ply_terminal_session_detach (ply_terminal_session_t *session);
 
 int ply_terminal_session_get_fd (ply_terminal_session_t *session);
 bool ply_terminal_session_open_log (ply_terminal_session_t *session,
diff --git a/src/libply/ply-trigger.c b/src/libply/ply-trigger.c
index 46ea547..b44778d 100644
--- a/src/libply/ply-trigger.c
+++ b/src/libply/ply-trigger.c
@@ -32,144 +32,139 @@
 
 typedef struct
 {
-  ply_trigger_handler_t  handler;
-  void                  *user_data;
+        ply_trigger_handler_t handler;
+        void                 *user_data;
 } ply_trigger_closure_t;
 
 struct _ply_trigger
 {
-  ply_list_t *closures;
+        ply_list_t     *closures;
 
-  ply_trigger_t **free_address;
-  int ignore_count;
+        ply_trigger_t **free_address;
+        int             ignore_count;
 };
 
 ply_trigger_t *
 ply_trigger_new (ply_trigger_t **free_address)
 {
-  ply_trigger_t *trigger;
+        ply_trigger_t *trigger;
 
-  trigger = calloc (1, sizeof (ply_trigger_t));
-  trigger->free_address = free_address;
-  trigger->closures = ply_list_new ();
-  trigger->ignore_count = 0;
+        trigger = calloc (1, sizeof(ply_trigger_t));
+        trigger->free_address = free_address;
+        trigger->closures = ply_list_new ();
+        trigger->ignore_count = 0;
 
-  return trigger;
+        return trigger;
 }
 
 void
 ply_trigger_free (ply_trigger_t *trigger)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (trigger == NULL)
-    return;
+        if (trigger == NULL)
+                return;
 
-  node = ply_list_get_first_node (trigger->closures);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_trigger_closure_t *closure;
+        node = ply_list_get_first_node (trigger->closures);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_trigger_closure_t *closure;
 
-      closure = (ply_trigger_closure_t *) ply_list_node_get_data (node);
+                closure = (ply_trigger_closure_t *) ply_list_node_get_data (node);
 
-      next_node = ply_list_get_next_node (trigger->closures, node);
+                next_node = ply_list_get_next_node (trigger->closures, node);
 
-      free (closure);
-      ply_list_remove_node (trigger->closures, node);
+                free (closure);
+                ply_list_remove_node (trigger->closures, node);
 
-      node = next_node;
-    }
-  ply_list_free (trigger->closures);
+                node = next_node;
+        }
+        ply_list_free (trigger->closures);
 
-  if (trigger->free_address != NULL)
-    *trigger->free_address = NULL;
+        if (trigger->free_address != NULL)
+                *trigger->free_address = NULL;
 
-  if (trigger->free_address != NULL)
-    *trigger->free_address = NULL;
+        if (trigger->free_address != NULL)
+                *trigger->free_address = NULL;
 
-  free (trigger);
+        free (trigger);
 }
 
 void
-ply_trigger_add_handler (ply_trigger_t         *trigger,
-                         ply_trigger_handler_t  handler,
-                         void                  *user_data)
+ply_trigger_add_handler (ply_trigger_t        *trigger,
+                         ply_trigger_handler_t handler,
+                         void                 *user_data)
 {
-  ply_trigger_closure_t *closure;
+        ply_trigger_closure_t *closure;
 
-  closure = calloc (1, sizeof (ply_trigger_closure_t));
-  closure->handler = handler;
-  closure->user_data = user_data;
+        closure = calloc (1, sizeof(ply_trigger_closure_t));
+        closure->handler = handler;
+        closure->user_data = user_data;
 
-  ply_list_append_data (trigger->closures, closure);
+        ply_list_append_data (trigger->closures, closure);
 }
 
 void
-ply_trigger_remove_handler (ply_trigger_t         *trigger,
-                            ply_trigger_handler_t  handler,
-                            void                  *user_data)
+ply_trigger_remove_handler (ply_trigger_t        *trigger,
+                            ply_trigger_handler_t handler,
+                            void                 *user_data)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (trigger->closures);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_trigger_closure_t *closure;
+        node = ply_list_get_first_node (trigger->closures);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_trigger_closure_t *closure;
 
-      closure = (ply_trigger_closure_t *) ply_list_node_get_data (node);
+                closure = (ply_trigger_closure_t *) ply_list_node_get_data (node);
 
-      next_node = ply_list_get_next_node (trigger->closures, node);
+                next_node = ply_list_get_next_node (trigger->closures, node);
 
-      if (closure->handler == handler && closure->user_data == user_data)
-        {
-          free (closure);
-          ply_list_remove_node (trigger->closures, node);
-          break;
-        }
+                if (closure->handler == handler && closure->user_data == user_data) {
+                        free (closure);
+                        ply_list_remove_node (trigger->closures, node);
+                        break;
+                }
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 void
 ply_trigger_ignore_next_pull (ply_trigger_t *trigger)
 {
-  trigger->ignore_count++;
+        trigger->ignore_count++;
 }
 
 void
 ply_trigger_pull (ply_trigger_t *trigger,
                   const void    *data)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (trigger != NULL);
-  assert (trigger->ignore_count >= 0);
+        assert (trigger != NULL);
+        assert (trigger->ignore_count >= 0);
 
-  if (trigger->ignore_count > 0)
-    {
-      trigger->ignore_count--;
-      return;
-    }
+        if (trigger->ignore_count > 0) {
+                trigger->ignore_count--;
+                return;
+        }
 
-  node = ply_list_get_first_node (trigger->closures);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_trigger_closure_t *closure;
+        node = ply_list_get_first_node (trigger->closures);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_trigger_closure_t *closure;
 
-      closure = (ply_trigger_closure_t *) ply_list_node_get_data (node);
+                closure = (ply_trigger_closure_t *) ply_list_node_get_data (node);
 
-      next_node = ply_list_get_next_node (trigger->closures, node);
+                next_node = ply_list_get_next_node (trigger->closures, node);
 
-      closure->handler (closure->user_data, data, trigger);
+                closure->handler (closure->user_data, data, trigger);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  if (trigger->free_address != NULL)
-    ply_trigger_free (trigger);
+        if (trigger->free_address != NULL)
+                ply_trigger_free (trigger);
 }
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-trigger.h b/src/libply/ply-trigger.h
index d543f04..2f3065c 100644
--- a/src/libply/ply-trigger.h
+++ b/src/libply/ply-trigger.h
@@ -30,18 +30,18 @@
 
 typedef struct _ply_trigger ply_trigger_t;
 
-typedef void (* ply_trigger_handler_t) (void          *user_data,
-                                        const void    *trigger_data,
-                                        ply_trigger_t *trigger);
+typedef void (*ply_trigger_handler_t) (void          *user_data,
+                                       const void    *trigger_data,
+                                       ply_trigger_t *trigger);
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_trigger_t *ply_trigger_new (ply_trigger_t **free_address);
 
-void ply_trigger_add_handler (ply_trigger_t          *trigger,
-                              ply_trigger_handler_t   handler,
-                              void                   *user_data);
-void ply_trigger_remove_handler (ply_trigger_t         *trigger,
-                                 ply_trigger_handler_t  handler,
-                                 void                  *user_data);
+void ply_trigger_add_handler (ply_trigger_t        *trigger,
+                              ply_trigger_handler_t handler,
+                              void                 *user_data);
+void ply_trigger_remove_handler (ply_trigger_t        *trigger,
+                                 ply_trigger_handler_t handler,
+                                 void                 *user_data);
 void ply_trigger_free (ply_trigger_t *trigger);
 
 void ply_trigger_ignore_next_pull (ply_trigger_t *trigger);
diff --git a/src/libply/ply-utils.c b/src/libply/ply-utils.c
index 8333485..8fb4f41 100644
--- a/src/libply/ply-utils.c
+++ b/src/libply/ply-utils.c
@@ -78,173 +78,164 @@
 static int errno_stack[PLY_ERRNO_STACK_SIZE];
 static int errno_stack_position = 0;
 
-bool 
+bool
 ply_open_unidirectional_pipe (int *sender_fd,
                               int *receiver_fd)
 {
-  int pipe_fds[2];
+        int pipe_fds[2];
 
-  assert (sender_fd != NULL);
-  assert (receiver_fd != NULL);
+        assert (sender_fd != NULL);
+        assert (receiver_fd != NULL);
 
-  if (pipe2 (pipe_fds, O_CLOEXEC) < 0)
-    return false;
+        if (pipe2 (pipe_fds, O_CLOEXEC) < 0)
+                return false;
 
-  *sender_fd = pipe_fds[1];
-  *receiver_fd = pipe_fds[0];
+        *sender_fd = pipe_fds[1];
+        *receiver_fd = pipe_fds[0];
 
-  return true;
+        return true;
 }
 
 static int
 ply_open_unix_socket (void)
 {
-  int fd;
-  const int should_pass_credentials = true;
+        int fd;
+        const int should_pass_credentials = true;
 
-  fd = socket (PF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);
+        fd = socket (PF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0);
 
-  if (fd < 0)
-    return -1;
+        if (fd < 0)
+                return -1;
 
-  if (setsockopt (fd, SOL_SOCKET, SO_PASSCRED,
-                  &should_pass_credentials, sizeof (should_pass_credentials)) < 0)
-    {
-      ply_save_errno ();
-      close (fd);
-      ply_restore_errno ();
-      return -1;
-    }
+        if (setsockopt (fd, SOL_SOCKET, SO_PASSCRED,
+                        &should_pass_credentials, sizeof(should_pass_credentials)) < 0) {
+                ply_save_errno ();
+                close (fd);
+                ply_restore_errno ();
+                return -1;
+        }
 
-  return fd;
+        return fd;
 }
 
 static struct sockaddr *
-create_unix_address_from_path (const char             *path,
-                               ply_unix_socket_type_t  type,
-                               size_t                 *address_size)
-{
-  struct sockaddr_un *address; 
-
-  assert (path != NULL && path[0] != '\0');
-  assert (strlen (path) < sizeof (address->sun_path));
-
-  address = calloc (1, sizeof (struct sockaddr_un));
-  address->sun_family = AF_UNIX;
-
-  /* a socket is marked as abstract if its path has the
-   * NUL byte at the beginning of the buffer.
-   * 
-   * Note, we depend on the memory being zeroed by the calloc
-   * call above.
-   */
-  if (type == PLY_UNIX_SOCKET_TYPE_CONCRETE)
-    strncpy (address->sun_path, path, sizeof (address->sun_path) - 1);
-  else
-    strncpy (address->sun_path + 1, path, sizeof (address->sun_path) - 1);
-
-  assert (address_size != NULL);
-
-  /* it's very popular to trim the trailing zeros off the end of the path these
-   * days for abstract sockets.  Unfortunately, the 0s are part of the name, so
-   * both client and server have to agree.
-   */
-  if (type == PLY_UNIX_SOCKET_TYPE_TRIMMED_ABSTRACT)
-    {
-      *address_size = offsetof (struct sockaddr_un, sun_path)
-                      + 1 /* NUL */ +
-                      strlen (address->sun_path + 1) /* path */;
-    }
-  else
-    {
-      *address_size = sizeof (struct sockaddr_un);
-    }
-
-  return (struct sockaddr *) address;
+create_unix_address_from_path (const char            *path,
+                               ply_unix_socket_type_t type,
+                               size_t                *address_size)
+{
+        struct sockaddr_un *address;
+
+        assert (path != NULL && path[0] != '\0');
+        assert (strlen (path) < sizeof(address->sun_path));
+
+        address = calloc (1, sizeof(struct sockaddr_un));
+        address->sun_family = AF_UNIX;
+
+        /* a socket is marked as abstract if its path has the
+         * NUL byte at the beginning of the buffer.
+         *
+         * Note, we depend on the memory being zeroed by the calloc
+         * call above.
+         */
+        if (type == PLY_UNIX_SOCKET_TYPE_CONCRETE)
+                strncpy (address->sun_path, path, sizeof(address->sun_path) - 1);
+        else
+                strncpy (address->sun_path + 1, path, sizeof(address->sun_path) - 1);
+
+        assert (address_size != NULL);
+
+        /* it's very popular to trim the trailing zeros off the end of the path these
+         * days for abstract sockets.  Unfortunately, the 0s are part of the name, so
+         * both client and server have to agree.
+         */
+        if (type == PLY_UNIX_SOCKET_TYPE_TRIMMED_ABSTRACT) {
+                *address_size = offsetof (struct sockaddr_un, sun_path)
+                                + 1 /* NUL */ +
+                                strlen (address->sun_path + 1) /* path */;
+        } else {
+                *address_size = sizeof(struct sockaddr_un);
+        }
+
+        return (struct sockaddr *) address;
 }
 
 int
-ply_connect_to_unix_socket (const char             *path,
-                            ply_unix_socket_type_t  type)
+ply_connect_to_unix_socket (const char            *path,
+                            ply_unix_socket_type_t type)
 {
-  struct sockaddr *address; 
-  size_t address_size;
-  int fd;
+        struct sockaddr *address;
+        size_t address_size;
+        int fd;
+
+        assert (path != NULL);
+        assert (path[0] != '\0');
 
-  assert (path != NULL);
-  assert (path[0] != '\0');
-  
-  fd = ply_open_unix_socket ();
+        fd = ply_open_unix_socket ();
 
-  if (fd < 0)
-    return -1;
+        if (fd < 0)
+                return -1;
 
-  address = create_unix_address_from_path (path, type, &address_size);
+        address = create_unix_address_from_path (path, type, &address_size);
 
-  if (connect (fd, address, address_size) < 0)
-    {
-      ply_save_errno ();
-      free (address);
-      close (fd);
-      ply_restore_errno ();
+        if (connect (fd, address, address_size) < 0) {
+                ply_save_errno ();
+                free (address);
+                close (fd);
+                ply_restore_errno ();
 
-      return -1;
-    }
-  free (address);
+                return -1;
+        }
+        free (address);
 
-  return fd;
+        return fd;
 }
 
 int
-ply_listen_to_unix_socket (const char             *path,
-                           ply_unix_socket_type_t  type)
-{
-  struct sockaddr *address; 
-  size_t address_size;
-  int fd;
-  
-  assert (path != NULL);
-  assert (path[0] != '\0');
-
-  fd = ply_open_unix_socket ();
-
-  if (fd < 0)
-    return -1;
-
-  address = create_unix_address_from_path (path, type, &address_size);
-
-  if (bind (fd, address, address_size) < 0)
-    {
-      ply_save_errno ();
-      free (address);
-      close (fd);
-      ply_restore_errno ();
-
-      return -1;
-    }
-
-  free (address);
-
-  if (listen (fd, SOMAXCONN) < 0)
-    {
-      ply_save_errno ();
-      close (fd);
-      ply_restore_errno ();
-      return -1;
-    }
-
-  if (type == PLY_UNIX_SOCKET_TYPE_CONCRETE)
-    {
-      if (fchmod (fd, 0600) < 0)
-        {
-          ply_save_errno ();
-          close (fd);
-          ply_restore_errno ();
-          return -1;
+ply_listen_to_unix_socket (const char            *path,
+                           ply_unix_socket_type_t type)
+{
+        struct sockaddr *address;
+        size_t address_size;
+        int fd;
+
+        assert (path != NULL);
+        assert (path[0] != '\0');
+
+        fd = ply_open_unix_socket ();
+
+        if (fd < 0)
+                return -1;
+
+        address = create_unix_address_from_path (path, type, &address_size);
+
+        if (bind (fd, address, address_size) < 0) {
+                ply_save_errno ();
+                free (address);
+                close (fd);
+                ply_restore_errno ();
+
+                return -1;
+        }
+
+        free (address);
+
+        if (listen (fd, SOMAXCONN) < 0) {
+                ply_save_errno ();
+                close (fd);
+                ply_restore_errno ();
+                return -1;
         }
-    }
 
-  return fd;
+        if (type == PLY_UNIX_SOCKET_TYPE_CONCRETE) {
+                if (fchmod (fd, 0600) < 0) {
+                        ply_save_errno ();
+                        close (fd);
+                        ply_restore_errno ();
+                        return -1;
+                }
+        }
+
+        return fd;
 }
 
 bool
@@ -253,725 +244,696 @@ ply_get_credentials_from_fd (int    fd,
                              uid_t *uid,
                              gid_t *gid)
 {
-  struct ucred credentials;
-  socklen_t credential_size;
+        struct ucred credentials;
+        socklen_t credential_size;
 
-  credential_size = sizeof (credentials);
-  if (getsockopt (fd, SOL_SOCKET, SO_PEERCRED, &credentials,
-                  &credential_size) < 0)
-    return false;
+        credential_size = sizeof(credentials);
+        if (getsockopt (fd, SOL_SOCKET, SO_PEERCRED, &credentials,
+                        &credential_size) < 0)
+                return false;
 
-  if (credential_size < sizeof (credentials))
-    return false;
+        if (credential_size < sizeof(credentials))
+                return false;
 
-  if (pid != NULL)
-    *pid = credentials.pid;
+        if (pid != NULL)
+                *pid = credentials.pid;
 
-  if (uid != NULL)
-    *uid = credentials.uid;
+        if (uid != NULL)
+                *uid = credentials.uid;
 
-  if (gid != NULL)
-    *gid = credentials.gid;
+        if (gid != NULL)
+                *gid = credentials.gid;
 
-  return true;
+        return true;
 }
 
-bool 
+bool
 ply_write (int         fd,
            const void *buffer,
            size_t      number_of_bytes)
 {
-  size_t bytes_left_to_write;
-  size_t total_bytes_written = 0;
+        size_t bytes_left_to_write;
+        size_t total_bytes_written = 0;
 
-  assert (fd >= 0);
+        assert (fd >= 0);
 
-  bytes_left_to_write = number_of_bytes;
+        bytes_left_to_write = number_of_bytes;
 
-  do
-    {
-      ssize_t bytes_written = 0;
+        do {
+                ssize_t bytes_written = 0;
 
-      bytes_written = write (fd,
-                             ((uint8_t *) buffer) + total_bytes_written,
-                             bytes_left_to_write);
+                bytes_written = write (fd,
+                                       ((uint8_t *) buffer) + total_bytes_written,
+                                       bytes_left_to_write);
 
-      if (bytes_written > 0)
-        {
-          total_bytes_written += bytes_written;
-          bytes_left_to_write -= bytes_written;
-        }
-      else if ((errno != EINTR))
-        break;
-    }
-  while (bytes_left_to_write > 0);
+                if (bytes_written > 0) {
+                        total_bytes_written += bytes_written;
+                        bytes_left_to_write -= bytes_written;
+                } else if ((errno != EINTR)) {
+                        break;
+                }
+        } while (bytes_left_to_write > 0);
 
-  return bytes_left_to_write == 0;
+        return bytes_left_to_write == 0;
 }
 
-bool 
+bool
 ply_write_uint32 (int      fd,
                   uint32_t value)
 {
-  uint8_t buffer[4];
-  
-  buffer[0] = (value >> 0) & 0xFF;
-  buffer[1] = (value >> 8) & 0xFF;
-  buffer[2] = (value >> 16) & 0xFF;
-  buffer[3] = (value >> 24) & 0xFF;
-  
-  return ply_write (fd, buffer, 4 * sizeof (uint8_t));
+        uint8_t buffer[4];
+
+        buffer[0] = (value >> 0) & 0xFF;
+        buffer[1] = (value >> 8) & 0xFF;
+        buffer[2] = (value >> 16) & 0xFF;
+        buffer[3] = (value >> 24) & 0xFF;
+
+        return ply_write (fd, buffer, 4 * sizeof(uint8_t));
 }
 
 static ssize_t
-ply_read_some_bytes (int     fd,
-                     void   *buffer,
-                     size_t  max_bytes)
+ply_read_some_bytes (int    fd,
+                     void  *buffer,
+                     size_t max_bytes)
 {
-  size_t bytes_left_to_read;
-  size_t total_bytes_read = 0;
+        size_t bytes_left_to_read;
+        size_t total_bytes_read = 0;
 
-  assert (fd >= 0);
+        assert (fd >= 0);
 
-  bytes_left_to_read = max_bytes;
+        bytes_left_to_read = max_bytes;
 
-  do
-    {
-      ssize_t bytes_read = 0;
+        do {
+                ssize_t bytes_read = 0;
 
-      bytes_read = read (fd,
-                         ((uint8_t *) buffer) + total_bytes_read,
-                         bytes_left_to_read);
+                bytes_read = read (fd,
+                                   ((uint8_t *) buffer) + total_bytes_read,
+                                   bytes_left_to_read);
 
-      if (bytes_read > 0)
-        {
-          total_bytes_read += bytes_read;
-          bytes_left_to_read -= bytes_read;
-        }
-      else if ((errno != EINTR))
-        break;
-    }
-  while (bytes_left_to_read > 0);
+                if (bytes_read > 0) {
+                        total_bytes_read += bytes_read;
+                        bytes_left_to_read -= bytes_read;
+                } else if ((errno != EINTR)) {
+                        break;
+                }
+        } while (bytes_left_to_read > 0);
 
-  if ((bytes_left_to_read > 0) && (errno != EAGAIN))
-    total_bytes_read = -1;
+        if ((bytes_left_to_read > 0) && (errno != EAGAIN))
+                total_bytes_read = -1;
 
-  return total_bytes_read;
+        return total_bytes_read;
 }
 
-bool 
-ply_read (int     fd,
-          void   *buffer,
-          size_t  number_of_bytes)
+bool
+ply_read (int    fd,
+          void  *buffer,
+          size_t number_of_bytes)
 {
-  size_t total_bytes_read;
-  bool read_was_successful;
+        size_t total_bytes_read;
+        bool read_was_successful;
 
-  assert (fd >= 0);
-  assert (buffer != NULL);
-  assert (number_of_bytes != 0);
+        assert (fd >= 0);
+        assert (buffer != NULL);
+        assert (number_of_bytes != 0);
 
-  total_bytes_read = ply_read_some_bytes (fd, buffer, number_of_bytes);
+        total_bytes_read = ply_read_some_bytes (fd, buffer, number_of_bytes);
 
-  read_was_successful = total_bytes_read == number_of_bytes;
+        read_was_successful = total_bytes_read == number_of_bytes;
 
-  return read_was_successful;
+        return read_was_successful;
 }
 
-bool 
+bool
 ply_read_uint32 (int       fd,
                  uint32_t *value)
 {
-  uint8_t buffer[4];
-  
-  if (!ply_read (fd, buffer, 4 * sizeof (uint8_t)))
-    return false;
-  
-  *value = (buffer[0] << 0) | 
-           (buffer[1] << 8) | 
-           (buffer[2] << 16) | 
-           (buffer[3] << 24);
-  return true;
+        uint8_t buffer[4];
+
+        if (!ply_read (fd, buffer, 4 * sizeof(uint8_t)))
+                return false;
+
+        *value = (buffer[0] << 0) |
+                 (buffer[1] << 8) |
+                 (buffer[2] << 16) |
+                 (buffer[3] << 24);
+        return true;
 }
 
-bool 
+bool
 ply_fd_has_data (int fd)
 {
-  struct pollfd poll_data;
-  int result;
+        struct pollfd poll_data;
+        int result;
 
-  poll_data.fd = fd;
-  poll_data.events = POLLIN | POLLPRI;
-  poll_data.revents = 0;
-  result = poll (&poll_data, 1, 10);
+        poll_data.fd = fd;
+        poll_data.events = POLLIN | POLLPRI;
+        poll_data.revents = 0;
+        result = poll (&poll_data, 1, 10);
 
-  return result == 1 
-         && ((poll_data.revents & POLLIN) 
-         || (poll_data.revents & POLLPRI));
+        return result == 1
+               && ((poll_data.revents & POLLIN)
+                   || (poll_data.revents & POLLPRI));
 }
 
-bool 
+bool
 ply_fd_can_take_data (int fd)
 {
-  struct pollfd poll_data;
-  int result;
+        struct pollfd poll_data;
+        int result;
 
-  poll_data.fd = fd;
-  poll_data.events = POLLOUT;
-  poll_data.revents = 0;
-  result = poll (&poll_data, 1, 10);
+        poll_data.fd = fd;
+        poll_data.events = POLLOUT;
+        poll_data.revents = 0;
+        result = poll (&poll_data, 1, 10);
 
-  return result == 1;
+        return result == 1;
 }
 
 bool
 ply_fd_may_block (int fd)
 {
-  int flags;
+        int flags;
 
-  assert (fd >= 0);
+        assert (fd >= 0);
 
-  flags = fcntl (fd, F_GETFL);
+        flags = fcntl (fd, F_GETFL);
 
-  return (flags & O_NONBLOCK) != 0;
+        return (flags & O_NONBLOCK) != 0;
 }
 
 char **
-ply_copy_string_array (const char * const *array)
+ply_copy_string_array (const char *const *array)
 {
-  char **copy;
-  int i;
+        char **copy;
+        int i;
 
-  for (i = 0; array[i] != NULL; i++);
+        for (i = 0; array[i] != NULL; i++) {
+        }
 
-  copy = calloc (i + 1, sizeof (char *));
+        copy = calloc (i + 1, sizeof(char *));
 
-  for (i = 0; array[i] != NULL; i++)
-    copy[i] = strdup (array[i]);
+        for (i = 0; array[i] != NULL; i++) {
+                copy[i] = strdup (array[i]);
+        }
 
-  return copy;
+        return copy;
 }
 
-void 
+void
 ply_free_string_array (char **array)
 {
-  int i;
+        int i;
 
-  if (array == NULL)
-    return;
+        if (array == NULL)
+                return;
 
-  for (i = 0; array[i] != NULL; i++)
-    {
-      free (array[i]);
-      array[i] = NULL;
-    }
+        for (i = 0; array[i] != NULL; i++) {
+                free (array[i]);
+                array[i] = NULL;
+        }
 
-  free (array);
+        free (array);
 }
 
 bool
 ply_string_has_prefix (const char *string,
                        const char *prefix)
 {
-  if (string == NULL)
-    return false;
+        if (string == NULL)
+                return false;
 
-  if (prefix == NULL)
-    return false;
+        if (prefix == NULL)
+                return false;
 
-  if (strlen (prefix) > strlen (string))
-    return false;
+        if (strlen (prefix) > strlen (string))
+                return false;
 
-  return strncmp (string, prefix, strlen (prefix)) == 0;
+        return strncmp (string, prefix, strlen (prefix)) == 0;
 }
 
 static int
 ply_get_max_open_fds (void)
 {
-  struct rlimit open_fd_limit;
+        struct rlimit open_fd_limit;
 
-  if (getrlimit (RLIMIT_NOFILE, &open_fd_limit) < 0) 
-    return -1;
+        if (getrlimit (RLIMIT_NOFILE, &open_fd_limit) < 0)
+                return -1;
 
-  if (open_fd_limit.rlim_cur == RLIM_INFINITY) 
-    return -1;
+        if (open_fd_limit.rlim_cur == RLIM_INFINITY)
+                return -1;
 
-  return (int) open_fd_limit.rlim_cur;
+        return (int) open_fd_limit.rlim_cur;
 }
 
 static bool
 ply_close_open_fds (void)
 {
-  DIR *dir;
-  struct dirent *entry;
-  int fd, opendir_fd;
+        DIR *dir;
+        struct dirent *entry;
+        int fd, opendir_fd;
 
-  opendir_fd = -1;
-  dir = opendir (PLY_OPEN_FILE_DESCRIPTORS_DIR);
+        opendir_fd = -1;
+        dir = opendir (PLY_OPEN_FILE_DESCRIPTORS_DIR);
 
-  if (dir == NULL)
-    return false;
+        if (dir == NULL)
+                return false;
 
-  while ((entry = readdir (dir)) != NULL) 
-    {
-      long filename_as_number;
-      char *byte_after_number;
+        while ((entry = readdir (dir)) != NULL) {
+                long filename_as_number;
+                char *byte_after_number;
 
-      errno = 0;
-      if (entry->d_name[0] == '.')
-        continue;
+                errno = 0;
+                if (entry->d_name[0] == '.')
+                        continue;
 
-      fd = -1;
-      filename_as_number = strtol (entry->d_name, &byte_after_number, 10);
+                fd = -1;
+                filename_as_number = strtol (entry->d_name, &byte_after_number, 10);
 
-      if ((*byte_after_number != '\0') ||
-          (filename_as_number < 0) ||
-          (filename_as_number > INT_MAX)) {
-        closedir (dir);
-        return false;
-      }
+                if ((*byte_after_number != '\0') ||
+                    (filename_as_number < 0) ||
+                    (filename_as_number > INT_MAX)) {
+                        closedir (dir);
+                        return false;
+                }
 
-      fd = (int) filename_as_number;
+                fd = (int) filename_as_number;
 
-      if (fd != opendir_fd)
-        close (fd);
-    }
+                if (fd != opendir_fd)
+                        close (fd);
+        }
 
-  assert (entry == NULL);
-  closedir (dir);
+        assert (entry == NULL);
+        closedir (dir);
 
-  return true;
+        return true;
 }
 
-void 
+void
 ply_close_all_fds (void)
 {
-  int max_open_fds, fd;
-
-  max_open_fds = ply_get_max_open_fds ();
+        int max_open_fds, fd;
 
-  /* if there isn't a reported maximum for some
-   * reason, then open up /proc/self/fd and close
-   * the ones we can find.  If that doesn't work
-   * out, then just bite the bullet and close the
-   * entire integer range
-   */
-  if (max_open_fds < 0)
-    {
-      if (ply_close_open_fds ())
-        return;
+        max_open_fds = ply_get_max_open_fds ();
 
-      max_open_fds = INT_MAX;
-    }
+        /* if there isn't a reported maximum for some
+         * reason, then open up /proc/self/fd and close
+         * the ones we can find.  If that doesn't work
+         * out, then just bite the bullet and close the
+         * entire integer range
+         */
+        if (max_open_fds < 0) {
+                if (ply_close_open_fds ())
+                        return;
 
-  else for (fd = 0; fd < max_open_fds; fd++) 
-    close (fd);
+                max_open_fds = INT_MAX;
+        } else { for (fd = 0; fd < max_open_fds; fd++) {
+                         close (fd);
+                 }
+        }
 }
 
-double 
+double
 ply_get_timestamp (void)
 {
-  const double nanoseconds_per_second = 1000000000.0;
-  double timestamp;
-  struct timespec now = { 0L, /* zero-filled */ };
+        const double nanoseconds_per_second = 1000000000.0;
+        double timestamp;
+        struct timespec now = { 0L, /* zero-filled */ };
 
-  clock_gettime (CLOCK_MONOTONIC, &now);
-  timestamp = ((nanoseconds_per_second * now.tv_sec) + now.tv_nsec) /
-               nanoseconds_per_second;
+        clock_gettime (CLOCK_MONOTONIC, &now);
+        timestamp = ((nanoseconds_per_second * now.tv_sec) + now.tv_nsec) /
+                    nanoseconds_per_second;
 
-  return timestamp;
+        return timestamp;
 }
 
-void 
+void
 ply_save_errno (void)
 {
-  assert (errno_stack_position < PLY_ERRNO_STACK_SIZE);
-  errno_stack[errno_stack_position] = errno;
-  errno_stack_position++;
+        assert (errno_stack_position < PLY_ERRNO_STACK_SIZE);
+        errno_stack[errno_stack_position] = errno;
+        errno_stack_position++;
 }
 
 void
 ply_restore_errno (void)
 {
-  assert (errno_stack_position > 0);
-  errno_stack_position--;
-  errno = errno_stack[errno_stack_position];
+        assert (errno_stack_position > 0);
+        errno_stack_position--;
+        errno = errno_stack[errno_stack_position];
 }
 
-bool 
+bool
 ply_directory_exists (const char *dir)
 {
-  struct stat file_info;
-  
-  if (stat (dir, &file_info) < 0)
-    return false;
+        struct stat file_info;
+
+        if (stat (dir, &file_info) < 0)
+                return false;
 
-  return S_ISDIR (file_info.st_mode);
+        return S_ISDIR (file_info.st_mode);
 }
 
 bool
 ply_file_exists (const char *file)
 {
-  struct stat file_info;
-  
-  if (stat (file, &file_info) < 0)
-    return false;
+        struct stat file_info;
+
+        if (stat (file, &file_info) < 0)
+                return false;
 
-  return S_ISREG (file_info.st_mode);
+        return S_ISREG (file_info.st_mode);
 }
 
 bool
 ply_character_device_exists (const char *device)
 {
-  struct stat file_info;
+        struct stat file_info;
 
-  if (stat (device, &file_info) < 0)
-    return false;
+        if (stat (device, &file_info) < 0)
+                return false;
 
-  return S_ISCHR (file_info.st_mode);
+        return S_ISCHR (file_info.st_mode);
 }
 
 ply_module_handle_t *
 ply_open_module (const char *module_path)
 {
-  ply_module_handle_t *handle;
+        ply_module_handle_t *handle;
 
-  assert (module_path != NULL);
+        assert (module_path != NULL);
 
-  handle = (ply_module_handle_t *) dlopen (module_path,
-                                           RTLD_NODELETE |RTLD_NOW | RTLD_LOCAL);
+        handle = (ply_module_handle_t *) dlopen (module_path,
+                                                 RTLD_NODELETE | RTLD_NOW | RTLD_LOCAL);
 
-  if (handle == NULL)
-    {
-      ply_trace("Could not load module \"%s\": %s\n", module_path, dlerror());
-      if (errno == 0)
-        errno = ELIBACC;
-    }
+        if (handle == NULL) {
+                ply_trace ("Could not load module \"%s\": %s\n", module_path, dlerror ());
+                if (errno == 0)
+                        errno = ELIBACC;
+        }
 
-  return handle;
+        return handle;
 }
 
 ply_module_handle_t *
 ply_open_built_in_module (void)
 {
-  ply_module_handle_t *handle;
+        ply_module_handle_t *handle;
 
-  handle = (ply_module_handle_t *) dlopen (NULL,
-                                           RTLD_NODELETE |RTLD_NOW | RTLD_LOCAL);
+        handle = (ply_module_handle_t *) dlopen (NULL,
+                                                 RTLD_NODELETE | RTLD_NOW | RTLD_LOCAL);
 
-  if (handle == NULL)
-    {
-      ply_trace("Could not load built-in module: %s\n",  dlerror ());
-      if (errno == 0)
-        errno = ELIBACC;
-    }
+        if (handle == NULL) {
+                ply_trace ("Could not load built-in module: %s\n", dlerror ());
+                if (errno == 0)
+                        errno = ELIBACC;
+        }
 
-  return handle;
+        return handle;
 }
 
 ply_module_function_t
 ply_module_look_up_function (ply_module_handle_t *handle,
                              const char          *function_name)
 {
-  ply_module_function_t function;
+        ply_module_function_t function;
 
-  assert (handle != NULL);
-  assert (function_name != NULL);
+        assert (handle != NULL);
+        assert (function_name != NULL);
 
-  dlerror ();
-  function = (ply_module_function_t) dlsym (handle, function_name);
+        dlerror ();
+        function = (ply_module_function_t) dlsym (handle, function_name);
 
-  if (dlerror () != NULL)
-    {
-      if (errno == 0)
-        errno = ELIBACC;
+        if (dlerror () != NULL) {
+                if (errno == 0)
+                        errno = ELIBACC;
 
-      return NULL;
-    }
+                return NULL;
+        }
 
-  return function;
+        return function;
 }
 
 void
 ply_close_module (ply_module_handle_t *handle)
 {
-  dlclose (handle);
+        dlclose (handle);
 }
 
 bool
 ply_create_directory (const char *directory)
 {
-  assert (directory != NULL);
-  assert (directory[0] != '\0');
-
-  if (ply_directory_exists (directory))
-    {
-      ply_trace ("directory '%s' already exists", directory);
-      return true;
-    }
-
-  if (ply_file_exists (directory))
-    {
-      ply_trace ("file '%s' is in the way", directory);
-      errno = EEXIST;
-      return false;
-    }
-
-  if (mkdir (directory, 0755) < 0)
-    {
-      char *parent_directory;
-      char *last_path_component;
-      bool is_created;
-
-      is_created = errno == EEXIST;
-      if (errno == ENOENT)
-        {
-          parent_directory = strdup (directory);
-          last_path_component = strrchr (parent_directory, '/');
-          *last_path_component = '\0';
-
-          ply_trace ("parent directory '%s' doesn't exist, creating it first", parent_directory);
-          if (ply_create_directory (parent_directory)
-              && ((mkdir (directory, 0755) == 0) || errno == EEXIST))
-            is_created = true;
-
-          ply_save_errno ();
-          free (parent_directory);
-          ply_restore_errno ();
+        assert (directory != NULL);
+        assert (directory[0] != '\0');
 
+        if (ply_directory_exists (directory)) {
+                ply_trace ("directory '%s' already exists", directory);
+                return true;
         }
 
-      return is_created;
-    }
+        if (ply_file_exists (directory)) {
+                ply_trace ("file '%s' is in the way", directory);
+                errno = EEXIST;
+                return false;
+        }
+
+        if (mkdir (directory, 0755) < 0) {
+                char *parent_directory;
+                char *last_path_component;
+                bool is_created;
+
+                is_created = errno == EEXIST;
+                if (errno == ENOENT) {
+                        parent_directory = strdup (directory);
+                        last_path_component = strrchr (parent_directory, '/');
+                        *last_path_component = '\0';
 
+                        ply_trace ("parent directory '%s' doesn't exist, creating it first", parent_directory);
+                        if (ply_create_directory (parent_directory)
+                            && ((mkdir (directory, 0755) == 0) || errno == EEXIST))
+                                is_created = true;
 
-  return true;
+                        ply_save_errno ();
+                        free (parent_directory);
+                        ply_restore_errno ();
+                }
+
+                return is_created;
+        }
+
+
+        return true;
 }
 
 bool
 ply_create_file_link (const char *source,
                       const char *destination)
 {
-  if (link (source, destination) < 0)
-    return false;
+        if (link (source, destination) < 0)
+                return false;
 
-  return true;
+        return true;
 }
 
 void
 ply_show_new_kernel_messages (bool should_show)
 {
-  int type;
+        int type;
 
-  if (should_show)
-    type = PLY_ENABLE_CONSOLE_PRINTK;
-  else
-    type = PLY_DISABLE_CONSOLE_PRINTK;
+        if (should_show)
+                type = PLY_ENABLE_CONSOLE_PRINTK;
+        else
+                type = PLY_DISABLE_CONSOLE_PRINTK;
 
-  if (klogctl (type, NULL, 0) < 0)
-    ply_trace ("could not toggle printk visibility: %m");
+        if (klogctl (type, NULL, 0) < 0)
+                ply_trace ("could not toggle printk visibility: %m");
 }
 
 ply_daemon_handle_t *
 ply_create_daemon (void)
 {
-  pid_t pid;
-  int sender_fd, receiver_fd;
-  int *handle;
-
-  if (!ply_open_unidirectional_pipe (&sender_fd, &receiver_fd))
-    return NULL;
-
-
-  pid = fork ();
-
-  if (pid < 0)
-    return NULL;
-
-  if (pid != 0)
-    {
-      uint8_t byte;
-      close (sender_fd);
-
-      if (!ply_read (receiver_fd, &byte, sizeof (uint8_t)))
-        {
-          int read_error = errno;
-          int status;
-
-          if (waitpid (pid, &status, WNOHANG) <= 0)
-            {
-              ply_error ("failed to read status from child immediately after starting to daemonize: %s", strerror (read_error));
-            }
-          else if (WIFEXITED (status))
-            {
-              ply_error ("unexpectedly exited with status %d immediately after starting to daemonize", (int) WEXITSTATUS (status));
-            }
-          else if (WIFSIGNALED (status))
-            {
-              ply_error ("unexpectedly died from signal %s immediately after starting to daemonize", strsignal (WTERMSIG (status)));
-            }
-          _exit (1);
-        }
+        pid_t pid;
+        int sender_fd, receiver_fd;
+        int *handle;
+
+        if (!ply_open_unidirectional_pipe (&sender_fd, &receiver_fd))
+                return NULL;
+
 
-      _exit ((int) byte);
-    }
-  close (receiver_fd);
+        pid = fork ();
 
-  handle = calloc (1, sizeof (int));
-  *handle = sender_fd;
+        if (pid < 0)
+                return NULL;
+
+        if (pid != 0) {
+                uint8_t byte;
+                close (sender_fd);
+
+                if (!ply_read (receiver_fd, &byte, sizeof(uint8_t))) {
+                        int read_error = errno;
+                        int status;
+
+                        if (waitpid (pid, &status, WNOHANG) <= 0)
+                                ply_error ("failed to read status from child immediately after starting to daemonize: %s", strerror (read_error));
+                        else if (WIFEXITED (status))
+                                ply_error ("unexpectedly exited with status %d immediately after starting to daemonize", (int) WEXITSTATUS (status));
+                        else if (WIFSIGNALED (status))
+                                ply_error ("unexpectedly died from signal %s immediately after starting to daemonize", strsignal (WTERMSIG (status)));
+                        _exit (1);
+                }
+
+                _exit ((int) byte);
+        }
+        close (receiver_fd);
 
-  return (ply_daemon_handle_t *) handle;
+        handle = calloc (1, sizeof(int));
+        *handle = sender_fd;
+
+        return (ply_daemon_handle_t *) handle;
 }
 
 bool
 ply_detach_daemon (ply_daemon_handle_t *handle,
                    int                  exit_code)
 {
-  int sender_fd;
-  uint8_t byte;
+        int sender_fd;
+        uint8_t byte;
 
-  assert (handle != NULL);
-  assert (exit_code >= 0 && exit_code < 256);
+        assert (handle != NULL);
+        assert (exit_code >= 0 && exit_code < 256);
 
-  sender_fd = *(int *) handle;
+        sender_fd = *(int *) handle;
 
-  byte = (uint8_t) exit_code;
+        byte = (uint8_t) exit_code;
 
-  if (!ply_write (sender_fd, &byte, sizeof (uint8_t)))
-    return false;
+        if (!ply_write (sender_fd, &byte, sizeof(uint8_t)))
+                return false;
 
-  close (sender_fd);
-  free (handle);
+        close (sender_fd);
+        free (handle);
 
-  return true;
+        return true;
 }
 
 
 /*                    UTF-8 encoding
-00000000-01111111 	00-7F 	US-ASCII (single byte)
-10000000-10111111 	80-BF 	Second, third, or fourth byte of a multi-byte sequence
-11000000-11011111 	C0-DF 	Start of 2-byte sequence
-11100000-11101111 	E0-EF 	Start of 3-byte sequence
-11110000-11110100 	F0-F4 	Start of 4-byte sequence
-*/
-
+ * 00000000-01111111    00-7F   US-ASCII (single byte)
+ * 10000000-10111111    80-BF   Second, third, or fourth byte of a multi-byte sequence
+ * 11000000-11011111    C0-DF   Start of 2-byte sequence
+ * 11100000-11101111    E0-EF   Start of 3-byte sequence
+ * 11110000-11110100    F0-F4   Start of 4-byte sequence
+ */
 int
-ply_utf8_character_get_size (const char   *string,
-                             size_t        n)
+ply_utf8_character_get_size (const char *string,
+                             size_t      n)
 {
-  int length;
-  if (n < 1) return -1;
-  if (string[0] == 0x00) length = 0;
-  else if ((string[0] & 0x80) == 0x00) length = 1;
-  else if ((string[0] & 0xE0) == 0xC0) length = 2;
-  else if ((string[0] & 0xF0) == 0xE0) length = 3;
-  else if ((string[0] & 0xF8) == 0xF0) length = 4;
-  else return -2;
-  if (length > (int) n) return -1;
-  return length;
+        int length;
+
+        if (n < 1) return -1;
+        if (string[0] == 0x00) length = 0;
+        else if ((string[0] & 0x80) == 0x00) length = 1;
+        else if ((string[0] & 0xE0) == 0xC0) length = 2;
+        else if ((string[0] & 0xF0) == 0xE0) length = 3;
+        else if ((string[0] & 0xF8) == 0xF0) length = 4;
+        else return -2;
+        if (length > (int) n) return -1;
+        return length;
 }
 
 int
-ply_utf8_string_get_length (const char   *string,
-                            size_t        n)
+ply_utf8_string_get_length (const char *string,
+                            size_t      n)
 {
-  size_t count = 0;
-  while (true)
-    {
-      int charlen = ply_utf8_character_get_size(string, n);
-      if (charlen <= 0) break;
-      string += charlen;
-      n -= charlen;
-      count++;
-    }
-  return count;
+        size_t count = 0;
+
+        while (true) {
+                int charlen = ply_utf8_character_get_size (string, n);
+                if (charlen <= 0) break;
+                string += charlen;
+                n -= charlen;
+                count++;
+        }
+        return count;
 }
 
 char *
 ply_get_process_command_line (pid_t pid)
 {
-  char *path;
-  char *command_line;
-  ssize_t bytes_read;
-  int fd;
-  ssize_t i;
-
-  path = NULL;
-  command_line = NULL;
-
-  asprintf (&path, "/proc/%ld/cmdline", (long) pid);
-
-  fd = open (path, O_RDONLY);
-
-  if (fd < 0)
-    {
-      ply_trace ("Could not open %s: %m", path);
-      goto error;
-    }
-
-  command_line = calloc (PLY_MAX_COMMAND_LINE_SIZE, sizeof (char));
-  bytes_read = read (fd, command_line, PLY_MAX_COMMAND_LINE_SIZE - 1);
-  if (bytes_read < 0)
-    {
-      ply_trace ("Could not read %s: %m", path);
-      close (fd);
-      goto error;
-    }
-  close (fd);
-  free (path);
-
-  for (i = 0; i < bytes_read - 1; i++)
-    {
-      if (command_line[i] == '\0')
-        command_line[i] = ' ';
-    }
-  command_line[i] = '\0';
-
-  return command_line;
+        char *path;
+        char *command_line;
+        ssize_t bytes_read;
+        int fd;
+        ssize_t i;
+
+        path = NULL;
+        command_line = NULL;
+
+        asprintf (&path, "/proc/%ld/cmdline", (long) pid);
+
+        fd = open (path, O_RDONLY);
+
+        if (fd < 0) {
+                ply_trace ("Could not open %s: %m", path);
+                goto error;
+        }
+
+        command_line = calloc (PLY_MAX_COMMAND_LINE_SIZE, sizeof(char));
+        bytes_read = read (fd, command_line, PLY_MAX_COMMAND_LINE_SIZE - 1);
+        if (bytes_read < 0) {
+                ply_trace ("Could not read %s: %m", path);
+                close (fd);
+                goto error;
+        }
+        close (fd);
+        free (path);
+
+        for (i = 0; i < bytes_read - 1; i++) {
+                if (command_line[i] == '\0')
+                        command_line[i] = ' ';
+        }
+        command_line[i] = '\0';
+
+        return command_line;
 
 error:
-  free (path);
-  free (command_line);
-  return NULL;
+        free (path);
+        free (command_line);
+        return NULL;
 }
 
 pid_t
 ply_get_process_parent_pid (pid_t pid)
 {
-  char *path;
-  FILE *fp;
-  int ppid;
+        char *path;
+        FILE *fp;
+        int ppid;
 
-  asprintf (&path, "/proc/%ld/stat", (long) pid);
+        asprintf (&path, "/proc/%ld/stat", (long) pid);
 
-  ppid = 0;
-  fp = fopen (path, "re");
+        ppid = 0;
+        fp = fopen (path, "re");
 
-  if (fp == NULL)
-    {
-      ply_trace ("Could not open %s: %m", path);
-      goto out;
-    }
+        if (fp == NULL) {
+                ply_trace ("Could not open %s: %m", path);
+                goto out;
+        }
 
-  if (fscanf (fp, "%*d %*s %*c %d", &ppid) != 1)
-    {
-      ply_trace ("Could not parse %s: %m", path);
-      goto out;
-    }
+        if (fscanf (fp, "%*d %*s %*c %d", &ppid) != 1) {
+                ply_trace ("Could not parse %s: %m", path);
+                goto out;
+        }
 
-  if (ppid <= 0)
-    {
-      ply_trace ("%s is returning invalid parent pid %d", path, ppid);
-      ppid = 0;
-      goto out;
-    }
+        if (ppid <= 0) {
+                ply_trace ("%s is returning invalid parent pid %d", path, ppid);
+                ppid = 0;
+                goto out;
+        }
 
 out:
-  free (path);
+        free (path);
 
-  if (fp != NULL)
-    fclose (fp);
+        if (fp != NULL)
+                fclose (fp);
 
-  return (pid_t) ppid;
+        return (pid_t) ppid;
 }
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/libply/ply-utils.h b/src/libply/ply-utils.h
index abe332a..b9a28d0 100644
--- a/src/libply/ply-utils.h
+++ b/src/libply/ply-utils.h
@@ -28,29 +28,29 @@
 #include <sys/types.h>
 
 #ifndef MIN
-#define MIN(a,b) ((a) <= (b)? (a) : (b))
+#define MIN(a, b) ((a) <= (b) ? (a) : (b))
 #endif
 
 #ifndef MAX
-#define MAX(a,b) ((a) >= (b)? (a) : (b))
+#define MAX(a, b) ((a) >= (b) ? (a) : (b))
 #endif
 
 #ifndef CLAMP
-#define CLAMP(a,b,c) (MIN (MAX ((a), (b)), (c)))
+#define CLAMP(a, b, c) (MIN (MAX ((a), (b)), (c)))
 #endif
 
 #define PLY_UTF8_CHARACTER_SIZE_MAX 4
 
 typedef intptr_t ply_module_handle_t;
-typedef void (* ply_module_function_t) (void);
+typedef void (*ply_module_function_t) (void);
 
 typedef intptr_t ply_daemon_handle_t;
 
 typedef enum
 {
-  PLY_UNIX_SOCKET_TYPE_CONCRETE = 0,
-  PLY_UNIX_SOCKET_TYPE_ABSTRACT,
-  PLY_UNIX_SOCKET_TYPE_TRIMMED_ABSTRACT
+        PLY_UNIX_SOCKET_TYPE_CONCRETE = 0,
+        PLY_UNIX_SOCKET_TYPE_ABSTRACT,
+        PLY_UNIX_SOCKET_TYPE_TRIMMED_ABSTRACT
 } ply_unix_socket_type_t;
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
@@ -59,10 +59,10 @@ typedef enum
 
 bool ply_open_unidirectional_pipe (int *sender_fd,
                                    int *receiver_fd);
-int ply_connect_to_unix_socket (const char             *path,
-                                ply_unix_socket_type_t  type);
-int ply_listen_to_unix_socket (const char *path,
-                                ply_unix_socket_type_t  type);
+int ply_connect_to_unix_socket (const char            *path,
+                                ply_unix_socket_type_t type);
+int ply_listen_to_unix_socket (const char            *path,
+                               ply_unix_socket_type_t type);
 bool ply_get_credentials_from_fd (int    fd,
                                   pid_t *pid,
                                   uid_t *uid,
@@ -70,19 +70,19 @@ bool ply_get_credentials_from_fd (int    fd,
 
 bool ply_write (int         fd,
                 const void *buffer,
-                size_t      number_of_bytes); 
+                size_t      number_of_bytes);
 bool ply_write_uint32 (int      fd,
                        uint32_t value);
-bool ply_read (int     fd,
-               void   *buffer,
-               size_t  number_of_bytes); 
+bool ply_read (int    fd,
+               void  *buffer,
+               size_t number_of_bytes);
 bool ply_read_uint32 (int       fd,
                       uint32_t *value);
 
 bool ply_fd_has_data (int fd);
 bool ply_fd_can_take_data (int fd);
 bool ply_fd_may_block (int fd);
-char **ply_copy_string_array (const char * const *array);
+char **ply_copy_string_array (const char *const *array);
 void ply_free_string_array (char **array);
 bool ply_string_has_prefix (const char *string,
                             const char *prefix);
@@ -100,7 +100,7 @@ ply_module_handle_t *ply_open_module (const char *module_path);
 ply_module_handle_t *ply_open_built_in_module (void);
 
 ply_module_function_t ply_module_look_up_function (ply_module_handle_t *handle,
-                                                   const char  *function_name);
+                                                   const char          *function_name);
 void ply_close_module (ply_module_handle_t *handle);
 
 bool ply_create_directory (const char *directory);
@@ -112,10 +112,10 @@ ply_daemon_handle_t *ply_create_daemon (void);
 bool ply_detach_daemon (ply_daemon_handle_t *handle,
                         int                  exit_code);
 
-int ply_utf8_character_get_size (const char   *string,
-                                 size_t        n);
-int ply_utf8_string_get_length (const char   *string,
-                                size_t        n);
+int ply_utf8_character_get_size (const char *string,
+                                 size_t      n);
+int ply_utf8_string_get_length (const char *string,
+                                size_t      n);
 
 char *ply_get_process_command_line (pid_t pid);
 pid_t ply_get_process_parent_pid (pid_t pid);
diff --git a/src/main.c b/src/main.c
index c3daac0..ab9e1f9 100644
--- a/src/main.c
+++ b/src/main.c
@@ -63,69 +63,70 @@
 #define BOOT_DURATION_FILE     PLYMOUTH_TIME_DIRECTORY "/boot-duration"
 #define SHUTDOWN_DURATION_FILE PLYMOUTH_TIME_DIRECTORY "/shutdown-duration"
 
-typedef enum {
-  PLY_MODE_BOOT,
-  PLY_MODE_SHUTDOWN,
-  PLY_MODE_UPDATES
+typedef enum
+{
+        PLY_MODE_BOOT,
+        PLY_MODE_SHUTDOWN,
+        PLY_MODE_UPDATES
 } ply_mode_t;
 
-typedef struct 
+typedef struct
 {
-  const char    *keys;
-  ply_trigger_t *trigger;
+        const char    *keys;
+        ply_trigger_t *trigger;
 } ply_keystroke_watch_t;
 
-typedef struct 
+typedef struct
 {
-  enum {PLY_ENTRY_TRIGGER_TYPE_PASSWORD,
-        PLY_ENTRY_TRIGGER_TYPE_QUESTION}
+        enum { PLY_ENTRY_TRIGGER_TYPE_PASSWORD,
+               PLY_ENTRY_TRIGGER_TYPE_QUESTION }
         type;
-  const char    *prompt;
-  ply_trigger_t *trigger;
+        const char    *prompt;
+        ply_trigger_t *trigger;
 } ply_entry_trigger_t;
 
 typedef struct
 {
-  ply_event_loop_t *loop;
-  ply_boot_server_t *boot_server;
-  ply_boot_splash_t *boot_splash;
-  ply_terminal_session_t *session;
-  ply_buffer_t *boot_buffer;
-  ply_progress_t *progress;
-  ply_list_t *keystroke_triggers;
-  ply_list_t *entry_triggers;
-  ply_buffer_t *entry_buffer;
-  ply_list_t *messages;
-  ply_command_parser_t *command_parser;
-  ply_mode_t mode;
-  ply_terminal_t *local_console_terminal;
-  ply_device_manager_t *device_manager;
-
-  ply_trigger_t *deactivate_trigger;
-  ply_trigger_t *quit_trigger;
-
-  double start_time;
-  double splash_delay;
-
-  char kernel_command_line[PLY_MAX_COMMAND_LINE_SIZE];
-  uint32_t kernel_command_line_is_set : 1;
-  uint32_t no_boot_log : 1;
-  uint32_t showing_details : 1;
-  uint32_t system_initialized : 1;
-  uint32_t is_redirected : 1;
-  uint32_t is_attached : 1;
-  uint32_t should_be_attached : 1;
-  uint32_t should_retain_splash : 1;
-  uint32_t is_inactive : 1;
-  uint32_t is_shown : 1;
-  uint32_t should_force_details : 1;
-
-  char *override_splash_path;
-  char *system_default_splash_path;
-  char *distribution_default_splash_path;
-  const char *default_tty;
-
-  int number_of_errors;
+        ply_event_loop_t       *loop;
+        ply_boot_server_t      *boot_server;
+        ply_boot_splash_t      *boot_splash;
+        ply_terminal_session_t *session;
+        ply_buffer_t           *boot_buffer;
+        ply_progress_t         *progress;
+        ply_list_t             *keystroke_triggers;
+        ply_list_t             *entry_triggers;
+        ply_buffer_t           *entry_buffer;
+        ply_list_t             *messages;
+        ply_command_parser_t   *command_parser;
+        ply_mode_t              mode;
+        ply_terminal_t         *local_console_terminal;
+        ply_device_manager_t   *device_manager;
+
+        ply_trigger_t          *deactivate_trigger;
+        ply_trigger_t          *quit_trigger;
+
+        double                  start_time;
+        double                  splash_delay;
+
+        char                    kernel_command_line[PLY_MAX_COMMAND_LINE_SIZE];
+        uint32_t                kernel_command_line_is_set : 1;
+        uint32_t                no_boot_log : 1;
+        uint32_t                showing_details : 1;
+        uint32_t                system_initialized : 1;
+        uint32_t                is_redirected : 1;
+        uint32_t                is_attached : 1;
+        uint32_t                should_be_attached : 1;
+        uint32_t                should_retain_splash : 1;
+        uint32_t                is_inactive : 1;
+        uint32_t                is_shown : 1;
+        uint32_t                should_force_details : 1;
+
+        char                   *override_splash_path;
+        char                   *system_default_splash_path;
+        char                   *distribution_default_splash_path;
+        const char             *default_tty;
+
+        int                     number_of_errors;
 } state_t;
 
 static void show_splash (state_t *state);
@@ -154,7 +155,7 @@ static void toggle_between_splash_and_details (state_t *state);
 static void tell_systemd_to_print_details (state_t *state);
 static void tell_systemd_to_stop_printing_details (state_t *state);
 #endif
-static const char * get_cache_file_for_mode (ply_mode_t mode);
+static const char *get_cache_file_for_mode (ply_mode_t mode);
 static void on_escape_pressed (state_t *state);
 static void on_enter (state_t    *state,
                       const char *line);
@@ -168,1132 +169,1050 @@ on_session_output (state_t    *state,
                    const char *output,
                    size_t      size)
 {
-  ply_buffer_append_bytes (state->boot_buffer, output, size);
-  if (state->boot_splash != NULL)
-    ply_boot_splash_update_output (state->boot_splash,
-                                   output, size);
+        ply_buffer_append_bytes (state->boot_buffer, output, size);
+        if (state->boot_splash != NULL)
+                ply_boot_splash_update_output (state->boot_splash,
+                                               output, size);
 }
 
 static void
 on_session_hangup (state_t *state)
 {
-  ply_trace ("got hang up on terminal session fd");
+        ply_trace ("got hang up on terminal session fd");
 }
 
 static void
-on_update (state_t     *state,
-           const char  *status)
+on_update (state_t    *state,
+           const char *status)
 {
-  ply_trace ("updating status to '%s'", status);
-  ply_progress_status_update (state->progress,
-                               status);
-  if (state->boot_splash != NULL)
-    ply_boot_splash_update_status (state->boot_splash,
-                                   status);
+        ply_trace ("updating status to '%s'", status);
+        ply_progress_status_update (state->progress,
+                                    status);
+        if (state->boot_splash != NULL)
+                ply_boot_splash_update_status (state->boot_splash,
+                                               status);
 }
 
 static void
-on_change_mode (state_t     *state,
-                const char  *mode)
-{
-  if (state->boot_splash == NULL)
-    {
-      ply_trace ("no splash set");
-      return;
-    }
-
-  ply_trace ("updating mode to '%s'", mode);
-  if (strcmp (mode, "boot-up") == 0)
-    state->mode = PLY_BOOT_SPLASH_MODE_BOOT_UP;
-  else if (strcmp (mode, "shutdown") == 0)
-    state->mode = PLY_BOOT_SPLASH_MODE_SHUTDOWN;
-  else if (strcmp (mode, "updates") == 0)
-    state->mode = PLY_BOOT_SPLASH_MODE_UPDATES;
-  else
-    return;
-
-  if (!ply_boot_splash_show (state->boot_splash, state->mode))
-    {
-      ply_trace ("failed to update splash");
-      return;
-    }
+on_change_mode (state_t    *state,
+                const char *mode)
+{
+        if (state->boot_splash == NULL) {
+                ply_trace ("no splash set");
+                return;
+        }
+
+        ply_trace ("updating mode to '%s'", mode);
+        if (strcmp (mode, "boot-up") == 0)
+                state->mode = PLY_BOOT_SPLASH_MODE_BOOT_UP;
+        else if (strcmp (mode, "shutdown") == 0)
+                state->mode = PLY_BOOT_SPLASH_MODE_SHUTDOWN;
+        else if (strcmp (mode, "updates") == 0)
+                state->mode = PLY_BOOT_SPLASH_MODE_UPDATES;
+        else
+                return;
+
+        if (!ply_boot_splash_show (state->boot_splash, state->mode)) {
+                ply_trace ("failed to update splash");
+                return;
+        }
 }
 
 static void
-on_system_update (state_t     *state,
-                  int          progress)
+on_system_update (state_t *state,
+                  int      progress)
 {
-  if (state->boot_splash == NULL)
-    {
-      ply_trace ("no splash set");
-      return;
-    }
+        if (state->boot_splash == NULL) {
+                ply_trace ("no splash set");
+                return;
+        }
 
-  ply_trace ("setting system update to '%i'", progress);
-  if (!ply_boot_splash_system_update (state->boot_splash, progress))
-    {
-      ply_trace ("failed to update splash");
-      return;
-    }
+        ply_trace ("setting system update to '%i'", progress);
+        if (!ply_boot_splash_system_update (state->boot_splash, progress)) {
+                ply_trace ("failed to update splash");
+                return;
+        }
 }
 
 static void
 show_messages (state_t *state)
 {
-  if (state->boot_splash == NULL)
-    {
-      ply_trace ("not displaying messages, since no boot splash");
-      return;
-    }
+        if (state->boot_splash == NULL) {
+                ply_trace ("not displaying messages, since no boot splash");
+                return;
+        }
 
-  ply_list_node_t *node = ply_list_get_first_node (state->messages);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      char *message = ply_list_node_get_data (node);
+        ply_list_node_t *node = ply_list_get_first_node (state->messages);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                char *message = ply_list_node_get_data (node);
 
-      ply_trace ("displaying messages");
+                ply_trace ("displaying messages");
 
-      ply_boot_splash_display_message (state->boot_splash, message);
-      next_node = ply_list_get_next_node (state->messages, node);
-      node = next_node;
-    }
+                ply_boot_splash_display_message (state->boot_splash, message);
+                next_node = ply_list_get_next_node (state->messages, node);
+                node = next_node;
+        }
 }
 
 static bool
-load_settings (state_t     *state,
-               const char  *path,
-               char       **theme_path)
+load_settings (state_t    *state,
+               const char *path,
+               char      **theme_path)
 {
-  ply_key_file_t *key_file = NULL;
-  const char *delay_string;
-  bool settings_loaded = false;
-  const char *splash_string;
+        ply_key_file_t *key_file = NULL;
+        const char *delay_string;
+        bool settings_loaded = false;
+        const char *splash_string;
 
-  ply_trace ("Trying to load %s", path);
-  key_file = ply_key_file_new (path);
+        ply_trace ("Trying to load %s", path);
+        key_file = ply_key_file_new (path);
 
-  if (!ply_key_file_load (key_file))
-    goto out;
+        if (!ply_key_file_load (key_file))
+                goto out;
 
-  splash_string = ply_key_file_get_value (key_file, "Daemon", "Theme");
+        splash_string = ply_key_file_get_value (key_file, "Daemon", "Theme");
 
-  if (splash_string == NULL)
-    goto out;
+        if (splash_string == NULL)
+                goto out;
 
-  asprintf (theme_path,
-            PLYMOUTH_THEME_PATH "%s/%s.plymouth",
-            splash_string, splash_string);
+        asprintf (theme_path,
+                  PLYMOUTH_THEME_PATH "%s/%s.plymouth",
+                  splash_string, splash_string);
 
-  if (isnan (state->splash_delay))
-    {
-      delay_string = ply_key_file_get_value (key_file, "Daemon", "ShowDelay");
+        if (isnan (state->splash_delay)) {
+                delay_string = ply_key_file_get_value (key_file, "Daemon", "ShowDelay");
 
-      if (delay_string != NULL)
-        {
-          state->splash_delay = atof (delay_string);
-          ply_trace ("Splash delay is set to %lf", state->splash_delay);
+                if (delay_string != NULL) {
+                        state->splash_delay = atof (delay_string);
+                        ply_trace ("Splash delay is set to %lf", state->splash_delay);
+                }
         }
-    }
 
-  settings_loaded = true;
+        settings_loaded = true;
 out:
-  ply_key_file_free (key_file);
+        ply_key_file_free (key_file);
 
-  return settings_loaded;
+        return settings_loaded;
 }
 
 static void
 show_detailed_splash (state_t *state)
 {
-  ply_boot_splash_t *splash;
+        ply_boot_splash_t *splash;
 
-  if (state->boot_splash != NULL)
-    return;
+        if (state->boot_splash != NULL)
+                return;
 
-  ply_trace ("Showing detailed splash screen");
-  splash = show_theme (state, NULL);
+        ply_trace ("Showing detailed splash screen");
+        splash = show_theme (state, NULL);
 
-  if (splash == NULL)
-    {
-      ply_trace ("Could not start detailed splash screen, this could be a problem.");
-      return;
-    }
+        if (splash == NULL) {
+                ply_trace ("Could not start detailed splash screen, this could be a problem.");
+                return;
+        }
 
-  state->boot_splash = splash;
-  update_display (state);
+        state->boot_splash = splash;
+        update_display (state);
 }
 
 static const char *
 command_line_get_string_after_prefix (const char *command_line,
                                       const char *prefix)
 {
-  char *argument;
+        char *argument;
 
-  argument = strstr (command_line, prefix);
+        argument = strstr (command_line, prefix);
 
-  if (argument == NULL)
-    return NULL;
+        if (argument == NULL)
+                return NULL;
 
-  if (argument == command_line ||
-      argument[-1] == ' ')
-    return argument + strlen (prefix);
+        if (argument == command_line ||
+            argument[-1] == ' ')
+                return argument + strlen (prefix);
 
-  return NULL;
+        return NULL;
 }
 
 static bool
 command_line_has_argument (const char *command_line,
                            const char *argument)
 {
-    const char *string;
+        const char *string;
 
-    string = command_line_get_string_after_prefix (command_line, argument);
+        string = command_line_get_string_after_prefix (command_line, argument);
 
-    if (string == NULL)
-      return false;
+        if (string == NULL)
+                return false;
 
-    if (!isspace ((int) string[0]) && string[0] != '\0')
-      return false;
+        if (!isspace ((int) string[0]) && string[0] != '\0')
+                return false;
 
-    return true;
+        return true;
 }
 
 static void
 find_override_splash (state_t *state)
 {
-  const char *splash_string;
+        const char *splash_string;
 
-  if (state->override_splash_path != NULL)
-      return;
+        if (state->override_splash_path != NULL)
+                return;
 
-  splash_string = command_line_get_string_after_prefix (state->kernel_command_line,
-                                                        "plymouth.splash=");
+        splash_string = command_line_get_string_after_prefix (state->kernel_command_line,
+                                                              "plymouth.splash=");
 
-  if (splash_string != NULL)
-    {
-      const char *end;
-      int length;
+        if (splash_string != NULL) {
+                const char *end;
+                int length;
 
-      end = splash_string + strcspn (splash_string, " \n");
-      length = end - splash_string;
+                end = splash_string + strcspn (splash_string, " \n");
+                length = end - splash_string;
 
-      ply_trace ("Splash is configured to be '%*.*s'", length, length, splash_string);
+                ply_trace ("Splash is configured to be '%*.*s'", length, length, splash_string);
 
-      asprintf (&state->override_splash_path,
-                PLYMOUTH_THEME_PATH "%*.*s/%*.*s.plymouth",
-                length, length, splash_string, length, length, splash_string);
-    }
+                asprintf (&state->override_splash_path,
+                          PLYMOUTH_THEME_PATH "%*.*s/%*.*s.plymouth",
+                          length, length, splash_string, length, length, splash_string);
+        }
 
-  if (isnan (state->splash_delay))
-    {
-      const char *delay_string;
+        if (isnan (state->splash_delay)) {
+                const char *delay_string;
 
-      delay_string = command_line_get_string_after_prefix (state->kernel_command_line, "plymouth.splash-delay=");
+                delay_string = command_line_get_string_after_prefix (state->kernel_command_line, "plymouth.splash-delay=");
 
-      if (delay_string != NULL)
-        state->splash_delay = atof (delay_string);
-    }
+                if (delay_string != NULL)
+                        state->splash_delay = atof (delay_string);
+        }
 }
 
 static void
 find_system_default_splash (state_t *state)
 {
-  if (state->system_default_splash_path != NULL)
-      return;
+        if (state->system_default_splash_path != NULL)
+                return;
 
-  if (!load_settings (state, PLYMOUTH_CONF_DIR "plymouthd.conf", &state->system_default_splash_path))
-    {
-      ply_trace ("failed to load " PLYMOUTH_CONF_DIR "plymouthd.conf");
-      return;
-    }
+        if (!load_settings (state, PLYMOUTH_CONF_DIR "plymouthd.conf", &state->system_default_splash_path)) {
+                ply_trace ("failed to load " PLYMOUTH_CONF_DIR "plymouthd.conf");
+                return;
+        }
 
-  ply_trace ("System configured theme file is '%s'", state->system_default_splash_path);
+        ply_trace ("System configured theme file is '%s'", state->system_default_splash_path);
 }
 
 static void
 find_distribution_default_splash (state_t *state)
 {
-  if (state->distribution_default_splash_path != NULL)
-      return;
+        if (state->distribution_default_splash_path != NULL)
+                return;
 
-  if (!load_settings (state, PLYMOUTH_POLICY_DIR "plymouthd.defaults", &state->distribution_default_splash_path))
-    {
-      ply_trace ("failed to load " PLYMOUTH_POLICY_DIR "plymouthd.defaults");
-      return;
-    }
+        if (!load_settings (state, PLYMOUTH_POLICY_DIR "plymouthd.defaults", &state->distribution_default_splash_path)) {
+                ply_trace ("failed to load " PLYMOUTH_POLICY_DIR "plymouthd.defaults");
+                return;
+        }
 
-  ply_trace ("Distribution default theme file is '%s'", state->distribution_default_splash_path);
+        ply_trace ("Distribution default theme file is '%s'", state->distribution_default_splash_path);
 }
 
 static void
 show_default_splash (state_t *state)
 {
-  if (state->boot_splash != NULL)
-    return;
-
-  ply_trace ("Showing splash screen");
-  if (state->override_splash_path != NULL)
-    {
-      ply_trace ("Trying override splash at '%s'", state->override_splash_path);
-      state->boot_splash = show_theme (state, state->override_splash_path);
-    }
-
-  if (state->boot_splash == NULL &&
-      state->system_default_splash_path != NULL)
-    {
-      ply_trace ("Trying system default splash");
-      state->boot_splash = show_theme (state, state->system_default_splash_path);
-    }
-
-  if (state->boot_splash == NULL &&
-      state->distribution_default_splash_path != NULL)
-    {
-      ply_trace ("Trying distribution default splash");
-      state->boot_splash = show_theme (state, state->distribution_default_splash_path);
-    }
-
-  if (state->boot_splash == NULL)
-    {
-      ply_trace ("Trying old scheme for default splash");
-      state->boot_splash = show_theme (state, PLYMOUTH_THEME_PATH "default.plymouth");
-    }
-
-  if (state->boot_splash == NULL)
-    {
-      ply_trace ("Could not start default splash screen,"
-                 "showing text splash screen");
-      state->boot_splash = show_theme (state, PLYMOUTH_THEME_PATH "text/text.plymouth");
-    }
-
-  if (state->boot_splash == NULL)
-    {
-      ply_trace ("Could not start text splash screen,"
-                 "showing built-in splash screen");
-      state->boot_splash = show_theme (state, NULL);
-    }
-
-  if (state->boot_splash == NULL)
-    {
-      ply_error ("plymouthd: could not start boot splash: %m");
-      return;
-    }
-
-  update_display (state);
+        if (state->boot_splash != NULL)
+                return;
+
+        ply_trace ("Showing splash screen");
+        if (state->override_splash_path != NULL) {
+                ply_trace ("Trying override splash at '%s'", state->override_splash_path);
+                state->boot_splash = show_theme (state, state->override_splash_path);
+        }
+
+        if (state->boot_splash == NULL &&
+            state->system_default_splash_path != NULL) {
+                ply_trace ("Trying system default splash");
+                state->boot_splash = show_theme (state, state->system_default_splash_path);
+        }
+
+        if (state->boot_splash == NULL &&
+            state->distribution_default_splash_path != NULL) {
+                ply_trace ("Trying distribution default splash");
+                state->boot_splash = show_theme (state, state->distribution_default_splash_path);
+        }
+
+        if (state->boot_splash == NULL) {
+                ply_trace ("Trying old scheme for default splash");
+                state->boot_splash = show_theme (state, PLYMOUTH_THEME_PATH "default.plymouth");
+        }
+
+        if (state->boot_splash == NULL) {
+                ply_trace ("Could not start default splash screen,"
+                           "showing text splash screen");
+                state->boot_splash = show_theme (state, PLYMOUTH_THEME_PATH "text/text.plymouth");
+        }
+
+        if (state->boot_splash == NULL) {
+                ply_trace ("Could not start text splash screen,"
+                           "showing built-in splash screen");
+                state->boot_splash = show_theme (state, NULL);
+        }
+
+        if (state->boot_splash == NULL) {
+                ply_error ("plymouthd: could not start boot splash: %m");
+                return;
+        }
+
+        update_display (state);
 }
 
 static void
 cancel_pending_delayed_show (state_t *state)
 {
-  if (isnan (state->splash_delay))
-    return;
+        if (isnan (state->splash_delay))
+                return;
 
-  ply_event_loop_stop_watching_for_timeout (state->loop,
-                                            (ply_event_loop_timeout_handler_t)
-                                            show_splash,
-                                            state);
-  state->splash_delay = NAN;
+        ply_event_loop_stop_watching_for_timeout (state->loop,
+                                                  (ply_event_loop_timeout_handler_t)
+                                                  show_splash,
+                                                  state);
+        state->splash_delay = NAN;
 }
 
 static void
-on_ask_for_password (state_t      *state,
-                     const char   *prompt,
+on_ask_for_password (state_t       *state,
+                     const char    *prompt,
                      ply_trigger_t *answer)
 {
-  ply_entry_trigger_t *entry_trigger;
-
-  if (state->boot_splash == NULL)
-    {
-      /* Waiting to be shown, boot splash will
-       * arrive shortly so just sit tight
-       */
-      if (state->is_shown)
-        {
-          bool has_open_seats;
-
-          cancel_pending_delayed_show (state);
-
-          has_open_seats = ply_device_manager_has_open_seats (state->device_manager);
-
-          if (has_open_seats)
-            {
-              ply_trace ("seats open now, showing splash immediately");
-              show_splash (state);
-            }
-          else
-            {
-              ply_trace ("splash still coming up, waiting a bit");
-            }
-        }
-      else
-        {
-          /* No splash, client will have to get password */
-          ply_trace ("no splash loaded, replying immediately with no password");
-          ply_trigger_pull (answer, NULL);
-          return;
+        ply_entry_trigger_t *entry_trigger;
+
+        if (state->boot_splash == NULL) {
+                /* Waiting to be shown, boot splash will
+                 * arrive shortly so just sit tight
+                 */
+                if (state->is_shown) {
+                        bool has_open_seats;
+
+                        cancel_pending_delayed_show (state);
+
+                        has_open_seats = ply_device_manager_has_open_seats (state->device_manager);
+
+                        if (has_open_seats) {
+                                ply_trace ("seats open now, showing splash immediately");
+                                show_splash (state);
+                        } else {
+                                ply_trace ("splash still coming up, waiting a bit");
+                        }
+                } else {
+                        /* No splash, client will have to get password */
+                        ply_trace ("no splash loaded, replying immediately with no password");
+                        ply_trigger_pull (answer, NULL);
+                        return;
+                }
         }
-    }
 
-  entry_trigger = calloc (1, sizeof (ply_entry_trigger_t));
-  entry_trigger->type = PLY_ENTRY_TRIGGER_TYPE_PASSWORD;
-  entry_trigger->prompt = prompt;
-  entry_trigger->trigger = answer;
-  ply_trace ("queuing password request with boot splash");
-  ply_list_append_data (state->entry_triggers, entry_trigger);
-  update_display (state);
+        entry_trigger = calloc (1, sizeof(ply_entry_trigger_t));
+        entry_trigger->type = PLY_ENTRY_TRIGGER_TYPE_PASSWORD;
+        entry_trigger->prompt = prompt;
+        entry_trigger->trigger = answer;
+        ply_trace ("queuing password request with boot splash");
+        ply_list_append_data (state->entry_triggers, entry_trigger);
+        update_display (state);
 }
 
 static void
-on_ask_question (state_t      *state,
-                 const char   *prompt,
+on_ask_question (state_t       *state,
+                 const char    *prompt,
                  ply_trigger_t *answer)
 {
-  ply_entry_trigger_t *entry_trigger;
+        ply_entry_trigger_t *entry_trigger;
 
-  entry_trigger = calloc (1, sizeof (ply_entry_trigger_t));
-  entry_trigger->type = PLY_ENTRY_TRIGGER_TYPE_QUESTION;
-  entry_trigger->prompt = prompt;
-  entry_trigger->trigger = answer;
-  ply_trace ("queuing question with boot splash");
-  ply_list_append_data (state->entry_triggers, entry_trigger);
-  update_display (state);
+        entry_trigger = calloc (1, sizeof(ply_entry_trigger_t));
+        entry_trigger->type = PLY_ENTRY_TRIGGER_TYPE_QUESTION;
+        entry_trigger->prompt = prompt;
+        entry_trigger->trigger = answer;
+        ply_trace ("queuing question with boot splash");
+        ply_list_append_data (state->entry_triggers, entry_trigger);
+        update_display (state);
 }
 
 static void
-on_display_message (state_t       *state,
-                    const char    *message)
+on_display_message (state_t    *state,
+                    const char *message)
 {
-  if (state->boot_splash != NULL)
-    {
-        ply_trace ("displaying message %s", message);
-        ply_boot_splash_display_message (state->boot_splash, message);
-    }
-  else
-    ply_trace ("not displaying message %s as no splash", message);
-  ply_list_append_data (state->messages, strdup(message));
-}
-
-static void
-on_hide_message (state_t       *state,
-                 const char    *message)
-{
-  ply_list_node_t *node;
-  
-  ply_trace ("hiding message %s", message);
-  
-  node = ply_list_get_first_node (state->messages);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      char *list_message;
-
-      list_message = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (state->messages, node);
-
-      if (strcmp (list_message, message) == 0)
-        {
-          free (list_message);
-          ply_list_remove_node (state->messages, node);
-          ply_boot_splash_hide_message (state->boot_splash, message);
+        if (state->boot_splash != NULL) {
+                ply_trace ("displaying message %s", message);
+                ply_boot_splash_display_message (state->boot_splash, message);
+        } else {
+                ply_trace ("not displaying message %s as no splash", message);
         }
-      node = next_node;
-    }
+        ply_list_append_data (state->messages, strdup (message));
 }
 
 static void
-on_watch_for_keystroke (state_t      *state,
-                     const char    *keys,
-                     ply_trigger_t *trigger)
+on_hide_message (state_t    *state,
+                 const char *message)
 {
-  ply_keystroke_watch_t *keystroke_trigger =
-                                  calloc (1, sizeof (ply_keystroke_watch_t));
-  ply_trace ("watching for keystroke");
-  keystroke_trigger->keys = keys;
-  keystroke_trigger->trigger = trigger;
-  ply_list_append_data (state->keystroke_triggers, keystroke_trigger);
+        ply_list_node_t *node;
+
+        ply_trace ("hiding message %s", message);
+
+        node = ply_list_get_first_node (state->messages);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                char *list_message;
+
+                list_message = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (state->messages, node);
+
+                if (strcmp (list_message, message) == 0) {
+                        free (list_message);
+                        ply_list_remove_node (state->messages, node);
+                        ply_boot_splash_hide_message (state->boot_splash, message);
+                }
+                node = next_node;
+        }
 }
 
 static void
-on_ignore_keystroke (state_t      *state,
-                     const char    *keys)
+on_watch_for_keystroke (state_t       *state,
+                        const char    *keys,
+                        ply_trigger_t *trigger)
 {
-  ply_list_node_t *node;
+        ply_keystroke_watch_t *keystroke_trigger =
+                calloc (1, sizeof(ply_keystroke_watch_t));
 
-  ply_trace ("ignoring for keystroke");
+        ply_trace ("watching for keystroke");
+        keystroke_trigger->keys = keys;
+        keystroke_trigger->trigger = trigger;
+        ply_list_append_data (state->keystroke_triggers, keystroke_trigger);
+}
 
-  for (node = ply_list_get_first_node (state->keystroke_triggers); node;
-                    node = ply_list_get_next_node (state->keystroke_triggers, node))
-    {
-      ply_keystroke_watch_t* keystroke_trigger = ply_list_node_get_data (node);
-      if ((!keystroke_trigger->keys && !keys) ||
-          (keystroke_trigger->keys && keys && strcmp(keystroke_trigger->keys, keys)==0))
-        {
-          ply_trigger_pull (keystroke_trigger->trigger, NULL);
-          ply_list_remove_node (state->keystroke_triggers, node);
-          return;
+static void
+on_ignore_keystroke (state_t    *state,
+                     const char *keys)
+{
+        ply_list_node_t *node;
+
+        ply_trace ("ignoring for keystroke");
+
+        for (node = ply_list_get_first_node (state->keystroke_triggers); node;
+             node = ply_list_get_next_node (state->keystroke_triggers, node)) {
+                ply_keystroke_watch_t *keystroke_trigger = ply_list_node_get_data (node);
+                if ((!keystroke_trigger->keys && !keys) ||
+                    (keystroke_trigger->keys && keys && strcmp (keystroke_trigger->keys, keys) == 0)) {
+                        ply_trigger_pull (keystroke_trigger->trigger, NULL);
+                        ply_list_remove_node (state->keystroke_triggers, node);
+                        return;
+                }
         }
-    }
 }
 
 static void
 on_progress_pause (state_t *state)
 {
-  ply_trace ("pausing progress");
-  ply_progress_pause (state->progress);
+        ply_trace ("pausing progress");
+        ply_progress_pause (state->progress);
 }
 
 static void
 on_progress_unpause (state_t *state)
 {
-  ply_trace ("unpausing progress");
-  ply_progress_unpause (state->progress);
+        ply_trace ("unpausing progress");
+        ply_progress_unpause (state->progress);
 }
 
 static void
 on_newroot (state_t    *state,
             const char *root_dir)
 {
-  ply_trace ("new root mounted at \"%s\", switching to it", root_dir);
-  chdir(root_dir);
-  chroot(".");
-  chdir("/");
-  ply_progress_load_cache (state->progress, get_cache_file_for_mode (state->mode));
-  if (state->boot_splash != NULL)
-    ply_boot_splash_root_mounted (state->boot_splash);
+        ply_trace ("new root mounted at \"%s\", switching to it", root_dir);
+        chdir (root_dir);
+        chroot (".");
+        chdir ("/");
+        ply_progress_load_cache (state->progress, get_cache_file_for_mode (state->mode));
+        if (state->boot_splash != NULL)
+                ply_boot_splash_root_mounted (state->boot_splash);
 }
 
 static const char *
 get_cache_file_for_mode (ply_mode_t mode)
 {
-  const char *filename;
-
-  switch ((int)mode)
-    {
-    case PLY_MODE_BOOT:
-      filename = BOOT_DURATION_FILE;
-      break;
-    case PLY_MODE_SHUTDOWN:
-      filename = SHUTDOWN_DURATION_FILE;
-      break;
-    case PLY_MODE_UPDATES:
-      filename = NULL;
-      break;
-    default:
-      ply_error ("Unhandled case in %s line %d\n", __FILE__, __LINE__);
-      abort ();
-      break;
-    }
-
-  ply_trace ("returning cache file '%s'", filename);
-  return filename;
+        const char *filename;
+
+        switch ((int) mode) {
+        case PLY_MODE_BOOT:
+                filename = BOOT_DURATION_FILE;
+                break;
+        case PLY_MODE_SHUTDOWN:
+                filename = SHUTDOWN_DURATION_FILE;
+                break;
+        case PLY_MODE_UPDATES:
+                filename = NULL;
+                break;
+        default:
+                ply_error ("Unhandled case in %s line %d\n", __FILE__, __LINE__);
+                abort ();
+                break;
+        }
+
+        ply_trace ("returning cache file '%s'", filename);
+        return filename;
 }
 
 static const char *
 get_log_file_for_state (state_t *state)
 {
-  const char *filename;
-
-  switch ((int)state->mode)
-    {
-    case PLY_MODE_BOOT:
-      if (state->no_boot_log)
-	filename = NULL;
-      else
-	filename = PLYMOUTH_LOG_DIRECTORY "/boot.log";
-      break;
-    case PLY_MODE_SHUTDOWN:
-    case PLY_MODE_UPDATES:
-      filename = _PATH_DEVNULL;
-      break;
-    default:
-      ply_error ("Unhandled case in %s line %d\n", __FILE__, __LINE__);
-      abort ();
-      break;
-    }
-
-  ply_trace ("returning log file '%s'", filename);
-  return filename;
+        const char *filename;
+
+        switch ((int) state->mode) {
+        case PLY_MODE_BOOT:
+                if (state->no_boot_log)
+                        filename = NULL;
+                else
+                        filename = PLYMOUTH_LOG_DIRECTORY "/boot.log";
+                break;
+        case PLY_MODE_SHUTDOWN:
+        case PLY_MODE_UPDATES:
+                filename = _PATH_DEVNULL;
+                break;
+        default:
+                ply_error ("Unhandled case in %s line %d\n", __FILE__, __LINE__);
+                abort ();
+                break;
+        }
+
+        ply_trace ("returning log file '%s'", filename);
+        return filename;
 }
 
 static const char *
 get_log_spool_file_for_mode (ply_mode_t mode)
 {
-  const char *filename;
-
-  switch ((int)mode)
-    {
-    case PLY_MODE_BOOT:
-      filename = PLYMOUTH_SPOOL_DIRECTORY "/boot.log";
-      break;
-    case PLY_MODE_SHUTDOWN:
-    case PLY_MODE_UPDATES:
-      filename = NULL;
-      break;
-    default:
-      ply_error ("Unhandled case in %s line %d\n", __FILE__, __LINE__);
-      abort ();
-      break;
-    }
+        const char *filename;
+
+        switch ((int) mode) {
+        case PLY_MODE_BOOT:
+                filename = PLYMOUTH_SPOOL_DIRECTORY "/boot.log";
+                break;
+        case PLY_MODE_SHUTDOWN:
+        case PLY_MODE_UPDATES:
+                filename = NULL;
+                break;
+        default:
+                ply_error ("Unhandled case in %s line %d\n", __FILE__, __LINE__);
+                abort ();
+                break;
+        }
 
-  ply_trace ("returning spool file '%s'", filename);
-  return filename;
+        ply_trace ("returning spool file '%s'", filename);
+        return filename;
 }
 
 static void
 spool_error (state_t *state)
 {
-  const char *logfile;
-  const char *logspool;
+        const char *logfile;
+        const char *logspool;
 
-  ply_trace ("spooling error for viewer");
+        ply_trace ("spooling error for viewer");
 
-  logfile = get_log_file_for_state (state);
-  logspool = get_log_spool_file_for_mode (state->mode);
+        logfile = get_log_file_for_state (state);
+        logspool = get_log_spool_file_for_mode (state->mode);
 
-  if (logfile != NULL && logspool != NULL)
-    {
-      unlink (logspool);
+        if (logfile != NULL && logspool != NULL) {
+                unlink (logspool);
 
-      ply_create_file_link (logfile, logspool);
-    }
+                ply_create_file_link (logfile, logspool);
+        }
 }
 
 static void
 prepare_logging (state_t *state)
 {
-  const char *logfile;
+        const char *logfile;
 
-  if (!state->system_initialized)
-    {
-      ply_trace ("not preparing logging yet, system not initialized");
-      return;
-    }
+        if (!state->system_initialized) {
+                ply_trace ("not preparing logging yet, system not initialized");
+                return;
+        }
 
-  if (state->session == NULL)
-    {
-      ply_trace ("not preparing logging, no session");
-      return;
-    }
+        if (state->session == NULL) {
+                ply_trace ("not preparing logging, no session");
+                return;
+        }
 
-  logfile = get_log_file_for_state (state);
-  if (logfile != NULL)
-    {
-      bool log_opened;
-      ply_trace ("opening log '%s'", logfile);
+        logfile = get_log_file_for_state (state);
+        if (logfile != NULL) {
+                bool log_opened;
+                ply_trace ("opening log '%s'", logfile);
 
-      log_opened = ply_terminal_session_open_log (state->session, logfile);
+                log_opened = ply_terminal_session_open_log (state->session, logfile);
 
-      if (!log_opened)
-        ply_trace ("failed to open log: %m");
+                if (!log_opened)
+                        ply_trace ("failed to open log: %m");
 
-      if (state->number_of_errors > 0)
-        spool_error (state);
-    }
+                if (state->number_of_errors > 0)
+                        spool_error (state);
+        }
 }
 
 static void
 on_system_initialized (state_t *state)
 {
-  ply_trace ("system now initialized, opening log");
-  state->system_initialized = true;
+        ply_trace ("system now initialized, opening log");
+        state->system_initialized = true;
 
-  prepare_logging (state);
+        prepare_logging (state);
 }
 
 static void
 on_error (state_t *state)
 {
-  ply_trace ("encountered error during boot up");
+        ply_trace ("encountered error during boot up");
 
-  if (state->system_initialized && state->number_of_errors == 0)
-    spool_error (state);
-  else
-    ply_trace ("not spooling because number of errors %d", state->number_of_errors);
+        if (state->system_initialized && state->number_of_errors == 0)
+                spool_error (state);
+        else
+                ply_trace ("not spooling because number of errors %d", state->number_of_errors);
 
-  state->number_of_errors++;
+        state->number_of_errors++;
 }
 
 static bool
 plymouth_should_ignore_show_splash_calls (state_t *state)
 {
-  const char *init_string;
-  size_t length;
+        const char *init_string;
+        size_t length;
 
-  ply_trace ("checking if plymouth should be running");
-  if (state->mode != PLY_MODE_BOOT || command_line_has_argument (state->kernel_command_line, "plymouth.force-splash"))
-      return false;
+        ply_trace ("checking if plymouth should be running");
+        if (state->mode != PLY_MODE_BOOT || command_line_has_argument (state->kernel_command_line, "plymouth.force-splash"))
+                return false;
 
-  if (command_line_has_argument (state->kernel_command_line, "plymouth.ignore-show-splash"))
-      return true;
+        if (command_line_has_argument (state->kernel_command_line, "plymouth.ignore-show-splash"))
+                return true;
 
-  init_string = command_line_get_string_after_prefix (state->kernel_command_line, "init=");
+        init_string = command_line_get_string_after_prefix (state->kernel_command_line, "init=");
 
-  if (init_string)
-    {
-      length = strcspn (init_string, " \n");
-      if (length > 2 && ply_string_has_prefix (init_string + length - 2, "sh"))
-        return true;
-    }
+        if (init_string) {
+                length = strcspn (init_string, " \n");
+                if (length > 2 && ply_string_has_prefix (init_string + length - 2, "sh"))
+                        return true;
+        }
 
-  return false;
+        return false;
 }
 
 static bool
 plymouth_should_show_default_splash (state_t *state)
 {
-  ply_trace ("checking if plymouth should show default splash");
+        ply_trace ("checking if plymouth should show default splash");
 
-  const char const *strings[] = {
-      "single", "1", "s", "S", "-S", NULL
-  };
-  int i;
+        const char const *strings[] = {
+                "single", "1", "s", "S", "-S", NULL
+        };
+        int i;
 
-  if (state->should_force_details)
-    return false;
+        if (state->should_force_details)
+                return false;
 
-  for (i = 0; strings[i] != NULL; i++)
-    {
-      if (command_line_has_argument (state->kernel_command_line, strings[i]))
-        {
-          ply_trace ("no default splash because kernel command line has option \"%s\"", strings[i]);
-          return false;
+        for (i = 0; strings[i] != NULL; i++) {
+                if (command_line_has_argument (state->kernel_command_line, strings[i])) {
+                        ply_trace ("no default splash because kernel command line has option \"%s\"", strings[i]);
+                        return false;
+                }
         }
-    }
 
-  if (command_line_has_argument (state->kernel_command_line, "splash=verbose"))
-    {
-      ply_trace ("no default splash because kernel command line has option \"splash=verbose\"");
-      return false;
-    }
+        if (command_line_has_argument (state->kernel_command_line, "splash=verbose")) {
+                ply_trace ("no default splash because kernel command line has option \"splash=verbose\"");
+                return false;
+        }
 
-  if (command_line_has_argument (state->kernel_command_line, "rhgb"))
-    {
-      ply_trace ("using default splash because kernel command line has option \"rhgb\"");
-      return true;
-    }
+        if (command_line_has_argument (state->kernel_command_line, "rhgb")) {
+                ply_trace ("using default splash because kernel command line has option \"rhgb\"");
+                return true;
+        }
 
-  if (command_line_has_argument (state->kernel_command_line, "splash"))
-    {
-      ply_trace ("using default splash because kernel command line has option \"splash\"");
-      return true;
-    }
+        if (command_line_has_argument (state->kernel_command_line, "splash")) {
+                ply_trace ("using default splash because kernel command line has option \"splash\"");
+                return true;
+        }
 
-  if (command_line_has_argument (state->kernel_command_line, "splash=silent"))
-    {
-      ply_trace ("using default splash because kernel command line has option \"splash=slient\"");
-      return true;
-    }
+        if (command_line_has_argument (state->kernel_command_line, "splash=silent")) {
+                ply_trace ("using default splash because kernel command line has option \"splash=slient\"");
+                return true;
+        }
 
-  ply_trace ("no default splash because kernel command line lacks \"splash\" or \"rhgb\"");
-  return false;
+        ply_trace ("no default splash because kernel command line lacks \"splash\" or \"rhgb\"");
+        return false;
 }
 
 static void
 on_show_splash (state_t *state)
 {
-  bool has_open_seats;
+        bool has_open_seats;
 
-  if (state->is_shown)
-    {
-      ply_trace ("show splash called while already shown");
-      return;
-    }
+        if (state->is_shown) {
+                ply_trace ("show splash called while already shown");
+                return;
+        }
 
-  if (state->is_inactive)
-    {
-      ply_trace ("show splash called while inactive");
-      return;
-    }
+        if (state->is_inactive) {
+                ply_trace ("show splash called while inactive");
+                return;
+        }
 
-  if (plymouth_should_ignore_show_splash_calls (state))
-    {
-      ply_trace ("show splash called while ignoring show splash calls");
-      dump_details_and_quit_splash (state);
-      return;
-    }
+        if (plymouth_should_ignore_show_splash_calls (state)) {
+                ply_trace ("show splash called while ignoring show splash calls");
+                dump_details_and_quit_splash (state);
+                return;
+        }
 
-  state->is_shown = true;
-  has_open_seats = ply_device_manager_has_open_seats (state->device_manager);
+        state->is_shown = true;
+        has_open_seats = ply_device_manager_has_open_seats (state->device_manager);
 
-  if (!state->is_attached && state->should_be_attached && has_open_seats)
-    attach_to_running_session (state);
+        if (!state->is_attached && state->should_be_attached && has_open_seats)
+                attach_to_running_session (state);
 
-  if (has_open_seats)
-    {
-      ply_trace ("at least one seat already open, so loading splash");
-      show_splash (state);
-    }
-  else
-    {
-      ply_trace ("no seats available to show splash on, waiting...");
-    }
+        if (has_open_seats) {
+                ply_trace ("at least one seat already open, so loading splash");
+                show_splash (state);
+        } else {
+                ply_trace ("no seats available to show splash on, waiting...");
+        }
 }
 
 static void
 on_seat_removed (state_t    *state,
                  ply_seat_t *seat)
 {
-  ply_keyboard_t *keyboard;
+        ply_keyboard_t *keyboard;
 
-  keyboard = ply_seat_get_keyboard (seat);
+        keyboard = ply_seat_get_keyboard (seat);
 
-  ply_trace ("no longer listening for keystrokes");
-  ply_keyboard_remove_input_handler (keyboard,
-                                     (ply_keyboard_input_handler_t)
-                                     on_keyboard_input);
-  ply_trace ("no longer listening for escape");
-  ply_keyboard_remove_escape_handler (keyboard,
-                                      (ply_keyboard_escape_handler_t)
-                                      on_escape_pressed);
-  ply_trace ("no longer listening for backspace");
-  ply_keyboard_remove_backspace_handler (keyboard,
-                                         (ply_keyboard_backspace_handler_t)
-                                         on_backspace);
-  ply_trace ("no longer listening for enter");
-  ply_keyboard_remove_enter_handler (keyboard,
-                                     (ply_keyboard_enter_handler_t)
-                                     on_enter);
+        ply_trace ("no longer listening for keystrokes");
+        ply_keyboard_remove_input_handler (keyboard,
+                                           (ply_keyboard_input_handler_t)
+                                           on_keyboard_input);
+        ply_trace ("no longer listening for escape");
+        ply_keyboard_remove_escape_handler (keyboard,
+                                            (ply_keyboard_escape_handler_t)
+                                            on_escape_pressed);
+        ply_trace ("no longer listening for backspace");
+        ply_keyboard_remove_backspace_handler (keyboard,
+                                               (ply_keyboard_backspace_handler_t)
+                                               on_backspace);
+        ply_trace ("no longer listening for enter");
+        ply_keyboard_remove_enter_handler (keyboard,
+                                           (ply_keyboard_enter_handler_t)
+                                           on_enter);
 
-  if (state->boot_splash != NULL)
-   ply_boot_splash_detach_from_seat (state->boot_splash, seat);
+        if (state->boot_splash != NULL)
+                ply_boot_splash_detach_from_seat (state->boot_splash, seat);
 }
 
 static void
 show_splash (state_t *state)
 {
-  if (state->boot_splash != NULL)
-    return;
-
-  if (!isnan (state->splash_delay))
-    {
-      double now, running_time;
+        if (state->boot_splash != NULL)
+                return;
+
+        if (!isnan (state->splash_delay)) {
+                double now, running_time;
+
+                now = ply_get_timestamp ();
+                running_time = now - state->start_time;
+                if (state->splash_delay > running_time) {
+                        double time_left = state->splash_delay - running_time;
+
+                        ply_trace ("delaying show splash for %lf seconds",
+                                   time_left);
+                        ply_event_loop_stop_watching_for_timeout (state->loop,
+                                                                  (ply_event_loop_timeout_handler_t)
+                                                                  show_splash,
+                                                                  state);
+                        ply_event_loop_watch_for_timeout (state->loop,
+                                                          time_left,
+                                                          (ply_event_loop_timeout_handler_t)
+                                                          show_splash,
+                                                          state);
+                        return;
+                }
+        }
 
-      now = ply_get_timestamp ();
-      running_time = now - state->start_time;
-      if (state->splash_delay > running_time)
-        {
-          double time_left = state->splash_delay - running_time;
-
-          ply_trace ("delaying show splash for %lf seconds",
-                     time_left);
-          ply_event_loop_stop_watching_for_timeout (state->loop,
-                                                    (ply_event_loop_timeout_handler_t)
-                                                    show_splash,
-                                                    state);
-          ply_event_loop_watch_for_timeout (state->loop,
-                                            time_left,
-                                            (ply_event_loop_timeout_handler_t)
-                                            show_splash,
-                                            state);
-          return;
-        }
-    }
-
-  if (plymouth_should_show_default_splash (state))
-    {
-      show_default_splash (state);
-      state->showing_details = false;
-    }
-  else
-    {
-      show_detailed_splash (state);
-      state->showing_details = true;
-    }
+        if (plymouth_should_show_default_splash (state)) {
+                show_default_splash (state);
+                state->showing_details = false;
+        } else {
+                show_detailed_splash (state);
+                state->showing_details = true;
+        }
 }
 
 static void
 on_seat_added (state_t    *state,
                ply_seat_t *seat)
 {
-  ply_keyboard_t *keyboard;
+        ply_keyboard_t *keyboard;
 
-  if (state->is_shown)
-    {
-      if (state->boot_splash == NULL)
-        {
-          ply_trace ("seat added before splash loaded, so loading splash now");
-          show_splash (state);
-        }
-      else
-        {
-          ply_trace ("seat added after splash loaded, so attaching to splash");
-          ply_boot_splash_attach_to_seat (state->boot_splash, seat);
+        if (state->is_shown) {
+                if (state->boot_splash == NULL) {
+                        ply_trace ("seat added before splash loaded, so loading splash now");
+                        show_splash (state);
+                } else {
+                        ply_trace ("seat added after splash loaded, so attaching to splash");
+                        ply_boot_splash_attach_to_seat (state->boot_splash, seat);
+                }
         }
-    }
-
-  keyboard = ply_seat_get_keyboard (seat);
-
-  ply_trace ("listening for keystrokes");
-  ply_keyboard_add_input_handler (keyboard,
-                                  (ply_keyboard_input_handler_t)
-                                  on_keyboard_input, state);
-  ply_trace ("listening for escape");
-  ply_keyboard_add_escape_handler (keyboard,
-                                   (ply_keyboard_escape_handler_t)
-                                   on_escape_pressed, state);
-  ply_trace ("listening for backspace");
-  ply_keyboard_add_backspace_handler (keyboard,
-                                      (ply_keyboard_backspace_handler_t)
-                                      on_backspace, state);
-  ply_trace ("listening for enter");
-  ply_keyboard_add_enter_handler (keyboard,
-                                  (ply_keyboard_enter_handler_t)
-                                  on_enter, state);
 
+        keyboard = ply_seat_get_keyboard (seat);
+
+        ply_trace ("listening for keystrokes");
+        ply_keyboard_add_input_handler (keyboard,
+                                        (ply_keyboard_input_handler_t)
+                                        on_keyboard_input, state);
+        ply_trace ("listening for escape");
+        ply_keyboard_add_escape_handler (keyboard,
+                                         (ply_keyboard_escape_handler_t)
+                                         on_escape_pressed, state);
+        ply_trace ("listening for backspace");
+        ply_keyboard_add_backspace_handler (keyboard,
+                                            (ply_keyboard_backspace_handler_t)
+                                            on_backspace, state);
+        ply_trace ("listening for enter");
+        ply_keyboard_add_enter_handler (keyboard,
+                                        (ply_keyboard_enter_handler_t)
+                                        on_enter, state);
 }
 
 static void
-load_devices (state_t                    *state,
-              ply_device_manager_flags_t  flags)
+load_devices (state_t                   *state,
+              ply_device_manager_flags_t flags)
 {
-  state->device_manager = ply_device_manager_new (state->default_tty, flags);
-  state->local_console_terminal = ply_device_manager_get_default_terminal (state->device_manager);
+        state->device_manager = ply_device_manager_new (state->default_tty, flags);
+        state->local_console_terminal = ply_device_manager_get_default_terminal (state->device_manager);
 
-  ply_device_manager_watch_seats (state->device_manager,
-                                  (ply_seat_added_handler_t)
-                                  on_seat_added,
-                                  (ply_seat_removed_handler_t)
-                                  on_seat_removed,
-                                  state);
+        ply_device_manager_watch_seats (state->device_manager,
+                                        (ply_seat_added_handler_t)
+                                        on_seat_added,
+                                        (ply_seat_removed_handler_t)
+                                        on_seat_removed,
+                                        state);
 }
 
 static void
 quit_splash (state_t *state)
 {
-  ply_trace ("quiting splash");
-  if (state->boot_splash != NULL)
-    {
-      ply_trace ("freeing splash");
-      ply_boot_splash_free (state->boot_splash);
-      state->boot_splash = NULL;
-    }
+        ply_trace ("quiting splash");
+        if (state->boot_splash != NULL) {
+                ply_trace ("freeing splash");
+                ply_boot_splash_free (state->boot_splash);
+                state->boot_splash = NULL;
+        }
 
-  ply_device_manager_deactivate_keyboards (state->device_manager);
+        ply_device_manager_deactivate_keyboards (state->device_manager);
 
-  if (state->local_console_terminal != NULL)
-    {
-      if (!state->should_retain_splash)
-        {
-          ply_trace ("Not retaining splash, so deallocating VT");
-          ply_terminal_deactivate_vt (state->local_console_terminal);
-          ply_terminal_close (state->local_console_terminal);
+        if (state->local_console_terminal != NULL) {
+                if (!state->should_retain_splash) {
+                        ply_trace ("Not retaining splash, so deallocating VT");
+                        ply_terminal_deactivate_vt (state->local_console_terminal);
+                        ply_terminal_close (state->local_console_terminal);
+                }
         }
-    }
 
-  detach_from_running_session (state);
+        detach_from_running_session (state);
 }
 
 static void
 hide_splash (state_t *state)
 {
-  state->is_shown = false;
+        state->is_shown = false;
 
-  cancel_pending_delayed_show (state);
+        cancel_pending_delayed_show (state);
 
-  if (state->boot_splash == NULL)
-    return;
+        if (state->boot_splash == NULL)
+                return;
 
-  ply_boot_splash_hide (state->boot_splash);
+        ply_boot_splash_hide (state->boot_splash);
 
-  if (state->local_console_terminal != NULL)
-    ply_terminal_set_mode (state->local_console_terminal, PLY_TERMINAL_MODE_TEXT);
+        if (state->local_console_terminal != NULL)
+                ply_terminal_set_mode (state->local_console_terminal, PLY_TERMINAL_MODE_TEXT);
 }
 
 static void
 dump_details_and_quit_splash (state_t *state)
 {
-  state->showing_details = false;
-  toggle_between_splash_and_details (state);
+        state->showing_details = false;
+        toggle_between_splash_and_details (state);
 
-  ply_device_manager_deactivate_renderers (state->device_manager);
-  hide_splash (state);
-  quit_splash (state);
+        ply_device_manager_deactivate_renderers (state->device_manager);
+        hide_splash (state);
+        quit_splash (state);
 }
 
 static void
 on_hide_splash (state_t *state)
 {
-  if (state->is_inactive)
-    return;
+        if (state->is_inactive)
+                return;
 
-  if (state->boot_splash == NULL)
-    return;
+        if (state->boot_splash == NULL)
+                return;
 
-  ply_trace ("hiding boot splash");
-  dump_details_and_quit_splash (state);
+        ply_trace ("hiding boot splash");
+        dump_details_and_quit_splash (state);
 }
 
 #ifdef PLY_ENABLE_DEPRECATED_GDM_TRANSITION
 static void
 tell_gdm_to_transition (void)
 {
-  int fd;
+        int fd;
 
-  fd = creat ("/var/spool/gdm/force-display-on-active-vt", 0644);
-  close (fd);
+        fd = creat ("/var/spool/gdm/force-display-on-active-vt", 0644);
+        close (fd);
 }
 #endif
 
 static void
 quit_program (state_t *state)
 {
-  ply_trace ("cleaning up devices");
-  ply_device_manager_free (state->device_manager);
+        ply_trace ("cleaning up devices");
+        ply_device_manager_free (state->device_manager);
 
-  ply_trace ("exiting event loop");
-  ply_event_loop_exit (state->loop, 0);
+        ply_trace ("exiting event loop");
+        ply_event_loop_exit (state->loop, 0);
 
-  if (pid_file != NULL)
-    {
-      unlink (pid_file);
-      free (pid_file);
-      pid_file = NULL;
-    }
+        if (pid_file != NULL) {
+                unlink (pid_file);
+                free (pid_file);
+                pid_file = NULL;
+        }
 
 #ifdef PLY_ENABLE_DEPRECATED_GDM_TRANSITION
-  if (state->should_retain_splash &&
-      state->mode == PLY_MODE_BOOT)
-    {
-      tell_gdm_to_transition ();
-    }
+        if (state->should_retain_splash &&
+            state->mode == PLY_MODE_BOOT)
+                tell_gdm_to_transition ();
+
 #endif
 
-  if (state->deactivate_trigger != NULL)
-    {
-      ply_trigger_pull (state->deactivate_trigger, NULL);
-      state->deactivate_trigger = NULL;
-    }
-  if (state->quit_trigger != NULL)
-    {
-      ply_trigger_pull (state->quit_trigger, NULL);
-      state->quit_trigger = NULL;
-    }
+        if (state->deactivate_trigger != NULL) {
+                ply_trigger_pull (state->deactivate_trigger, NULL);
+                state->deactivate_trigger = NULL;
+        }
+        if (state->quit_trigger != NULL) {
+                ply_trigger_pull (state->quit_trigger, NULL);
+                state->quit_trigger = NULL;
+        }
 }
 
 static void
 deactivate_splash (state_t *state)
 {
-  assert (!state->is_inactive);
+        assert (!state->is_inactive);
 
-  ply_device_manager_deactivate_renderers (state->device_manager);
+        ply_device_manager_deactivate_renderers (state->device_manager);
 
-  detach_from_running_session (state);
+        detach_from_running_session (state);
 
-  if (state->local_console_terminal != NULL)
-    {
-      ply_trace ("deactivating terminal");
-      ply_terminal_stop_watching_for_vt_changes (state->local_console_terminal);
-      ply_terminal_set_buffered_input (state->local_console_terminal);
-      ply_terminal_close (state->local_console_terminal);
-    }
+        if (state->local_console_terminal != NULL) {
+                ply_trace ("deactivating terminal");
+                ply_terminal_stop_watching_for_vt_changes (state->local_console_terminal);
+                ply_terminal_set_buffered_input (state->local_console_terminal);
+                ply_terminal_close (state->local_console_terminal);
+        }
 
-  /* do not let any tty opened where we could write after deactivate */
-  if (command_line_has_argument (state->kernel_command_line, "plymouth.debug"))
-    {
-      ply_logger_close_file (ply_logger_get_error_default ());
-    }
+        /* do not let any tty opened where we could write after deactivate */
+        if (command_line_has_argument (state->kernel_command_line, "plymouth.debug"))
+                ply_logger_close_file (ply_logger_get_error_default ());
 
-  state->is_inactive = true;
+        state->is_inactive = true;
 
-  ply_trigger_pull (state->deactivate_trigger, NULL);
-  state->deactivate_trigger = NULL;
+        ply_trigger_pull (state->deactivate_trigger, NULL);
+        state->deactivate_trigger = NULL;
 }
 
 static void
 on_boot_splash_idle (state_t *state)
 {
-  ply_trace ("boot splash idle");
-
-  /* In the case where we've received both a deactivate command and a
-   * quit command, the quit command takes precedence.
-   */
-  if (state->quit_trigger != NULL)
-    {
-      if (!state->should_retain_splash)
-        {
-          ply_trace ("hiding splash");
-          ply_device_manager_deactivate_renderers (state->device_manager);
-          hide_splash (state);
+        ply_trace ("boot splash idle");
+
+        /* In the case where we've received both a deactivate command and a
+         * quit command, the quit command takes precedence.
+         */
+        if (state->quit_trigger != NULL) {
+                if (!state->should_retain_splash) {
+                        ply_trace ("hiding splash");
+                        ply_device_manager_deactivate_renderers (state->device_manager);
+                        hide_splash (state);
+                }
+
+                ply_trace ("quitting splash");
+                quit_splash (state);
+                ply_trace ("quitting program");
+                quit_program (state);
+        } else if (state->deactivate_trigger != NULL) {
+                ply_trace ("deactivating splash");
+                deactivate_splash (state);
         }
-
-      ply_trace ("quitting splash");
-      quit_splash (state);
-      ply_trace ("quitting program");
-      quit_program (state);
-    }
-  else if (state->deactivate_trigger != NULL)
-    {
-      ply_trace ("deactivating splash");
-      deactivate_splash (state);
-    }
 }
 
 static void
 on_deactivate (state_t       *state,
                ply_trigger_t *deactivate_trigger)
 {
-  if (state->is_inactive)
-    {
-      ply_trigger_pull (deactivate_trigger, NULL);
-      return;
-    }
-
-  if (state->deactivate_trigger != NULL)
-    {
-      ply_trigger_add_handler (state->deactivate_trigger,
-                               (ply_trigger_handler_t)
-                               ply_trigger_pull,
-                               deactivate_trigger);
-      return;
-    }
-
-  state->deactivate_trigger = deactivate_trigger;
-
-  ply_trace ("deactivating");
-  cancel_pending_delayed_show (state);
-
-  ply_device_manager_deactivate_keyboards (state->device_manager);
-
-  if (state->boot_splash != NULL)
-    {
-      ply_boot_splash_become_idle (state->boot_splash,
-                                   (ply_boot_splash_on_idle_handler_t)
-                                   on_boot_splash_idle,
-                                   state);
-    }
-  else
-    {
-      ply_trace ("deactivating splash");
-      deactivate_splash (state);
-    }
+        if (state->is_inactive) {
+                ply_trigger_pull (deactivate_trigger, NULL);
+                return;
+        }
+
+        if (state->deactivate_trigger != NULL) {
+                ply_trigger_add_handler (state->deactivate_trigger,
+                                         (ply_trigger_handler_t)
+                                         ply_trigger_pull,
+                                         deactivate_trigger);
+                return;
+        }
+
+        state->deactivate_trigger = deactivate_trigger;
+
+        ply_trace ("deactivating");
+        cancel_pending_delayed_show (state);
+
+        ply_device_manager_deactivate_keyboards (state->device_manager);
+
+        if (state->boot_splash != NULL) {
+                ply_boot_splash_become_idle (state->boot_splash,
+                                             (ply_boot_splash_on_idle_handler_t)
+                                             on_boot_splash_idle,
+                                             state);
+        } else {
+                ply_trace ("deactivating splash");
+                deactivate_splash (state);
+        }
 }
 
 static void
 on_reactivate (state_t *state)
 {
-  if (!state->is_inactive)
-    return;
+        if (!state->is_inactive)
+                return;
 
-  if (state->local_console_terminal != NULL)
-    {
-      ply_terminal_open (state->local_console_terminal);
-      ply_terminal_watch_for_vt_changes (state->local_console_terminal);
-      ply_terminal_set_unbuffered_input (state->local_console_terminal);
-      ply_terminal_ignore_mode_changes (state->local_console_terminal, false);
-    }
+        if (state->local_console_terminal != NULL) {
+                ply_terminal_open (state->local_console_terminal);
+                ply_terminal_watch_for_vt_changes (state->local_console_terminal);
+                ply_terminal_set_unbuffered_input (state->local_console_terminal);
+                ply_terminal_ignore_mode_changes (state->local_console_terminal, false);
+        }
 
-  if ((state->session != NULL) && state->should_be_attached)
-    {
-      ply_trace ("reactivating terminal session");
-      attach_to_running_session (state);
-    }
+        if ((state->session != NULL) && state->should_be_attached) {
+                ply_trace ("reactivating terminal session");
+                attach_to_running_session (state);
+        }
 
-  ply_device_manager_activate_keyboards (state->device_manager);
-  ply_device_manager_activate_renderers (state->device_manager);
+        ply_device_manager_activate_keyboards (state->device_manager);
+        ply_device_manager_activate_renderers (state->device_manager);
 
-  state->is_inactive = false;
+        state->is_inactive = false;
 
-  update_display (state);
+        update_display (state);
 }
 
 static void
@@ -1301,748 +1220,686 @@ on_quit (state_t       *state,
          bool           retain_splash,
          ply_trigger_t *quit_trigger)
 {
-  ply_trace ("quitting (retain splash: %s)", retain_splash? "true" : "false");
-
-  if (state->quit_trigger != NULL)
-    {
-      ply_trace ("quit trigger already pending, so chaining to it");
-      ply_trigger_add_handler (state->quit_trigger,
-                               (ply_trigger_handler_t)
-                               ply_trigger_pull,
-                               quit_trigger);
-      return;
-    }
-
-  if (state->system_initialized)
-    {
-      ply_trace ("system initialized so saving boot-duration file");
-      ply_create_directory (PLYMOUTH_TIME_DIRECTORY);
-      ply_progress_save_cache (state->progress,
-                               get_cache_file_for_mode (state->mode));
-    }
-  else
-    {
-      ply_trace ("system not initialized so skipping saving boot-duration file");
-    }
-  state->quit_trigger = quit_trigger;
-  state->should_retain_splash = retain_splash;
+        ply_trace ("quitting (retain splash: %s)", retain_splash ? "true" : "false");
+
+        if (state->quit_trigger != NULL) {
+                ply_trace ("quit trigger already pending, so chaining to it");
+                ply_trigger_add_handler (state->quit_trigger,
+                                         (ply_trigger_handler_t)
+                                         ply_trigger_pull,
+                                         quit_trigger);
+                return;
+        }
+
+        if (state->system_initialized) {
+                ply_trace ("system initialized so saving boot-duration file");
+                ply_create_directory (PLYMOUTH_TIME_DIRECTORY);
+                ply_progress_save_cache (state->progress,
+                                         get_cache_file_for_mode (state->mode));
+        } else {
+                ply_trace ("system not initialized so skipping saving boot-duration file");
+        }
+        state->quit_trigger = quit_trigger;
+        state->should_retain_splash = retain_splash;
 
 #ifdef PLY_ENABLE_SYSTEMD_INTEGRATION
-  tell_systemd_to_stop_printing_details (state);
+        tell_systemd_to_stop_printing_details (state);
 #endif
 
-  ply_trace ("closing log");
-  if (state->session != NULL)
-    ply_terminal_session_close_log (state->session);
-
-  ply_device_manager_deactivate_keyboards (state->device_manager);
-
-  ply_trace ("unloading splash");
-  if (state->is_inactive && !retain_splash)
-    {
-      /* We've been deactivated and X failed to start
-       */
-      dump_details_and_quit_splash (state);
-      quit_program (state);
-    }
-  else if (state->boot_splash != NULL)
-    {
-      ply_boot_splash_become_idle (state->boot_splash,
-                                   (ply_boot_splash_on_idle_handler_t)
-                                   on_boot_splash_idle,
-                                   state);
-    }
-  else
-    quit_program (state);
+        ply_trace ("closing log");
+        if (state->session != NULL)
+                ply_terminal_session_close_log (state->session);
+
+        ply_device_manager_deactivate_keyboards (state->device_manager);
+
+        ply_trace ("unloading splash");
+        if (state->is_inactive && !retain_splash) {
+                /* We've been deactivated and X failed to start
+                 */
+                dump_details_and_quit_splash (state);
+                quit_program (state);
+        } else if (state->boot_splash != NULL) {
+                ply_boot_splash_become_idle (state->boot_splash,
+                                             (ply_boot_splash_on_idle_handler_t)
+                                             on_boot_splash_idle,
+                                             state);
+        } else {
+                quit_program (state);
+        }
 }
 
 static bool
 on_has_active_vt (state_t *state)
 {
-  if (state->local_console_terminal != NULL)
-    return ply_terminal_is_active (state->local_console_terminal);
-  else
-    return false;
+        if (state->local_console_terminal != NULL)
+                return ply_terminal_is_active (state->local_console_terminal);
+        else
+                return false;
 }
 
 static ply_boot_server_t *
 start_boot_server (state_t *state)
 {
-  ply_boot_server_t *server;
-
-  server = ply_boot_server_new ((ply_boot_server_update_handler_t) on_update,
-                                (ply_boot_server_change_mode_handler_t) on_change_mode,
-                                (ply_boot_server_system_update_handler_t) on_system_update,
-                                (ply_boot_server_ask_for_password_handler_t) on_ask_for_password,
-                                (ply_boot_server_ask_question_handler_t) on_ask_question,
-                                (ply_boot_server_display_message_handler_t) on_display_message,
-                                (ply_boot_server_hide_message_handler_t) on_hide_message,
-                                (ply_boot_server_watch_for_keystroke_handler_t) on_watch_for_keystroke,
-                                (ply_boot_server_ignore_keystroke_handler_t) on_ignore_keystroke,
-                                (ply_boot_server_progress_pause_handler_t) on_progress_pause,
-                                (ply_boot_server_progress_unpause_handler_t) on_progress_unpause,
-                                (ply_boot_server_show_splash_handler_t) on_show_splash,
-                                (ply_boot_server_hide_splash_handler_t) on_hide_splash,
-                                (ply_boot_server_newroot_handler_t) on_newroot,
-                                (ply_boot_server_system_initialized_handler_t) on_system_initialized,
-                                (ply_boot_server_error_handler_t) on_error,
-                                (ply_boot_server_deactivate_handler_t) on_deactivate,
-                                (ply_boot_server_reactivate_handler_t) on_reactivate,
-                                (ply_boot_server_quit_handler_t) on_quit,
-                                (ply_boot_server_has_active_vt_handler_t) on_has_active_vt,
-                                state);
-
-  if (!ply_boot_server_listen (server))
-    {
-      ply_save_errno ();
-      ply_boot_server_free (server);
-      ply_restore_errno ();
-      return NULL;
-    }
-
-  ply_boot_server_attach_to_event_loop (server, state->loop);
-
-  return server;
+        ply_boot_server_t *server;
+
+        server = ply_boot_server_new ((ply_boot_server_update_handler_t) on_update,
+                                      (ply_boot_server_change_mode_handler_t) on_change_mode,
+                                      (ply_boot_server_system_update_handler_t) on_system_update,
+                                      (ply_boot_server_ask_for_password_handler_t) on_ask_for_password,
+                                      (ply_boot_server_ask_question_handler_t) on_ask_question,
+                                      (ply_boot_server_display_message_handler_t) on_display_message,
+                                      (ply_boot_server_hide_message_handler_t) on_hide_message,
+                                      (ply_boot_server_watch_for_keystroke_handler_t) on_watch_for_keystroke,
+                                      (ply_boot_server_ignore_keystroke_handler_t) on_ignore_keystroke,
+                                      (ply_boot_server_progress_pause_handler_t) on_progress_pause,
+                                      (ply_boot_server_progress_unpause_handler_t) on_progress_unpause,
+                                      (ply_boot_server_show_splash_handler_t) on_show_splash,
+                                      (ply_boot_server_hide_splash_handler_t) on_hide_splash,
+                                      (ply_boot_server_newroot_handler_t) on_newroot,
+                                      (ply_boot_server_system_initialized_handler_t) on_system_initialized,
+                                      (ply_boot_server_error_handler_t) on_error,
+                                      (ply_boot_server_deactivate_handler_t) on_deactivate,
+                                      (ply_boot_server_reactivate_handler_t) on_reactivate,
+                                      (ply_boot_server_quit_handler_t) on_quit,
+                                      (ply_boot_server_has_active_vt_handler_t) on_has_active_vt,
+                                      state);
+
+        if (!ply_boot_server_listen (server)) {
+                ply_save_errno ();
+                ply_boot_server_free (server);
+                ply_restore_errno ();
+                return NULL;
+        }
+
+        ply_boot_server_attach_to_event_loop (server, state->loop);
+
+        return server;
 }
 
 
 static void
 update_display (state_t *state)
 {
-  if (!state->boot_splash) return;
-  
-  ply_list_node_t *node;
-  node = ply_list_get_first_node (state->entry_triggers);
-  if (node)
-    {
-      ply_entry_trigger_t* entry_trigger = ply_list_node_get_data (node);
-      if (entry_trigger->type == PLY_ENTRY_TRIGGER_TYPE_PASSWORD)
-        {
-          int bullets = ply_utf8_string_get_length (ply_buffer_get_bytes (state->entry_buffer),
-                                                    ply_buffer_get_size (state->entry_buffer));
-          bullets = MAX(0, bullets);
-          ply_boot_splash_display_password (state->boot_splash, 
-                                            entry_trigger->prompt,
-                                            bullets);
-        }
-      else if (entry_trigger->type == PLY_ENTRY_TRIGGER_TYPE_QUESTION)
-        {
-          ply_boot_splash_display_question (state->boot_splash,
-                                            entry_trigger->prompt,
-                                            ply_buffer_get_bytes (state->entry_buffer));
-        }
-      else {
-          ply_trace("unkown entry type");
+        if (!state->boot_splash) return;
+
+        ply_list_node_t *node;
+        node = ply_list_get_first_node (state->entry_triggers);
+        if (node) {
+                ply_entry_trigger_t *entry_trigger = ply_list_node_get_data (node);
+                if (entry_trigger->type == PLY_ENTRY_TRIGGER_TYPE_PASSWORD) {
+                        int bullets = ply_utf8_string_get_length (ply_buffer_get_bytes (state->entry_buffer),
+                                                                  ply_buffer_get_size (state->entry_buffer));
+                        bullets = MAX (0, bullets);
+                        ply_boot_splash_display_password (state->boot_splash,
+                                                          entry_trigger->prompt,
+                                                          bullets);
+                } else if (entry_trigger->type == PLY_ENTRY_TRIGGER_TYPE_QUESTION) {
+                        ply_boot_splash_display_question (state->boot_splash,
+                                                          entry_trigger->prompt,
+                                                          ply_buffer_get_bytes (state->entry_buffer));
+                } else {
+                        ply_trace ("unkown entry type");
+                }
+        } else {
+                ply_boot_splash_display_normal (state->boot_splash);
         }
-    }
-  else
-    {
-      ply_boot_splash_display_normal (state->boot_splash);
-    }
-
 }
 
 static void
 toggle_between_splash_and_details (state_t *state)
 {
-  ply_trace ("toggling between splash and details");
-  if (state->boot_splash != NULL)
-    {
-      ply_trace ("hiding and freeing current splash");
-      hide_splash (state);
-      ply_boot_splash_free (state->boot_splash);
-      state->boot_splash = NULL;
-    }
-
-  if (!state->showing_details)
-    {
-      show_detailed_splash (state);
-      state->showing_details = true;
-    }
-  else
-    {
-      show_default_splash (state);
-      state->showing_details = false;
-    }
+        ply_trace ("toggling between splash and details");
+        if (state->boot_splash != NULL) {
+                ply_trace ("hiding and freeing current splash");
+                hide_splash (state);
+                ply_boot_splash_free (state->boot_splash);
+                state->boot_splash = NULL;
+        }
+
+        if (!state->showing_details) {
+                show_detailed_splash (state);
+                state->showing_details = true;
+        } else {
+                show_default_splash (state);
+                state->showing_details = false;
+        }
 }
 
 static void
 on_escape_pressed (state_t *state)
 {
-  ply_trace ("escape key pressed");
-  toggle_between_splash_and_details (state);
+        ply_trace ("escape key pressed");
+        toggle_between_splash_and_details (state);
 }
 
 static void
-on_keyboard_input (state_t                  *state,
-                   const char               *keyboard_input,
-                   size_t                    character_size)
-{
-  ply_list_node_t *node;
-  node = ply_list_get_first_node (state->entry_triggers);
-  if (node)
-    {               /* \x3 (ETX) is Ctrl+C and \x4 (EOT) is Ctrl+D */
-      if (character_size == 1 && ( keyboard_input[0] == '\x3' || keyboard_input[0] == '\x4' ))
-        {
-          ply_entry_trigger_t* entry_trigger = ply_list_node_get_data (node);
-          ply_trigger_pull (entry_trigger->trigger, "\x3");
-          ply_buffer_clear (state->entry_buffer);
-          ply_list_remove_node (state->entry_triggers, node);
-          free (entry_trigger);
-        }
-      else
-        {
-          ply_buffer_append_bytes (state->entry_buffer, keyboard_input, character_size);
-        }
-      update_display (state);
-    }
-  else
-    {
-      for (node = ply_list_get_first_node (state->keystroke_triggers); node;
-                        node = ply_list_get_next_node (state->keystroke_triggers, node))
-        {
-          ply_keystroke_watch_t* keystroke_trigger = ply_list_node_get_data (node);
-          if (!keystroke_trigger->keys || strstr(keystroke_trigger->keys, keyboard_input))  /* assume strstr works on utf8 arrays */
-            {
-              ply_trigger_pull (keystroke_trigger->trigger, keyboard_input);
-              ply_list_remove_node (state->keystroke_triggers, node);
-              free(keystroke_trigger);
-              return;
-            }
+on_keyboard_input (state_t    *state,
+                   const char *keyboard_input,
+                   size_t      character_size)
+{
+        ply_list_node_t *node;
+
+        node = ply_list_get_first_node (state->entry_triggers);
+        if (node) { /* \x3 (ETX) is Ctrl+C and \x4 (EOT) is Ctrl+D */
+                if (character_size == 1 && (keyboard_input[0] == '\x3' || keyboard_input[0] == '\x4')) {
+                        ply_entry_trigger_t *entry_trigger = ply_list_node_get_data (node);
+                        ply_trigger_pull (entry_trigger->trigger, "\x3");
+                        ply_buffer_clear (state->entry_buffer);
+                        ply_list_remove_node (state->entry_triggers, node);
+                        free (entry_trigger);
+                } else {
+                        ply_buffer_append_bytes (state->entry_buffer, keyboard_input, character_size);
+                }
+                update_display (state);
+        } else {
+                for (node = ply_list_get_first_node (state->keystroke_triggers); node;
+                     node = ply_list_get_next_node (state->keystroke_triggers, node)) {
+                        ply_keystroke_watch_t *keystroke_trigger = ply_list_node_get_data (node);
+                        if (!keystroke_trigger->keys || strstr (keystroke_trigger->keys, keyboard_input)) { /* assume strstr works on utf8 arrays */
+                                ply_trigger_pull (keystroke_trigger->trigger, keyboard_input);
+                                ply_list_remove_node (state->keystroke_triggers, node);
+                                free (keystroke_trigger);
+                                return;
+                        }
+                }
+                return;
         }
-      return;
-    }
 }
 
 static void
-on_backspace (state_t                  *state)
+on_backspace (state_t *state)
 {
-  ssize_t bytes_to_remove;
-  ssize_t previous_character_size;
-  const char *bytes;
-  size_t size;
-  ply_list_node_t *node = ply_list_get_first_node (state->entry_triggers);
-  if (!node) return;
+        ssize_t bytes_to_remove;
+        ssize_t previous_character_size;
+        const char *bytes;
+        size_t size;
+        ply_list_node_t *node = ply_list_get_first_node (state->entry_triggers);
 
-  bytes = ply_buffer_get_bytes (state->entry_buffer);
-  size = ply_buffer_get_size (state->entry_buffer);
+        if (!node) return;
 
-  bytes_to_remove = MIN(size, PLY_UTF8_CHARACTER_SIZE_MAX);
-  while ((previous_character_size = ply_utf8_character_get_size (bytes + size - bytes_to_remove, bytes_to_remove)) < bytes_to_remove)
-    {
-      if (previous_character_size > 0)
-        bytes_to_remove -= previous_character_size;
-      else
-        bytes_to_remove--;
-    }
+        bytes = ply_buffer_get_bytes (state->entry_buffer);
+        size = ply_buffer_get_size (state->entry_buffer);
 
-  ply_buffer_remove_bytes_at_end (state->entry_buffer, bytes_to_remove);
-  update_display (state);
+        bytes_to_remove = MIN (size, PLY_UTF8_CHARACTER_SIZE_MAX);
+        while ((previous_character_size = ply_utf8_character_get_size (bytes + size - bytes_to_remove, bytes_to_remove)) < bytes_to_remove) {
+                if (previous_character_size > 0)
+                        bytes_to_remove -= previous_character_size;
+                else
+                        bytes_to_remove--;
+        }
+
+        ply_buffer_remove_bytes_at_end (state->entry_buffer, bytes_to_remove);
+        update_display (state);
 }
 
 static void
-on_enter (state_t                  *state,
-          const char               *line)
-{
-  ply_list_node_t *node;
-  node = ply_list_get_first_node (state->entry_triggers);
-  if (node)
-    {
-      ply_entry_trigger_t* entry_trigger = ply_list_node_get_data (node);
-      const char* reply_text = ply_buffer_get_bytes (state->entry_buffer);
-      ply_trigger_pull (entry_trigger->trigger, reply_text);
-      ply_buffer_clear (state->entry_buffer);
-      ply_list_remove_node (state->entry_triggers, node);
-      free (entry_trigger);
-      update_display (state);
-    }
-  else
-    {
-      for (node = ply_list_get_first_node (state->keystroke_triggers); node;
-                        node = ply_list_get_next_node (state->keystroke_triggers, node))
-        {
-          ply_keystroke_watch_t* keystroke_trigger = ply_list_node_get_data (node);
-          if (!keystroke_trigger->keys || strstr(keystroke_trigger->keys, "\n"))  /* assume strstr works on utf8 arrays */
-            {
-              ply_trigger_pull (keystroke_trigger->trigger, line);
-              ply_list_remove_node (state->keystroke_triggers, node);
-              free(keystroke_trigger);
-              return;
-            }
+on_enter (state_t    *state,
+          const char *line)
+{
+        ply_list_node_t *node;
+
+        node = ply_list_get_first_node (state->entry_triggers);
+        if (node) {
+                ply_entry_trigger_t *entry_trigger = ply_list_node_get_data (node);
+                const char *reply_text = ply_buffer_get_bytes (state->entry_buffer);
+                ply_trigger_pull (entry_trigger->trigger, reply_text);
+                ply_buffer_clear (state->entry_buffer);
+                ply_list_remove_node (state->entry_triggers, node);
+                free (entry_trigger);
+                update_display (state);
+        } else {
+                for (node = ply_list_get_first_node (state->keystroke_triggers); node;
+                     node = ply_list_get_next_node (state->keystroke_triggers, node)) {
+                        ply_keystroke_watch_t *keystroke_trigger = ply_list_node_get_data (node);
+                        if (!keystroke_trigger->keys || strstr (keystroke_trigger->keys, "\n")) { /* assume strstr works on utf8 arrays */
+                                ply_trigger_pull (keystroke_trigger->trigger, line);
+                                ply_list_remove_node (state->keystroke_triggers, node);
+                                free (keystroke_trigger);
+                                return;
+                        }
+                }
+                return;
         }
-      return;
-    }
 }
 
 static void
 attach_splash_to_seats (state_t           *state,
                         ply_boot_splash_t *splash)
 {
+        ply_list_t *seats;
+        ply_list_node_t *node;
 
-  ply_list_t *seats;
-  ply_list_node_t *node;
-
-  seats = ply_device_manager_get_seats (state->device_manager);
-  node = ply_list_get_first_node (seats);
-  while (node != NULL)
-    {
-      ply_seat_t *seat;
-      ply_list_node_t *next_node;
+        seats = ply_device_manager_get_seats (state->device_manager);
+        node = ply_list_get_first_node (seats);
+        while (node != NULL) {
+                ply_seat_t *seat;
+                ply_list_node_t *next_node;
 
-      seat = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (seats, node);
+                seat = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (seats, node);
 
-      ply_boot_splash_attach_to_seat (splash, seat);
+                ply_boot_splash_attach_to_seat (splash, seat);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 #ifdef PLY_ENABLE_SYSTEMD_INTEGRATION
 static void
 tell_systemd_to_print_details (state_t *state)
 {
-  ply_trace ("telling systemd to start printing details");
-  if (kill (1, SIGRTMIN + 20) < 0)
-    ply_trace ("could not tell systemd to print details: %m");
+        ply_trace ("telling systemd to start printing details");
+        if (kill (1, SIGRTMIN + 20) < 0)
+                ply_trace ("could not tell systemd to print details: %m");
 }
 
 static void
 tell_systemd_to_stop_printing_details (state_t *state)
 {
-  ply_trace ("telling systemd to stop printing details");
-  if (kill (1, SIGRTMIN + 21) < 0)
-    ply_trace ("could not tell systemd to stop printing details: %m");
+        ply_trace ("telling systemd to stop printing details");
+        if (kill (1, SIGRTMIN + 21) < 0)
+                ply_trace ("could not tell systemd to stop printing details: %m");
 }
 #endif
 
 static ply_boot_splash_t *
 load_built_in_theme (state_t *state)
 {
-  ply_boot_splash_t *splash;
-  bool is_loaded;
+        ply_boot_splash_t *splash;
+        bool is_loaded;
 
-  ply_trace ("Loading built-in theme");
+        ply_trace ("Loading built-in theme");
 
-  splash = ply_boot_splash_new ("",
-                                PLYMOUTH_PLUGIN_PATH,
-                                state->boot_buffer);
+        splash = ply_boot_splash_new ("",
+                                      PLYMOUTH_PLUGIN_PATH,
+                                      state->boot_buffer);
 
-  is_loaded = ply_boot_splash_load_built_in (splash);
+        is_loaded = ply_boot_splash_load_built_in (splash);
 
-  if (!is_loaded)
-    {
-      ply_save_errno ();
-      ply_boot_splash_free (splash);
-      ply_restore_errno ();
-      return NULL;
-    }
+        if (!is_loaded) {
+                ply_save_errno ();
+                ply_boot_splash_free (splash);
+                ply_restore_errno ();
+                return NULL;
+        }
 
-  ply_trace ("attaching plugin to event loop");
-  ply_boot_splash_attach_to_event_loop (splash, state->loop);
+        ply_trace ("attaching plugin to event loop");
+        ply_boot_splash_attach_to_event_loop (splash, state->loop);
 
-  ply_trace ("attaching progress to plugin");
-  ply_boot_splash_attach_progress (splash, state->progress);
+        ply_trace ("attaching progress to plugin");
+        ply_boot_splash_attach_progress (splash, state->progress);
 
-  return splash;
+        return splash;
 }
 
 static ply_boot_splash_t *
 load_theme (state_t    *state,
             const char *theme_path)
 {
-  ply_boot_splash_t *splash;
-  bool is_loaded;
+        ply_boot_splash_t *splash;
+        bool is_loaded;
 
-  ply_trace ("Loading boot splash theme '%s'",
-             theme_path);
+        ply_trace ("Loading boot splash theme '%s'",
+                   theme_path);
 
-  splash = ply_boot_splash_new (theme_path,
-                                PLYMOUTH_PLUGIN_PATH,
-                                state->boot_buffer);
+        splash = ply_boot_splash_new (theme_path,
+                                      PLYMOUTH_PLUGIN_PATH,
+                                      state->boot_buffer);
 
-  is_loaded = ply_boot_splash_load (splash);
+        is_loaded = ply_boot_splash_load (splash);
 
-  if (!is_loaded)
-    {
-      ply_save_errno ();
-      ply_boot_splash_free (splash);
-      ply_restore_errno ();
-      return NULL;
-    }
+        if (!is_loaded) {
+                ply_save_errno ();
+                ply_boot_splash_free (splash);
+                ply_restore_errno ();
+                return NULL;
+        }
 
-  ply_trace ("attaching plugin to event loop");
-  ply_boot_splash_attach_to_event_loop (splash, state->loop);
+        ply_trace ("attaching plugin to event loop");
+        ply_boot_splash_attach_to_event_loop (splash, state->loop);
 
-  ply_trace ("attaching progress to plugin");
-  ply_boot_splash_attach_progress (splash, state->progress);
+        ply_trace ("attaching progress to plugin");
+        ply_boot_splash_attach_progress (splash, state->progress);
 
-  return splash;
+        return splash;
 }
 
 static ply_boot_splash_t *
-show_theme (state_t           *state,
-            const char        *theme_path)
+show_theme (state_t    *state,
+            const char *theme_path)
 {
-  ply_boot_splash_mode_t splash_mode;
-  ply_boot_splash_t *splash;
+        ply_boot_splash_mode_t splash_mode;
+        ply_boot_splash_t *splash;
 
-  if (theme_path != NULL)
-    splash = load_theme (state, theme_path);
-  else
-    splash = load_built_in_theme (state);
+        if (theme_path != NULL)
+                splash = load_theme (state, theme_path);
+        else
+                splash = load_built_in_theme (state);
 
-  if (splash == NULL)
-    return NULL;
+        if (splash == NULL)
+                return NULL;
 
-  attach_splash_to_seats (state, splash);
-  ply_device_manager_activate_renderers (state->device_manager);
+        attach_splash_to_seats (state, splash);
+        ply_device_manager_activate_renderers (state->device_manager);
 
-  if (state->mode == PLY_MODE_SHUTDOWN)
-    splash_mode = PLY_BOOT_SPLASH_MODE_SHUTDOWN;
-  else
-    splash_mode = PLY_BOOT_SPLASH_MODE_BOOT_UP;
+        if (state->mode == PLY_MODE_SHUTDOWN)
+                splash_mode = PLY_BOOT_SPLASH_MODE_SHUTDOWN;
+        else
+                splash_mode = PLY_BOOT_SPLASH_MODE_BOOT_UP;
 
-  if (!ply_boot_splash_show (splash, splash_mode))
-    {
-      ply_save_errno ();
-      ply_boot_splash_free (splash);
-      ply_restore_errno ();
-      return NULL;
-    }
+        if (!ply_boot_splash_show (splash, splash_mode)) {
+                ply_save_errno ();
+                ply_boot_splash_free (splash);
+                ply_restore_errno ();
+                return NULL;
+        }
 
 #ifdef PLY_ENABLE_SYSTEMD_INTEGRATION
-  if (state->is_attached)
-    tell_systemd_to_print_details (state);
+        if (state->is_attached)
+                tell_systemd_to_print_details (state);
 #endif
 
-  ply_device_manager_activate_keyboards (state->device_manager);
-  show_messages (state);
+        ply_device_manager_activate_keyboards (state->device_manager);
+        show_messages (state);
 
-  return splash;
+        return splash;
 }
 
 static bool
 attach_to_running_session (state_t *state)
 {
-  ply_terminal_session_t *session;
-  ply_terminal_session_flags_t flags;
-  bool should_be_redirected;
-
-  flags = 0;
+        ply_terminal_session_t *session;
+        ply_terminal_session_flags_t flags;
+        bool should_be_redirected;
 
-  should_be_redirected = !state->no_boot_log;
+        flags = 0;
 
-  if (should_be_redirected)
-    flags |= PLY_TERMINAL_SESSION_FLAGS_REDIRECT_CONSOLE;
+        should_be_redirected = !state->no_boot_log;
 
- if (state->session == NULL)
-   {
-     ply_trace ("creating new terminal session");
-     session = ply_terminal_session_new (NULL);
+        if (should_be_redirected)
+                flags |= PLY_TERMINAL_SESSION_FLAGS_REDIRECT_CONSOLE;
 
-     ply_terminal_session_attach_to_event_loop (session, state->loop);
-   }
- else
-   {
-     session = state->session;
-     ply_trace ("session already created");
-   }
+        if (state->session == NULL) {
+                ply_trace ("creating new terminal session");
+                session = ply_terminal_session_new (NULL);
 
-  if (!ply_terminal_session_attach (session, flags,
-                                 (ply_terminal_session_output_handler_t)
-                                 on_session_output,
-                                 (ply_terminal_session_hangup_handler_t)
-                                 (should_be_redirected? on_session_hangup: NULL),
-                                 -1, state))
-    {
-      ply_save_errno ();
-      ply_terminal_session_free (session);
-      ply_buffer_free (state->boot_buffer);
-      state->boot_buffer = NULL;
-      ply_restore_errno ();
+                ply_terminal_session_attach_to_event_loop (session, state->loop);
+        } else {
+                session = state->session;
+                ply_trace ("session already created");
+        }
 
-      state->is_redirected = false;
-      state->is_attached = false;
-      return false;
-    }
+        if (!ply_terminal_session_attach (session, flags,
+                                          (ply_terminal_session_output_handler_t)
+                                          on_session_output,
+                                          (ply_terminal_session_hangup_handler_t)
+                                          (should_be_redirected ? on_session_hangup : NULL),
+                                          -1, state)) {
+                ply_save_errno ();
+                ply_terminal_session_free (session);
+                ply_buffer_free (state->boot_buffer);
+                state->boot_buffer = NULL;
+                ply_restore_errno ();
+
+                state->is_redirected = false;
+                state->is_attached = false;
+                return false;
+        }
 
-  state->is_redirected = should_be_redirected;
-  state->is_attached = true;
-  state->session = session;
+        state->is_redirected = should_be_redirected;
+        state->is_attached = true;
+        state->session = session;
 
-  return true;
+        return true;
 }
 
 static void
 detach_from_running_session (state_t *state)
 {
-  if (state->session == NULL)
-    return;
+        if (state->session == NULL)
+                return;
 
-  if (!state->is_attached)
-    return;
+        if (!state->is_attached)
+                return;
 
-  ply_trace ("detaching from terminal session");
-  ply_terminal_session_detach (state->session);
-  state->is_redirected = false;
-  state->is_attached = false;
+        ply_trace ("detaching from terminal session");
+        ply_terminal_session_detach (state->session);
+        state->is_redirected = false;
+        state->is_attached = false;
 }
 
 static bool
 get_kernel_command_line (state_t *state)
 {
-  int fd;
-  const char *remaining_command_line;
-  char *key;
+        int fd;
+        const char *remaining_command_line;
+        char *key;
 
-  if (state->kernel_command_line_is_set)
-    return true;
+        if (state->kernel_command_line_is_set)
+                return true;
 
-  ply_trace ("opening /proc/cmdline");
-  fd = open ("/proc/cmdline", O_RDONLY);
+        ply_trace ("opening /proc/cmdline");
+        fd = open ("/proc/cmdline", O_RDONLY);
 
-  if (fd < 0)
-    {
-      ply_trace ("couldn't open it: %m");
-      return false;
-    }
+        if (fd < 0) {
+                ply_trace ("couldn't open it: %m");
+                return false;
+        }
 
-  ply_trace ("reading kernel command line");
-  if (read (fd, state->kernel_command_line, sizeof (state->kernel_command_line)) < 0)
-    {
-      ply_trace ("couldn't read it: %m");
-      close (fd);
-      return false;
-    }
+        ply_trace ("reading kernel command line");
+        if (read (fd, state->kernel_command_line, sizeof(state->kernel_command_line)) < 0) {
+                ply_trace ("couldn't read it: %m");
+                close (fd);
+                return false;
+        }
 
 
-  /* we now use plymouth.argument for kernel commandline arguments.
-   * It used to be plymouth:argument. This bit just rewrites all : to be .
-   */
-  remaining_command_line = state->kernel_command_line;
-  while ((key = strstr (remaining_command_line, "plymouth:")) != NULL)
-    {
-      char *colon;
+        /* we now use plymouth.argument for kernel commandline arguments.
+         * It used to be plymouth:argument. This bit just rewrites all : to be .
+         */
+        remaining_command_line = state->kernel_command_line;
+        while ((key = strstr (remaining_command_line, "plymouth:")) != NULL) {
+                char *colon;
 
-      colon = key + strlen ("plymouth");
-      *colon = '.';
+                colon = key + strlen ("plymouth");
+                *colon = '.';
 
-      remaining_command_line = colon + 1;
-    }
-  ply_trace ("Kernel command line is: '%s'", state->kernel_command_line);
+                remaining_command_line = colon + 1;
+        }
+        ply_trace ("Kernel command line is: '%s'", state->kernel_command_line);
 
-  close (fd);
+        close (fd);
 
-  state->kernel_command_line_is_set = true;
-  return true;
+        state->kernel_command_line_is_set = true;
+        return true;
 }
 
 static void
 check_verbosity (state_t *state)
 {
-  const char *stream;
-  const char *path;
+        const char *stream;
+        const char *path;
 
-  ply_trace ("checking if tracing should be enabled");
+        ply_trace ("checking if tracing should be enabled");
 
-  stream = command_line_get_string_after_prefix (state->kernel_command_line,
-                                                 "plymouth.debug=stream:");
+        stream = command_line_get_string_after_prefix (state->kernel_command_line,
+                                                       "plymouth.debug=stream:");
 
-  path = command_line_get_string_after_prefix (state->kernel_command_line,
-                                               "plymouth.debug=file:");
-  if (stream != NULL || path != NULL ||
-      command_line_has_argument (state->kernel_command_line, "plymouth.debug"))
-    {
-      int fd;
+        path = command_line_get_string_after_prefix (state->kernel_command_line,
+                                                     "plymouth.debug=file:");
+        if (stream != NULL || path != NULL ||
+            command_line_has_argument (state->kernel_command_line, "plymouth.debug")) {
+                int fd;
 
-      ply_trace ("tracing should be enabled!");
-      if (!ply_is_tracing ())
-        ply_toggle_tracing ();
+                ply_trace ("tracing should be enabled!");
+                if (!ply_is_tracing ())
+                        ply_toggle_tracing ();
 
-      if (path != NULL && debug_buffer_path == NULL)
-        {
-          char *end;
+                if (path != NULL && debug_buffer_path == NULL) {
+                        char *end;
 
-          debug_buffer_path = strdup (path);
-          end = debug_buffer_path + strcspn (debug_buffer_path, " \n");
-          *end = '\0';
-        }
+                        debug_buffer_path = strdup (path);
+                        end = debug_buffer_path + strcspn (debug_buffer_path, " \n");
+                        *end = '\0';
+                }
 
-        if (debug_buffer == NULL)
-          debug_buffer = ply_buffer_new ();
+                if (debug_buffer == NULL)
+                        debug_buffer = ply_buffer_new ();
 
-      if (stream != NULL)
-        {
-          char *end;
-          char *stream_copy;
-
-          stream_copy = strdup (stream);
-          end = stream_copy + strcspn (stream_copy, " \n");
-          *end = '\0';
-
-          ply_trace ("streaming debug output to %s instead of screen", stream_copy);
-          fd = open (stream_copy, O_RDWR | O_NOCTTY | O_CREAT, 0600);
-
-          if (fd < 0)
-            {
-              ply_trace ("could not stream output to %s: %m", stream_copy);
-            }
-          else
-            {
-              ply_logger_set_output_fd (ply_logger_get_error_default (), fd);
-            }
-          free (stream_copy);
-        } else {
-            const char* device;
-            char *file;
+                if (stream != NULL) {
+                        char *end;
+                        char *stream_copy;
 
-            device = state->default_tty;
+                        stream_copy = strdup (stream);
+                        end = stream_copy + strcspn (stream_copy, " \n");
+                        *end = '\0';
 
-            ply_trace ("redirecting debug output to %s", device);
+                        ply_trace ("streaming debug output to %s instead of screen", stream_copy);
+                        fd = open (stream_copy, O_RDWR | O_NOCTTY | O_CREAT, 0600);
 
-            if (strncmp (device, "/dev/", strlen ("/dev/")) == 0)
-                file = strdup (device);
-              else
-                asprintf (&file, "/dev/%s", device);
+                        if (fd < 0)
+                                ply_trace ("could not stream output to %s: %m", stream_copy);
+                        else
+                                ply_logger_set_output_fd (ply_logger_get_error_default (), fd);
+                        free (stream_copy);
+                } else {
+                        const char *device;
+                        char *file;
 
-            fd = open (file, O_RDWR | O_APPEND);
+                        device = state->default_tty;
 
-            if (fd < 0)
-              {
-                 ply_trace ("could not redirected debug output to %s: %m", device);
-              }
-            else {
-                ply_logger_set_output_fd (ply_logger_get_error_default (), fd);
-            }
+                        ply_trace ("redirecting debug output to %s", device);
 
-            free (file);
-        }
-    }
-  else
-    ply_trace ("tracing shouldn't be enabled!");
+                        if (strncmp (device, "/dev/", strlen ("/dev/")) == 0)
+                                file = strdup (device);
+                        else
+                                asprintf (&file, "/dev/%s", device);
 
-  if (debug_buffer != NULL)
-    {
-      if (debug_buffer_path == NULL)
-        debug_buffer_path = strdup (PLYMOUTH_LOG_DIRECTORY "/plymouth-debug.log");
+                        fd = open (file, O_RDWR | O_APPEND);
+
+                        if (fd < 0)
+                                ply_trace ("could not redirected debug output to %s: %m", device);
+                        else
+                                ply_logger_set_output_fd (ply_logger_get_error_default (), fd);
+
+                        free (file);
+                }
+        } else {
+                ply_trace ("tracing shouldn't be enabled!");
+        }
 
-      ply_logger_add_filter (ply_logger_get_error_default (),
-                             (ply_logger_filter_handler_t)
-                             on_error_message,
-                             debug_buffer);
+        if (debug_buffer != NULL) {
+                if (debug_buffer_path == NULL)
+                        debug_buffer_path = strdup (PLYMOUTH_LOG_DIRECTORY "/plymouth-debug.log");
 
-    }
+                ply_logger_add_filter (ply_logger_get_error_default (),
+                                       (ply_logger_filter_handler_t)
+                                       on_error_message,
+                                       debug_buffer);
+        }
 }
 
 static void
 check_logging (state_t *state)
 {
-  bool kernel_no_log;
+        bool kernel_no_log;
 
-  ply_trace ("checking if console messages should be redirected and logged");
+        ply_trace ("checking if console messages should be redirected and logged");
 
-  kernel_no_log = command_line_has_argument (state->kernel_command_line, "plymouth.nolog");
-  if (kernel_no_log)
-    state->no_boot_log = true;
+        kernel_no_log = command_line_has_argument (state->kernel_command_line, "plymouth.nolog");
+        if (kernel_no_log)
+                state->no_boot_log = true;
 
-  if (state->no_boot_log)
-    ply_trace ("logging won't be enabled!");
-  else
-    ply_trace ("logging will be enabled!");
+        if (state->no_boot_log)
+                ply_trace ("logging won't be enabled!");
+        else
+                ply_trace ("logging will be enabled!");
 }
 
 static bool
 redirect_standard_io_to_dev_null (void)
 {
-  int fd;
+        int fd;
 
-  fd = open ("/dev/null", O_RDWR | O_APPEND);
+        fd = open ("/dev/null", O_RDWR | O_APPEND);
 
-  if (fd < 0)
-    return false;
+        if (fd < 0)
+                return false;
 
-  dup2 (fd, STDIN_FILENO);
-  dup2 (fd, STDOUT_FILENO);
-  dup2 (fd, STDERR_FILENO);
+        dup2 (fd, STDIN_FILENO);
+        dup2 (fd, STDOUT_FILENO);
+        dup2 (fd, STDERR_FILENO);
 
-  close (fd);
+        close (fd);
 
-  return true;
+        return true;
 }
 static const char *
 find_fallback_tty (state_t *state)
 {
-  static const char *tty_list[] =
-    {
-      "/dev/ttyS0",
-      "/dev/hvc0",
-      "/dev/xvc0",
-      "/dev/ttySG0",
-      NULL
-    };
-  int i;
-
-  for (i = 0; tty_list[i] != NULL; i++)
-    {
-      if (ply_character_device_exists (tty_list[i]))
-        return tty_list[i];
-    }
+        static const char *tty_list[] =
+        {
+                "/dev/ttyS0",
+                "/dev/hvc0",
+                "/dev/xvc0",
+                "/dev/ttySG0",
+                NULL
+        };
+        int i;
+
+        for (i = 0; tty_list[i] != NULL; i++) {
+                if (ply_character_device_exists (tty_list[i]))
+                        return tty_list[i];
+        }
 
-  return state->default_tty;
+        return state->default_tty;
 }
 
 static bool
 initialize_environment (state_t *state)
 {
-  ply_trace ("initializing minimal work environment");
+        ply_trace ("initializing minimal work environment");
 
-  if (!get_kernel_command_line (state))
-    return false;
+        if (!get_kernel_command_line (state))
+                return false;
 
-  if (!state->default_tty)
-    {
-      if (getenv ("DISPLAY") != NULL && access (PLYMOUTH_PLUGIN_PATH "renderers/x11.so", F_OK) == 0)
-          state->default_tty = "/dev/tty";
-    }
-  if (!state->default_tty)
-    {
-      if (state->mode == PLY_MODE_SHUTDOWN)
-        {
-          state->default_tty = SHUTDOWN_TTY;
-        }
-      else
-        state->default_tty = BOOT_TTY;
+        if (!state->default_tty)
+                if (getenv ("DISPLAY") != NULL && access (PLYMOUTH_PLUGIN_PATH "renderers/x11.so", F_OK) == 0)
+                        state->default_tty = "/dev/tty";
+        if (!state->default_tty) {
+                if (state->mode == PLY_MODE_SHUTDOWN)
+                        state->default_tty = SHUTDOWN_TTY;
+                else
+                        state->default_tty = BOOT_TTY;
 
-      ply_trace ("checking if '%s' exists", state->default_tty);
-      if (!ply_character_device_exists (state->default_tty))
-        {
-          ply_trace ("nope, forcing details mode");
-          state->should_force_details = true;
+                ply_trace ("checking if '%s' exists", state->default_tty);
+                if (!ply_character_device_exists (state->default_tty)) {
+                        ply_trace ("nope, forcing details mode");
+                        state->should_force_details = true;
 
-          state->default_tty = find_fallback_tty (state);
-          ply_trace ("going to go with '%s'", state->default_tty);
+                        state->default_tty = find_fallback_tty (state);
+                        ply_trace ("going to go with '%s'", state->default_tty);
+                }
         }
-    }
 
-  check_verbosity (state);
-  check_logging (state);
+        check_verbosity (state);
+        check_logging (state);
 
-  ply_trace ("source built on %s", __DATE__);
+        ply_trace ("source built on %s", __DATE__);
 
-  state->keystroke_triggers = ply_list_new ();
-  state->entry_triggers = ply_list_new ();
-  state->entry_buffer = ply_buffer_new();
-  state->messages = ply_list_new ();
+        state->keystroke_triggers = ply_list_new ();
+        state->entry_triggers = ply_list_new ();
+        state->entry_buffer = ply_buffer_new ();
+        state->messages = ply_list_new ();
 
-  redirect_standard_io_to_dev_null ();
+        redirect_standard_io_to_dev_null ();
 
-  ply_trace ("Making sure " PLYMOUTH_RUNTIME_DIR " exists");
-  if (!ply_create_directory (PLYMOUTH_RUNTIME_DIR))
-    ply_trace ("could not create " PLYMOUTH_RUNTIME_DIR ": %m");
+        ply_trace ("Making sure " PLYMOUTH_RUNTIME_DIR " exists");
+        if (!ply_create_directory (PLYMOUTH_RUNTIME_DIR))
+                ply_trace ("could not create " PLYMOUTH_RUNTIME_DIR ": %m");
 
-  ply_trace ("initialized minimal work environment");
-  return true;
+        ply_trace ("initialized minimal work environment");
+        return true;
 }
 
 static void
@@ -2050,331 +1907,309 @@ on_error_message (ply_buffer_t *debug_buffer,
                   const void   *bytes,
                   size_t        number_of_bytes)
 {
-  ply_buffer_append_bytes (debug_buffer, bytes, number_of_bytes);
+        ply_buffer_append_bytes (debug_buffer, bytes, number_of_bytes);
 }
 
 static void
 dump_debug_buffer_to_file (void)
 {
-  int fd;
-  const char *bytes;
-  size_t size;
+        int fd;
+        const char *bytes;
+        size_t size;
 
-  fd = open (debug_buffer_path,
-             O_WRONLY | O_CREAT | O_TRUNC, 0600);
+        fd = open (debug_buffer_path,
+                   O_WRONLY | O_CREAT | O_TRUNC, 0600);
 
-  if (fd < 0)
-    return;
+        if (fd < 0)
+                return;
 
-  size = ply_buffer_get_size (debug_buffer);
-  bytes = ply_buffer_get_bytes (debug_buffer);
-  ply_write (fd, bytes, size);
-  close (fd);
+        size = ply_buffer_get_size (debug_buffer);
+        bytes = ply_buffer_get_bytes (debug_buffer);
+        ply_write (fd, bytes, size);
+        close (fd);
 }
 
- #include <termios.h>
- #include <unistd.h>
+#include <termios.h>
+#include <unistd.h>
 static void
 on_crash (int signum)
 {
-    struct termios term_attributes;
-    int fd;
+        struct termios term_attributes;
+        int fd;
 
-    fd = open ("/dev/tty1", O_RDWR | O_NOCTTY);
-    if (fd < 0) fd = open ("/dev/hvc0", O_RDWR | O_NOCTTY);
+        fd = open ("/dev/tty1", O_RDWR | O_NOCTTY);
+        if (fd < 0) fd = open ("/dev/hvc0", O_RDWR | O_NOCTTY);
 
-    ioctl (fd, KDSETMODE, KD_TEXT);
+        ioctl (fd, KDSETMODE, KD_TEXT);
 
-    tcgetattr (fd, &term_attributes);
+        tcgetattr (fd, &term_attributes);
 
-    term_attributes.c_iflag |= BRKINT | IGNPAR | ICRNL | IXON;
-    term_attributes.c_oflag |= OPOST;
-    term_attributes.c_lflag |= ECHO | ICANON | ISIG | IEXTEN;
+        term_attributes.c_iflag |= BRKINT | IGNPAR | ICRNL | IXON;
+        term_attributes.c_oflag |= OPOST;
+        term_attributes.c_lflag |= ECHO | ICANON | ISIG | IEXTEN;
 
-    tcsetattr (fd, TCSAFLUSH, &term_attributes);
+        tcsetattr (fd, TCSAFLUSH, &term_attributes);
 
-    close (fd);
+        close (fd);
 
-    if (debug_buffer != NULL)
-      {
-        dump_debug_buffer_to_file ();
-        sleep (30);
-      }
+        if (debug_buffer != NULL) {
+                dump_debug_buffer_to_file ();
+                sleep (30);
+        }
 
-    if (pid_file != NULL)
-      {
-        unlink (pid_file);
-        free (pid_file);
-        pid_file = NULL;
-      }
+        if (pid_file != NULL) {
+                unlink (pid_file);
+                free (pid_file);
+                pid_file = NULL;
+        }
 
-    signal (signum, SIG_DFL);
-    raise(signum);
+        signal (signum, SIG_DFL);
+        raise (signum);
 }
 
 static void
 write_pid_file (const char *filename)
 {
-  FILE *fp;
+        FILE *fp;
 
-  fp = fopen (filename, "w");
-  if (fp == NULL)
-    {
-      ply_error ("could not write pid file %s: %m", filename);
-    }
-  else
-    {
-      fprintf (fp, "%d\n", (int) getpid ());
-      fclose (fp);
-    }
+        fp = fopen (filename, "w");
+        if (fp == NULL) {
+                ply_error ("could not write pid file %s: %m", filename);
+        } else {
+                fprintf (fp, "%d\n", (int) getpid ());
+                fclose (fp);
+        }
 }
 
 int
 main (int    argc,
       char **argv)
 {
-  state_t state = { 0 };
-  int exit_code;
-  bool should_help = false;
-  bool no_boot_log = false;
-  bool no_daemon = false;
-  bool debug = false;
-  bool attach_to_session;
-  ply_daemon_handle_t *daemon_handle = NULL;
-  char *mode_string = NULL;
-  char *kernel_command_line = NULL;
-  char *tty = NULL;
-  ply_device_manager_flags_t device_manager_flags = PLY_DEVICE_MANAGER_FLAGS_NONE;
-
-  state.start_time = ply_get_timestamp ();
-  state.command_parser = ply_command_parser_new ("plymouthd", "Splash server");
-
-  state.loop = ply_event_loop_get_default ();
-
-  ply_command_parser_add_options (state.command_parser,
-                                  "help", "This help message", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "attach-to-session", "Redirect console messages from screen to log", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "no-daemon", "Do not daemonize", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "debug", "Output debugging information", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "debug-file", "File to output debugging information to", PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "mode", "Mode is one of: boot, shutdown", PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "pid-file", "Write the pid of the daemon to a file", PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "kernel-command-line", "Fake kernel command line to use", PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "tty", "TTY to use instead of default", PLY_COMMAND_OPTION_TYPE_STRING,
-                                  "no-boot-log", "Do not write boot log file", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  NULL);
-
-  if (!ply_command_parser_parse_arguments (state.command_parser, state.loop, argv, argc))
-    {
-      char *help_string;
-
-      help_string = ply_command_parser_get_help_string (state.command_parser);
-
-      ply_error_without_new_line ("%s", help_string);
-
-      free (help_string);
-      return EX_USAGE;
-    }
-
-  ply_command_parser_get_options (state.command_parser,
-                                  "help", &should_help,
-                                  "attach-to-session", &attach_to_session,
-                                  "mode", &mode_string,
-                                  "no-boot-log", &no_boot_log,
-                                  "no-daemon", &no_daemon,
-                                  "debug", &debug,
-                                  "debug-file", &debug_buffer_path,
-                                  "pid-file", &pid_file,
-                                  "tty", &tty,
-                                  "kernel-command-line", &kernel_command_line,
-                                  NULL);
-
-  if (should_help)
-    {
-      char *help_string;
-
-      help_string = ply_command_parser_get_help_string (state.command_parser);
-
-      if (argc < 2)
-        fprintf (stderr, "%s", help_string);
-      else
-        printf ("%s", help_string);
-
-      free (help_string);
-      return 0;
-    }
-
-  if (debug && !ply_is_tracing ())
-    ply_toggle_tracing ();
-
-  if (mode_string != NULL)
-    {
-      if (strcmp (mode_string, "shutdown") == 0)
-        state.mode = PLY_MODE_SHUTDOWN;
-      else if (strcmp (mode_string, "updates") == 0)
-        state.mode = PLY_MODE_UPDATES;
-      else
-        state.mode = PLY_MODE_BOOT;
-
-      free (mode_string);
-    }
-
-  if (tty != NULL)
-    {
-      state.default_tty = tty;
-    }
-
-  if (kernel_command_line != NULL)
-    {
-      strncpy (state.kernel_command_line, kernel_command_line, sizeof (state.kernel_command_line));
-      state.kernel_command_line[sizeof (state.kernel_command_line) - 1] = '\0';
-      state.kernel_command_line_is_set = true;
-    }
-
-  if (geteuid () != 0)
-    {
-      ply_error ("plymouthd must be run as root user");
-      return EX_OSERR;
-    }
-
-  state.no_boot_log = no_boot_log;
-
-  chdir ("/");
-  signal (SIGPIPE, SIG_IGN);
-
-  if (! no_daemon)
-    {
-      daemon_handle = ply_create_daemon ();
-
-      if (daemon_handle == NULL)
-        {
-          ply_error ("plymouthd: cannot daemonize: %m");
-          return EX_UNAVAILABLE;
+        state_t state = { 0 };
+        int exit_code;
+        bool should_help = false;
+        bool no_boot_log = false;
+        bool no_daemon = false;
+        bool debug = false;
+        bool attach_to_session;
+        ply_daemon_handle_t *daemon_handle = NULL;
+        char *mode_string = NULL;
+        char *kernel_command_line = NULL;
+        char *tty = NULL;
+        ply_device_manager_flags_t device_manager_flags = PLY_DEVICE_MANAGER_FLAGS_NONE;
+
+        state.start_time = ply_get_timestamp ();
+        state.command_parser = ply_command_parser_new ("plymouthd", "Splash server");
+
+        state.loop = ply_event_loop_get_default ();
+
+        ply_command_parser_add_options (state.command_parser,
+                                        "help", "This help message", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "attach-to-session", "Redirect console messages from screen to log", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "no-daemon", "Do not daemonize", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "debug", "Output debugging information", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "debug-file", "File to output debugging information to", PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "mode", "Mode is one of: boot, shutdown", PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "pid-file", "Write the pid of the daemon to a file", PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "kernel-command-line", "Fake kernel command line to use", PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "tty", "TTY to use instead of default", PLY_COMMAND_OPTION_TYPE_STRING,
+                                        "no-boot-log", "Do not write boot log file", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        NULL);
+
+        if (!ply_command_parser_parse_arguments (state.command_parser, state.loop, argv, argc)) {
+                char *help_string;
+
+                help_string = ply_command_parser_get_help_string (state.command_parser);
+
+                ply_error_without_new_line ("%s", help_string);
+
+                free (help_string);
+                return EX_USAGE;
         }
-    }
 
-  if (debug)
-    debug_buffer = ply_buffer_new ();
+        ply_command_parser_get_options (state.command_parser,
+                                        "help", &should_help,
+                                        "attach-to-session", &attach_to_session,
+                                        "mode", &mode_string,
+                                        "no-boot-log", &no_boot_log,
+                                        "no-daemon", &no_daemon,
+                                        "debug", &debug,
+                                        "debug-file", &debug_buffer_path,
+                                        "pid-file", &pid_file,
+                                        "tty", &tty,
+                                        "kernel-command-line", &kernel_command_line,
+                                        NULL);
+
+        if (should_help) {
+                char *help_string;
+
+                help_string = ply_command_parser_get_help_string (state.command_parser);
+
+                if (argc < 2)
+                        fprintf (stderr, "%s", help_string);
+                else
+                        printf ("%s", help_string);
+
+                free (help_string);
+                return 0;
+        }
 
-  signal (SIGABRT, on_crash);
-  signal (SIGSEGV, on_crash);
+        if (debug && !ply_is_tracing ())
+                ply_toggle_tracing ();
 
-  /* before do anything we need to make sure we have a working
-   * environment.
-   */
-  if (!initialize_environment (&state))
-    {
-      if (errno == 0)
-        {
-          if (daemon_handle != NULL)
-            ply_detach_daemon (daemon_handle, 0);
-          return 0;
+        if (mode_string != NULL) {
+                if (strcmp (mode_string, "shutdown") == 0)
+                        state.mode = PLY_MODE_SHUTDOWN;
+                else if (strcmp (mode_string, "updates") == 0)
+                        state.mode = PLY_MODE_UPDATES;
+                else
+                        state.mode = PLY_MODE_BOOT;
+
+                free (mode_string);
         }
 
-      ply_error ("plymouthd: could not setup basic operating environment: %m");
-      if (daemon_handle != NULL)
-        ply_detach_daemon (daemon_handle, EX_OSERR);
-      return EX_OSERR;
-    }
+        if (tty != NULL)
+                state.default_tty = tty;
+
+        if (kernel_command_line != NULL) {
+                strncpy (state.kernel_command_line, kernel_command_line, sizeof(state.kernel_command_line));
+                state.kernel_command_line[sizeof(state.kernel_command_line) - 1] = '\0';
+                state.kernel_command_line_is_set = true;
+        }
 
-  /* Make the first byte in argv be '@' so that we can survive systemd's killing
-   * spree when going from initrd to /, and so we stay alive all the way until
-   * the power is killed at shutdown.
-   * http://www.freedesktop.org/wiki/Software/systemd/RootStorageDaemons
-   */
-  argv[0][0] = '@';
+        if (geteuid () != 0) {
+                ply_error ("plymouthd must be run as root user");
+                return EX_OSERR;
+        }
 
-  state.boot_server = start_boot_server (&state);
+        state.no_boot_log = no_boot_log;
 
-  if (state.boot_server == NULL)
-    {
-      ply_trace ("plymouthd is already running");
+        chdir ("/");
+        signal (SIGPIPE, SIG_IGN);
 
-      if (daemon_handle != NULL)
-        ply_detach_daemon (daemon_handle, EX_OK);
-      return EX_OK;
-    }
+        if (!no_daemon) {
+                daemon_handle = ply_create_daemon ();
 
-  state.boot_buffer = ply_buffer_new ();
+                if (daemon_handle == NULL) {
+                        ply_error ("plymouthd: cannot daemonize: %m");
+                        return EX_UNAVAILABLE;
+                }
+        }
 
-  if (attach_to_session)
-    {
-      state.should_be_attached = attach_to_session;
-      if (!attach_to_running_session (&state))
-        {
-          ply_trace ("could not redirect console session: %m");
-          if (! no_daemon)
-            ply_detach_daemon (daemon_handle, EX_UNAVAILABLE);
-          return EX_UNAVAILABLE;
+        if (debug)
+                debug_buffer = ply_buffer_new ();
+
+        signal (SIGABRT, on_crash);
+        signal (SIGSEGV, on_crash);
+
+        /* before do anything we need to make sure we have a working
+         * environment.
+         */
+        if (!initialize_environment (&state)) {
+                if (errno == 0) {
+                        if (daemon_handle != NULL)
+                                ply_detach_daemon (daemon_handle, 0);
+                        return 0;
+                }
+
+                ply_error ("plymouthd: could not setup basic operating environment: %m");
+                if (daemon_handle != NULL)
+                        ply_detach_daemon (daemon_handle, EX_OSERR);
+                return EX_OSERR;
         }
-    }
 
-  state.progress = ply_progress_new ();
-  state.splash_delay = NAN;
+        /* Make the first byte in argv be '@' so that we can survive systemd's killing
+         * spree when going from initrd to /, and so we stay alive all the way until
+         * the power is killed at shutdown.
+         * http://www.freedesktop.org/wiki/Software/systemd/RootStorageDaemons
+         */
+        argv[0][0] = '@';
 
-  ply_progress_load_cache (state.progress,
-                           get_cache_file_for_mode (state.mode));
+        state.boot_server = start_boot_server (&state);
 
-  if (pid_file != NULL)
-    write_pid_file (pid_file);
+        if (state.boot_server == NULL) {
+                ply_trace ("plymouthd is already running");
 
-  if (daemon_handle != NULL
-      && !ply_detach_daemon (daemon_handle, 0))
-    {
-      ply_error ("plymouthd: could not tell parent to exit: %m");
-      return EX_UNAVAILABLE;
-    }
+                if (daemon_handle != NULL)
+                        ply_detach_daemon (daemon_handle, EX_OK);
+                return EX_OK;
+        }
+
+        state.boot_buffer = ply_buffer_new ();
+
+        if (attach_to_session) {
+                state.should_be_attached = attach_to_session;
+                if (!attach_to_running_session (&state)) {
+                        ply_trace ("could not redirect console session: %m");
+                        if (!no_daemon)
+                                ply_detach_daemon (daemon_handle, EX_UNAVAILABLE);
+                        return EX_UNAVAILABLE;
+                }
+        }
+
+        state.progress = ply_progress_new ();
+        state.splash_delay = NAN;
+
+        ply_progress_load_cache (state.progress,
+                                 get_cache_file_for_mode (state.mode));
 
-  find_override_splash (&state);
-  find_system_default_splash (&state);
-  find_distribution_default_splash (&state);
+        if (pid_file != NULL)
+                write_pid_file (pid_file);
 
-  if (command_line_has_argument (state.kernel_command_line, "plymouth.ignore-serial-consoles"))
-    device_manager_flags |= PLY_DEVICE_MANAGER_FLAGS_IGNORE_SERIAL_CONSOLES;
+        if (daemon_handle != NULL
+            && !ply_detach_daemon (daemon_handle, 0)) {
+                ply_error ("plymouthd: could not tell parent to exit: %m");
+                return EX_UNAVAILABLE;
+        }
+
+        find_override_splash (&state);
+        find_system_default_splash (&state);
+        find_distribution_default_splash (&state);
+
+        if (command_line_has_argument (state.kernel_command_line, "plymouth.ignore-serial-consoles"))
+                device_manager_flags |= PLY_DEVICE_MANAGER_FLAGS_IGNORE_SERIAL_CONSOLES;
 
-  if (command_line_has_argument (state.kernel_command_line, "plymouth.ignore-udev") ||
-      (getenv ("DISPLAY") != NULL))
-    device_manager_flags |= PLY_DEVICE_MANAGER_FLAGS_IGNORE_UDEV;
+        if (command_line_has_argument (state.kernel_command_line, "plymouth.ignore-udev") ||
+            (getenv ("DISPLAY") != NULL))
+                device_manager_flags |= PLY_DEVICE_MANAGER_FLAGS_IGNORE_UDEV;
 
-  if (!plymouth_should_show_default_splash (&state))
-    {
-      /* don't bother listening for udev events if we're forcing details */
-      device_manager_flags |= PLY_DEVICE_MANAGER_FLAGS_IGNORE_UDEV;
+        if (!plymouth_should_show_default_splash (&state)) {
+                /* don't bother listening for udev events if we're forcing details */
+                device_manager_flags |= PLY_DEVICE_MANAGER_FLAGS_IGNORE_UDEV;
 
-      /* don't ever delay showing the detailed splash */
-      state.splash_delay = NAN;
-    }
+                /* don't ever delay showing the detailed splash */
+                state.splash_delay = NAN;
+        }
+
+        load_devices (&state, device_manager_flags);
 
-  load_devices (&state, device_manager_flags);
+        ply_trace ("entering event loop");
+        exit_code = ply_event_loop_run (state.loop);
+        ply_trace ("exited event loop");
 
-  ply_trace ("entering event loop");
-  exit_code = ply_event_loop_run (state.loop);
-  ply_trace ("exited event loop");
+        ply_boot_splash_free (state.boot_splash);
+        state.boot_splash = NULL;
 
-  ply_boot_splash_free (state.boot_splash);
-  state.boot_splash = NULL;
+        ply_command_parser_free (state.command_parser);
 
-  ply_command_parser_free (state.command_parser);
+        ply_boot_server_free (state.boot_server);
+        state.boot_server = NULL;
 
-  ply_boot_server_free (state.boot_server);
-  state.boot_server = NULL;
+        ply_trace ("freeing terminal session");
+        ply_terminal_session_free (state.session);
 
-  ply_trace ("freeing terminal session");
-  ply_terminal_session_free (state.session);
+        ply_buffer_free (state.boot_buffer);
+        ply_progress_free (state.progress);
 
-  ply_buffer_free (state.boot_buffer);
-  ply_progress_free (state.progress);
+        ply_trace ("exiting with code %d", exit_code);
 
-  ply_trace ("exiting with code %d", exit_code);
-  
-  if (debug_buffer != NULL)
-    {
-      dump_debug_buffer_to_file ();
-      ply_buffer_free (debug_buffer);
-    }
+        if (debug_buffer != NULL) {
+                dump_debug_buffer_to_file ();
+                ply_buffer_free (debug_buffer);
+        }
 
-  ply_free_error_log();
+        ply_free_error_log ();
 
-  return exit_code;
+        return exit_code;
 }
 /* vim: set sts=4 ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/plugins/controls/label/plugin.c b/src/plugins/controls/label/plugin.c
index a570aca..5edce3b 100644
--- a/src/plugins/controls/label/plugin.c
+++ b/src/plugins/controls/label/plugin.c
@@ -51,147 +51,147 @@
 
 struct _ply_label_plugin_control
 {
-  ply_event_loop_t   *loop;
-  ply_pixel_display_t       *display;
-  ply_rectangle_t     area;
+        ply_event_loop_t    *loop;
+        ply_pixel_display_t *display;
+        ply_rectangle_t      area;
 
-  char               *text;
-  char               *fontdesc;
+        char                *text;
+        char                *fontdesc;
 
-  PangoAlignment      alignment;
-  long                width;
-  float               red;
-  float               green;
-  float               blue;
-  float               alpha;
+        PangoAlignment       alignment;
+        long                 width;
+        float                red;
+        float                green;
+        float                blue;
+        float                alpha;
 
-  uint32_t is_hidden : 1;
+        uint32_t             is_hidden : 1;
 };
 
-ply_label_plugin_interface_t * ply_label_plugin_get_interface (void);
+ply_label_plugin_interface_t *ply_label_plugin_get_interface (void);
 
 static ply_label_plugin_control_t *
 create_control (void)
 {
-  ply_label_plugin_control_t *label;
+        ply_label_plugin_control_t *label;
 
-  label = calloc (1, sizeof (ply_label_plugin_control_t));
+        label = calloc (1, sizeof(ply_label_plugin_control_t));
 
-  label->is_hidden = true;
-  label->alignment = PANGO_ALIGN_LEFT;
-  label->width     = -1;
+        label->is_hidden = true;
+        label->alignment = PANGO_ALIGN_LEFT;
+        label->width = -1;
 
-  return label;
+        return label;
 }
 
 static void
 destroy_control (ply_label_plugin_control_t *label)
 {
-  if (label == NULL)
-    return;
+        if (label == NULL)
+                return;
 
-  free (label);
+        free (label);
 }
 
 static long
 get_width_of_control (ply_label_plugin_control_t *label)
 {
-  return label->area.width;
+        return label->area.width;
 }
 
 static long
 get_height_of_control (ply_label_plugin_control_t *label)
 {
-  return label->area.height;
+        return label->area.height;
 }
 
 static cairo_t *
 get_cairo_context_for_pixel_buffer (ply_label_plugin_control_t *label,
                                     ply_pixel_buffer_t         *pixel_buffer)
 {
-  cairo_surface_t *cairo_surface;
-  cairo_t         *cairo_context;
-  unsigned char   *data;
-  ply_rectangle_t  size;
-
-  data = (unsigned char *) ply_pixel_buffer_get_argb32_data (pixel_buffer);
-  ply_pixel_buffer_get_size (pixel_buffer, &size);
-
-  cairo_surface = cairo_image_surface_create_for_data (data,
-                                                       CAIRO_FORMAT_ARGB32,
-                                                       size.width,
-                                                       size.height,
-                                                       size.width * 4);
-  cairo_context = cairo_create (cairo_surface);
-  cairo_surface_destroy (cairo_surface);
-
-  return cairo_context;
+        cairo_surface_t *cairo_surface;
+        cairo_t *cairo_context;
+        unsigned char *data;
+        ply_rectangle_t size;
+
+        data = (unsigned char *) ply_pixel_buffer_get_argb32_data (pixel_buffer);
+        ply_pixel_buffer_get_size (pixel_buffer, &size);
+
+        cairo_surface = cairo_image_surface_create_for_data (data,
+                                                             CAIRO_FORMAT_ARGB32,
+                                                             size.width,
+                                                             size.height,
+                                                             size.width * 4);
+        cairo_context = cairo_create (cairo_surface);
+        cairo_surface_destroy (cairo_surface);
+
+        return cairo_context;
 }
 
 static cairo_t *
 get_cairo_context_for_sizing (ply_label_plugin_control_t *label)
 {
-  cairo_surface_t *cairo_surface;
-  cairo_t         *cairo_context;
+        cairo_surface_t *cairo_surface;
+        cairo_t *cairo_context;
 
-  cairo_surface = cairo_image_surface_create_for_data (NULL, CAIRO_FORMAT_ARGB32, 0, 0, 0);
-  cairo_context = cairo_create (cairo_surface);
-  cairo_surface_destroy (cairo_surface);
+        cairo_surface = cairo_image_surface_create_for_data (NULL, CAIRO_FORMAT_ARGB32, 0, 0, 0);
+        cairo_context = cairo_create (cairo_surface);
+        cairo_surface_destroy (cairo_surface);
 
-  return cairo_context;
+        return cairo_context;
 }
 
-static PangoLayout*
-init_pango_text_layout (cairo_t *cairo_context,
-			char *text,
-                        char *font_description,
+static PangoLayout *
+init_pango_text_layout (cairo_t       *cairo_context,
+                        char          *text,
+                        char          *font_description,
                         PangoAlignment alignment,
-                        long width)
+                        long           width)
 {
-  PangoLayout          *pango_layout;
-  PangoFontDescription *description;
+        PangoLayout *pango_layout;
+        PangoFontDescription *description;
 
-  pango_layout = pango_cairo_create_layout (cairo_context);
+        pango_layout = pango_cairo_create_layout (cairo_context);
 
-  if (!font_description)
-    description = pango_font_description_from_string ("Sans 12");
-  else
-    description = pango_font_description_from_string (font_description);
+        if (!font_description)
+                description = pango_font_description_from_string ("Sans 12");
+        else
+                description = pango_font_description_from_string (font_description);
 
-  pango_layout_set_font_description (pango_layout, description);
-  pango_font_description_free (description);
+        pango_layout_set_font_description (pango_layout, description);
+        pango_font_description_free (description);
 
-  pango_layout_set_alignment(pango_layout, alignment);
-  if (width >= 0)
-    pango_layout_set_width(pango_layout, width * PANGO_SCALE);
+        pango_layout_set_alignment (pango_layout, alignment);
+        if (width >= 0)
+                pango_layout_set_width (pango_layout, width * PANGO_SCALE);
 
-  pango_layout_set_text (pango_layout, text, -1);
-  pango_cairo_update_layout (cairo_context, pango_layout);
+        pango_layout_set_text (pango_layout, text, -1);
+        pango_cairo_update_layout (cairo_context, pango_layout);
 
-  return pango_layout;
+        return pango_layout;
 }
 
 static void
 size_control (ply_label_plugin_control_t *label)
 {
-  cairo_t              *cairo_context;
-  PangoLayout          *pango_layout;
-  int                   text_width;
-  int                   text_height;
+        cairo_t *cairo_context;
+        PangoLayout *pango_layout;
+        int text_width;
+        int text_height;
 
-  if (label->is_hidden)
-    return;
+        if (label->is_hidden)
+                return;
 
-  cairo_context = get_cairo_context_for_sizing (label);
+        cairo_context = get_cairo_context_for_sizing (label);
 
-  pango_layout = init_pango_text_layout(cairo_context, label->text, label->fontdesc, label->alignment, label->width);
+        pango_layout = init_pango_text_layout (cairo_context, label->text, label->fontdesc, label->alignment, label->width);
 
-  pango_layout_get_size (pango_layout, &text_width, &text_height);
-  label->area.width = (long) ((double) text_width / PANGO_SCALE);
-  label->area.height = (long) ((double) text_height / PANGO_SCALE);
+        pango_layout_get_size (pango_layout, &text_width, &text_height);
+        label->area.width = (long) ((double) text_width / PANGO_SCALE);
+        label->area.height = (long) ((double) text_height / PANGO_SCALE);
 
-  g_object_unref (pango_layout);
-  cairo_destroy (cairo_context);
+        g_object_unref (pango_layout);
+        cairo_destroy (cairo_context);
 }
 
 static void
@@ -202,133 +202,124 @@ draw_control (ply_label_plugin_control_t *label,
               unsigned long               width,
               unsigned long               height)
 {
-  cairo_t              *cairo_context;
-  PangoLayout          *pango_layout;
-  int                   text_width;
-  int                   text_height;
-
-  if (label->is_hidden)
-    return;
-
-  cairo_context = get_cairo_context_for_pixel_buffer (label, pixel_buffer);
-
-  pango_layout = init_pango_text_layout(cairo_context, label->text, label->fontdesc, label->alignment, label->width);
-
-  pango_layout_get_size (pango_layout, &text_width, &text_height);
-  label->area.width = (long) ((double) text_width / PANGO_SCALE);
-  label->area.height = (long) ((double) text_height / PANGO_SCALE);
-
-  cairo_rectangle (cairo_context, x, y, width, height);
-  cairo_clip (cairo_context);
-  cairo_move_to (cairo_context,
-                 label->area.x,
-                 label->area.y);
-  cairo_set_source_rgba (cairo_context,
-                         label->red,
-                         label->green,
-                         label->blue,
-                         label->alpha);
-  pango_cairo_show_layout (cairo_context,
-                           pango_layout);
-
-  g_object_unref (pango_layout);
-  cairo_destroy (cairo_context);
+        cairo_t *cairo_context;
+        PangoLayout *pango_layout;
+        int text_width;
+        int text_height;
+
+        if (label->is_hidden)
+                return;
+
+        cairo_context = get_cairo_context_for_pixel_buffer (label, pixel_buffer);
+
+        pango_layout = init_pango_text_layout (cairo_context, label->text, label->fontdesc, label->alignment, label->width);
+
+        pango_layout_get_size (pango_layout, &text_width, &text_height);
+        label->area.width = (long) ((double) text_width / PANGO_SCALE);
+        label->area.height = (long) ((double) text_height / PANGO_SCALE);
+
+        cairo_rectangle (cairo_context, x, y, width, height);
+        cairo_clip (cairo_context);
+        cairo_move_to (cairo_context,
+                       label->area.x,
+                       label->area.y);
+        cairo_set_source_rgba (cairo_context,
+                               label->red,
+                               label->green,
+                               label->blue,
+                               label->alpha);
+        pango_cairo_show_layout (cairo_context,
+                                 pango_layout);
+
+        g_object_unref (pango_layout);
+        cairo_destroy (cairo_context);
 }
 
 static void
 set_alignment_for_control (ply_label_plugin_control_t *label,
-                           ply_label_alignment_t alignment)
+                           ply_label_alignment_t       alignment)
 {
-  ply_rectangle_t dirty_area;
-  PangoAlignment pango_alignment;
-
-  switch(alignment)
-    {
-    case PLY_LABEL_ALIGN_CENTER:
-      pango_alignment = PANGO_ALIGN_CENTER;
-      break;
-    case PLY_LABEL_ALIGN_RIGHT:
-      pango_alignment = PANGO_ALIGN_RIGHT;
-      break;
-    case PLY_LABEL_ALIGN_LEFT:
-    default:
-      pango_alignment = PANGO_ALIGN_LEFT;
-      break;
-    }
-
-  if (label->alignment != pango_alignment)
-    {
-      dirty_area = label->area;
-      label->alignment = pango_alignment;
-      size_control (label);
-      if (!label->is_hidden && label->display != NULL)
-        ply_pixel_display_draw_area (label->display,
-                                     dirty_area.x, dirty_area.y,
-                                     dirty_area.width, dirty_area.height);
-
-    }
+        ply_rectangle_t dirty_area;
+        PangoAlignment pango_alignment;
+
+        switch (alignment) {
+        case PLY_LABEL_ALIGN_CENTER:
+                pango_alignment = PANGO_ALIGN_CENTER;
+                break;
+        case PLY_LABEL_ALIGN_RIGHT:
+                pango_alignment = PANGO_ALIGN_RIGHT;
+                break;
+        case PLY_LABEL_ALIGN_LEFT:
+        default:
+                pango_alignment = PANGO_ALIGN_LEFT;
+                break;
+        }
+
+        if (label->alignment != pango_alignment) {
+                dirty_area = label->area;
+                label->alignment = pango_alignment;
+                size_control (label);
+                if (!label->is_hidden && label->display != NULL)
+                        ply_pixel_display_draw_area (label->display,
+                                                     dirty_area.x, dirty_area.y,
+                                                     dirty_area.width, dirty_area.height);
+        }
 }
 
 static void
 set_width_for_control (ply_label_plugin_control_t *label,
                        long                        width)
 {
-  ply_rectangle_t dirty_area;
-
-  if (label->width != width)
-    {
-      dirty_area = label->area;
-      label->width = width;
-      size_control (label);
-      if (!label->is_hidden && label->display != NULL)
-        ply_pixel_display_draw_area (label->display,
-                                     dirty_area.x, dirty_area.y,
-                                     dirty_area.width, dirty_area.height);
-
-    }
+        ply_rectangle_t dirty_area;
+
+        if (label->width != width) {
+                dirty_area = label->area;
+                label->width = width;
+                size_control (label);
+                if (!label->is_hidden && label->display != NULL)
+                        ply_pixel_display_draw_area (label->display,
+                                                     dirty_area.x, dirty_area.y,
+                                                     dirty_area.width, dirty_area.height);
+        }
 }
 
 static void
 set_text_for_control (ply_label_plugin_control_t *label,
                       const char                 *text)
 {
-  ply_rectangle_t dirty_area;
-
-  if (label->text != text)
-    {
-      dirty_area = label->area;
-      free (label->text);
-      label->text = strdup (text);
-      size_control (label);
-      if (!label->is_hidden && label->display != NULL)
-        ply_pixel_display_draw_area (label->display,
-                                     dirty_area.x, dirty_area.y,
-                                     dirty_area.width, dirty_area.height);
-
-    }
+        ply_rectangle_t dirty_area;
+
+        if (label->text != text) {
+                dirty_area = label->area;
+                free (label->text);
+                label->text = strdup (text);
+                size_control (label);
+                if (!label->is_hidden && label->display != NULL)
+                        ply_pixel_display_draw_area (label->display,
+                                                     dirty_area.x, dirty_area.y,
+                                                     dirty_area.width, dirty_area.height);
+        }
 }
 
 static void
 set_font_for_control (ply_label_plugin_control_t *label,
                       const char                 *fontdesc)
 {
-  ply_rectangle_t dirty_area;
-
-  if (label->fontdesc != fontdesc)
-    {
-      dirty_area = label->area;
-      free (label->fontdesc);
-      if (fontdesc)
-        label->fontdesc = strdup (fontdesc);
-      else
-        label->fontdesc = NULL;
-      size_control (label);
-      if (!label->is_hidden && label->display != NULL)
-        ply_pixel_display_draw_area (label->display,
-                                     dirty_area.x, dirty_area.y,
-                                     dirty_area.width, dirty_area.height);
-
-    }
+        ply_rectangle_t dirty_area;
+
+        if (label->fontdesc != fontdesc) {
+                dirty_area = label->area;
+                free (label->fontdesc);
+                if (fontdesc)
+                        label->fontdesc = strdup (fontdesc);
+                else
+                        label->fontdesc = NULL;
+                size_control (label);
+                if (!label->is_hidden && label->display != NULL)
+                        ply_pixel_display_draw_area (label->display,
+                                                     dirty_area.x, dirty_area.y,
+                                                     dirty_area.width, dirty_area.height);
+        }
 }
 
 static void
@@ -338,15 +329,15 @@ set_color_for_control (ply_label_plugin_control_t *label,
                        float                       blue,
                        float                       alpha)
 {
-  label->red = red;
-  label->green = green;
-  label->blue = blue;
-  label->alpha = alpha;
-
-  if (!label->is_hidden && label->display != NULL)
-    ply_pixel_display_draw_area (label->display,
-                                 label->area.x, label->area.y,
-                                 label->area.width, label->area.height);
+        label->red = red;
+        label->green = green;
+        label->blue = blue;
+        label->alpha = alpha;
+
+        if (!label->is_hidden && label->display != NULL)
+                ply_pixel_display_draw_area (label->display,
+                                             label->area.x, label->area.y,
+                                             label->area.width, label->area.height);
 }
 
 static bool
@@ -355,67 +346,67 @@ show_control (ply_label_plugin_control_t *label,
               long                        x,
               long                        y)
 {
-  ply_rectangle_t dirty_area;
+        ply_rectangle_t dirty_area;
 
-  dirty_area = label->area;
-  label->display = display;
-  label->area.x = x;
-  label->area.y = y;
+        dirty_area = label->area;
+        label->display = display;
+        label->area.x = x;
+        label->area.y = y;
 
-  label->is_hidden = false;
+        label->is_hidden = false;
 
-  size_control (label);
+        size_control (label);
 
-  if (!label->is_hidden && label->display != NULL)
-    ply_pixel_display_draw_area (label->display,
-                                 dirty_area.x, dirty_area.y,
-                                 dirty_area.width, dirty_area.height);
+        if (!label->is_hidden && label->display != NULL)
+                ply_pixel_display_draw_area (label->display,
+                                             dirty_area.x, dirty_area.y,
+                                             dirty_area.width, dirty_area.height);
 
-  label->is_hidden = false;
+        label->is_hidden = false;
 
-  return true;
+        return true;
 }
 
 static void
 hide_control (ply_label_plugin_control_t *label)
 {
-  label->is_hidden = true;
-  if (label->display != NULL)
-    ply_pixel_display_draw_area (label->display,
-                                 label->area.x, label->area.y,
-                                 label->area.width, label->area.height);
-
-  label->display = NULL;
-  label->loop = NULL;
+        label->is_hidden = true;
+        if (label->display != NULL)
+                ply_pixel_display_draw_area (label->display,
+                                             label->area.x, label->area.y,
+                                             label->area.width, label->area.height);
+
+        label->display = NULL;
+        label->loop = NULL;
 }
 
 static bool
 is_control_hidden (ply_label_plugin_control_t *label)
 {
-  return label->is_hidden;
+        return label->is_hidden;
 }
 
 ply_label_plugin_interface_t *
 ply_label_plugin_get_interface (void)
 {
-  static ply_label_plugin_interface_t plugin_interface =
-    {
-      .create_control = create_control,
-      .destroy_control = destroy_control,
-      .show_control = show_control,
-      .hide_control = hide_control,
-      .draw_control = draw_control,
-      .is_control_hidden = is_control_hidden,
-      .set_text_for_control = set_text_for_control,
-      .set_alignment_for_control = set_alignment_for_control,
-      .set_width_for_control = set_width_for_control,
-      .set_font_for_control = set_font_for_control,
-      .set_color_for_control = set_color_for_control,
-      .get_width_of_control = get_width_of_control,
-      .get_height_of_control = get_height_of_control
-    };
-
-  return &plugin_interface;
+        static ply_label_plugin_interface_t plugin_interface =
+        {
+                .create_control            = create_control,
+                .destroy_control           = destroy_control,
+                .show_control              = show_control,
+                .hide_control              = hide_control,
+                .draw_control              = draw_control,
+                .is_control_hidden         = is_control_hidden,
+                .set_text_for_control      = set_text_for_control,
+                .set_alignment_for_control = set_alignment_for_control,
+                .set_width_for_control     = set_width_for_control,
+                .set_font_for_control      = set_font_for_control,
+                .set_color_for_control     = set_color_for_control,
+                .get_width_of_control      = get_width_of_control,
+                .get_height_of_control     = get_height_of_control
+        };
+
+        return &plugin_interface;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/plugins/renderers/drm/plugin.c b/src/plugins/renderers/drm/plugin.c
index 6677279..45aab7d 100644
--- a/src/plugins/renderers/drm/plugin.c
+++ b/src/plugins/renderers/drm/plugin.c
@@ -65,55 +65,55 @@
 
 struct _ply_renderer_head
 {
-  ply_renderer_backend_t *backend;
-  ply_pixel_buffer_t *pixel_buffer;
-  ply_rectangle_t area;
+        ply_renderer_backend_t *backend;
+        ply_pixel_buffer_t     *pixel_buffer;
+        ply_rectangle_t         area;
 
-  unsigned long row_stride;
+        unsigned long           row_stride;
 
-  ply_array_t *connector_ids;
-  drmModeConnector *connector0;
-  int connector0_mode_index;
+        ply_array_t            *connector_ids;
+        drmModeConnector       *connector0;
+        int                     connector0_mode_index;
 
-  uint32_t controller_id;
-  uint32_t encoder_id;
-  uint32_t console_buffer_id;
-  uint32_t scan_out_buffer_id;
+        uint32_t                controller_id;
+        uint32_t                encoder_id;
+        uint32_t                console_buffer_id;
+        uint32_t                scan_out_buffer_id;
 };
 
 struct _ply_renderer_input_source
 {
-  ply_renderer_backend_t *backend;
-  ply_fd_watch_t *terminal_input_watch;
+        ply_renderer_backend_t             *backend;
+        ply_fd_watch_t                     *terminal_input_watch;
 
-  ply_buffer_t   *key_buffer;
+        ply_buffer_t                       *key_buffer;
 
-  ply_renderer_input_source_handler_t handler;
-  void           *user_data;
+        ply_renderer_input_source_handler_t handler;
+        void                               *user_data;
 };
 
 struct _ply_renderer_backend
 {
-  ply_event_loop_t *loop;
-  ply_terminal_t *terminal;
+        ply_event_loop_t                *loop;
+        ply_terminal_t                  *terminal;
 
-  ply_renderer_driver_interface_t *driver_interface;
-  ply_renderer_driver_t *driver;
-  uint32_t driver_supports_mapping_console;
+        ply_renderer_driver_interface_t *driver_interface;
+        ply_renderer_driver_t           *driver;
+        uint32_t                         driver_supports_mapping_console;
 
-  int device_fd;
-  char *device_name;
-  drmModeRes *resources;
+        int                              device_fd;
+        char                            *device_name;
+        drmModeRes                      *resources;
 
-  ply_renderer_input_source_t input_source;
-  ply_list_t *heads;
-  ply_hashtable_t *heads_by_connector_id;
+        ply_renderer_input_source_t      input_source;
+        ply_list_t                      *heads;
+        ply_hashtable_t                 *heads_by_connector_id;
 
-  int32_t dither_red;
-  int32_t dither_green;
-  int32_t dither_blue;
+        int32_t                          dither_red;
+        int32_t                          dither_green;
+        int32_t                          dither_blue;
 
-  uint32_t is_active : 1;
+        uint32_t                         is_active : 1;
 };
 
 ply_renderer_plugin_interface_t *ply_renderer_backend_get_interface (void);
@@ -131,27 +131,24 @@ ply_renderer_head_add_connector (ply_renderer_head_t *head,
                                  drmModeConnector    *connector,
                                  int                  connector_mode_index)
 {
-  drmModeModeInfo *mode;
-
-  mode = &connector->modes[connector_mode_index];
-
-  if (mode->hdisplay != head->area.width || mode->vdisplay != head->area.height)
-    {
-      ply_trace ("Tried to add connector with resolution %dx%d to %dx%d head",
-                 (int) mode->hdisplay, (int) mode->vdisplay,
-                 (int) head->area.width, (int) head->area.height);
-      return false;
-    }
-  else
-    {
-      ply_trace ("Adding connector with id %d to %dx%d head",
-                 (int) connector->connector_id,
-                 (int) head->area.width, (int) head->area.height);
-    }
-
-  ply_array_add_uint32_element (head->connector_ids, connector->connector_id);
-
-  return true;
+        drmModeModeInfo *mode;
+
+        mode = &connector->modes[connector_mode_index];
+
+        if (mode->hdisplay != head->area.width || mode->vdisplay != head->area.height) {
+                ply_trace ("Tried to add connector with resolution %dx%d to %dx%d head",
+                           (int) mode->hdisplay, (int) mode->vdisplay,
+                           (int) head->area.width, (int) head->area.height);
+                return false;
+        } else {
+                ply_trace ("Adding connector with id %d to %dx%d head",
+                           (int) connector->connector_id,
+                           (int) head->area.width, (int) head->area.height);
+        }
+
+        ply_array_add_uint32_element (head->connector_ids, connector->connector_id);
+
+        return true;
 }
 
 static ply_renderer_head_t *
@@ -162,49 +159,49 @@ ply_renderer_head_new (ply_renderer_backend_t *backend,
                        uint32_t                controller_id,
                        uint32_t                console_buffer_id)
 {
-  ply_renderer_head_t *head;
-  drmModeModeInfo *mode;
+        ply_renderer_head_t *head;
+        drmModeModeInfo *mode;
 
-  head = calloc (1, sizeof (ply_renderer_head_t));
+        head = calloc (1, sizeof(ply_renderer_head_t));
 
-  head->backend = backend;
-  head->encoder_id = encoder_id;
-  head->connector_ids = ply_array_new (PLY_ARRAY_ELEMENT_TYPE_UINT32);
-  head->controller_id = controller_id;
-  head->console_buffer_id = console_buffer_id;
+        head->backend = backend;
+        head->encoder_id = encoder_id;
+        head->connector_ids = ply_array_new (PLY_ARRAY_ELEMENT_TYPE_UINT32);
+        head->controller_id = controller_id;
+        head->console_buffer_id = console_buffer_id;
 
-  assert (connector_mode_index < connector->count_modes);
-  mode = &connector->modes[connector_mode_index];
+        assert (connector_mode_index < connector->count_modes);
+        mode = &connector->modes[connector_mode_index];
 
-  head->connector0 = connector;
-  head->connector0_mode_index = connector_mode_index;
+        head->connector0 = connector;
+        head->connector0_mode_index = connector_mode_index;
 
-  head->area.x = 0;
-  head->area.y = 0;
-  head->area.width = mode->hdisplay;
-  head->area.height = mode->vdisplay;
+        head->area.x = 0;
+        head->area.y = 0;
+        head->area.width = mode->hdisplay;
+        head->area.height = mode->vdisplay;
 
-  ply_renderer_head_add_connector (head, connector, connector_mode_index);
-  assert (ply_array_get_size (head->connector_ids) > 0);
+        ply_renderer_head_add_connector (head, connector, connector_mode_index);
+        assert (ply_array_get_size (head->connector_ids) > 0);
 
-  head->pixel_buffer = ply_pixel_buffer_new (head->area.width, head->area.height);
+        head->pixel_buffer = ply_pixel_buffer_new (head->area.width, head->area.height);
 
-  ply_trace ("Creating %ldx%ld renderer head", head->area.width, head->area.height);
-  ply_pixel_buffer_fill_with_color (head->pixel_buffer, NULL,
-                                    0.0, 0.0, 0.0, 1.0);
+        ply_trace ("Creating %ldx%ld renderer head", head->area.width, head->area.height);
+        ply_pixel_buffer_fill_with_color (head->pixel_buffer, NULL,
+                                          0.0, 0.0, 0.0, 1.0);
 
-  return head;
+        return head;
 }
 
 static void
 ply_renderer_head_free (ply_renderer_head_t *head)
 {
-  ply_trace ("freeing %ldx%ld renderer head", head->area.width, head->area.height);
-  ply_pixel_buffer_free (head->pixel_buffer);
+        ply_trace ("freeing %ldx%ld renderer head", head->area.width, head->area.height);
+        ply_pixel_buffer_free (head->pixel_buffer);
 
-  drmModeFreeConnector (head->connector0);
-  ply_array_free (head->connector_ids);
-  free (head);
+        drmModeFreeConnector (head->connector0);
+        ply_array_free (head->connector_ids);
+        free (head);
 }
 
 static bool
@@ -212,91 +209,88 @@ ply_renderer_head_set_scan_out_buffer (ply_renderer_backend_t *backend,
                                        ply_renderer_head_t    *head,
                                        uint32_t                buffer_id)
 {
-  drmModeModeInfo *mode;
-  uint32_t *connector_ids;
-  int number_of_connectors;
+        drmModeModeInfo *mode;
+        uint32_t *connector_ids;
+        int number_of_connectors;
 
-  connector_ids = (uint32_t *) ply_array_get_uint32_elements (head->connector_ids);
-  number_of_connectors = ply_array_get_size (head->connector_ids);
+        connector_ids = (uint32_t *) ply_array_get_uint32_elements (head->connector_ids);
+        number_of_connectors = ply_array_get_size (head->connector_ids);
 
-  mode = &head->connector0->modes[head->connector0_mode_index];
+        mode = &head->connector0->modes[head->connector0_mode_index];
 
-  ply_trace ("Setting scan out buffer of %ldx%ld head to our buffer",
-             head->area.width, head->area.height);
+        ply_trace ("Setting scan out buffer of %ldx%ld head to our buffer",
+                   head->area.width, head->area.height);
 
-  /* Tell the controller to use the allocated scan out buffer on each connectors
-  */
-  if (drmModeSetCrtc (backend->device_fd, head->controller_id, buffer_id,
-                      0, 0, connector_ids, number_of_connectors, mode) < 0)
-    {
-      ply_trace ("Couldn't set scan out buffer for head with controller id %d",
-                 head->controller_id);
-      return false;
-    }
+        /* Tell the controller to use the allocated scan out buffer on each connectors
+         */
+        if (drmModeSetCrtc (backend->device_fd, head->controller_id, buffer_id,
+                            0, 0, connector_ids, number_of_connectors, mode) < 0) {
+                ply_trace ("Couldn't set scan out buffer for head with controller id %d",
+                           head->controller_id);
+                return false;
+        }
 
-  return true;
+        return true;
 }
 
 static bool
 ply_renderer_head_map (ply_renderer_backend_t *backend,
                        ply_renderer_head_t    *head)
 {
-  bool scan_out_set;
-
-  assert (backend != NULL);
-  assert (backend->device_fd >= 0);
-  assert (backend->driver_interface != NULL);
-  assert (backend->driver != NULL);
-
-  assert (head != NULL);
-
-  ply_trace ("Creating buffer for %ldx%ld renderer head", head->area.width, head->area.height);
-  head->scan_out_buffer_id =
-    backend->driver_interface->create_buffer (backend->driver,
-                                              head->area.width, head->area.height,
-                                              &head->row_stride);
-
-  if (head->scan_out_buffer_id == 0)
-    return false;
+        bool scan_out_set;
+
+        assert (backend != NULL);
+        assert (backend->device_fd >= 0);
+        assert (backend->driver_interface != NULL);
+        assert (backend->driver != NULL);
+
+        assert (head != NULL);
+
+        ply_trace ("Creating buffer for %ldx%ld renderer head", head->area.width, head->area.height);
+        head->scan_out_buffer_id =
+                backend->driver_interface->create_buffer (backend->driver,
+                                                          head->area.width, head->area.height,
+                                                          &head->row_stride);
+
+        if (head->scan_out_buffer_id == 0)
+                return false;
+
+        ply_trace ("Mapping buffer for %ldx%ld renderer head", head->area.width, head->area.height);
+        if (!backend->driver_interface->map_buffer (backend->driver,
+                                                    head->scan_out_buffer_id)) {
+                backend->driver_interface->destroy_buffer (backend->driver,
+                                                           head->scan_out_buffer_id);
+                head->scan_out_buffer_id = 0;
+                return false;
+        }
 
-  ply_trace ("Mapping buffer for %ldx%ld renderer head", head->area.width, head->area.height);
-  if (!backend->driver_interface->map_buffer (backend->driver,
-                                              head->scan_out_buffer_id))
-    {
-      backend->driver_interface->destroy_buffer (backend->driver,
-                                                 head->scan_out_buffer_id);
-      head->scan_out_buffer_id = 0;
-      return false;
-    }
-
-  /* FIXME: Maybe we should blit the fbcon contents instead of the (blank)
-   * shadow buffer?
-   */
-  ply_renderer_head_redraw (backend, head);
-
-  scan_out_set = reset_scan_out_buffer_if_needed (backend, head);
-  if (!scan_out_set && backend->is_active)
-    {
-      backend->driver_interface->destroy_buffer (backend->driver,
-                                                 head->scan_out_buffer_id);
-      head->scan_out_buffer_id = 0;
-      return false;
-    }
+        /* FIXME: Maybe we should blit the fbcon contents instead of the (blank)
+         * shadow buffer?
+         */
+        ply_renderer_head_redraw (backend, head);
+
+        scan_out_set = reset_scan_out_buffer_if_needed (backend, head);
+        if (!scan_out_set && backend->is_active) {
+                backend->driver_interface->destroy_buffer (backend->driver,
+                                                           head->scan_out_buffer_id);
+                head->scan_out_buffer_id = 0;
+                return false;
+        }
 
-  return true;
+        return true;
 }
 
 static void
 ply_renderer_head_unmap (ply_renderer_backend_t *backend,
                          ply_renderer_head_t    *head)
 {
-  ply_trace ("unmapping %ldx%ld renderer head", head->area.width, head->area.height);
-  backend->driver_interface->unmap_buffer (backend->driver,
-                                           head->scan_out_buffer_id);
+        ply_trace ("unmapping %ldx%ld renderer head", head->area.width, head->area.height);
+        backend->driver_interface->unmap_buffer (backend->driver,
+                                                 head->scan_out_buffer_id);
 
-  backend->driver_interface->destroy_buffer (backend->driver,
-                                             head->scan_out_buffer_id);
-  head->scan_out_buffer_id = 0;
+        backend->driver_interface->destroy_buffer (backend->driver,
+                                                   head->scan_out_buffer_id);
+        head->scan_out_buffer_id = 0;
 }
 
 static void
@@ -306,24 +300,22 @@ flush_area (const char      *src,
             unsigned long    dst_row_stride,
             ply_rectangle_t *area_to_flush)
 {
-  unsigned long y1, y2, y;
-
-  y1 = area_to_flush->y;
-  y2 = y1 + area_to_flush->height;
-
-  if (area_to_flush->width * 4 == src_row_stride &&
-      area_to_flush->width * 4 == dst_row_stride)
-    {
-      memcpy (dst, src, area_to_flush->width * area_to_flush->height * 4);
-      return;
-    }
-
-  for (y = y1; y < y2; y++)
-    {
-      memcpy (dst, src, area_to_flush->width * 4);
-      dst += dst_row_stride;
-      src += src_row_stride;
-    }
+        unsigned long y1, y2, y;
+
+        y1 = area_to_flush->y;
+        y2 = y1 + area_to_flush->height;
+
+        if (area_to_flush->width * 4 == src_row_stride &&
+            area_to_flush->width * 4 == dst_row_stride) {
+                memcpy (dst, src, area_to_flush->width * area_to_flush->height * 4);
+                return;
+        }
+
+        for (y = y1; y < y2; y++) {
+                memcpy (dst, src, area_to_flush->width * 4);
+                dst += dst_row_stride;
+                src += src_row_stride;
+        }
 }
 
 static void
@@ -331,306 +323,291 @@ ply_renderer_head_flush_area (ply_renderer_head_t *head,
                               ply_rectangle_t     *area_to_flush,
                               char                *map_address)
 {
-  uint32_t *shadow_buffer;
-  char *dst, *src;
+        uint32_t *shadow_buffer;
+        char *dst, *src;
 
-  shadow_buffer = ply_pixel_buffer_get_argb32_data (head->pixel_buffer);
+        shadow_buffer = ply_pixel_buffer_get_argb32_data (head->pixel_buffer);
 
-  dst = &map_address[area_to_flush->y * head->row_stride + area_to_flush->x * BYTES_PER_PIXEL];
-  src = (char *) &shadow_buffer[area_to_flush->y * head->area.width + area_to_flush->x];
+        dst = &map_address[area_to_flush->y * head->row_stride + area_to_flush->x * BYTES_PER_PIXEL];
+        src = (char *) &shadow_buffer[area_to_flush->y * head->area.width + area_to_flush->x];
 
-  flush_area (src, head->area.width * 4, dst, head->row_stride, area_to_flush);
+        flush_area (src, head->area.width * 4, dst, head->row_stride, area_to_flush);
 }
 
 static void
 free_heads (ply_renderer_backend_t *backend)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (backend->heads);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_renderer_head_t *head;
+        node = ply_list_get_first_node (backend->heads);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_renderer_head_t *head;
 
-      head = (ply_renderer_head_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (backend->heads, node);
+                head = (ply_renderer_head_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (backend->heads, node);
 
-      ply_renderer_head_free (head);
-      ply_list_remove_node (backend->heads, node);
+                ply_renderer_head_free (head);
+                ply_list_remove_node (backend->heads, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static ply_renderer_backend_t *
-create_backend (const char *device_name,
+create_backend (const char     *device_name,
                 ply_terminal_t *terminal)
 {
-  ply_renderer_backend_t *backend;
+        ply_renderer_backend_t *backend;
 
-  backend = calloc (1, sizeof (ply_renderer_backend_t));
+        backend = calloc (1, sizeof(ply_renderer_backend_t));
 
-  if (device_name != NULL)
-    backend->device_name = strdup (device_name);
-  else
-    backend->device_name = strdup ("/dev/dri/card0");
+        if (device_name != NULL)
+                backend->device_name = strdup (device_name);
+        else
+                backend->device_name = strdup ("/dev/dri/card0");
 
-  ply_trace ("creating renderer backend for device %s", backend->device_name);
+        ply_trace ("creating renderer backend for device %s", backend->device_name);
 
-  backend->device_fd = -1;
+        backend->device_fd = -1;
 
-  backend->loop = ply_event_loop_get_default ();
-  backend->heads = ply_list_new ();
-  backend->input_source.key_buffer = ply_buffer_new ();
-  backend->terminal = terminal;
+        backend->loop = ply_event_loop_get_default ();
+        backend->heads = ply_list_new ();
+        backend->input_source.key_buffer = ply_buffer_new ();
+        backend->terminal = terminal;
 
-  return backend;
+        return backend;
 }
 
 static void
 destroy_backend (ply_renderer_backend_t *backend)
 {
-  ply_trace ("destroying renderer backend for device %s", backend->device_name);
-  free_heads (backend);
+        ply_trace ("destroying renderer backend for device %s", backend->device_name);
+        free_heads (backend);
 
-  free (backend->device_name);
+        free (backend->device_name);
 
-  free (backend);
+        free (backend);
 }
 
 static void
 activate (ply_renderer_backend_t *backend)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("taking master and scanning out");
-  backend->is_active = true;
+        ply_trace ("taking master and scanning out");
+        backend->is_active = true;
 
-  drmSetMaster (backend->device_fd);
-  node = ply_list_get_first_node (backend->heads);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_renderer_head_t *head;
+        drmSetMaster (backend->device_fd);
+        node = ply_list_get_first_node (backend->heads);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_renderer_head_t *head;
 
-      head = (ply_renderer_head_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (backend->heads, node);
+                head = (ply_renderer_head_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (backend->heads, node);
 
-      if (head->scan_out_buffer_id != 0)
-        {
-          /* Flush out any pending drawing to the buffer
-           */
-          flush_head (backend, head);
+                if (head->scan_out_buffer_id != 0) {
+                        /* Flush out any pending drawing to the buffer
+                         */
+                        flush_head (backend, head);
 
-          /* Then send the buffer to the monitor
-           */
-          ply_renderer_head_set_scan_out_buffer (backend, head,
-                                                 head->scan_out_buffer_id);
-        }
+                        /* Then send the buffer to the monitor
+                         */
+                        ply_renderer_head_set_scan_out_buffer (backend, head,
+                                                               head->scan_out_buffer_id);
+                }
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 deactivate (ply_renderer_backend_t *backend)
 {
-  ply_trace ("dropping master");
-  drmDropMaster (backend->device_fd);
-  backend->is_active = false;
+        ply_trace ("dropping master");
+        drmDropMaster (backend->device_fd);
+        backend->is_active = false;
 }
 
 static void
 on_active_vt_changed (ply_renderer_backend_t *backend)
 {
-  if (ply_terminal_is_active (backend->terminal))
-    {
-      ply_trace ("activating on vt change");
-      activate (backend);
-    }
-  else
-    {
-      ply_trace ("deactivating on vt change");
-      deactivate (backend);
-    }
+        if (ply_terminal_is_active (backend->terminal)) {
+                ply_trace ("activating on vt change");
+                activate (backend);
+        } else {
+                ply_trace ("deactivating on vt change");
+                deactivate (backend);
+        }
 }
 
 static bool
 load_driver (ply_renderer_backend_t *backend)
 {
-  int device_fd;
+        int device_fd;
 
-  ply_trace ("Opening '%s'", backend->device_name);
-  device_fd = open (backend->device_name, O_RDWR);
+        ply_trace ("Opening '%s'", backend->device_name);
+        device_fd = open (backend->device_name, O_RDWR);
 
-  if (device_fd < 0)
-    {
-      ply_trace ("open failed: %m");
-      return false;
-    }
+        if (device_fd < 0) {
+                ply_trace ("open failed: %m");
+                return false;
+        }
 
-  backend->driver_interface = ply_renderer_generic_driver_get_interface (device_fd);
-  backend->driver_supports_mapping_console = false;
+        backend->driver_interface = ply_renderer_generic_driver_get_interface (device_fd);
+        backend->driver_supports_mapping_console = false;
 
-  if (backend->driver_interface == NULL)
-    {
-      close (device_fd);
-      return false;
-    }
+        if (backend->driver_interface == NULL) {
+                close (device_fd);
+                return false;
+        }
 
-  backend->driver = backend->driver_interface->create_driver (device_fd);
+        backend->driver = backend->driver_interface->create_driver (device_fd);
 
-  if (backend->driver == NULL)
-    {
-      close (device_fd);
-      return false;
-    }
+        if (backend->driver == NULL) {
+                close (device_fd);
+                return false;
+        }
 
-  backend->device_fd = device_fd;
+        backend->device_fd = device_fd;
 
-  return true;
+        return true;
 }
 
 static void
 unload_driver (ply_renderer_backend_t *backend)
 {
-  if (backend->driver == NULL)
-    return;
+        if (backend->driver == NULL)
+                return;
 
-  ply_trace ("unloading driver");
-  assert (backend->driver_interface != NULL);
+        ply_trace ("unloading driver");
+        assert (backend->driver_interface != NULL);
 
-  backend->driver_interface->destroy_driver (backend->driver);
-  backend->driver = NULL;
+        backend->driver_interface->destroy_driver (backend->driver);
+        backend->driver = NULL;
 
-  backend->driver_interface = NULL;
+        backend->driver_interface = NULL;
 
-  if (backend->device_fd >= 0)
-    {
-      drmClose (backend->device_fd);
-      backend->device_fd = -1;
-    }
+        if (backend->device_fd >= 0) {
+                drmClose (backend->device_fd);
+                backend->device_fd = -1;
+        }
 }
 
 static bool
 open_device (ply_renderer_backend_t *backend)
 {
-  assert (backend != NULL);
-  assert (backend->device_name != NULL);
-
-  if (!load_driver (backend))
-    return false;
-
-  if (backend->terminal == NULL)
-    return true;
-
-  if (!ply_terminal_open (backend->terminal))
-    {
-      ply_trace ("could not open terminal: %m");
-      return false;
-    }
-
-  if (!ply_terminal_is_vt (backend->terminal))
-    {
-      ply_trace ("terminal is not a VT");
-      ply_terminal_close (backend->terminal);
-      return false;
-    }
-
-  ply_terminal_watch_for_active_vt_change (backend->terminal,
-                                           (ply_terminal_active_vt_changed_handler_t)
-                                           on_active_vt_changed,
-                                           backend);
-
-  return true;
+        assert (backend != NULL);
+        assert (backend->device_name != NULL);
+
+        if (!load_driver (backend))
+                return false;
+
+        if (backend->terminal == NULL)
+                return true;
+
+        if (!ply_terminal_open (backend->terminal)) {
+                ply_trace ("could not open terminal: %m");
+                return false;
+        }
+
+        if (!ply_terminal_is_vt (backend->terminal)) {
+                ply_trace ("terminal is not a VT");
+                ply_terminal_close (backend->terminal);
+                return false;
+        }
+
+        ply_terminal_watch_for_active_vt_change (backend->terminal,
+                                                 (ply_terminal_active_vt_changed_handler_t)
+                                                 on_active_vt_changed,
+                                                 backend);
+
+        return true;
 }
 
 static void
 close_device (ply_renderer_backend_t *backend)
 {
-  ply_trace ("closing device");
+        ply_trace ("closing device");
 
-  free_heads (backend);
+        free_heads (backend);
 
-  if (backend->terminal != NULL)
-    ply_terminal_stop_watching_for_active_vt_change (backend->terminal,
-                                                     (ply_terminal_active_vt_changed_handler_t)
-                                                     on_active_vt_changed,
-                                                     backend);
+        if (backend->terminal != NULL) {
+                ply_terminal_stop_watching_for_active_vt_change (backend->terminal,
+                                                                 (ply_terminal_active_vt_changed_handler_t)
+                                                                 on_active_vt_changed,
+                                                                 backend);
+        }
 
-  unload_driver (backend);
+        unload_driver (backend);
 }
 
 static drmModeCrtc *
 find_controller_for_encoder (ply_renderer_backend_t *backend,
                              drmModeEncoder         *encoder)
 {
-  drmModeCrtc *controller;
+        drmModeCrtc *controller;
 
-  controller = NULL;
+        controller = NULL;
 
-  /* Monitor is already lit. We'll use the same controller.
-   */
-  if (encoder->crtc_id != 0)
-    {
-      controller = drmModeGetCrtc (backend->device_fd, encoder->crtc_id);
+        /* Monitor is already lit. We'll use the same controller.
+         */
+        if (encoder->crtc_id != 0) {
+                controller = drmModeGetCrtc (backend->device_fd, encoder->crtc_id);
 
-      if (controller != NULL)
-        {
-          ply_trace ("Found already lit monitor");
-          return controller;
+                if (controller != NULL) {
+                        ply_trace ("Found already lit monitor");
+                        return controller;
+                }
         }
-    }
 
-  return NULL;
+        return NULL;
 }
 
 static drmModeEncoder *
 find_encoder_for_connector (ply_renderer_backend_t *backend,
                             drmModeConnector       *connector)
 {
-  int i;
-  drmModeEncoder *encoder;
+        int i;
+        drmModeEncoder *encoder;
 
-  assert (backend != NULL);
+        assert (backend != NULL);
 
-  for (i = 0; i < connector->count_encoders; i++)
-    {
-      encoder = drmModeGetEncoder (backend->device_fd,
-                                   connector->encoders[i]);
+        for (i = 0; i < connector->count_encoders; i++) {
+                encoder = drmModeGetEncoder (backend->device_fd,
+                                             connector->encoders[i]);
 
-      if (encoder == NULL)
-        continue;
+                if (encoder == NULL)
+                        continue;
 
-      if (encoder->encoder_id == connector->encoder_id)
-        return encoder;
+                if (encoder->encoder_id == connector->encoder_id)
+                        return encoder;
 
-      drmModeFreeEncoder (encoder);
-    }
+                drmModeFreeEncoder (encoder);
+        }
 
-  return NULL;
+        return NULL;
 }
 
 static bool
 modes_are_equal (drmModeModeInfo *a,
                  drmModeModeInfo *b)
 {
-  return a->clock == b->clock &&
-         a->hdisplay == b->hdisplay &&
-         a->hsync_start == b->hsync_start &&
-         a->hsync_end == b->hsync_end &&
-         a->htotal == b->htotal &&
-         a->hskew == b->hskew &&
-         a->vdisplay == b->vdisplay &&
-         a->vsync_start == b->vsync_start &&
-         a->vsync_end == b->vsync_end &&
-         a->vtotal == b->vtotal &&
-         a->vscan == b->vscan &&
-         a->vrefresh == b->vrefresh &&
-         a->flags == b->flags &&
-         a->type == b->type;
-
+        return a->clock == b->clock &&
+               a->hdisplay == b->hdisplay &&
+               a->hsync_start == b->hsync_start &&
+               a->hsync_end == b->hsync_end &&
+               a->htotal == b->htotal &&
+               a->hskew == b->hskew &&
+               a->vdisplay == b->vdisplay &&
+               a->vsync_start == b->vsync_start &&
+               a->vsync_end == b->vsync_end &&
+               a->vtotal == b->vtotal &&
+               a->vscan == b->vscan &&
+               a->vrefresh == b->vrefresh &&
+               a->flags == b->flags &&
+               a->type == b->type;
 }
 
 static int
@@ -638,20 +615,18 @@ find_index_of_mode (ply_renderer_backend_t *backend,
                     drmModeConnector       *connector,
                     drmModeModeInfo        *mode)
 {
-  int i;
+        int i;
 
-  for (i = 0; i < connector->count_modes; i++)
-    {
-      if (modes_are_equal (&connector->modes[i], mode))
-        {
-          ply_trace ("Found connector mode index %d for mode %dx%d",
-                     i, mode->hdisplay, mode->vdisplay);
+        for (i = 0; i < connector->count_modes; i++) {
+                if (modes_are_equal (&connector->modes[i], mode)) {
+                        ply_trace ("Found connector mode index %d for mode %dx%d",
+                                   i, mode->hdisplay, mode->vdisplay);
 
-          return i;
+                        return i;
+                }
         }
-    }
 
-  return -1;
+        return -1;
 }
 
 static int
@@ -659,252 +634,230 @@ get_index_of_active_mode (ply_renderer_backend_t *backend,
                           drmModeCrtc            *controller,
                           drmModeConnector       *connector)
 {
-  if (!controller->mode_valid)
-    {
-      ply_trace ("No valid mode currently active on monitor");
-      return -1;
-    }
+        if (!controller->mode_valid) {
+                ply_trace ("No valid mode currently active on monitor");
+                return -1;
+        }
 
-  ply_trace ("Looking for connector mode index of active mode %dx%d",
-             controller->mode.hdisplay, controller->mode.vdisplay);
+        ply_trace ("Looking for connector mode index of active mode %dx%d",
+                   controller->mode.hdisplay, controller->mode.vdisplay);
 
-  return find_index_of_mode (backend, connector, &controller->mode);
+        return find_index_of_mode (backend, connector, &controller->mode);
 }
 
 static bool
 create_heads_for_active_connectors (ply_renderer_backend_t *backend)
 {
-  int i;
-  drmModeConnector *connector;
-  ply_hashtable_t *heads_by_controller_id;
-
-  heads_by_controller_id = ply_hashtable_new (NULL, NULL);
-
-  for (i = 0; i < backend->resources->count_connectors; i++)
-    {
-      ply_renderer_head_t *head;
-      drmModeEncoder *encoder;
-      uint32_t encoder_id;
-      drmModeCrtc *controller;
-      uint32_t controller_id;
-      uint32_t console_buffer_id;
-      int connector_mode_index;
-
-      connector = drmModeGetConnector (backend->device_fd,
-                                       backend->resources->connectors[i]);
-
-      if (connector == NULL)
-        continue;
-
-      if (connector->connection != DRM_MODE_CONNECTED)
-        {
-          drmModeFreeConnector (connector);
-          continue;
-        }
-
-      if (connector->count_modes <= 0)
-        {
-          drmModeFreeConnector (connector);
-          continue;
+        int i;
+        drmModeConnector *connector;
+        ply_hashtable_t *heads_by_controller_id;
+
+        heads_by_controller_id = ply_hashtable_new (NULL, NULL);
+
+        for (i = 0; i < backend->resources->count_connectors; i++) {
+                ply_renderer_head_t *head;
+                drmModeEncoder *encoder;
+                uint32_t encoder_id;
+                drmModeCrtc *controller;
+                uint32_t controller_id;
+                uint32_t console_buffer_id;
+                int connector_mode_index;
+
+                connector = drmModeGetConnector (backend->device_fd,
+                                                 backend->resources->connectors[i]);
+
+                if (connector == NULL)
+                        continue;
+
+                if (connector->connection != DRM_MODE_CONNECTED) {
+                        drmModeFreeConnector (connector);
+                        continue;
+                }
+
+                if (connector->count_modes <= 0) {
+                        drmModeFreeConnector (connector);
+                        continue;
+                }
+
+                encoder = find_encoder_for_connector (backend, connector);
+
+                if (encoder == NULL) {
+                        drmModeFreeConnector (connector);
+                        continue;
+                }
+
+                encoder_id = encoder->encoder_id;
+                controller = find_controller_for_encoder (backend, encoder);
+                drmModeFreeEncoder (encoder);
+
+                if (controller == NULL) {
+                        drmModeFreeConnector (connector);
+                        continue;
+                }
+
+                controller_id = controller->crtc_id;
+
+                connector_mode_index = get_index_of_active_mode (backend, controller, connector);
+
+                /* If we couldn't find the current active mode, fall back to the first available.
+                 */
+                if (connector_mode_index < 0) {
+                        ply_trace ("falling back to first available mode");
+                        connector_mode_index = 0;
+                }
+
+                console_buffer_id = controller->buffer_id;
+                drmModeFreeCrtc (controller);
+
+                head = ply_hashtable_lookup (heads_by_controller_id,
+                                             (void *) (intptr_t) controller_id);
+
+                if (head == NULL) {
+                        head = ply_renderer_head_new (backend, connector, connector_mode_index,
+                                                      encoder_id, controller_id,
+                                                      console_buffer_id);
+
+                        ply_list_append_data (backend->heads, head);
+
+                        ply_hashtable_insert (heads_by_controller_id,
+                                              (void *) (intptr_t) controller_id,
+                                              head);
+                } else {
+                        if (!ply_renderer_head_add_connector (head, connector, connector_mode_index))
+                                ply_trace ("couldn't connect monitor to existing head");
+
+                        drmModeFreeConnector (connector);
+                }
         }
 
-      encoder = find_encoder_for_connector (backend, connector);
-
-      if (encoder == NULL)
-        {
-          drmModeFreeConnector (connector);
-          continue;
-        }
+        ply_hashtable_free (heads_by_controller_id);
 
-      encoder_id = encoder->encoder_id;
-      controller = find_controller_for_encoder (backend, encoder);
-      drmModeFreeEncoder (encoder);
-
-      if (controller == NULL)
-        {
-          drmModeFreeConnector (connector);
-          continue;
+#ifdef PLY_ENABLE_DEPRECATED_GDM_TRANSITION
+        /* If the driver doesn't support mapping the fb console
+         * then we can't get a smooth crossfade transition to
+         * the display manager unless we use the /dev/fb interface
+         * or the plymouth deactivate interface.
+         *
+         * In multihead configurations, we'd rather have working
+         * multihead, but otherwise bail now.
+         */
+        if (!backend->driver_supports_mapping_console &&
+            ply_list_get_length (backend->heads) == 1) {
+                ply_list_node_t *node;
+                ply_renderer_head_t *head;
+
+                node = ply_list_get_first_node (backend->heads);
+                head = (ply_renderer_head_t *) ply_list_node_get_data (node);
+
+                if (ply_array_get_size (head->connector_ids) == 1) {
+                        ply_trace ("Only one monitor configured, and driver doesn't "
+                                   "support mapping console, so letting frame-buffer "
+                                   "take over");
+
+                        free_heads (backend);
+                        return false;
+                }
         }
+#endif
 
-      controller_id = controller->crtc_id;
-
-      connector_mode_index = get_index_of_active_mode (backend, controller, connector);
+        return ply_list_get_length (backend->heads) > 0;
+}
 
-      /* If we couldn't find the current active mode, fall back to the first available.
-       */
-      if (connector_mode_index < 0)
-        {
-          ply_trace ("falling back to first available mode");
-          connector_mode_index = 0;
+static bool
+has_32bpp_support (ply_renderer_backend_t *backend)
+{
+        uint32_t buffer_id;
+        unsigned long row_stride;
+        uint32_t min_width;
+        uint32_t min_height;
+
+        min_width = backend->resources->min_width;
+        min_height = backend->resources->min_height;
+
+        /* Some drivers set min_width/min_height to 0,
+         * but 0x0 sized buffers don't work.
+         */
+        if (min_width == 0)
+                min_width = 1;
+
+        if (min_height == 0)
+                min_height = 1;
+
+        buffer_id = backend->driver_interface->create_buffer (backend->driver,
+                                                              min_width,
+                                                              min_height,
+                                                              &row_stride);
+
+        if (buffer_id == 0) {
+                ply_trace ("Could not create minimal (%ux%u) 32bpp dummy buffer",
+                           backend->resources->min_width,
+                           backend->resources->min_height);
+                return false;
         }
 
-      console_buffer_id = controller->buffer_id;
-      drmModeFreeCrtc (controller);
+        backend->driver_interface->destroy_buffer (backend->driver,
+                                                   buffer_id);
 
-      head = ply_hashtable_lookup (heads_by_controller_id,
-                                   (void *) (intptr_t) controller_id);
+        return true;
+}
 
-      if (head == NULL)
-        {
-          head = ply_renderer_head_new (backend, connector, connector_mode_index,
-                                        encoder_id, controller_id,
-                                        console_buffer_id);
+static bool
+query_device (ply_renderer_backend_t *backend)
+{
+        assert (backend != NULL);
+        assert (backend->device_fd >= 0);
 
-          ply_list_append_data (backend->heads, head);
+        backend->resources = drmModeGetResources (backend->device_fd);
 
-          ply_hashtable_insert (heads_by_controller_id,
-                                (void *) (intptr_t) controller_id,
-                                head);
+        if (backend->resources == NULL) {
+                ply_trace ("Could not get card resources");
+                return false;
         }
-      else
-        {
-          if (!ply_renderer_head_add_connector (head, connector, connector_mode_index))
-            {
-              ply_trace ("couldn't connect monitor to existing head");
-            }
 
-          drmModeFreeConnector (connector);
+        if (!create_heads_for_active_connectors (backend)) {
+                ply_trace ("Could not initialize heads");
+                return false;
         }
-    }
-
-  ply_hashtable_free (heads_by_controller_id);
-
-#ifdef PLY_ENABLE_DEPRECATED_GDM_TRANSITION
-  /* If the driver doesn't support mapping the fb console
-   * then we can't get a smooth crossfade transition to
-   * the display manager unless we use the /dev/fb interface
-   * or the plymouth deactivate interface.
-   *
-   * In multihead configurations, we'd rather have working
-   * multihead, but otherwise bail now.
-   */
-  if (!backend->driver_supports_mapping_console &&
-      ply_list_get_length (backend->heads) == 1)
-    {
-      ply_list_node_t *node;
-      ply_renderer_head_t *head;
-
-      node = ply_list_get_first_node (backend->heads);
-      head = (ply_renderer_head_t *) ply_list_node_get_data (node);
-
-      if (ply_array_get_size (head->connector_ids) == 1)
-        {
-          ply_trace ("Only one monitor configured, and driver doesn't "
-                     "support mapping console, so letting frame-buffer "
-                     "take over");
 
-          free_heads (backend);
-          return false;
+        if (!has_32bpp_support (backend)) {
+                ply_trace ("Device doesn't support 32bpp framebuffer");
+                return false;
         }
-    }
-#endif
 
-  return ply_list_get_length (backend->heads) > 0;
+        return true;
 }
 
 static bool
-has_32bpp_support (ply_renderer_backend_t *backend)
+map_to_device (ply_renderer_backend_t *backend)
 {
-    uint32_t buffer_id;
-    unsigned long row_stride;
-    uint32_t min_width;
-    uint32_t min_height;
-
-    min_width = backend->resources->min_width;
-    min_height = backend->resources->min_height;
-
-    /* Some drivers set min_width/min_height to 0,
-     * but 0x0 sized buffers don't work.
-     */
-    if (min_width == 0)
-      min_width = 1;
-
-    if (min_height == 0)
-      min_height = 1;
-
-    buffer_id = backend->driver_interface->create_buffer (backend->driver,
-                                                          min_width,
-                                                          min_height,
-                                                          &row_stride);
-
-    if (buffer_id == 0)
-      {
-        ply_trace ("Could not create minimal (%ux%u) 32bpp dummy buffer",
-                    backend->resources->min_width,
-                    backend->resources->min_height);
-        return false;
-      }
-
-    backend->driver_interface->destroy_buffer (backend->driver,
-                                               buffer_id);
-
-    return true;
-}
+        ply_list_node_t *node;
+        bool head_mapped;
 
-static bool
-query_device (ply_renderer_backend_t *backend)
-{
-  assert (backend != NULL);
-  assert (backend->device_fd >= 0);
-
-  backend->resources = drmModeGetResources (backend->device_fd);
-
-  if (backend->resources == NULL)
-    {
-      ply_trace ("Could not get card resources");
-      return false;
-    }
-
-  if (!create_heads_for_active_connectors (backend))
-    {
-      ply_trace ("Could not initialize heads");
-      return false;
-    }
-
-  if (!has_32bpp_support (backend))
-    {
-      ply_trace ("Device doesn't support 32bpp framebuffer");
-      return false;
-    }
-
-  return true;
-}
+        head_mapped = false;
+        node = ply_list_get_first_node (backend->heads);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_renderer_head_t *head;
 
-static bool
-map_to_device (ply_renderer_backend_t *backend)
-{
-  ply_list_node_t *node;
-  bool head_mapped;
-
-  head_mapped = false;
-  node = ply_list_get_first_node (backend->heads);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_renderer_head_t *head;
-
-      head = (ply_renderer_head_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (backend->heads, node);
-
-      if (ply_renderer_head_map (backend, head))
-        head_mapped = true;
-
-      node = next_node;
-    }
-
-  if (backend->terminal != NULL)
-    {
-      if (ply_terminal_is_active (backend->terminal))
-        activate (backend);
-      else
-        ply_terminal_activate_vt (backend->terminal);
-    }
-  else
-    {
-      activate (backend);
-    }
-
-  return head_mapped;
+                head = (ply_renderer_head_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (backend->heads, node);
+
+                if (ply_renderer_head_map (backend, head))
+                        head_mapped = true;
+
+                node = next_node;
+        }
+
+        if (backend->terminal != NULL) {
+                if (ply_terminal_is_active (backend->terminal))
+                        activate (backend);
+                else
+                        ply_terminal_activate_vt (backend->terminal);
+        } else {
+                activate (backend);
+        }
+
+        return head_mapped;
 }
 
 static bool
@@ -912,338 +865,324 @@ ply_renderer_head_set_scan_out_buffer_to_console (ply_renderer_backend_t *backen
                                                   ply_renderer_head_t    *head,
                                                   bool                    should_set_to_black)
 {
-  unsigned long width;
-  unsigned long height;
-  unsigned long row_stride;
-  uint32_t *shadow_buffer;
-  ply_pixel_buffer_t *pixel_buffer;
-  char *map_address;
-  ply_rectangle_t area;
-
-  if (!backend->driver_interface->fetch_buffer (backend->driver,
-                                               head->console_buffer_id,
-                                               &width, &height, &row_stride))
-    return false;
-
-  if (!backend->driver_interface->map_buffer (backend->driver,
-                                              head->console_buffer_id))
-    {
-      backend->driver_interface->destroy_buffer (backend->driver,
+        unsigned long width;
+        unsigned long height;
+        unsigned long row_stride;
+        uint32_t *shadow_buffer;
+        ply_pixel_buffer_t *pixel_buffer;
+        char *map_address;
+        ply_rectangle_t area;
+
+        if (!backend->driver_interface->fetch_buffer (backend->driver,
+                                                      head->console_buffer_id,
+                                                      &width, &height, &row_stride))
+                return false;
+
+        if (!backend->driver_interface->map_buffer (backend->driver,
+                                                    head->console_buffer_id)) {
+                backend->driver_interface->destroy_buffer (backend->driver,
+                                                           head->console_buffer_id);
+                return false;
+        }
+
+        if (head->area.width != width || head->area.height != height) {
+                /* Force black if the fb console resolution doesn't match our resolution
+                 */
+                area.x = 0;
+                area.y = 0;
+                area.width = width;
+                area.height = height;
+
+                should_set_to_black = true;
+                ply_trace ("Console fb is %ldx%ld and screen contents are %ldx%ld. "
+                           "They aren't the same dimensions; forcing black",
+                           width, height, head->area.width, head->area.height);
+        } else {
+                area = head->area;
+        }
+
+        if (should_set_to_black) {
+                pixel_buffer = ply_pixel_buffer_new (width, height);
+                shadow_buffer = ply_pixel_buffer_get_argb32_data (pixel_buffer);
+        } else {
+                pixel_buffer = NULL;
+                shadow_buffer = ply_pixel_buffer_get_argb32_data (head->pixel_buffer);
+        }
+
+        ply_trace ("Drawing %s to console fb", should_set_to_black ? "black" : "screen contents");
+        map_address =
+                backend->driver_interface->begin_flush (backend->driver,
+                                                        head->console_buffer_id);
+
+        flush_area ((char *) shadow_buffer, area.width * 4,
+                    map_address, row_stride, &area);
+
+        backend->driver_interface->end_flush (backend->driver,
+                                              head->console_buffer_id);
+
+        backend->driver_interface->unmap_buffer (backend->driver,
                                                  head->console_buffer_id);
-      return false;
-    }
-
-  if (head->area.width != width || head->area.height != height)
-    {
-      /* Force black if the fb console resolution doesn't match our resolution
-       */
-      area.x = 0;
-      area.y = 0;
-      area.width = width;
-      area.height = height;
-
-      should_set_to_black = true;
-      ply_trace ("Console fb is %ldx%ld and screen contents are %ldx%ld. "
-                 "They aren't the same dimensions; forcing black",
-                 width, height, head->area.width, head->area.height);
-    }
-  else
-    area = head->area;
-
-  if (should_set_to_black)
-    {
-      pixel_buffer = ply_pixel_buffer_new (width, height);
-      shadow_buffer = ply_pixel_buffer_get_argb32_data (pixel_buffer);
-    }
-  else
-    {
-      pixel_buffer = NULL;
-      shadow_buffer = ply_pixel_buffer_get_argb32_data (head->pixel_buffer);
-    }
-
-  ply_trace ("Drawing %s to console fb", should_set_to_black? "black" : "screen contents");
-  map_address =
-        backend->driver_interface->begin_flush (backend->driver,
-                                                head->console_buffer_id);
-
-  flush_area ((char *) shadow_buffer, area.width * 4,
-              map_address, row_stride, &area);
-
-  backend->driver_interface->end_flush (backend->driver,
-                                        head->console_buffer_id);
-
-  backend->driver_interface->unmap_buffer (backend->driver,
-                                           head->console_buffer_id);
-
-  ply_trace ("Setting scan out hardware to console fb");
-  ply_renderer_head_set_scan_out_buffer (backend,
-                                         head, head->console_buffer_id);
-
-  backend->driver_interface->destroy_buffer (backend->driver,
-                                             head->console_buffer_id);
-
-  if (pixel_buffer != NULL)
-    ply_pixel_buffer_free (pixel_buffer);
-
-  return true;
+
+        ply_trace ("Setting scan out hardware to console fb");
+        ply_renderer_head_set_scan_out_buffer (backend,
+                                               head, head->console_buffer_id);
+
+        backend->driver_interface->destroy_buffer (backend->driver,
+                                                   head->console_buffer_id);
+
+        if (pixel_buffer != NULL)
+                ply_pixel_buffer_free (pixel_buffer);
+
+        return true;
 }
 
 static void
 unmap_from_device (ply_renderer_backend_t *backend)
 {
-  ply_list_node_t *node;
-  bool should_set_to_black;
+        ply_list_node_t *node;
+        bool should_set_to_black;
 
-  /* We only copy what's on screen back to the fb console
-   * if there's one head (since in multihead set ups the fb console
-   * is cloned).
-   */
-  should_set_to_black = ply_list_get_length (backend->heads) > 1;
+        /* We only copy what's on screen back to the fb console
+         * if there's one head (since in multihead set ups the fb console
+         * is cloned).
+         */
+        should_set_to_black = ply_list_get_length (backend->heads) > 1;
 
-  node = ply_list_get_first_node (backend->heads);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_renderer_head_t *head;
+        node = ply_list_get_first_node (backend->heads);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_renderer_head_t *head;
 
-      head = (ply_renderer_head_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (backend->heads, node);
+                head = (ply_renderer_head_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (backend->heads, node);
 
-      if (backend->is_active)
-        {
-          ply_trace ("scanning out %s directly to console",
-                     should_set_to_black? "black" : "splash");
-          ply_renderer_head_set_scan_out_buffer_to_console (backend, head,
-                                                            should_set_to_black);
-        }
+                if (backend->is_active) {
+                        ply_trace ("scanning out %s directly to console",
+                                   should_set_to_black ? "black" : "splash");
+                        ply_renderer_head_set_scan_out_buffer_to_console (backend, head,
+                                                                          should_set_to_black);
+                }
 
-      ply_renderer_head_unmap (backend, head);
+                ply_renderer_head_unmap (backend, head);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static bool
 reset_scan_out_buffer_if_needed (ply_renderer_backend_t *backend,
                                  ply_renderer_head_t    *head)
 {
-  drmModeCrtc *controller;
-  bool did_reset = false;
+        drmModeCrtc *controller;
+        bool did_reset = false;
 
-  if (backend->terminal != NULL)
-    {
-      if (!ply_terminal_is_active (backend->terminal))
-        return false;
-    }
+        if (backend->terminal != NULL)
+                if (!ply_terminal_is_active (backend->terminal))
+                        return false;
 
-  controller = drmModeGetCrtc (backend->device_fd, head->controller_id);
+        controller = drmModeGetCrtc (backend->device_fd, head->controller_id);
 
-  if (controller == NULL)
-    return false;
+        if (controller == NULL)
+                return false;
 
-  if (controller->buffer_id != head->scan_out_buffer_id)
-    {
-      ply_renderer_head_set_scan_out_buffer (backend, head,
-                                             head->scan_out_buffer_id);
-      did_reset = true;
-    }
+        if (controller->buffer_id != head->scan_out_buffer_id) {
+                ply_renderer_head_set_scan_out_buffer (backend, head,
+                                                       head->scan_out_buffer_id);
+                did_reset = true;
+        }
 
-  drmModeFreeCrtc (controller);
+        drmModeFreeCrtc (controller);
 
-  return did_reset;
+        return did_reset;
 }
 
 static void
 flush_head (ply_renderer_backend_t *backend,
             ply_renderer_head_t    *head)
 {
-  ply_region_t *updated_region;
-  ply_list_t *areas_to_flush;
-  ply_list_node_t *node;
-  ply_pixel_buffer_t *pixel_buffer;
-  char *map_address;
-
-  assert (backend != NULL);
-
-  if (!backend->is_active)
-    return;
-
-  if (backend->terminal != NULL)
-    {
-      ply_terminal_set_mode (backend->terminal, PLY_TERMINAL_MODE_GRAPHICS);
-      ply_terminal_set_unbuffered_input (backend->terminal);
-    }
-  pixel_buffer = head->pixel_buffer;
-  updated_region = ply_pixel_buffer_get_updated_areas (pixel_buffer);
-  areas_to_flush = ply_region_get_sorted_rectangle_list (updated_region);
-
-  map_address =
-    backend->driver_interface->begin_flush (backend->driver,
-                                            head->scan_out_buffer_id);
-
-  node = ply_list_get_first_node (areas_to_flush);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_rectangle_t *area_to_flush;
-
-      area_to_flush = (ply_rectangle_t *) ply_list_node_get_data (node);
-
-      next_node = ply_list_get_next_node (areas_to_flush, node);
-
-      if (reset_scan_out_buffer_if_needed (backend, head))
-        ply_trace ("Needed to reset scan out buffer on %ldx%ld renderer head",
-                   head->area.width, head->area.height);
+        ply_region_t *updated_region;
+        ply_list_t *areas_to_flush;
+        ply_list_node_t *node;
+        ply_pixel_buffer_t *pixel_buffer;
+        char *map_address;
+
+        assert (backend != NULL);
+
+        if (!backend->is_active)
+                return;
+
+        if (backend->terminal != NULL) {
+                ply_terminal_set_mode (backend->terminal, PLY_TERMINAL_MODE_GRAPHICS);
+                ply_terminal_set_unbuffered_input (backend->terminal);
+        }
+        pixel_buffer = head->pixel_buffer;
+        updated_region = ply_pixel_buffer_get_updated_areas (pixel_buffer);
+        areas_to_flush = ply_region_get_sorted_rectangle_list (updated_region);
+
+        map_address =
+                backend->driver_interface->begin_flush (backend->driver,
+                                                        head->scan_out_buffer_id);
+
+        node = ply_list_get_first_node (areas_to_flush);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_rectangle_t *area_to_flush;
+
+                area_to_flush = (ply_rectangle_t *) ply_list_node_get_data (node);
 
-      ply_renderer_head_flush_area (head, area_to_flush, map_address);
+                next_node = ply_list_get_next_node (areas_to_flush, node);
 
-      node = next_node;
-    }
+                if (reset_scan_out_buffer_if_needed (backend, head))
+                        ply_trace ("Needed to reset scan out buffer on %ldx%ld renderer head",
+                                   head->area.width, head->area.height);
 
-  backend->driver_interface->end_flush (backend->driver,
-                                        head->scan_out_buffer_id);
+                ply_renderer_head_flush_area (head, area_to_flush, map_address);
 
-  ply_region_clear (updated_region);
+                node = next_node;
+        }
+
+        backend->driver_interface->end_flush (backend->driver,
+                                              head->scan_out_buffer_id);
+
+        ply_region_clear (updated_region);
 }
 
 static void
 ply_renderer_head_redraw (ply_renderer_backend_t *backend,
                           ply_renderer_head_t    *head)
 {
-  ply_region_t *region;
+        ply_region_t *region;
 
-  ply_trace ("Redrawing %ldx%ld renderer head", head->area.width, head->area.height);
+        ply_trace ("Redrawing %ldx%ld renderer head", head->area.width, head->area.height);
 
-  region = ply_pixel_buffer_get_updated_areas (head->pixel_buffer);
+        region = ply_pixel_buffer_get_updated_areas (head->pixel_buffer);
 
-  ply_region_add_rectangle (region, &head->area);
+        ply_region_add_rectangle (region, &head->area);
 
-  flush_head (backend, head);
+        flush_head (backend, head);
 }
 
 static ply_list_t *
 get_heads (ply_renderer_backend_t *backend)
 {
-  return backend->heads;
+        return backend->heads;
 }
 
 static ply_pixel_buffer_t *
 get_buffer_for_head (ply_renderer_backend_t *backend,
                      ply_renderer_head_t    *head)
 {
+        if (head->backend != backend)
+                return NULL;
 
-  if (head->backend != backend)
-    return NULL;
-
-  return head->pixel_buffer;
+        return head->pixel_buffer;
 }
 
 static bool
 has_input_source (ply_renderer_backend_t      *backend,
                   ply_renderer_input_source_t *input_source)
 {
-  return input_source == &backend->input_source;
+        return input_source == &backend->input_source;
 }
 
 static ply_renderer_input_source_t *
 get_input_source (ply_renderer_backend_t *backend)
 {
-  return &backend->input_source;
+        return &backend->input_source;
 }
 
 static void
 on_key_event (ply_renderer_input_source_t *input_source,
               int                          terminal_fd)
-{ 
-  ply_buffer_append_from_fd (input_source->key_buffer,
-                             terminal_fd);
-
-  if (input_source->handler != NULL)
-    input_source->handler (input_source->user_data, input_source->key_buffer, input_source);
+{
+        ply_buffer_append_from_fd (input_source->key_buffer,
+                                   terminal_fd);
 
+        if (input_source->handler != NULL)
+                input_source->handler (input_source->user_data, input_source->key_buffer, input_source);
 }
 
 static void
 on_input_source_disconnected (ply_renderer_input_source_t *input_source)
 {
-  ply_trace ("input source disconnected, reopening");
+        ply_trace ("input source disconnected, reopening");
 
-  open_input_source (input_source->backend, input_source);
+        open_input_source (input_source->backend, input_source);
 }
 
 static bool
 open_input_source (ply_renderer_backend_t      *backend,
                    ply_renderer_input_source_t *input_source)
 {
-  int terminal_fd;
+        int terminal_fd;
 
-  assert (backend != NULL);
-  assert (has_input_source (backend, input_source));
+        assert (backend != NULL);
+        assert (has_input_source (backend, input_source));
 
-  if (backend->terminal == NULL)
-    return false;
+        if (backend->terminal == NULL)
+                return false;
 
-  terminal_fd = ply_terminal_get_fd (backend->terminal);
+        terminal_fd = ply_terminal_get_fd (backend->terminal);
 
-  input_source->backend = backend;
-  input_source->terminal_input_watch = ply_event_loop_watch_fd (backend->loop, terminal_fd, PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                                                                (ply_event_handler_t) on_key_event,
-                                                                (ply_event_handler_t)
-                                                                on_input_source_disconnected, input_source);
-  return true;
+        input_source->backend = backend;
+        input_source->terminal_input_watch = ply_event_loop_watch_fd (backend->loop, terminal_fd, PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                                                      (ply_event_handler_t) on_key_event,
+                                                                      (ply_event_handler_t)
+                                                                      on_input_source_disconnected, input_source);
+        return true;
 }
 
 static void
-set_handler_for_input_source (ply_renderer_backend_t      *backend,
-                              ply_renderer_input_source_t *input_source,
+set_handler_for_input_source (ply_renderer_backend_t             *backend,
+                              ply_renderer_input_source_t        *input_source,
                               ply_renderer_input_source_handler_t handler,
-                              void                        *user_data)
+                              void                               *user_data)
 {
-  assert (backend != NULL);
-  assert (has_input_source (backend, input_source));
+        assert (backend != NULL);
+        assert (has_input_source (backend, input_source));
 
-  input_source->handler = handler;
-  input_source->user_data = user_data;
+        input_source->handler = handler;
+        input_source->user_data = user_data;
 }
 
 static void
 close_input_source (ply_renderer_backend_t      *backend,
                     ply_renderer_input_source_t *input_source)
 {
-  assert (backend != NULL);
-  assert (has_input_source (backend, input_source));
+        assert (backend != NULL);
+        assert (has_input_source (backend, input_source));
 
-  if (backend->terminal == NULL)
-    return;
+        if (backend->terminal == NULL)
+                return;
 
-  ply_event_loop_stop_watching_fd (backend->loop, input_source->terminal_input_watch);
-  input_source->terminal_input_watch = NULL;
-  input_source->backend = NULL;
+        ply_event_loop_stop_watching_fd (backend->loop, input_source->terminal_input_watch);
+        input_source->terminal_input_watch = NULL;
+        input_source->backend = NULL;
 }
 
 ply_renderer_plugin_interface_t *
 ply_renderer_backend_get_interface (void)
 {
-  static ply_renderer_plugin_interface_t plugin_interface =
-    {
-      .create_backend = create_backend,
-      .destroy_backend = destroy_backend,
-      .open_device = open_device,
-      .close_device = close_device,
-      .query_device = query_device,
-      .map_to_device = map_to_device,
-      .unmap_from_device = unmap_from_device,
-      .activate = activate,
-      .deactivate = deactivate,
-      .flush_head = flush_head,
-      .get_heads = get_heads,
-      .get_buffer_for_head = get_buffer_for_head,
-      .get_input_source = get_input_source,
-      .open_input_source = open_input_source,
-      .set_handler_for_input_source = set_handler_for_input_source,
-      .close_input_source = close_input_source
-    };
-
-  return &plugin_interface;
+        static ply_renderer_plugin_interface_t plugin_interface =
+        {
+                .create_backend               = create_backend,
+                .destroy_backend              = destroy_backend,
+                .open_device                  = open_device,
+                .close_device                 = close_device,
+                .query_device                 = query_device,
+                .map_to_device                = map_to_device,
+                .unmap_from_device            = unmap_from_device,
+                .activate                     = activate,
+                .deactivate                   = deactivate,
+                .flush_head                   = flush_head,
+                .get_heads                    = get_heads,
+                .get_buffer_for_head          = get_buffer_for_head,
+                .get_input_source             = get_input_source,
+                .open_input_source            = open_input_source,
+                .set_handler_for_input_source = set_handler_for_input_source,
+                .close_input_source           = close_input_source
+        };
+
+        return &plugin_interface;
 }
 /* vim: set ts=4 sw=4 et ai ci cino={.5s,^-2,+.5s,t0,g0,e-2,n-2,p2s,(0,=.5s,:.5s */
diff --git a/src/plugins/renderers/drm/ply-renderer-driver.h b/src/plugins/renderers/drm/ply-renderer-driver.h
index a0d6044..f3febcf 100644
--- a/src/plugins/renderers/drm/ply-renderer-driver.h
+++ b/src/plugins/renderers/drm/ply-renderer-driver.h
@@ -33,34 +33,33 @@ typedef struct _ply_renderer_driver ply_renderer_driver_t;
 
 typedef struct
 {
-    ply_renderer_driver_t * (* create_driver) (int device_fd);
+        ply_renderer_driver_t * (*create_driver)(int device_fd);
 
-    void (* destroy_driver) (ply_renderer_driver_t *driver);
+        void (*destroy_driver)(ply_renderer_driver_t *driver);
 
-    uint32_t (* create_buffer) (ply_renderer_driver_t *driver,
-                                unsigned long          width,
-                                unsigned long          height,
-                                unsigned long         *row_stride);
-    bool (* fetch_buffer) (ply_renderer_driver_t *driver,
-                           uint32_t               buffer_id,
-                           unsigned long         *width,
-                           unsigned long         *height,
-                           unsigned long         *row_stride);
+        uint32_t (*create_buffer)(ply_renderer_driver_t *driver,
+                                  unsigned long          width,
+                                  unsigned long          height,
+                                  unsigned long         *row_stride);
+        bool (*fetch_buffer)(ply_renderer_driver_t *driver,
+                             uint32_t               buffer_id,
+                             unsigned long         *width,
+                             unsigned long         *height,
+                             unsigned long         *row_stride);
 
-    bool (* map_buffer) (ply_renderer_driver_t *driver,
-                         uint32_t               buffer_id);
-
-    void (* unmap_buffer) (ply_renderer_driver_t *driver,
+        bool (*map_buffer)(ply_renderer_driver_t *driver,
                            uint32_t               buffer_id);
 
-    char * (* begin_flush) (ply_renderer_driver_t *driver,
-                            uint32_t               buffer_id);
-    void (* end_flush) (ply_renderer_driver_t *driver,
-                        uint32_t               buffer_id);
-
-    void (* destroy_buffer) (ply_renderer_driver_t *driver,
+        void (*unmap_buffer)(ply_renderer_driver_t *driver,
                              uint32_t               buffer_id);
 
+        char * (*begin_flush)(ply_renderer_driver_t * driver,
+                              uint32_t buffer_id);
+        void (*end_flush)(ply_renderer_driver_t *driver,
+                          uint32_t               buffer_id);
+
+        void (*destroy_buffer)(ply_renderer_driver_t *driver,
+                               uint32_t               buffer_id);
 } ply_renderer_driver_interface_t;
 
 #endif /* PLY_RENDERER_DRIVER_H */
diff --git a/src/plugins/renderers/drm/ply-renderer-generic-driver.c b/src/plugins/renderers/drm/ply-renderer-generic-driver.c
index 45a8faa..b1be714 100644
--- a/src/plugins/renderers/drm/ply-renderer-generic-driver.c
+++ b/src/plugins/renderers/drm/ply-renderer-generic-driver.c
@@ -53,91 +53,89 @@ typedef struct _ply_renderer_buffer ply_renderer_buffer_t;
 
 struct _ply_renderer_buffer
 {
-  uint32_t id;
+        uint32_t id;
 
-  uint32_t handle;
-  uint32_t width;
-  uint32_t height;
-  uint32_t row_stride;
+        uint32_t handle;
+        uint32_t width;
+        uint32_t height;
+        uint32_t row_stride;
 
-  void *map_address;
-  uint32_t map_size;
-  int map_count;
+        void    *map_address;
+        uint32_t map_size;
+        int      map_count;
 
-  uint32_t added_fb : 1;
+        uint32_t added_fb : 1;
 };
 
 struct _ply_renderer_driver
 {
-  int device_fd;
-  ply_hashtable_t *buffers;
+        int              device_fd;
+        ply_hashtable_t *buffers;
 
-  uint32_t requires_explicit_flushing : 1;
+        uint32_t         requires_explicit_flushing : 1;
 };
 
 static bool
 ply_renderer_buffer_map (ply_renderer_driver_t *driver,
                          ply_renderer_buffer_t *buffer)
 {
-  struct drm_mode_map_dumb map_dumb_buffer_request;
-  void *map_address;
-
-  if (buffer->map_address != MAP_FAILED)
-    {
-      buffer->map_count++;
-      return true;
-    }
-
-  memset (&map_dumb_buffer_request, 0, sizeof (struct drm_mode_map_dumb));
-  map_dumb_buffer_request.handle = buffer->handle;
-  if (drmIoctl (driver->device_fd, DRM_IOCTL_MODE_MAP_DUMB, &map_dumb_buffer_request) < 0)
-    {
-      ply_trace ("Could not map GEM object %u: %m", buffer->handle);
-      return false;
-    }
-
-  map_address = mmap (0, buffer->map_size,
-                      PROT_READ | PROT_WRITE, MAP_SHARED,
-                      driver->device_fd, map_dumb_buffer_request.offset);
-
-  if (map_address == MAP_FAILED)
-    return false;
-
-  buffer->map_address = map_address;
-  buffer->map_count++;
-
-  return true;
+        struct drm_mode_map_dumb map_dumb_buffer_request;
+        void *map_address;
+
+        if (buffer->map_address != MAP_FAILED) {
+                buffer->map_count++;
+                return true;
+        }
+
+        memset (&map_dumb_buffer_request, 0, sizeof(struct drm_mode_map_dumb));
+        map_dumb_buffer_request.handle = buffer->handle;
+        if (drmIoctl (driver->device_fd, DRM_IOCTL_MODE_MAP_DUMB, &map_dumb_buffer_request) < 0) {
+                ply_trace ("Could not map GEM object %u: %m", buffer->handle);
+                return false;
+        }
+
+        map_address = mmap (0, buffer->map_size,
+                            PROT_READ | PROT_WRITE, MAP_SHARED,
+                            driver->device_fd, map_dumb_buffer_request.offset);
+
+        if (map_address == MAP_FAILED)
+                return false;
+
+        buffer->map_address = map_address;
+        buffer->map_count++;
+
+        return true;
 }
 
 static void
 ply_renderer_buffer_unmap (ply_renderer_driver_t *driver,
                            ply_renderer_buffer_t *buffer)
 {
-  buffer->map_count--;
+        buffer->map_count--;
 
-  assert (buffer->map_count >= 0);
+        assert (buffer->map_count >= 0);
 }
 
 static ply_renderer_driver_t *
 create_driver (int device_fd)
 {
-  ply_renderer_driver_t *driver;
+        ply_renderer_driver_t *driver;
 
-  driver = calloc (1, sizeof (ply_renderer_driver_t));
-  driver->device_fd = device_fd;
-  driver->requires_explicit_flushing = true;
-  driver->buffers = ply_hashtable_new (ply_hashtable_direct_hash,
-                                       ply_hashtable_direct_compare);
+        driver = calloc (1, sizeof(ply_renderer_driver_t));
+        driver->device_fd = device_fd;
+        driver->requires_explicit_flushing = true;
+        driver->buffers = ply_hashtable_new (ply_hashtable_direct_hash,
+                                             ply_hashtable_direct_compare);
 
-  return driver;
+        return driver;
 }
 
 static void
 destroy_driver (ply_renderer_driver_t *driver)
 {
-  ply_hashtable_free (driver->buffers);
+        ply_hashtable_free (driver->buffers);
 
-  free (driver);
+        free (driver);
 }
 
 static ply_renderer_buffer_t *
@@ -145,77 +143,73 @@ ply_renderer_buffer_new (ply_renderer_driver_t *driver,
                          uint32_t               width,
                          uint32_t               height)
 {
-  ply_renderer_buffer_t *buffer;
-  struct drm_mode_create_dumb create_dumb_buffer_request;
-
-  buffer = calloc (1, sizeof (ply_renderer_buffer_t));
-  buffer->width = width;
-  buffer->height = height;
-  buffer->map_address = MAP_FAILED;
-
-  memset (&create_dumb_buffer_request, 0, sizeof (struct drm_mode_create_dumb));
-
-  create_dumb_buffer_request.width = width;
-  create_dumb_buffer_request.height = height;
-  create_dumb_buffer_request.bpp = 32;
-  create_dumb_buffer_request.flags = 0;
-
-  if (drmIoctl (driver->device_fd,
-                DRM_IOCTL_MODE_CREATE_DUMB,
-                &create_dumb_buffer_request) < 0)
-    {
-      free (buffer);
-      ply_trace ("Could not allocate GEM object for frame buffer: %m");
-      return NULL;
-    }
-
-  buffer->handle = create_dumb_buffer_request.handle;
-  buffer->row_stride = create_dumb_buffer_request.pitch;
-  buffer->map_size = create_dumb_buffer_request.size;
-
-  ply_trace ("returning %ux%u buffer with stride %u",
-             width, height, buffer->row_stride);
-
-  return buffer;
+        ply_renderer_buffer_t *buffer;
+        struct drm_mode_create_dumb create_dumb_buffer_request;
+
+        buffer = calloc (1, sizeof(ply_renderer_buffer_t));
+        buffer->width = width;
+        buffer->height = height;
+        buffer->map_address = MAP_FAILED;
+
+        memset (&create_dumb_buffer_request, 0, sizeof(struct drm_mode_create_dumb));
+
+        create_dumb_buffer_request.width = width;
+        create_dumb_buffer_request.height = height;
+        create_dumb_buffer_request.bpp = 32;
+        create_dumb_buffer_request.flags = 0;
+
+        if (drmIoctl (driver->device_fd,
+                      DRM_IOCTL_MODE_CREATE_DUMB,
+                      &create_dumb_buffer_request) < 0) {
+                free (buffer);
+                ply_trace ("Could not allocate GEM object for frame buffer: %m");
+                return NULL;
+        }
+
+        buffer->handle = create_dumb_buffer_request.handle;
+        buffer->row_stride = create_dumb_buffer_request.pitch;
+        buffer->map_size = create_dumb_buffer_request.size;
+
+        ply_trace ("returning %ux%u buffer with stride %u",
+                   width, height, buffer->row_stride);
+
+        return buffer;
 }
 
 static void
 ply_renderer_buffer_free (ply_renderer_driver_t *driver,
                           ply_renderer_buffer_t *buffer)
 {
-  struct drm_mode_destroy_dumb destroy_dumb_buffer_request;
+        struct drm_mode_destroy_dumb destroy_dumb_buffer_request;
 
-  if (buffer->added_fb)
-    drmModeRmFB (driver->device_fd, buffer->id);
+        if (buffer->added_fb)
+                drmModeRmFB (driver->device_fd, buffer->id);
 
-  if (buffer->map_address != MAP_FAILED)
-    {
-      munmap (buffer->map_address, buffer->map_size);
-      buffer->map_address = MAP_FAILED;
-    }
+        if (buffer->map_address != MAP_FAILED) {
+                munmap (buffer->map_address, buffer->map_size);
+                buffer->map_address = MAP_FAILED;
+        }
 
-  memset (&destroy_dumb_buffer_request, 0, sizeof (struct drm_mode_destroy_dumb));
-  destroy_dumb_buffer_request.handle = buffer->handle;
+        memset (&destroy_dumb_buffer_request, 0, sizeof(struct drm_mode_destroy_dumb));
+        destroy_dumb_buffer_request.handle = buffer->handle;
 
-  if (drmIoctl (driver->device_fd,
-                DRM_IOCTL_MODE_DESTROY_DUMB,
-                &destroy_dumb_buffer_request) < 0)
-    {
-      ply_trace ("Could not deallocate GEM object %u: %m", buffer->handle);
-    }
+        if (drmIoctl (driver->device_fd,
+                      DRM_IOCTL_MODE_DESTROY_DUMB,
+                      &destroy_dumb_buffer_request) < 0)
+                ply_trace ("Could not deallocate GEM object %u: %m", buffer->handle);
 
-  free (buffer);
+        free (buffer);
 }
 
 static ply_renderer_buffer_t *
 get_buffer_from_id (ply_renderer_driver_t *driver,
                     uint32_t               id)
 {
-  static ply_renderer_buffer_t *buffer;
+        static ply_renderer_buffer_t *buffer;
 
-  buffer = ply_hashtable_lookup (driver->buffers, (void *) (uintptr_t) id);
+        buffer = ply_hashtable_lookup (driver->buffers, (void *) (uintptr_t) id);
 
-  return buffer;
+        return buffer;
 }
 
 static bool
@@ -225,28 +219,27 @@ fetch_buffer (ply_renderer_driver_t *driver,
               unsigned long         *height,
               unsigned long         *row_stride)
 {
-  ply_renderer_buffer_t *buffer;
+        ply_renderer_buffer_t *buffer;
 
-  buffer = get_buffer_from_id (driver, buffer_id);
+        buffer = get_buffer_from_id (driver, buffer_id);
 
-  if (buffer == NULL)
-    {
-      ply_trace ("could not fetch buffer %u", buffer_id);
-      return false;
-    }
+        if (buffer == NULL) {
+                ply_trace ("could not fetch buffer %u", buffer_id);
+                return false;
+        }
 
-  if (width != NULL)
-    *width = buffer->width;
+        if (width != NULL)
+                *width = buffer->width;
 
-  if (height != NULL)
-    *height = buffer->height;
+        if (height != NULL)
+                *height = buffer->height;
 
-  if (row_stride != NULL)
-    *row_stride = buffer->row_stride;
+        if (row_stride != NULL)
+                *row_stride = buffer->row_stride;
 
-  ply_trace ("fetched %ux%u buffer with stride %u",
-             buffer->width, buffer->height, buffer->row_stride);
-  return true;
+        ply_trace ("fetched %ux%u buffer with stride %u",
+                   buffer->width, buffer->height, buffer->row_stride);
+        return true;
 }
 
 static uint32_t
@@ -255,141 +248,138 @@ create_buffer (ply_renderer_driver_t *driver,
                unsigned long          height,
                unsigned long         *row_stride)
 {
-  ply_renderer_buffer_t *buffer;
+        ply_renderer_buffer_t *buffer;
 
-  buffer = ply_renderer_buffer_new (driver, width, height);
+        buffer = ply_renderer_buffer_new (driver, width, height);
 
-  if (buffer == NULL)
-    {
-      ply_trace ("Could not allocate GEM object for frame buffer: %m");
-      return 0;
-    }
+        if (buffer == NULL) {
+                ply_trace ("Could not allocate GEM object for frame buffer: %m");
+                return 0;
+        }
 
-  if (drmModeAddFB (driver->device_fd, width, height,
-                    24, 32, buffer->row_stride, buffer->handle,
-                    &buffer->id) != 0)
-    {
-      ply_trace ("Could not set up GEM object as frame buffer: %m");
-      ply_renderer_buffer_free (driver, buffer);
-      return 0;
-    }
+        if (drmModeAddFB (driver->device_fd, width, height,
+                          24, 32, buffer->row_stride, buffer->handle,
+                          &buffer->id) != 0) {
+                ply_trace ("Could not set up GEM object as frame buffer: %m");
+                ply_renderer_buffer_free (driver, buffer);
+                return 0;
+        }
 
-  *row_stride = buffer->row_stride;
+        *row_stride = buffer->row_stride;
 
-  buffer->added_fb = true;
-  ply_hashtable_insert (driver->buffers,
-                        (void *) (uintptr_t) buffer->id,
-                        buffer);
+        buffer->added_fb = true;
+        ply_hashtable_insert (driver->buffers,
+                              (void *) (uintptr_t) buffer->id,
+                              buffer);
 
-  return buffer->id;
+        return buffer->id;
 }
 
 static bool
 map_buffer (ply_renderer_driver_t *driver,
             uint32_t               buffer_id)
 {
-  ply_renderer_buffer_t *buffer;
+        ply_renderer_buffer_t *buffer;
 
-  buffer = get_buffer_from_id (driver, buffer_id);
+        buffer = get_buffer_from_id (driver, buffer_id);
 
-  assert (buffer != NULL);
+        assert (buffer != NULL);
 
-  return ply_renderer_buffer_map (driver, buffer);
+        return ply_renderer_buffer_map (driver, buffer);
 }
 
 static void
 unmap_buffer (ply_renderer_driver_t *driver,
               uint32_t               buffer_id)
 {
-  ply_renderer_buffer_t *buffer;
+        ply_renderer_buffer_t *buffer;
 
-  buffer = get_buffer_from_id (driver, buffer_id);
+        buffer = get_buffer_from_id (driver, buffer_id);
 
-  assert (buffer != NULL);
+        assert (buffer != NULL);
 
-  ply_renderer_buffer_unmap (driver, buffer);
+        ply_renderer_buffer_unmap (driver, buffer);
 }
 
 static char *
 begin_flush (ply_renderer_driver_t *driver,
              uint32_t               buffer_id)
 {
-  ply_renderer_buffer_t *buffer;
+        ply_renderer_buffer_t *buffer;
 
-  buffer = get_buffer_from_id (driver, buffer_id);
+        buffer = get_buffer_from_id (driver, buffer_id);
 
-  assert (buffer != NULL);
+        assert (buffer != NULL);
 
-  return buffer->map_address;
+        return buffer->map_address;
 }
 
 static void
 end_flush (ply_renderer_driver_t *driver,
            uint32_t               buffer_id)
 {
-  ply_renderer_buffer_t *buffer;
+        ply_renderer_buffer_t *buffer;
 
-  buffer = get_buffer_from_id (driver, buffer_id);
+        buffer = get_buffer_from_id (driver, buffer_id);
 
-  assert (buffer != NULL);
+        assert (buffer != NULL);
 
-  if (driver->requires_explicit_flushing)
-    {
-      struct drm_clip_rect flush_area;
-      int ret;
+        if (driver->requires_explicit_flushing) {
+                struct drm_clip_rect flush_area;
+                int ret;
 
-      flush_area.x1 = 0;
-      flush_area.y1 = 0;
-      flush_area.x2 = buffer->width;
-      flush_area.y2 = buffer->height;
+                flush_area.x1 = 0;
+                flush_area.y1 = 0;
+                flush_area.x2 = buffer->width;
+                flush_area.y2 = buffer->height;
 
-      ret = drmModeDirtyFB (driver->device_fd, buffer->id, &flush_area, 1);
+                ret = drmModeDirtyFB (driver->device_fd, buffer->id, &flush_area, 1);
 
-      if (ret == -ENOSYS)
-        driver->requires_explicit_flushing = false;
-    }
+                if (ret == -ENOSYS)
+                        driver->requires_explicit_flushing = false;
+        }
 }
 
 static void
 destroy_buffer (ply_renderer_driver_t *driver,
                 uint32_t               buffer_id)
 {
-  ply_renderer_buffer_t *buffer;
+        ply_renderer_buffer_t *buffer;
 
-  buffer = ply_hashtable_remove (driver->buffers,
-                                 (void *) (uintptr_t) buffer_id);
+        buffer = ply_hashtable_remove (driver->buffers,
+                                       (void *) (uintptr_t) buffer_id);
 
-  assert (buffer != NULL);
+        assert (buffer != NULL);
 
-  ply_renderer_buffer_free (driver, buffer);
+        ply_renderer_buffer_free (driver, buffer);
 }
 
 ply_renderer_driver_interface_t *
 ply_renderer_generic_driver_get_interface (int device_fd)
 {
-  uint64_t supports_dumb_buffers;
+        uint64_t supports_dumb_buffers;
 
-  static ply_renderer_driver_interface_t driver_interface =
-    {
-      .create_driver = create_driver,
-      .destroy_driver = destroy_driver,
-      .create_buffer = create_buffer,
-      .fetch_buffer = fetch_buffer,
-      .map_buffer = map_buffer,
-      .unmap_buffer = unmap_buffer,
-      .begin_flush = begin_flush,
-      .end_flush = end_flush,
-      .destroy_buffer = destroy_buffer,
-    };
+        static ply_renderer_driver_interface_t driver_interface =
+        {
+                .create_driver  = create_driver,
+                .destroy_driver = destroy_driver,
+                .create_buffer  = create_buffer,
+                .fetch_buffer   = fetch_buffer,
+                .map_buffer     = map_buffer,
+                .unmap_buffer   = unmap_buffer,
+                .begin_flush    = begin_flush,
+                .end_flush      = end_flush,
+                .destroy_buffer = destroy_buffer,
+        };
 
 
-  if (drmGetCap (device_fd, DRM_CAP_DUMB_BUFFER, &supports_dumb_buffers) < 0)
-    return NULL;
+        if (drmGetCap (device_fd, DRM_CAP_DUMB_BUFFER, &supports_dumb_buffers) < 0)
+                return NULL;
 
-  if (!supports_dumb_buffers)
-    return NULL;
+        if (!supports_dumb_buffers)
+                return NULL;
 
-  return &driver_interface;
+        return &driver_interface;
 }
 
 /* vim: set ts=4 sw=4 et ai ci cino={.5s,^-2,+.5s,t0,g0,e-2,n-2,p2s, (0,=.5s,:.5s */
diff --git a/src/plugins/renderers/frame-buffer/plugin.c b/src/plugins/renderers/frame-buffer/plugin.c
index dd73a0f..418855a 100644
--- a/src/plugins/renderers/frame-buffer/plugin.c
+++ b/src/plugins/renderers/frame-buffer/plugin.c
@@ -61,58 +61,57 @@
 
 struct _ply_renderer_head
 {
-  ply_pixel_buffer_t *pixel_buffer;
-  ply_rectangle_t area;
-  char *map_address;
-  size_t size;
-
+        ply_pixel_buffer_t *pixel_buffer;
+        ply_rectangle_t     area;
+        char               *map_address;
+        size_t              size;
 };
 
 struct _ply_renderer_input_source
 {
-  ply_renderer_backend_t *backend;
-  ply_fd_watch_t *terminal_input_watch;
+        ply_renderer_backend_t             *backend;
+        ply_fd_watch_t                     *terminal_input_watch;
 
-  ply_buffer_t   *key_buffer;
+        ply_buffer_t                       *key_buffer;
 
-  ply_renderer_input_source_handler_t handler;
-  void           *user_data;
+        ply_renderer_input_source_handler_t handler;
+        void                               *user_data;
 };
 
 struct _ply_renderer_backend
 {
-  ply_event_loop_t *loop;
-  ply_terminal_t *terminal;
+        ply_event_loop_t           *loop;
+        ply_terminal_t             *terminal;
 
-  char *device_name;
-  int   device_fd;
+        char                       *device_name;
+        int                         device_fd;
 
-  ply_renderer_input_source_t input_source;
-  ply_renderer_head_t head;
-  ply_list_t *heads;
+        ply_renderer_input_source_t input_source;
+        ply_renderer_head_t         head;
+        ply_list_t                 *heads;
 
-  uint32_t red_bit_position;
-  uint32_t green_bit_position;
-  uint32_t blue_bit_position;
-  uint32_t alpha_bit_position;
+        uint32_t                    red_bit_position;
+        uint32_t                    green_bit_position;
+        uint32_t                    blue_bit_position;
+        uint32_t                    alpha_bit_position;
 
-  uint32_t bits_for_red;
-  uint32_t bits_for_green;
-  uint32_t bits_for_blue;
-  uint32_t bits_for_alpha;
+        uint32_t                    bits_for_red;
+        uint32_t                    bits_for_green;
+        uint32_t                    bits_for_blue;
+        uint32_t                    bits_for_alpha;
 
-  int32_t dither_red;
-  int32_t dither_green;
-  int32_t dither_blue;
+        int32_t                     dither_red;
+        int32_t                     dither_green;
+        int32_t                     dither_blue;
 
-  unsigned int bytes_per_pixel;
-  unsigned int row_stride;
+        unsigned int                bytes_per_pixel;
+        unsigned int                row_stride;
 
-  uint32_t is_active : 1;
+        uint32_t                    is_active : 1;
 
-  void (* flush_area) (ply_renderer_backend_t *backend,
-                       ply_renderer_head_t    *head,
-                       ply_rectangle_t        *area_to_flush);
+        void                        (*flush_area) (ply_renderer_backend_t *backend,
+                                                   ply_renderer_head_t    *head,
+                                                   ply_rectangle_t        *area_to_flush);
 };
 
 ply_renderer_plugin_interface_t *ply_renderer_backend_get_interface (void);
@@ -125,44 +124,47 @@ static inline uint_fast32_t
 argb32_pixel_value_to_device_pixel_value (ply_renderer_backend_t *backend,
                                           uint32_t                pixel_value)
 {
-  uint8_t r, g, b, a;
-  int orig_r, orig_g, orig_b, orig_a;
-  uint8_t new_r, new_g, new_b;
-  int i;
+        uint8_t r, g, b, a;
+        int orig_r, orig_g, orig_b, orig_a;
+        uint8_t new_r, new_g, new_b;
+        int i;
 
-  orig_a = pixel_value >> 24;
-  a = orig_a >> (8 - backend->bits_for_alpha);
+        orig_a = pixel_value >> 24;
+        a = orig_a >> (8 - backend->bits_for_alpha);
 
-  orig_r = ((pixel_value >> 16) & 0xff) - backend->dither_red;
-  r = CLAMP (orig_r, 0, 255) >> (8 - backend->bits_for_red);
+        orig_r = ((pixel_value >> 16) & 0xff) - backend->dither_red;
+        r = CLAMP (orig_r, 0, 255) >> (8 - backend->bits_for_red);
 
-  orig_g = ((pixel_value >> 8) & 0xff) - backend->dither_green;
-  g = CLAMP (orig_g, 0, 255) >> (8 - backend->bits_for_green);
+        orig_g = ((pixel_value >> 8) & 0xff) - backend->dither_green;
+        g = CLAMP (orig_g, 0, 255) >> (8 - backend->bits_for_green);
 
-  orig_b = (pixel_value & 0xff) - backend->dither_blue;
-  b = CLAMP (orig_b, 0, 255) >> (8 - backend->bits_for_blue);
+        orig_b = (pixel_value & 0xff) - backend->dither_blue;
+        b = CLAMP (orig_b, 0, 255) >> (8 - backend->bits_for_blue);
 
-  new_r = r << (8 - backend->bits_for_red);
-  new_g = g << (8 - backend->bits_for_green);
-  new_b = b << (8 - backend->bits_for_blue);
+        new_r = r << (8 - backend->bits_for_red);
+        new_g = g << (8 - backend->bits_for_green);
+        new_b = b << (8 - backend->bits_for_blue);
 
-  for (i = backend->bits_for_red; i < 8; i <<= 1)
-    new_r |= new_r >> i;
+        for (i = backend->bits_for_red; i < 8; i <<= 1) {
+                new_r |= new_r >> i;
+        }
 
-  for (i = backend->bits_for_green; i < 8; i <<= 1)
-    new_g |= new_g >> i;
+        for (i = backend->bits_for_green; i < 8; i <<= 1) {
+                new_g |= new_g >> i;
+        }
 
-  for (i = backend->bits_for_blue; i < 8; i <<= 1)
-    new_b |= new_b >> i;
+        for (i = backend->bits_for_blue; i < 8; i <<= 1) {
+                new_b |= new_b >> i;
+        }
 
-  backend->dither_red = new_r - orig_r;
-  backend->dither_green = new_g - orig_g;
-  backend->dither_blue = new_b - orig_b;
+        backend->dither_red = new_r - orig_r;
+        backend->dither_green = new_g - orig_g;
+        backend->dither_blue = new_b - orig_b;
 
-  return ((a << backend->alpha_bit_position)
-          | (r << backend->red_bit_position)
-          | (g << backend->green_bit_position)
-          | (b << backend->blue_bit_position));
+        return (a << backend->alpha_bit_position)
+               | (r << backend->red_bit_position)
+               | (g << backend->green_bit_position)
+               | (b << backend->blue_bit_position);
 }
 
 static void
@@ -170,41 +172,39 @@ flush_area_to_any_device (ply_renderer_backend_t *backend,
                           ply_renderer_head_t    *head,
                           ply_rectangle_t        *area_to_flush)
 {
-  unsigned long row, column;
-  uint32_t *shadow_buffer;
-  char *row_backend;
-  unsigned long x1, y1, x2, y2;
-
-  x1 = area_to_flush->x;
-  y1 = area_to_flush->y;
-  x2 = x1 + area_to_flush->width;
-  y2 = y1 + area_to_flush->height;
-
-  row_backend = malloc (backend->row_stride);
-  shadow_buffer = ply_pixel_buffer_get_argb32_data (backend->head.pixel_buffer);
-  for (row = y1; row < y2; row++)
-    {
-      unsigned long offset;
-
-      for (column = x1; column < x2; column++)
-        {
-          uint32_t pixel_value;
-          uint_fast32_t device_pixel_value;
+        unsigned long row, column;
+        uint32_t *shadow_buffer;
+        char *row_backend;
+        unsigned long x1, y1, x2, y2;
 
-          pixel_value = shadow_buffer[row * head->area.width + column];
+        x1 = area_to_flush->x;
+        y1 = area_to_flush->y;
+        x2 = x1 + area_to_flush->width;
+        y2 = y1 + area_to_flush->height;
 
-          device_pixel_value = argb32_pixel_value_to_device_pixel_value (backend,
-                                                                         pixel_value);
+        row_backend = malloc (backend->row_stride);
+        shadow_buffer = ply_pixel_buffer_get_argb32_data (backend->head.pixel_buffer);
+        for (row = y1; row < y2; row++) {
+                unsigned long offset;
 
-          memcpy (row_backend + column * backend->bytes_per_pixel,
-                  &device_pixel_value, backend->bytes_per_pixel);
-        }
+                for (column = x1; column < x2; column++) {
+                        uint32_t pixel_value;
+                        uint_fast32_t device_pixel_value;
+
+                        pixel_value = shadow_buffer[row * head->area.width + column];
+
+                        device_pixel_value = argb32_pixel_value_to_device_pixel_value (backend,
+                                                                                       pixel_value);
 
-      offset = row * backend->row_stride + x1 * backend->bytes_per_pixel;
-      memcpy (head->map_address + offset, row_backend + x1 * backend->bytes_per_pixel,
-              area_to_flush->width * backend->bytes_per_pixel);
-    }
-  free (row_backend);
+                        memcpy (row_backend + column * backend->bytes_per_pixel,
+                                &device_pixel_value, backend->bytes_per_pixel);
+                }
+
+                offset = row * backend->row_stride + x1 * backend->bytes_per_pixel;
+                memcpy (head->map_address + offset, row_backend + x1 * backend->bytes_per_pixel,
+                        area_to_flush->width * backend->bytes_per_pixel);
+        }
+        free (row_backend);
 }
 
 static void
@@ -212,557 +212,529 @@ flush_area_to_xrgb32_device (ply_renderer_backend_t *backend,
                              ply_renderer_head_t    *head,
                              ply_rectangle_t        *area_to_flush)
 {
-  unsigned long x, y, y1, y2;
-  uint32_t *shadow_buffer;
-  char *dst, *src;
-
-  x = area_to_flush->x;
-  y1 = area_to_flush->y;
-  y2 = y1 + area_to_flush->height;
-
-  shadow_buffer = ply_pixel_buffer_get_argb32_data (backend->head.pixel_buffer);
-
-  dst = &head->map_address[y1 * backend->row_stride + x * backend->bytes_per_pixel];
-  src = (char *) &shadow_buffer[y1 * head->area.width + x];
-
-  if (area_to_flush->width * 4 == backend->row_stride &&
-      head->area.width * 4 == backend->row_stride)
-    {
-      memcpy (dst, src, area_to_flush->width * area_to_flush->height * 4);
-      return;
-    }
-
-  for (y = y1; y < y2; y++)
-    {
-      memcpy (dst, src, area_to_flush->width * 4);
-      dst += backend->row_stride;
-      src += head->area.width * 4;
-    }
+        unsigned long x, y, y1, y2;
+        uint32_t *shadow_buffer;
+        char *dst, *src;
+
+        x = area_to_flush->x;
+        y1 = area_to_flush->y;
+        y2 = y1 + area_to_flush->height;
+
+        shadow_buffer = ply_pixel_buffer_get_argb32_data (backend->head.pixel_buffer);
+
+        dst = &head->map_address[y1 * backend->row_stride + x * backend->bytes_per_pixel];
+        src = (char *) &shadow_buffer[y1 * head->area.width + x];
+
+        if (area_to_flush->width * 4 == backend->row_stride &&
+            head->area.width * 4 == backend->row_stride) {
+                memcpy (dst, src, area_to_flush->width * area_to_flush->height * 4);
+                return;
+        }
+
+        for (y = y1; y < y2; y++) {
+                memcpy (dst, src, area_to_flush->width * 4);
+                dst += backend->row_stride;
+                src += head->area.width * 4;
+        }
 }
 
 static ply_renderer_backend_t *
-create_backend (const char *device_name,
+create_backend (const char     *device_name,
                 ply_terminal_t *terminal)
 {
-  ply_renderer_backend_t *backend;
+        ply_renderer_backend_t *backend;
 
-  backend = calloc (1, sizeof (ply_renderer_backend_t));
+        backend = calloc (1, sizeof(ply_renderer_backend_t));
 
-  if (device_name != NULL)
-    backend->device_name = strdup (device_name);
-  else if (getenv ("FRAMEBUFFER") != NULL)
-    backend->device_name = strdup (getenv ("FRAMEBUFFER"));
-  else
-    backend->device_name =
-      strdup (PLY_FRAME_BUFFER_DEFAULT_FB_DEVICE_NAME);
+        if (device_name != NULL)
+                backend->device_name = strdup (device_name);
+        else if (getenv ("FRAMEBUFFER") != NULL)
+                backend->device_name = strdup (getenv ("FRAMEBUFFER"));
+        else
+                backend->device_name =
+                        strdup (PLY_FRAME_BUFFER_DEFAULT_FB_DEVICE_NAME);
 
-  ply_trace ("creating renderer backend for device %s", backend->device_name);
+        ply_trace ("creating renderer backend for device %s", backend->device_name);
 
-  backend->loop = ply_event_loop_get_default ();
-  backend->head.map_address = MAP_FAILED;
-  backend->heads = ply_list_new ();
-  backend->input_source.key_buffer = ply_buffer_new ();
-  backend->terminal = terminal;
+        backend->loop = ply_event_loop_get_default ();
+        backend->head.map_address = MAP_FAILED;
+        backend->heads = ply_list_new ();
+        backend->input_source.key_buffer = ply_buffer_new ();
+        backend->terminal = terminal;
 
-  return backend;
+        return backend;
 }
 
 static void
 initialize_head (ply_renderer_backend_t *backend,
                  ply_renderer_head_t    *head)
 {
-  ply_trace ("initializing %lux%lu head",
-             head->area.width, head->area.height);
-  head->pixel_buffer = ply_pixel_buffer_new (head->area.width,
-                                             head->area.height);
-  ply_pixel_buffer_fill_with_color (backend->head.pixel_buffer, NULL,
-                                    0.0, 0.0, 0.0, 1.0);
-  ply_list_append_data (backend->heads, head);
+        ply_trace ("initializing %lux%lu head",
+                   head->area.width, head->area.height);
+        head->pixel_buffer = ply_pixel_buffer_new (head->area.width,
+                                                   head->area.height);
+        ply_pixel_buffer_fill_with_color (backend->head.pixel_buffer, NULL,
+                                          0.0, 0.0, 0.0, 1.0);
+        ply_list_append_data (backend->heads, head);
 }
 
 static void
 uninitialize_head (ply_renderer_backend_t *backend,
                    ply_renderer_head_t    *head)
 {
-  ply_trace ("uninitializing %lux%lu head",
-             head->area.width, head->area.height);
-  if (head->pixel_buffer != NULL)
-    {
-      ply_pixel_buffer_free (head->pixel_buffer);
-      head->pixel_buffer = NULL;
-
-      ply_list_remove_data (backend->heads, head);
-    }
+        ply_trace ("uninitializing %lux%lu head",
+                   head->area.width, head->area.height);
+        if (head->pixel_buffer != NULL) {
+                ply_pixel_buffer_free (head->pixel_buffer);
+                head->pixel_buffer = NULL;
+
+                ply_list_remove_data (backend->heads, head);
+        }
 }
 
 static void
 destroy_backend (ply_renderer_backend_t *backend)
 {
+        ply_trace ("destroying renderer backend for device %s",
+                   backend->device_name);
+        free (backend->device_name);
+        uninitialize_head (backend, &backend->head);
 
-  ply_trace ("destroying renderer backend for device %s",
-             backend->device_name);
-  free (backend->device_name);
-  uninitialize_head (backend, &backend->head);
+        ply_list_free (backend->heads);
 
-  ply_list_free (backend->heads);
-
-  free (backend);
+        free (backend);
 }
 
 static void
 activate (ply_renderer_backend_t *backend)
 {
-  ply_trace ("Redrawing screen");
-  backend->is_active = true;
+        ply_trace ("Redrawing screen");
+        backend->is_active = true;
 
-  if (backend->head.map_address != MAP_FAILED)
-    ply_renderer_head_redraw (backend, &backend->head);
+        if (backend->head.map_address != MAP_FAILED)
+                ply_renderer_head_redraw (backend, &backend->head);
 }
 
 static void
 deactivate (ply_renderer_backend_t *backend)
 {
-  backend->is_active = false;
+        backend->is_active = false;
 }
 
 static void
 on_active_vt_changed (ply_renderer_backend_t *backend)
 {
-  if (ply_terminal_is_active (backend->terminal))
-    {
-      ply_trace ("activating on vt change");
-      activate (backend);
-    }
-  else
-    {
-      ply_trace ("deactivating on vt change");
-      deactivate (backend);
-    }
+        if (ply_terminal_is_active (backend->terminal)) {
+                ply_trace ("activating on vt change");
+                activate (backend);
+        } else {
+                ply_trace ("deactivating on vt change");
+                deactivate (backend);
+        }
 }
 
 static bool
 open_device (ply_renderer_backend_t *backend)
 {
-  backend->device_fd = open (backend->device_name, O_RDWR);
-
-  if (backend->device_fd < 0)
-    {
-      ply_trace ("could not open '%s': %m", backend->device_name);
-      return false;
-    }
-
-  if (backend->terminal == NULL)
-    return true;
-
-  if (!ply_terminal_open (backend->terminal))
-    {
-      ply_trace ("could not open terminal: %m");
-      return false;
-    }
-
-  if (!ply_terminal_is_vt (backend->terminal))
-    {
-      ply_trace ("terminal is not a VT");
-      ply_terminal_close (backend->terminal);
-      return false;
-    }
-
-  ply_terminal_watch_for_active_vt_change (backend->terminal,
-                                           (ply_terminal_active_vt_changed_handler_t)
-                                           on_active_vt_changed,
-                                           backend);
-
-  return true;
+        backend->device_fd = open (backend->device_name, O_RDWR);
+
+        if (backend->device_fd < 0) {
+                ply_trace ("could not open '%s': %m", backend->device_name);
+                return false;
+        }
+
+        if (backend->terminal == NULL)
+                return true;
+
+        if (!ply_terminal_open (backend->terminal)) {
+                ply_trace ("could not open terminal: %m");
+                return false;
+        }
+
+        if (!ply_terminal_is_vt (backend->terminal)) {
+                ply_trace ("terminal is not a VT");
+                ply_terminal_close (backend->terminal);
+                return false;
+        }
+
+        ply_terminal_watch_for_active_vt_change (backend->terminal,
+                                                 (ply_terminal_active_vt_changed_handler_t)
+                                                 on_active_vt_changed,
+                                                 backend);
+
+        return true;
 }
 
 static void
 close_device (ply_renderer_backend_t *backend)
 {
+        if (backend->terminal != NULL) {
+                ply_terminal_stop_watching_for_active_vt_change (backend->terminal,
+                                                                 (ply_terminal_active_vt_changed_handler_t)
+                                                                 on_active_vt_changed,
+                                                                 backend);
+        }
+        uninitialize_head (backend, &backend->head);
 
-  if (backend->terminal != NULL)
-    ply_terminal_stop_watching_for_active_vt_change (backend->terminal,
-                                                     (ply_terminal_active_vt_changed_handler_t)
-                                                     on_active_vt_changed,
-                                                     backend);
-  uninitialize_head (backend, &backend->head);
-
-  close (backend->device_fd);
-  backend->device_fd = -1;
-
-  backend->bytes_per_pixel = 0;
-  backend->head.area.x = 0;
-  backend->head.area.y = 0;
-  backend->head.area.width = 0;
-  backend->head.area.height = 0;
+        close (backend->device_fd);
+        backend->device_fd = -1;
+
+        backend->bytes_per_pixel = 0;
+        backend->head.area.x = 0;
+        backend->head.area.y = 0;
+        backend->head.area.width = 0;
+        backend->head.area.height = 0;
 }
 
 static const char const *get_visual_name (int visual)
 {
-  static const char const *visuals[] =
-    {
-      [FB_VISUAL_MONO01] = "FB_VISUAL_MONO01",
-      [FB_VISUAL_MONO10] = "FB_VISUAL_MONO10",
-      [FB_VISUAL_TRUECOLOR] = "FB_VISUAL_TRUECOLOR",
-      [FB_VISUAL_PSEUDOCOLOR] = "FB_VISUAL_PSEUDOCOLOR",
-      [FB_VISUAL_DIRECTCOLOR] = "FB_VISUAL_DIRECTCOLOR",
-      [FB_VISUAL_STATIC_PSEUDOCOLOR] = "FB_VISUAL_STATIC_PSEUDOCOLOR",
-      NULL
-    };
-  static char unknown[] = "invalid visual: -4294967295";
-
-  if (visual < FB_VISUAL_MONO01 || visual > FB_VISUAL_STATIC_PSEUDOCOLOR)
-    {
-      sprintf (unknown, "invalid visual: %d", visual);
-      return unknown;
-    }
-
-  return visuals[visual];
+        static const char const *visuals[] =
+        {
+                [FB_VISUAL_MONO01] = "FB_VISUAL_MONO01",
+                [FB_VISUAL_MONO10] = "FB_VISUAL_MONO10",
+                [FB_VISUAL_TRUECOLOR] = "FB_VISUAL_TRUECOLOR",
+                [FB_VISUAL_PSEUDOCOLOR] = "FB_VISUAL_PSEUDOCOLOR",
+                [FB_VISUAL_DIRECTCOLOR] = "FB_VISUAL_DIRECTCOLOR",
+                [FB_VISUAL_STATIC_PSEUDOCOLOR] = "FB_VISUAL_STATIC_PSEUDOCOLOR",
+                NULL
+        };
+        static char unknown[] = "invalid visual: -4294967295";
+
+        if (visual < FB_VISUAL_MONO01 || visual > FB_VISUAL_STATIC_PSEUDOCOLOR) {
+                sprintf (unknown, "invalid visual: %d", visual);
+                return unknown;
+        }
+
+        return visuals[visual];
 }
 
 static bool
 query_device (ply_renderer_backend_t *backend)
 {
-  struct fb_var_screeninfo variable_screen_info;
-  struct fb_fix_screeninfo fixed_screen_info;
-
-  assert (backend != NULL);
-  assert (backend->device_fd >= 0);
-
-  if (ioctl (backend->device_fd, FBIOGET_VSCREENINFO, &variable_screen_info) < 0)
-    return false;
-
-  if (ioctl (backend->device_fd, FBIOGET_FSCREENINFO, &fixed_screen_info) < 0)
-    return false;
-
-  /* Normally the pixel is divided into channels between the color components.
-   * Each channel directly maps to a color channel on the hardware.
-   *
-   * There are some odd ball modes that use an indexed palette instead.  In
-   * those cases (pseudocolor, direct color, etc), the pixel value is just an
-   * index into a lookup table of the real color values.
-   *
-   * We don't support that.
-   */
-  if (fixed_screen_info.visual != FB_VISUAL_TRUECOLOR)
-    {
-      int rc = -1;
-      int i;
-      static const int depths[] = {32, 24, 16, 0};
-
-      ply_trace ("Visual was %s, trying to find usable mode.\n",
-                 get_visual_name (fixed_screen_info.visual));
-
-      for (i = 0; depths[i] != 0; i++)
-        {
-          variable_screen_info.bits_per_pixel = depths[i];
-          variable_screen_info.activate |= FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
-
-          rc = ioctl (backend->device_fd, FBIOPUT_VSCREENINFO, &variable_screen_info);
-          if (rc >= 0)
-            {
-              if (ioctl (backend->device_fd, FBIOGET_FSCREENINFO, &fixed_screen_info) < 0)
-                return false;
+        struct fb_var_screeninfo variable_screen_info;
+        struct fb_fix_screeninfo fixed_screen_info;
 
-              if (fixed_screen_info.visual == FB_VISUAL_TRUECOLOR)
-                break;
-            }
-        }
+        assert (backend != NULL);
+        assert (backend->device_fd >= 0);
 
-      if (ioctl (backend->device_fd, FBIOGET_VSCREENINFO, &variable_screen_info) < 0)
-        return false;
+        if (ioctl (backend->device_fd, FBIOGET_VSCREENINFO, &variable_screen_info) < 0)
+                return false;
 
-      if (ioctl (backend->device_fd, FBIOGET_FSCREENINFO, &fixed_screen_info) < 0)
-        return false;
-    }
+        if (ioctl (backend->device_fd, FBIOGET_FSCREENINFO, &fixed_screen_info) < 0)
+                return false;
 
-  if (fixed_screen_info.visual != FB_VISUAL_TRUECOLOR ||
-      variable_screen_info.bits_per_pixel < 16)
-    {
-      ply_trace ("Visual is %s; not using graphics\n",
-                 get_visual_name (fixed_screen_info.visual));
-      return false;
-    }
+        /* Normally the pixel is divided into channels between the color components.
+         * Each channel directly maps to a color channel on the hardware.
+         *
+         * There are some odd ball modes that use an indexed palette instead.  In
+         * those cases (pseudocolor, direct color, etc), the pixel value is just an
+         * index into a lookup table of the real color values.
+         *
+         * We don't support that.
+         */
+        if (fixed_screen_info.visual != FB_VISUAL_TRUECOLOR) {
+                int rc = -1;
+                int i;
+                static const int depths[] = { 32, 24, 16, 0 };
+
+                ply_trace ("Visual was %s, trying to find usable mode.\n",
+                           get_visual_name (fixed_screen_info.visual));
+
+                for (i = 0; depths[i] != 0; i++) {
+                        variable_screen_info.bits_per_pixel = depths[i];
+                        variable_screen_info.activate |= FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
+
+                        rc = ioctl (backend->device_fd, FBIOPUT_VSCREENINFO, &variable_screen_info);
+                        if (rc >= 0) {
+                                if (ioctl (backend->device_fd, FBIOGET_FSCREENINFO, &fixed_screen_info) < 0)
+                                        return false;
+
+                                if (fixed_screen_info.visual == FB_VISUAL_TRUECOLOR)
+                                        break;
+                        }
+                }
+
+                if (ioctl (backend->device_fd, FBIOGET_VSCREENINFO, &variable_screen_info) < 0)
+                        return false;
+
+                if (ioctl (backend->device_fd, FBIOGET_FSCREENINFO, &fixed_screen_info) < 0)
+                        return false;
+        }
 
-  backend->head.area.x = variable_screen_info.xoffset;
-  backend->head.area.y = variable_screen_info.yoffset;
-  backend->head.area.width = variable_screen_info.xres;
-  backend->head.area.height = variable_screen_info.yres;
+        if (fixed_screen_info.visual != FB_VISUAL_TRUECOLOR ||
+            variable_screen_info.bits_per_pixel < 16) {
+                ply_trace ("Visual is %s; not using graphics\n",
+                           get_visual_name (fixed_screen_info.visual));
+                return false;
+        }
 
-  backend->red_bit_position = variable_screen_info.red.offset;
-  backend->bits_for_red = variable_screen_info.red.length;
+        backend->head.area.x = variable_screen_info.xoffset;
+        backend->head.area.y = variable_screen_info.yoffset;
+        backend->head.area.width = variable_screen_info.xres;
+        backend->head.area.height = variable_screen_info.yres;
 
-  backend->green_bit_position = variable_screen_info.green.offset;
-  backend->bits_for_green = variable_screen_info.green.length;
+        backend->red_bit_position = variable_screen_info.red.offset;
+        backend->bits_for_red = variable_screen_info.red.length;
 
-  backend->blue_bit_position = variable_screen_info.blue.offset;
-  backend->bits_for_blue = variable_screen_info.blue.length;
+        backend->green_bit_position = variable_screen_info.green.offset;
+        backend->bits_for_green = variable_screen_info.green.length;
 
-  backend->alpha_bit_position = variable_screen_info.transp.offset;
-  backend->bits_for_alpha = variable_screen_info.transp.length;
+        backend->blue_bit_position = variable_screen_info.blue.offset;
+        backend->bits_for_blue = variable_screen_info.blue.length;
 
-  backend->bytes_per_pixel = variable_screen_info.bits_per_pixel >> 3;
-  backend->row_stride = fixed_screen_info.line_length;
-  backend->dither_red = 0;
-  backend->dither_green = 0;
-  backend->dither_blue = 0;
+        backend->alpha_bit_position = variable_screen_info.transp.offset;
+        backend->bits_for_alpha = variable_screen_info.transp.length;
 
-  ply_trace ("%d bpp (%d, %d, %d, %d) with rowstride %d",
-             (int) backend->bytes_per_pixel * 8, 
-             backend->bits_for_red,
-             backend->bits_for_green,
-             backend->bits_for_blue,
-             backend->bits_for_alpha,
-             (int) backend->row_stride);
+        backend->bytes_per_pixel = variable_screen_info.bits_per_pixel >> 3;
+        backend->row_stride = fixed_screen_info.line_length;
+        backend->dither_red = 0;
+        backend->dither_green = 0;
+        backend->dither_blue = 0;
 
-  backend->head.size = backend->head.area.height * backend->row_stride;
+        ply_trace ("%d bpp (%d, %d, %d, %d) with rowstride %d",
+                   (int) backend->bytes_per_pixel * 8,
+                   backend->bits_for_red,
+                   backend->bits_for_green,
+                   backend->bits_for_blue,
+                   backend->bits_for_alpha,
+                   (int) backend->row_stride);
 
-  if (backend->bytes_per_pixel == 4 &&
-      backend->red_bit_position == 16 && backend->bits_for_red == 8 &&
-      backend->green_bit_position == 8 && backend->bits_for_green == 8 &&
-      backend->blue_bit_position == 0 && backend->bits_for_blue == 8)
-    backend->flush_area = flush_area_to_xrgb32_device;
-  else
-    backend->flush_area = flush_area_to_any_device;
+        backend->head.size = backend->head.area.height * backend->row_stride;
 
-  initialize_head (backend, &backend->head);
+        if (backend->bytes_per_pixel == 4 &&
+            backend->red_bit_position == 16 && backend->bits_for_red == 8 &&
+            backend->green_bit_position == 8 && backend->bits_for_green == 8 &&
+            backend->blue_bit_position == 0 && backend->bits_for_blue == 8)
+                backend->flush_area = flush_area_to_xrgb32_device;
+        else
+                backend->flush_area = flush_area_to_any_device;
 
-  return true;
+        initialize_head (backend, &backend->head);
 
+        return true;
 }
 
 static bool
 map_to_device (ply_renderer_backend_t *backend)
 {
-  ply_renderer_head_t *head;
+        ply_renderer_head_t *head;
 
-  assert (backend != NULL);
-  assert (backend->device_fd >= 0);
+        assert (backend != NULL);
+        assert (backend->device_fd >= 0);
 
-  head = &backend->head;
-  assert (head->size > 0);
+        head = &backend->head;
+        assert (head->size > 0);
 
-  head->map_address = mmap (NULL, head->size, PROT_WRITE,
-                            MAP_SHARED, backend->device_fd, 0);
+        head->map_address = mmap (NULL, head->size, PROT_WRITE,
+                                  MAP_SHARED, backend->device_fd, 0);
 
-  if (head->map_address == MAP_FAILED)
-    {
-      ply_trace ("could not map fb device: %m");
-      return false;
-    }
-
-  if (backend->terminal != NULL)
-    {
-      if (ply_terminal_is_active (backend->terminal))
-        {
-          ply_trace ("already on right vt, activating");
-          activate (backend);
+        if (head->map_address == MAP_FAILED) {
+                ply_trace ("could not map fb device: %m");
+                return false;
         }
-      else
-        {
-          ply_trace ("on wrong vt, changing vts");
-          ply_terminal_activate_vt (backend->terminal);
+
+        if (backend->terminal != NULL) {
+                if (ply_terminal_is_active (backend->terminal)) {
+                        ply_trace ("already on right vt, activating");
+                        activate (backend);
+                } else {
+                        ply_trace ("on wrong vt, changing vts");
+                        ply_terminal_activate_vt (backend->terminal);
+                }
+        } else {
+                activate (backend);
         }
-    }
-  else
-    {
-      activate (backend);
-    }
 
-  return true;
+        return true;
 }
 
 static void
 unmap_from_device (ply_renderer_backend_t *backend)
 {
-  ply_renderer_head_t *head;
+        ply_renderer_head_t *head;
 
-  head = &backend->head;
+        head = &backend->head;
 
-  ply_trace ("unmapping device");
-  if (head->map_address != MAP_FAILED)
-    {
-      munmap (head->map_address, head->size);
-      head->map_address = MAP_FAILED;
-    }
+        ply_trace ("unmapping device");
+        if (head->map_address != MAP_FAILED) {
+                munmap (head->map_address, head->size);
+                head->map_address = MAP_FAILED;
+        }
 }
 
 static void
 flush_head (ply_renderer_backend_t *backend,
             ply_renderer_head_t    *head)
 {
-  ply_region_t *updated_region;
-  ply_list_t *areas_to_flush;
-  ply_list_node_t *node;
-  ply_pixel_buffer_t *pixel_buffer;
+        ply_region_t *updated_region;
+        ply_list_t *areas_to_flush;
+        ply_list_node_t *node;
+        ply_pixel_buffer_t *pixel_buffer;
 
-  assert (backend != NULL);
-  assert (&backend->head == head);
+        assert (backend != NULL);
+        assert (&backend->head == head);
 
-  if (!backend->is_active)
-    return;
+        if (!backend->is_active)
+                return;
 
-  if (backend->terminal != NULL)
-    {
-      ply_terminal_set_mode (backend->terminal, PLY_TERMINAL_MODE_GRAPHICS);
-      ply_terminal_set_unbuffered_input (backend->terminal);
-    }
-  pixel_buffer = head->pixel_buffer;
-  updated_region = ply_pixel_buffer_get_updated_areas (pixel_buffer);
-  areas_to_flush = ply_region_get_sorted_rectangle_list (updated_region);
+        if (backend->terminal != NULL) {
+                ply_terminal_set_mode (backend->terminal, PLY_TERMINAL_MODE_GRAPHICS);
+                ply_terminal_set_unbuffered_input (backend->terminal);
+        }
+        pixel_buffer = head->pixel_buffer;
+        updated_region = ply_pixel_buffer_get_updated_areas (pixel_buffer);
+        areas_to_flush = ply_region_get_sorted_rectangle_list (updated_region);
 
-  node = ply_list_get_first_node (areas_to_flush);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_rectangle_t *area_to_flush;
+        node = ply_list_get_first_node (areas_to_flush);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_rectangle_t *area_to_flush;
 
-      area_to_flush = (ply_rectangle_t *) ply_list_node_get_data (node);
+                area_to_flush = (ply_rectangle_t *) ply_list_node_get_data (node);
 
-      next_node = ply_list_get_next_node (areas_to_flush, node);
+                next_node = ply_list_get_next_node (areas_to_flush, node);
 
-      backend->flush_area (backend, head, area_to_flush);
+                backend->flush_area (backend, head, area_to_flush);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  ply_region_clear (updated_region);
+        ply_region_clear (updated_region);
 }
 
 static void
 ply_renderer_head_redraw (ply_renderer_backend_t *backend,
                           ply_renderer_head_t    *head)
 {
-  ply_region_t *region;
+        ply_region_t *region;
 
-  region = ply_pixel_buffer_get_updated_areas (head->pixel_buffer);
+        region = ply_pixel_buffer_get_updated_areas (head->pixel_buffer);
 
-  ply_region_add_rectangle (region, &head->area);
+        ply_region_add_rectangle (region, &head->area);
 
-  flush_head (backend, head);
+        flush_head (backend, head);
 }
 
 static ply_list_t *
 get_heads (ply_renderer_backend_t *backend)
 {
-  return backend->heads;
+        return backend->heads;
 }
 
 static ply_pixel_buffer_t *
 get_buffer_for_head (ply_renderer_backend_t *backend,
                      ply_renderer_head_t    *head)
 {
+        if (head != &backend->head)
+                return NULL;
 
-  if (head != &backend->head)
-    return NULL;
-
-  return backend->head.pixel_buffer;
+        return backend->head.pixel_buffer;
 }
 
 static bool
 has_input_source (ply_renderer_backend_t      *backend,
                   ply_renderer_input_source_t *input_source)
 {
-  return input_source == &backend->input_source;
+        return input_source == &backend->input_source;
 }
 
 static ply_renderer_input_source_t *
 get_input_source (ply_renderer_backend_t *backend)
 {
-  return &backend->input_source;
+        return &backend->input_source;
 }
 
 static void
 on_key_event (ply_renderer_input_source_t *input_source,
               int                          terminal_fd)
-{ 
-  ply_buffer_append_from_fd (input_source->key_buffer,
-                             terminal_fd);
-
-  if (input_source->handler != NULL)
-    input_source->handler (input_source->user_data, input_source->key_buffer, input_source);
+{
+        ply_buffer_append_from_fd (input_source->key_buffer,
+                                   terminal_fd);
 
+        if (input_source->handler != NULL)
+                input_source->handler (input_source->user_data, input_source->key_buffer, input_source);
 }
 
 static void
 on_input_source_disconnected (ply_renderer_input_source_t *input_source)
 {
-  ply_trace ("input source disconnected, reopening");
-  open_input_source (input_source->backend, input_source);
+        ply_trace ("input source disconnected, reopening");
+        open_input_source (input_source->backend, input_source);
 }
 
 static bool
 open_input_source (ply_renderer_backend_t      *backend,
                    ply_renderer_input_source_t *input_source)
 {
-  int terminal_fd;
+        int terminal_fd;
 
-  assert (backend != NULL);
-  assert (has_input_source (backend, input_source));
+        assert (backend != NULL);
+        assert (has_input_source (backend, input_source));
 
-  if (backend->terminal == NULL)
-    return false;
+        if (backend->terminal == NULL)
+                return false;
 
-  terminal_fd = ply_terminal_get_fd (backend->terminal);
+        terminal_fd = ply_terminal_get_fd (backend->terminal);
 
-  input_source->backend = backend;
-  input_source->terminal_input_watch = ply_event_loop_watch_fd (backend->loop, terminal_fd, PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                                                                (ply_event_handler_t) on_key_event,
-                                                                (ply_event_handler_t) on_input_source_disconnected,
-                                                                input_source);
-  return true;
+        input_source->backend = backend;
+        input_source->terminal_input_watch = ply_event_loop_watch_fd (backend->loop, terminal_fd, PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                                                      (ply_event_handler_t) on_key_event,
+                                                                      (ply_event_handler_t) on_input_source_disconnected,
+                                                                      input_source);
+        return true;
 }
 
 static void
-set_handler_for_input_source (ply_renderer_backend_t      *backend,
-                              ply_renderer_input_source_t *input_source,
+set_handler_for_input_source (ply_renderer_backend_t             *backend,
+                              ply_renderer_input_source_t        *input_source,
                               ply_renderer_input_source_handler_t handler,
-                              void                        *user_data)
+                              void                               *user_data)
 {
-  assert (backend != NULL);
-  assert (has_input_source (backend, input_source));
+        assert (backend != NULL);
+        assert (has_input_source (backend, input_source));
 
-  input_source->handler = handler;
-  input_source->user_data = user_data;
+        input_source->handler = handler;
+        input_source->user_data = user_data;
 }
 
 static void
 close_input_source (ply_renderer_backend_t      *backend,
                     ply_renderer_input_source_t *input_source)
 {
-  assert (backend != NULL);
-  assert (has_input_source (backend, input_source));
+        assert (backend != NULL);
+        assert (has_input_source (backend, input_source));
 
-  if (backend->terminal == NULL)
-    return;
+        if (backend->terminal == NULL)
+                return;
 
-  ply_event_loop_stop_watching_fd (backend->loop, input_source->terminal_input_watch);
-  input_source->terminal_input_watch = NULL;
-  input_source->backend = NULL;
+        ply_event_loop_stop_watching_fd (backend->loop, input_source->terminal_input_watch);
+        input_source->terminal_input_watch = NULL;
+        input_source->backend = NULL;
 }
 
 ply_renderer_plugin_interface_t *
 ply_renderer_backend_get_interface (void)
 {
-  static ply_renderer_plugin_interface_t plugin_interface =
-    {
-      .create_backend = create_backend,
-      .destroy_backend = destroy_backend,
-      .open_device = open_device,
-      .close_device = close_device,
-      .query_device = query_device,
-      .map_to_device = map_to_device,
-      .unmap_from_device = unmap_from_device,
-      .activate = activate,
-      .deactivate = deactivate,
-      .flush_head = flush_head,
-      .get_heads = get_heads,
-      .get_buffer_for_head = get_buffer_for_head,
-      .get_input_source = get_input_source,
-      .open_input_source = open_input_source,
-      .set_handler_for_input_source = set_handler_for_input_source,
-      .close_input_source = close_input_source
-    };
-
-  return &plugin_interface;
+        static ply_renderer_plugin_interface_t plugin_interface =
+        {
+                .create_backend               = create_backend,
+                .destroy_backend              = destroy_backend,
+                .open_device                  = open_device,
+                .close_device                 = close_device,
+                .query_device                 = query_device,
+                .map_to_device                = map_to_device,
+                .unmap_from_device            = unmap_from_device,
+                .activate                     = activate,
+                .deactivate                   = deactivate,
+                .flush_head                   = flush_head,
+                .get_heads                    = get_heads,
+                .get_buffer_for_head          = get_buffer_for_head,
+                .get_input_source             = get_input_source,
+                .open_input_source            = open_input_source,
+                .set_handler_for_input_source = set_handler_for_input_source,
+                .close_input_source           = close_input_source
+        };
+
+        return &plugin_interface;
 }
 /* vim: set ts=4 sw=4 et ai ci cino={.5s,^-2,+.5s,t0,g0,e-2,n-2,p2s,(0,=.5s,:.5s */
diff --git a/src/plugins/renderers/x11/plugin.c b/src/plugins/renderers/x11/plugin.c
index 54980ee..ef9d2ba 100644
--- a/src/plugins/renderers/x11/plugin.c
+++ b/src/plugins/renderers/x11/plugin.c
@@ -62,31 +62,31 @@
 
 struct _ply_renderer_head
 {
-  ply_renderer_backend_t *backend;
-  ply_pixel_buffer_t     *pixel_buffer;
-  ply_rectangle_t         area;
-  GtkWidget              *window;
-  GdkPixmap              *pixmap;
-  cairo_surface_t        *image;
-  uint32_t                is_fullscreen : 1;
+        ply_renderer_backend_t *backend;
+        ply_pixel_buffer_t     *pixel_buffer;
+        ply_rectangle_t         area;
+        GtkWidget              *window;
+        GdkPixmap              *pixmap;
+        cairo_surface_t        *image;
+        uint32_t                is_fullscreen : 1;
 };
 
 struct _ply_renderer_input_source
 {
-  ply_buffer_t                        *key_buffer;
-  ply_renderer_input_source_handler_t  handler;
-  void                                *user_data;
+        ply_buffer_t                       *key_buffer;
+        ply_renderer_input_source_handler_t handler;
+        void                               *user_data;
 };
 
 struct _ply_renderer_backend
 {
-  ply_event_loop_t            *loop;
-  ply_renderer_input_source_t  input_source;
-  ply_list_t                  *heads;
+        ply_event_loop_t           *loop;
+        ply_renderer_input_source_t input_source;
+        ply_list_t                 *heads;
 
-  ply_fd_watch_t *display_watch;
+        ply_fd_watch_t             *display_watch;
 
-  uint32_t is_active : 1;
+        uint32_t                    is_active : 1;
 };
 
 ply_renderer_plugin_interface_t *ply_renderer_backend_get_interface (void);
@@ -104,150 +104,150 @@ static ply_renderer_backend_t *
 create_backend (const char     *device_name,
                 ply_terminal_t *terminal)
 {
-  ply_renderer_backend_t *backend;
+        ply_renderer_backend_t *backend;
 
-  backend = calloc (1, sizeof (ply_renderer_backend_t));
+        backend = calloc (1, sizeof(ply_renderer_backend_t));
 
-  backend->loop = ply_event_loop_get_default ();
-  backend->heads = ply_list_new ();
-  backend->input_source.key_buffer = ply_buffer_new ();
+        backend->loop = ply_event_loop_get_default ();
+        backend->heads = ply_list_new ();
+        backend->input_source.key_buffer = ply_buffer_new ();
 
-  return backend;
+        return backend;
 }
 
 static void
 destroy_backend (ply_renderer_backend_t *backend)
 {
-  ply_list_node_t *node;
-  node = ply_list_get_first_node (backend->heads);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_renderer_head_t *head;
-
-      head = (ply_renderer_head_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (backend->heads, node);
-
-      free (head);
-      node = next_node;
-    }
-
-  ply_list_free (backend->heads);
-  ply_buffer_free (backend->input_source.key_buffer);
-  free (backend);
+        ply_list_node_t *node;
+
+        node = ply_list_get_first_node (backend->heads);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_renderer_head_t *head;
+
+                head = (ply_renderer_head_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (backend->heads, node);
+
+                free (head);
+                node = next_node;
+        }
+
+        ply_list_free (backend->heads);
+        ply_buffer_free (backend->input_source.key_buffer);
+        free (backend);
 }
 
 static void
 on_display_event (ply_renderer_backend_t *backend)
 {
-  while (gtk_events_pending ())
-    gtk_main_iteration ();
+        while (gtk_events_pending ()) {
+                gtk_main_iteration ();
+        }
 }
 
 static bool
 open_device (ply_renderer_backend_t *backend)
 {
-  Display *display;
-  int display_fd;
-
-  if (!gtk_init_check (0, NULL))
-    return false;
-
-  display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  display_fd = ConnectionNumber (display);
-  backend->display_watch = ply_event_loop_watch_fd (backend->loop,
-                                                    display_fd,
-                                                    PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                                                    (ply_event_handler_t) on_display_event,
-                                                    NULL,
-                                                    backend);
-
-  return true;
+        Display *display;
+        int display_fd;
+
+        if (!gtk_init_check (0, NULL))
+                return false;
+
+        display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+        display_fd = ConnectionNumber (display);
+        backend->display_watch = ply_event_loop_watch_fd (backend->loop,
+                                                          display_fd,
+                                                          PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                                          (ply_event_handler_t) on_display_event,
+                                                          NULL,
+                                                          backend);
+
+        return true;
 }
 
 static void
 close_device (ply_renderer_backend_t *backend)
 {
-  ply_event_loop_stop_watching_fd (backend->loop, backend->display_watch);
-  backend->display_watch = NULL;
-  return;
+        ply_event_loop_stop_watching_fd (backend->loop, backend->display_watch);
+        backend->display_watch = NULL;
+        return;
 }
 
 static void
 create_fake_multi_head_setup (ply_renderer_backend_t *backend)
 {
-  ply_renderer_head_t *head;
-
-  head = calloc (1, sizeof (ply_renderer_head_t));
-
-  head->backend = backend;
-  head->area.x = 0;
-  head->area.y = 0;
-  head->area.width = 800;         /* FIXME hardcoded */
-  head->area.height = 600;
-  head->pixmap = gdk_pixmap_new (NULL,
-                                 head->area.width,
-                                 head->area.height,
-                                 24);
-  head->pixel_buffer = ply_pixel_buffer_new (head->area.width, head->area.height);
-
-  ply_list_append_data (backend->heads, head);
-
-  head = calloc (1, sizeof (ply_renderer_head_t));
-
-  head->backend = backend;
-  head->area.x = 800;
-  head->area.y = 0;
-  head->area.width = 640;         /* FIXME hardcoded */
-  head->area.height = 480;
-  head->pixmap = gdk_pixmap_new (NULL,
-                                 head->area.width,
-                                 head->area.height,
-                                 24);
-  head->pixel_buffer = ply_pixel_buffer_new (head->area.width, head->area.height);
-
-  ply_list_append_data (backend->heads, head);
+        ply_renderer_head_t *head;
+
+        head = calloc (1, sizeof(ply_renderer_head_t));
+
+        head->backend = backend;
+        head->area.x = 0;
+        head->area.y = 0;
+        head->area.width = 800;   /* FIXME hardcoded */
+        head->area.height = 600;
+        head->pixmap = gdk_pixmap_new (NULL,
+                                       head->area.width,
+                                       head->area.height,
+                                       24);
+        head->pixel_buffer = ply_pixel_buffer_new (head->area.width, head->area.height);
+
+        ply_list_append_data (backend->heads, head);
+
+        head = calloc (1, sizeof(ply_renderer_head_t));
+
+        head->backend = backend;
+        head->area.x = 800;
+        head->area.y = 0;
+        head->area.width = 640;   /* FIXME hardcoded */
+        head->area.height = 480;
+        head->pixmap = gdk_pixmap_new (NULL,
+                                       head->area.width,
+                                       head->area.height,
+                                       24);
+        head->pixel_buffer = ply_pixel_buffer_new (head->area.width, head->area.height);
+
+        ply_list_append_data (backend->heads, head);
 }
 
 static void
 create_fullscreen_single_head_setup (ply_renderer_backend_t *backend)
 {
-  ply_renderer_head_t *head;
-  GdkRectangle         monitor_geometry;
-
-  gdk_screen_get_monitor_geometry (gdk_screen_get_default (), 0, &monitor_geometry);
-
-  head = calloc (1, sizeof (ply_renderer_head_t));
-
-  head->backend = backend;
-  head->area.x = monitor_geometry.x;
-  head->area.y = monitor_geometry.y;
-  head->area.width = monitor_geometry.width;
-  head->area.height = monitor_geometry.height;
-  head->is_fullscreen = true;
-  head->pixmap = gdk_pixmap_new (NULL,
-                                 head->area.width,
-                                 head->area.height,
-                                 24);
-  head->pixel_buffer = ply_pixel_buffer_new (head->area.width, head->area.height);
-
-  ply_list_append_data (backend->heads, head);
+        ply_renderer_head_t *head;
+        GdkRectangle monitor_geometry;
+
+        gdk_screen_get_monitor_geometry (gdk_screen_get_default (), 0, &monitor_geometry);
+
+        head = calloc (1, sizeof(ply_renderer_head_t));
+
+        head->backend = backend;
+        head->area.x = monitor_geometry.x;
+        head->area.y = monitor_geometry.y;
+        head->area.width = monitor_geometry.width;
+        head->area.height = monitor_geometry.height;
+        head->is_fullscreen = true;
+        head->pixmap = gdk_pixmap_new (NULL,
+                                       head->area.width,
+                                       head->area.height,
+                                       24);
+        head->pixel_buffer = ply_pixel_buffer_new (head->area.width, head->area.height);
+
+        ply_list_append_data (backend->heads, head);
 }
 
 static bool
 query_device (ply_renderer_backend_t *backend)
 {
-  assert (backend != NULL);
+        assert (backend != NULL);
 
-  if (ply_list_get_first_node (backend->heads) == NULL)
-    {
-      if (getenv ("PLY_CREATE_FAKE_MULTI_HEAD_SETUP") != NULL)
-        create_fake_multi_head_setup (backend);
-      else
-        create_fullscreen_single_head_setup (backend);
-    }
+        if (ply_list_get_first_node (backend->heads) == NULL) {
+                if (getenv ("PLY_CREATE_FAKE_MULTI_HEAD_SETUP") != NULL)
+                        create_fake_multi_head_setup (backend);
+                else
+                        create_fullscreen_single_head_setup (backend);
+        }
 
-  return true;
+        return true;
 }
 
 static gboolean
@@ -255,105 +255,104 @@ on_window_destroy (GtkWidget *widget,
                    GdkEvent  *event,
                    gpointer   user_data)
 {
-  return TRUE;
+        return TRUE;
 }
 
 static bool
 map_to_device (ply_renderer_backend_t *backend)
 {
-  ply_list_node_t *node;
-  assert (backend != NULL);
-
-  node = ply_list_get_first_node (backend->heads);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_renderer_head_t *head;
-      uint32_t *shadow_buffer;
-
-      head = (ply_renderer_head_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (backend->heads, node);
-
-      if (head->window == NULL)
-        {
-          head->window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-          gtk_window_set_resizable (GTK_WINDOW (head->window), FALSE);
-          gtk_widget_set_size_request (head->window,
-                                       head->area.width,
-                                       head->area.height);
-          shadow_buffer = ply_pixel_buffer_get_argb32_data (head->pixel_buffer);
-          head->image = cairo_image_surface_create_for_data ((unsigned char *) shadow_buffer,
-                                                             CAIRO_FORMAT_ARGB32,
-                                                             head->area.width, head->area.height,
-                                                             head->area.width * 4);
-          gtk_widget_set_app_paintable (head->window, TRUE);
-          gtk_widget_show_all (head->window);
-          gdk_window_set_back_pixmap (head->window->window, head->pixmap, FALSE);
-          gdk_window_set_decorations (head->window->window, GDK_DECOR_BORDER);
-          gtk_window_move (GTK_WINDOW (head->window), head->area.x, head->area.y);
-
-          gtk_window_set_type_hint (GTK_WINDOW (head->window), GDK_WINDOW_TYPE_HINT_DOCK);
-
-          if (head->is_fullscreen)
-            gtk_window_fullscreen (GTK_WINDOW (head->window));
-
-          gtk_widget_add_events (head->window, GDK_BUTTON1_MOTION_MASK);
-
-          g_signal_connect (head->window, "motion-notify-event",
-                            G_CALLBACK (on_motion_notify_event),
-                            head);
-          g_signal_connect (head->window, "key-press-event",
-                            G_CALLBACK (on_key_event),
-                            &backend->input_source);
-          g_signal_connect (head->window, "delete-event",
-                            G_CALLBACK (on_window_destroy),
-                            NULL);
+        ply_list_node_t *node;
+
+        assert (backend != NULL);
+
+        node = ply_list_get_first_node (backend->heads);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_renderer_head_t *head;
+                uint32_t *shadow_buffer;
+
+                head = (ply_renderer_head_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (backend->heads, node);
+
+                if (head->window == NULL) {
+                        head->window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+                        gtk_window_set_resizable (GTK_WINDOW (head->window), FALSE);
+                        gtk_widget_set_size_request (head->window,
+                                                     head->area.width,
+                                                     head->area.height);
+                        shadow_buffer = ply_pixel_buffer_get_argb32_data (head->pixel_buffer);
+                        head->image = cairo_image_surface_create_for_data ((unsigned char *) shadow_buffer,
+                                                                           CAIRO_FORMAT_ARGB32,
+                                                                           head->area.width, head->area.height,
+                                                                           head->area.width * 4);
+                        gtk_widget_set_app_paintable (head->window, TRUE);
+                        gtk_widget_show_all (head->window);
+                        gdk_window_set_back_pixmap (head->window->window, head->pixmap, FALSE);
+                        gdk_window_set_decorations (head->window->window, GDK_DECOR_BORDER);
+                        gtk_window_move (GTK_WINDOW (head->window), head->area.x, head->area.y);
+
+                        gtk_window_set_type_hint (GTK_WINDOW (head->window), GDK_WINDOW_TYPE_HINT_DOCK);
+
+                        if (head->is_fullscreen)
+                                gtk_window_fullscreen (GTK_WINDOW (head->window));
+
+                        gtk_widget_add_events (head->window, GDK_BUTTON1_MOTION_MASK);
+
+                        g_signal_connect (head->window, "motion-notify-event",
+                                          G_CALLBACK (on_motion_notify_event),
+                                          head);
+                        g_signal_connect (head->window, "key-press-event",
+                                          G_CALLBACK (on_key_event),
+                                          &backend->input_source);
+                        g_signal_connect (head->window, "delete-event",
+                                          G_CALLBACK (on_window_destroy),
+                                          NULL);
+                }
+                ply_renderer_head_redraw (backend, head);
+                node = next_node;
         }
-      ply_renderer_head_redraw (backend, head);
-      node = next_node;
-    }
 
-  backend->is_active = true;
+        backend->is_active = true;
 
-  return true;
+        return true;
 }
 
 static void
 unmap_from_device (ply_renderer_backend_t *backend)
 {
-  ply_list_node_t *node;
-  assert (backend != NULL);
-
-  node = ply_list_get_first_node (backend->heads);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_renderer_head_t *head;
-
-      head = (ply_renderer_head_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (backend->heads, node);
-
-      gtk_widget_destroy (head->window);
-      head->window = NULL;
-      ply_pixel_buffer_free (head->pixel_buffer);
-      head->pixel_buffer = NULL;
-      cairo_surface_destroy (head->image);
-      head->image = NULL;
-
-      node = next_node;
-    }
+        ply_list_node_t *node;
+
+        assert (backend != NULL);
+
+        node = ply_list_get_first_node (backend->heads);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_renderer_head_t *head;
+
+                head = (ply_renderer_head_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (backend->heads, node);
+
+                gtk_widget_destroy (head->window);
+                head->window = NULL;
+                ply_pixel_buffer_free (head->pixel_buffer);
+                head->pixel_buffer = NULL;
+                cairo_surface_destroy (head->image);
+                head->image = NULL;
+
+                node = next_node;
+        }
 }
 
 static void
 activate (ply_renderer_backend_t *backend)
 {
-  backend->is_active = true;
+        backend->is_active = true;
 }
 
 static void
 deactivate (ply_renderer_backend_t *backend)
 {
-  backend->is_active = false;
+        backend->is_active = false;
 }
 
 static void
@@ -362,115 +361,114 @@ flush_area_to_device (ply_renderer_backend_t *backend,
                       ply_rectangle_t        *area_to_flush,
                       cairo_t                *cr)
 {
-  cairo_save (cr);
-  cairo_rectangle (cr,
-                   area_to_flush->x,
-                   area_to_flush->y,
-                   area_to_flush->width,
-                   area_to_flush->height);
-  cairo_clip (cr);
-
-  cairo_set_source_surface (cr, head->image, 0, 0);
-  cairo_paint (cr);
-  cairo_restore (cr);
+        cairo_save (cr);
+        cairo_rectangle (cr,
+                         area_to_flush->x,
+                         area_to_flush->y,
+                         area_to_flush->width,
+                         area_to_flush->height);
+        cairo_clip (cr);
+
+        cairo_set_source_surface (cr, head->image, 0, 0);
+        cairo_paint (cr);
+        cairo_restore (cr);
 }
 
 static void
 flush_head (ply_renderer_backend_t *backend,
             ply_renderer_head_t    *head)
 {
-  ply_region_t *updated_region;
-  ply_list_t *areas_to_flush;
-  ply_list_node_t *node;
-  ply_pixel_buffer_t *pixel_buffer;
-  cairo_t *cr;
-
-  assert (backend != NULL);
-
-  if (!backend->is_active)
-    return;
-
-  pixel_buffer = head->pixel_buffer;
-  updated_region = ply_pixel_buffer_get_updated_areas (pixel_buffer);
-  areas_to_flush = ply_region_get_sorted_rectangle_list (updated_region);
-
-  cr = gdk_cairo_create (head->pixmap);
-
-  node = ply_list_get_first_node (areas_to_flush);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      ply_rectangle_t *area_to_flush;
-
-      area_to_flush = (ply_rectangle_t *) ply_list_node_get_data (node);
-
-      next_node = ply_list_get_next_node (areas_to_flush, node);
-
-      flush_area_to_device (backend, head, area_to_flush, cr);
-      gdk_window_clear_area (head->window->window,
-                             area_to_flush->x,
-                             area_to_flush->y,
-                             area_to_flush->width,
-                             area_to_flush->height);
-      node = next_node;
-    }
-  ply_region_clear (updated_region);
-
-  cairo_destroy (cr);
-
-  /* Force read-back to make sure plymouth isn't saturating the
-   * X server with requests
-   */
-  g_object_unref (gdk_drawable_get_image (GDK_DRAWABLE (head->pixmap),
-                  0, 0, 1, 1));
+        ply_region_t *updated_region;
+        ply_list_t *areas_to_flush;
+        ply_list_node_t *node;
+        ply_pixel_buffer_t *pixel_buffer;
+        cairo_t *cr;
+
+        assert (backend != NULL);
+
+        if (!backend->is_active)
+                return;
+
+        pixel_buffer = head->pixel_buffer;
+        updated_region = ply_pixel_buffer_get_updated_areas (pixel_buffer);
+        areas_to_flush = ply_region_get_sorted_rectangle_list (updated_region);
+
+        cr = gdk_cairo_create (head->pixmap);
+
+        node = ply_list_get_first_node (areas_to_flush);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                ply_rectangle_t *area_to_flush;
+
+                area_to_flush = (ply_rectangle_t *) ply_list_node_get_data (node);
+
+                next_node = ply_list_get_next_node (areas_to_flush, node);
+
+                flush_area_to_device (backend, head, area_to_flush, cr);
+                gdk_window_clear_area (head->window->window,
+                                       area_to_flush->x,
+                                       area_to_flush->y,
+                                       area_to_flush->width,
+                                       area_to_flush->height);
+                node = next_node;
+        }
+        ply_region_clear (updated_region);
+
+        cairo_destroy (cr);
+
+        /* Force read-back to make sure plymouth isn't saturating the
+         * X server with requests
+         */
+        g_object_unref (gdk_drawable_get_image (GDK_DRAWABLE (head->pixmap),
+                                                0, 0, 1, 1));
 }
 
 static void
 ply_renderer_head_redraw (ply_renderer_backend_t *backend,
                           ply_renderer_head_t    *head)
 {
-  ply_region_t *region;
-  ply_rectangle_t area;
+        ply_region_t *region;
+        ply_rectangle_t area;
 
-  area.x = 0;
-  area.y = 0;
-  area.width = head->area.width;
-  area.height = head->area.height;
+        area.x = 0;
+        area.y = 0;
+        area.width = head->area.width;
+        area.height = head->area.height;
 
-  region = ply_pixel_buffer_get_updated_areas (head->pixel_buffer);
+        region = ply_pixel_buffer_get_updated_areas (head->pixel_buffer);
 
-  ply_region_add_rectangle (region, &area);
+        ply_region_add_rectangle (region, &area);
 
-  flush_head (backend, head);
+        flush_head (backend, head);
 }
 
 static ply_list_t *
 get_heads (ply_renderer_backend_t *backend)
 {
-  return backend->heads;
+        return backend->heads;
 }
 
 static ply_pixel_buffer_t *
 get_buffer_for_head (ply_renderer_backend_t *backend,
                      ply_renderer_head_t    *head)
 {
-  if (head->backend != backend)
-    return NULL;
+        if (head->backend != backend)
+                return NULL;
 
-  return head->pixel_buffer;
+        return head->pixel_buffer;
 }
 
 static bool
 has_input_source (ply_renderer_backend_t      *backend,
                   ply_renderer_input_source_t *input_source)
 {
-  return input_source == &backend->input_source;
+        return input_source == &backend->input_source;
 }
 
 static ply_renderer_input_source_t *
 get_input_source (ply_renderer_backend_t *backend)
 {
-  return &backend->input_source;
+        return &backend->input_source;
 }
 
 static gboolean
@@ -478,11 +476,11 @@ on_motion_notify_event (GtkWidget      *widget,
                         GdkEventMotion *event,
                         gpointer        user_data)
 {
-  ply_renderer_head_t *head = user_data;
+        ply_renderer_head_t *head = user_data;
 
-  gtk_window_begin_move_drag (GTK_WINDOW (head->window), 1,
-                              event->x_root, event->y_root, event->time);
-  return FALSE;
+        gtk_window_begin_move_drag (GTK_WINDOW (head->window), 1,
+                                    event->x_root, event->y_root, event->time);
+        return FALSE;
 }
 
 static gboolean
@@ -490,95 +488,88 @@ on_key_event (GtkWidget   *widget,
               GdkEventKey *event,
               gpointer     user_data)
 {
-  ply_renderer_input_source_t *input_source = user_data;
-
-  if (event->keyval == GDK_Return)          /* Enter */
-    {
-      ply_buffer_append_bytes (input_source->key_buffer, "\n", 1);
-    }
-  else if (event->keyval == GDK_Escape)     /* Esc */
-    {
-      ply_buffer_append_bytes (input_source->key_buffer, "\033", 1);
-    }
-  else if (event->keyval == GDK_BackSpace)  /* Backspace */
-    {
-      ply_buffer_append_bytes (input_source->key_buffer, "\177", 1);
-    }
-  else
-    {
-      gchar bytes[7];
-      int byte_count;
-      guint32 unichar;
-      unichar = gdk_keyval_to_unicode (event->keyval);
-      byte_count = g_unichar_to_utf8 (unichar, bytes);
-      if (bytes[0] != 0)
-        ply_buffer_append_bytes (input_source->key_buffer, bytes, byte_count);
-      else
-        ply_trace ("unknown GDK key: 0x%X \"%s\"",
-                   event->keyval,
-                   gdk_keyval_name (event->keyval));
-    }
-
-  if (input_source->handler != NULL)
-    input_source->handler (input_source->user_data, input_source->key_buffer, input_source);
-  return FALSE;
+        ply_renderer_input_source_t *input_source = user_data;
+
+        if (event->keyval == GDK_Return) {           /* Enter */
+                ply_buffer_append_bytes (input_source->key_buffer, "\n", 1);
+        } else if (event->keyval == GDK_Escape) {    /* Esc */
+                ply_buffer_append_bytes (input_source->key_buffer, "\033", 1);
+        } else if (event->keyval == GDK_BackSpace) { /* Backspace */
+                ply_buffer_append_bytes (input_source->key_buffer, "\177", 1);
+        } else {
+                gchar bytes[7];
+                int byte_count;
+                guint32 unichar;
+                unichar = gdk_keyval_to_unicode (event->keyval);
+                byte_count = g_unichar_to_utf8 (unichar, bytes);
+                if (bytes[0] != 0)
+                        ply_buffer_append_bytes (input_source->key_buffer, bytes, byte_count);
+                else
+                        ply_trace ("unknown GDK key: 0x%X \"%s\"",
+                                   event->keyval,
+                                   gdk_keyval_name (event->keyval));
+        }
+
+        if (input_source->handler != NULL)
+                input_source->handler (input_source->user_data, input_source->key_buffer, input_source);
+        return FALSE;
 }
 
 static bool
 open_input_source (ply_renderer_backend_t      *backend,
                    ply_renderer_input_source_t *input_source)
 {
+        assert (backend != NULL);
+        assert (has_input_source (backend, input_source));
 
-  assert (backend != NULL);
-  assert (has_input_source (backend, input_source));
-
-  return true;
+        return true;
 }
 
 static void
-set_handler_for_input_source (ply_renderer_backend_t      *backend,
-                              ply_renderer_input_source_t *input_source,
+set_handler_for_input_source (ply_renderer_backend_t             *backend,
+                              ply_renderer_input_source_t        *input_source,
                               ply_renderer_input_source_handler_t handler,
-                              void                        *user_data)
+                              void                               *user_data)
 {
-  assert (backend != NULL);
-  assert (has_input_source (backend, input_source));
+        assert (backend != NULL);
+        assert (has_input_source (backend, input_source));
 
-  input_source->handler = handler;
-  input_source->user_data = user_data;
+        input_source->handler = handler;
+        input_source->user_data = user_data;
 }
 
 static void
 close_input_source (ply_renderer_backend_t      *backend,
                     ply_renderer_input_source_t *input_source)
 {
-  assert (backend != NULL);
-  assert (has_input_source (backend, input_source));
+        assert (backend != NULL);
+        assert (has_input_source (backend, input_source));
 }
 
 ply_renderer_plugin_interface_t *
 ply_renderer_backend_get_interface (void)
 {
-  static ply_renderer_plugin_interface_t plugin_interface =
-    {
-      .create_backend = create_backend,
-      .destroy_backend = destroy_backend,
-      .open_device = open_device,
-      .close_device = close_device,
-      .query_device = query_device,
-      .map_to_device = map_to_device,
-      .unmap_from_device = unmap_from_device,
-      .activate = activate,
-      .deactivate = deactivate,
-      .flush_head = flush_head,
-      .get_heads = get_heads,
-      .get_buffer_for_head = get_buffer_for_head,
-      .get_input_source = get_input_source,
-      .open_input_source = open_input_source,
-      .set_handler_for_input_source = set_handler_for_input_source,
-      .close_input_source = close_input_source
-    };
-  return &plugin_interface;
+        static ply_renderer_plugin_interface_t plugin_interface =
+        {
+                .create_backend               = create_backend,
+                .destroy_backend              = destroy_backend,
+                .open_device                  = open_device,
+                .close_device                 = close_device,
+                .query_device                 = query_device,
+                .map_to_device                = map_to_device,
+                .unmap_from_device            = unmap_from_device,
+                .activate                     = activate,
+                .deactivate                   = deactivate,
+                .flush_head                   = flush_head,
+                .get_heads                    = get_heads,
+                .get_buffer_for_head          = get_buffer_for_head,
+                .get_input_source             = get_input_source,
+                .open_input_source            = open_input_source,
+                .set_handler_for_input_source = set_handler_for_input_source,
+                .close_input_source           = close_input_source
+        };
+
+        return &plugin_interface;
 }
 
 /* vim: set ts=4 sw=4 et ai ci cino={.5s,^-2,+.5s,t0,g0,e-2,n-2,p2s,(0,=.5s,:.5s */
diff --git a/src/plugins/splash/details/plugin.c b/src/plugins/splash/details/plugin.c
index aff2f1c..8e55d05 100644
--- a/src/plugins/splash/details/plugin.c
+++ b/src/plugins/splash/details/plugin.c
@@ -54,16 +54,17 @@
 
 #define CLEAR_LINE_SEQUENCE "\033[2K\r"
 
-typedef enum {
-   PLY_BOOT_SPLASH_DISPLAY_NORMAL,
-   PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
-   PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
+typedef enum
+{
+        PLY_BOOT_SPLASH_DISPLAY_NORMAL,
+        PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
+        PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
 } ply_boot_splash_display_type_t;
 
 typedef struct
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_text_display_t *display;
+        ply_boot_splash_plugin_t *plugin;
+        ply_text_display_t       *display;
 } view_t;
 
 ply_boot_splash_plugin_interface_t *ply_boot_splash_plugin_get_interface (void);
@@ -71,125 +72,121 @@ static void detach_from_event_loop (ply_boot_splash_plugin_t *plugin);
 
 struct _ply_boot_splash_plugin
 {
-  ply_event_loop_t *loop;
-  ply_boot_splash_mode_t mode;
-  ply_list_t *views;
-  ply_boot_splash_display_type_t state;
-  ply_list_t *messages;
-
+        ply_event_loop_t              *loop;
+        ply_boot_splash_mode_t         mode;
+        ply_list_t                    *views;
+        ply_boot_splash_display_type_t state;
+        ply_list_t                    *messages;
 };
 
 static view_t *
 view_new (ply_boot_splash_plugin_t *plugin,
-          ply_text_display_t      *display)
+          ply_text_display_t       *display)
 {
-  view_t *view;
+        view_t *view;
 
-  view = calloc (1, sizeof (view_t));
-  view->plugin = plugin;
-  view->display = display;
+        view = calloc (1, sizeof(view_t));
+        view->plugin = plugin;
+        view->display = display;
 
-  return view;
+        return view;
 }
 
 static void
 view_free (view_t *view)
 {
-  free (view);
+        free (view);
 }
 
 static void
 free_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_free (view);
-      ply_list_remove_node (plugin->views, node);
+                view_free (view);
+                ply_list_remove_node (plugin->views, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  ply_list_free (plugin->views);
-  plugin->views = NULL;
+        ply_list_free (plugin->views);
+        plugin->views = NULL;
 }
 
 static void
 free_messages (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->messages);
+        node = ply_list_get_first_node (plugin->messages);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      char *message;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                char *message;
 
-      message = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->messages, node);
+                message = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->messages, node);
 
-      free (message);
-      ply_list_remove_node (plugin->messages, node);
+                free (message);
+                ply_list_remove_node (plugin->messages, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  ply_list_free (plugin->messages);
-  plugin->messages = NULL;
+        ply_list_free (plugin->messages);
+        plugin->messages = NULL;
 }
 
 static ply_boot_splash_plugin_t *
 create_plugin (ply_key_file_t *key_file)
 {
-  ply_boot_splash_plugin_t *plugin;
+        ply_boot_splash_plugin_t *plugin;
 
-  ply_trace ("creating plugin");
+        ply_trace ("creating plugin");
 
-  plugin = calloc (1, sizeof (ply_boot_splash_plugin_t));
-  plugin->views = ply_list_new ();
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
-  plugin->messages = ply_list_new ();
-  return plugin;
+        plugin = calloc (1, sizeof(ply_boot_splash_plugin_t));
+        plugin->views = ply_list_new ();
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
+        plugin->messages = ply_list_new ();
+        return plugin;
 }
 
 static void
 destroy_plugin (ply_boot_splash_plugin_t *plugin)
 {
-  ply_trace ("destroying plugin");
+        ply_trace ("destroying plugin");
 
-  if (plugin == NULL)
-    return;
+        if (plugin == NULL)
+                return;
 
-  if (plugin->loop != NULL)
-    {
-      ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
+        if (plugin->loop != NULL) {
+                ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
 
-  free_messages (plugin);
-  free_views (plugin);
+        free_messages (plugin);
+        free_views (plugin);
 
-  free (plugin);
+        free (plugin);
 }
 
 static void
 detach_from_event_loop (ply_boot_splash_plugin_t *plugin)
 {
-  plugin->loop = NULL;
+        plugin->loop = NULL;
 
-  ply_trace ("detaching from event loop");
+        ply_trace ("detaching from event loop");
 }
 
 static void
@@ -197,10 +194,10 @@ view_write (view_t     *view,
             const char *text,
             size_t      number_of_bytes)
 {
-  ply_terminal_t *terminal;
+        ply_terminal_t *terminal;
 
-  terminal = ply_text_display_get_terminal (view->display);
-  ply_terminal_write (terminal, "%.*s", (int) number_of_bytes, text);
+        terminal = ply_text_display_get_terminal (view->display);
+        ply_terminal_write (terminal, "%.*s", (int) number_of_bytes, text);
 }
 
 static void
@@ -208,67 +205,63 @@ write_on_views (ply_boot_splash_plugin_t *plugin,
                 const char               *text,
                 size_t                    number_of_bytes)
 {
-  ply_list_node_t *node;
-
-  if (number_of_bytes == 0)
-    return;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
+        if (number_of_bytes == 0)
+                return;
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view_write (view, text, number_of_bytes);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      node = next_node;
-    }
+                view_write (view, text, number_of_bytes);
 
+                node = next_node;
+        }
 }
 
 static void
 add_text_display (ply_boot_splash_plugin_t *plugin,
                   ply_text_display_t       *display)
 {
-  view_t *view;
-  ply_terminal_t *terminal;
+        view_t *view;
+        ply_terminal_t *terminal;
 
-  view = view_new (plugin, display);
+        view = view_new (plugin, display);
 
-  terminal = ply_text_display_get_terminal (view->display);
-  if (ply_terminal_open (terminal))
-    ply_terminal_activate_vt (terminal);
+        terminal = ply_text_display_get_terminal (view->display);
+        if (ply_terminal_open (terminal))
+                ply_terminal_activate_vt (terminal);
 
-  ply_list_append_data (plugin->views, view);
+        ply_list_append_data (plugin->views, view);
 }
 
 static void
 remove_text_display (ply_boot_splash_plugin_t *plugin,
                      ply_text_display_t       *display)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      view_t *view;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                view_t *view;
+                ply_list_node_t *next_node;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view->display == display)
-        {
-          ply_list_remove_node (plugin->views, node);
-          return;
-        }
+                if (view->display == display) {
+                        ply_list_remove_node (plugin->views, node);
+                        return;
+                }
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static bool
@@ -277,34 +270,33 @@ show_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_buffer_t             *boot_buffer,
                     ply_boot_splash_mode_t    mode)
 {
-  size_t size;
+        size_t size;
 
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  plugin->loop = loop;
-  plugin->mode = mode;
+        plugin->loop = loop;
+        plugin->mode = mode;
 
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
-                                 detach_from_event_loop,
-                                 plugin);
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       detach_from_event_loop,
+                                       plugin);
 
-  if (boot_buffer)
-    {
-      size = ply_buffer_get_size (boot_buffer);
+        if (boot_buffer) {
+                size = ply_buffer_get_size (boot_buffer);
 
-      write_on_views (plugin, ply_buffer_get_bytes (boot_buffer), size);
-    }
+                write_on_views (plugin, ply_buffer_get_bytes (boot_buffer), size);
+        }
 
-  return true;
+        return true;
 }
 
 static void
 update_status (ply_boot_splash_plugin_t *plugin,
                const char               *status)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  ply_trace ("status update");
+        ply_trace ("status update");
 }
 
 static void
@@ -312,51 +304,50 @@ on_boot_output (ply_boot_splash_plugin_t *plugin,
                 const char               *output,
                 size_t                    size)
 {
-  ply_trace ("writing '%s' to all views (%d bytes)",
-             output, (int) size);
-  write_on_views (plugin, output, size);
+        ply_trace ("writing '%s' to all views (%d bytes)",
+                   output, (int) size);
+        write_on_views (plugin, output, size);
 }
 
 static void
 hide_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_event_loop_t         *loop)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  ply_trace ("hiding splash screen");
+        ply_trace ("hiding splash screen");
 
-  ply_event_loop_stop_watching_for_exit (plugin->loop,
-                                         (ply_event_loop_exit_handler_t)
-                                         detach_from_event_loop,
-                                         plugin);
-  detach_from_event_loop (plugin);
+        ply_event_loop_stop_watching_for_exit (plugin->loop,
+                                               (ply_event_loop_exit_handler_t)
+                                               detach_from_event_loop,
+                                               plugin);
+        detach_from_event_loop (plugin);
 }
 
 static void
 display_normal (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    write_on_views (plugin, "\r\n", strlen ("\r\n"));
+        if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                write_on_views (plugin, "\r\n", strlen ("\r\n"));
 
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
 
-  node = ply_list_get_first_node (plugin->messages);
-  while (node != NULL)
-    {
-      const char *message;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (plugin->messages);
+        while (node != NULL) {
+                const char *message;
+                ply_list_node_t *next_node;
 
-      message = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->messages, node);
+                message = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->messages, node);
 
-      write_on_views (plugin, message, strlen (message));
-      write_on_views (plugin, "\r\n", strlen ("\r\n"));
+                write_on_views (plugin, message, strlen (message));
+                write_on_views (plugin, "\r\n", strlen ("\r\n"));
 
-      ply_list_remove_node (plugin->messages, node);
-      node = next_node;
-    }
+                ply_list_remove_node (plugin->messages, node);
+                node = next_node;
+        }
 }
 
 static void
@@ -364,28 +355,30 @@ display_password (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   int                       bullets)
 {
-  int i;
-  if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY)
-    write_on_views (plugin, "\r\n", strlen ("\r\n"));
-  else
-    write_on_views (plugin,
-                    CLEAR_LINE_SEQUENCE,
-                    strlen (CLEAR_LINE_SEQUENCE));
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
-
-  if (prompt)
-    write_on_views (plugin,
-                    prompt,
-                    strlen (prompt));
-  else
-    write_on_views (plugin,
-                    "Password",
-                    strlen ("Password"));
-
-  write_on_views (plugin, ":", strlen (":"));
-
-  for (i = 0; i < bullets; i++)
-    write_on_views (plugin, "*", strlen ("*"));
+        int i;
+
+        if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY)
+                write_on_views (plugin, "\r\n", strlen ("\r\n"));
+        else
+                write_on_views (plugin,
+                                CLEAR_LINE_SEQUENCE,
+                                strlen (CLEAR_LINE_SEQUENCE));
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
+
+        if (prompt)
+                write_on_views (plugin,
+                                prompt,
+                                strlen (prompt));
+        else
+                write_on_views (plugin,
+                                "Password",
+                                strlen ("Password"));
+
+        write_on_views (plugin, ":", strlen (":"));
+
+        for (i = 0; i < bullets; i++) {
+                write_on_views (plugin, "*", strlen ("*"));
+        }
 }
 
 static void
@@ -393,54 +386,53 @@ display_question (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   const char               *entry_text)
 {
-  if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY)
-    write_on_views (plugin, "\r\n", strlen ("\r\n"));
-  else
-    write_on_views (plugin,
-                    CLEAR_LINE_SEQUENCE,
-                    strlen (CLEAR_LINE_SEQUENCE));
-
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY;
-  if (prompt)
-    write_on_views (plugin, prompt, strlen (prompt));
-
-  write_on_views (plugin, ":", strlen (":"));
-  write_on_views (plugin, entry_text, strlen (entry_text));
+        if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY)
+                write_on_views (plugin, "\r\n", strlen ("\r\n"));
+        else
+                write_on_views (plugin,
+                                CLEAR_LINE_SEQUENCE,
+                                strlen (CLEAR_LINE_SEQUENCE));
+
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY;
+        if (prompt)
+                write_on_views (plugin, prompt, strlen (prompt));
+
+        write_on_views (plugin, ":", strlen (":"));
+        write_on_views (plugin, entry_text, strlen (entry_text));
 }
 
 static void
 display_message (ply_boot_splash_plugin_t *plugin,
                  const char               *message)
 {
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    {
-      write_on_views (plugin, message, strlen (message));
-      write_on_views (plugin, "\r\n", strlen ("\r\n"));
-    }
-  else
-    ply_list_append_data (plugin->messages, strdup (message));
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL) {
+                write_on_views (plugin, message, strlen (message));
+                write_on_views (plugin, "\r\n", strlen ("\r\n"));
+        } else {
+                ply_list_append_data (plugin->messages, strdup (message));
+        }
 }
 
 ply_boot_splash_plugin_interface_t *
 ply_boot_splash_plugin_get_interface (void)
 {
-  static ply_boot_splash_plugin_interface_t plugin_interface =
-    {
-      .create_plugin = create_plugin,
-      .destroy_plugin = destroy_plugin,
-      .add_text_display = add_text_display,
-      .remove_text_display = remove_text_display,
-      .show_splash_screen = show_splash_screen,
-      .update_status = update_status,
-      .on_boot_output = on_boot_output,
-      .hide_splash_screen = hide_splash_screen,
-      .display_normal = display_normal,
-      .display_password = display_password,
-      .display_question = display_question,      
-      .display_message = display_message,
-    };
-
-  return &plugin_interface;
+        static ply_boot_splash_plugin_interface_t plugin_interface =
+        {
+                .create_plugin       = create_plugin,
+                .destroy_plugin      = destroy_plugin,
+                .add_text_display    = add_text_display,
+                .remove_text_display = remove_text_display,
+                .show_splash_screen  = show_splash_screen,
+                .update_status       = update_status,
+                .on_boot_output      = on_boot_output,
+                .hide_splash_screen  = hide_splash_screen,
+                .display_normal      = display_normal,
+                .display_password    = display_password,
+                .display_question    = display_question,
+                .display_message     = display_message,
+        };
+
+        return &plugin_interface;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/plugins/splash/fade-throbber/plugin.c b/src/plugins/splash/fade-throbber/plugin.c
index 4af6cae..1643b87 100644
--- a/src/plugins/splash/fade-throbber/plugin.c
+++ b/src/plugins/splash/fade-throbber/plugin.c
@@ -60,49 +60,50 @@
 #endif
 
 
-typedef enum {
-   PLY_BOOT_SPLASH_DISPLAY_NORMAL,
-   PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
-   PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
+typedef enum
+{
+        PLY_BOOT_SPLASH_DISPLAY_NORMAL,
+        PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
+        PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
 } ply_boot_splash_display_type_t;
 
 typedef struct
 {
-  unsigned int x;
-  unsigned int y;
-  double start_time;
-  double speed;
-  double opacity;
+        unsigned int x;
+        unsigned int y;
+        double       start_time;
+        double       speed;
+        double       opacity;
 } star_t;
 
 typedef struct
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_pixel_display_t *display;
-  ply_list_t *stars;
-  ply_entry_t *entry;
-  ply_label_t *label;
-  ply_label_t *message_label;
-  ply_rectangle_t lock_area;
-  double logo_opacity;
+        ply_boot_splash_plugin_t *plugin;
+        ply_pixel_display_t      *display;
+        ply_list_t               *stars;
+        ply_entry_t              *entry;
+        ply_label_t              *label;
+        ply_label_t              *message_label;
+        ply_rectangle_t           lock_area;
+        double                    logo_opacity;
 } view_t;
 
 struct _ply_boot_splash_plugin
 {
-  ply_event_loop_t *loop;
-  ply_boot_splash_mode_t mode;
-  ply_image_t *logo_image;
-  ply_image_t *star_image;
-  ply_image_t *lock_image;
-  char *image_dir;
-  ply_list_t *views;
+        ply_event_loop_t              *loop;
+        ply_boot_splash_mode_t         mode;
+        ply_image_t                   *logo_image;
+        ply_image_t                   *star_image;
+        ply_image_t                   *lock_image;
+        char                          *image_dir;
+        ply_list_t                    *views;
 
-  ply_boot_splash_display_type_t state;
+        ply_boot_splash_display_type_t state;
 
-  double start_time;
-  double now;
+        double                         start_time;
+        double                         now;
 
-  uint32_t is_animating : 1;
+        uint32_t                       is_animating : 1;
 };
 
 ply_boot_splash_plugin_interface_t *ply_boot_splash_plugin_get_interface (void);
@@ -111,84 +112,82 @@ static void
 view_show_prompt (view_t     *view,
                   const char *prompt)
 {
-  ply_boot_splash_plugin_t *plugin;
-  int x, y;
-  int entry_width, entry_height;
+        ply_boot_splash_plugin_t *plugin;
+        int x, y;
+        int entry_width, entry_height;
 
-  assert (view != NULL);
+        assert (view != NULL);
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  if (ply_entry_is_hidden (view->entry))
-    {
-      unsigned long screen_width, screen_height;
+        if (ply_entry_is_hidden (view->entry)) {
+                unsigned long screen_width, screen_height;
 
-      screen_width = ply_pixel_display_get_width (view->display);
-      screen_height = ply_pixel_display_get_height (view->display);
+                screen_width = ply_pixel_display_get_width (view->display);
+                screen_height = ply_pixel_display_get_height (view->display);
 
-      view->lock_area.width = ply_image_get_width (plugin->lock_image);
-      view->lock_area.height = ply_image_get_height (plugin->lock_image);
+                view->lock_area.width = ply_image_get_width (plugin->lock_image);
+                view->lock_area.height = ply_image_get_height (plugin->lock_image);
 
-      entry_width = ply_entry_get_width (view->entry);
-      entry_height = ply_entry_get_height (view->entry);
+                entry_width = ply_entry_get_width (view->entry);
+                entry_height = ply_entry_get_height (view->entry);
 
-      x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0 + view->lock_area.width;
-      y = screen_height / 2.0 - entry_height / 2.0;
+                x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0 + view->lock_area.width;
+                y = screen_height / 2.0 - entry_height / 2.0;
 
-      view->lock_area.x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0;
-      view->lock_area.y = screen_height / 2.0 - view->lock_area.height / 2.0;
+                view->lock_area.x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0;
+                view->lock_area.y = screen_height / 2.0 - view->lock_area.height / 2.0;
 
-      ply_entry_show (view->entry, plugin->loop, view->display, x, y);
-    }
+                ply_entry_show (view->entry, plugin->loop, view->display, x, y);
+        }
 
-  if (prompt != NULL)
-    {
-      ply_label_set_text (view->label, prompt);
+        if (prompt != NULL) {
+                ply_label_set_text (view->label, prompt);
 
-      x = view->lock_area.x;
-      y = view->lock_area.y + view->lock_area.height;
+                x = view->lock_area.x;
+                y = view->lock_area.y + view->lock_area.height;
 
-      ply_label_show (view->label, view->display, x, y);
-    }
+                ply_label_show (view->label, view->display, x, y);
+        }
 }
 
 static void
 view_hide_prompt (view_t *view)
 {
-  assert (view != NULL);
+        assert (view != NULL);
 
-  ply_entry_hide (view->entry);
-  ply_label_hide (view->label);
+        ply_entry_hide (view->entry);
+        ply_label_hide (view->label);
 }
 
 
 static ply_boot_splash_plugin_t *
 create_plugin (ply_key_file_t *key_file)
 {
-  ply_boot_splash_plugin_t *plugin;
-  char *image_dir, *image_path;
+        ply_boot_splash_plugin_t *plugin;
+        char *image_dir, *image_path;
 
-  srand ((int) ply_get_timestamp ());
-  plugin = calloc (1, sizeof (ply_boot_splash_plugin_t));
-  plugin->start_time = 0.0;
+        srand ((int) ply_get_timestamp ());
+        plugin = calloc (1, sizeof(ply_boot_splash_plugin_t));
+        plugin->start_time = 0.0;
 
-  plugin->logo_image = ply_image_new (PLYMOUTH_LOGO_FILE);
-  image_dir = ply_key_file_get_value (key_file, "fade-throbber", "ImageDir");
+        plugin->logo_image = ply_image_new (PLYMOUTH_LOGO_FILE);
+        image_dir = ply_key_file_get_value (key_file, "fade-throbber", "ImageDir");
 
-  asprintf (&image_path, "%s/star.png", image_dir);
-  plugin->star_image = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/star.png", image_dir);
+        plugin->star_image = ply_image_new (image_path);
+        free (image_path);
 
-  asprintf (&image_path, "%s/lock.png", image_dir);
-  plugin->lock_image = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/lock.png", image_dir);
+        plugin->lock_image = ply_image_new (image_path);
+        free (image_path);
 
-  plugin->image_dir = image_dir;
+        plugin->image_dir = image_dir;
 
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
-  plugin->views = ply_list_new ();
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
+        plugin->views = ply_list_new ();
 
-  return plugin;
+        return plugin;
 }
 
 static star_t *
@@ -196,46 +195,45 @@ star_new (int    x,
           int    y,
           double speed)
 {
-  star_t *star;
+        star_t *star;
 
-  star = calloc (1, sizeof (star_t));
-  star->x = x;
-  star->y = y;
-  star->speed = speed;
-  star->start_time = ply_get_timestamp ();
+        star = calloc (1, sizeof(star_t));
+        star->x = x;
+        star->y = y;
+        star->speed = speed;
+        star->start_time = ply_get_timestamp ();
 
-  return star;
+        return star;
 }
 
 static void
 star_free (star_t *star)
 {
-  free (star);
+        free (star);
 }
 
 static void
 free_stars (view_t *view)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (view != NULL);
+        assert (view != NULL);
 
-  node = ply_list_get_first_node (view->stars);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      star_t *star;
+        node = ply_list_get_first_node (view->stars);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                star_t *star;
 
-      star = (star_t *) ply_list_node_get_data (node);
+                star = (star_t *) ply_list_node_get_data (node);
 
-      next_node = ply_list_get_next_node (view->stars, node);
+                next_node = ply_list_get_next_node (view->stars, node);
 
-      star_free (star);
-      node = next_node;
-    }
+                star_free (star);
+                node = next_node;
+        }
 
-  ply_list_free (view->stars);
-  view->stars = NULL;
+        ply_list_free (view->stars);
+        view->stars = NULL;
 }
 
 static void detach_from_event_loop (ply_boot_splash_plugin_t *plugin);
@@ -244,380 +242,368 @@ static view_t *
 view_new (ply_boot_splash_plugin_t *plugin,
           ply_pixel_display_t      *display)
 {
-  view_t *view;
+        view_t *view;
 
-  view = calloc (1, sizeof (view_t));
-  view->plugin = plugin;
-  view->display = display;
+        view = calloc (1, sizeof(view_t));
+        view->plugin = plugin;
+        view->display = display;
 
-  view->entry = ply_entry_new (plugin->image_dir);
-  view->stars = ply_list_new ();
-  view->label = ply_label_new ();
+        view->entry = ply_entry_new (plugin->image_dir);
+        view->stars = ply_list_new ();
+        view->label = ply_label_new ();
 
-  view->message_label = ply_label_new ();
+        view->message_label = ply_label_new ();
 
-  return view;
+        return view;
 }
 
 static void
 view_free (view_t *view)
 {
+        ply_entry_free (view->entry);
+        ply_label_free (view->message_label);
+        free_stars (view);
 
-  ply_entry_free (view->entry);
-  ply_label_free (view->message_label);
-  free_stars (view);
-
-  free (view);
+        free (view);
 }
 
 static bool
 view_load (view_t *view)
 {
-  ply_trace ("loading entry");
-  if (!ply_entry_load (view->entry))
-    return false;
+        ply_trace ("loading entry");
+        if (!ply_entry_load (view->entry))
+                return false;
 
-  return true;
+        return true;
 }
 
 static bool
 load_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
-  bool view_loaded;
+        ply_list_node_t *node;
+        bool view_loaded;
 
-  view_loaded = false;
-  node = ply_list_get_first_node (plugin->views);
+        view_loaded = false;
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view_load (view))
-        view_loaded = true;
+                if (view_load (view))
+                        view_loaded = true;
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  return view_loaded;
+        return view_loaded;
 }
 
 static void
 view_redraw (view_t *view)
 {
-  unsigned long screen_width, screen_height;
+        unsigned long screen_width, screen_height;
 
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
 
-  ply_pixel_display_draw_area (view->display, 0, 0,
-                               screen_width, screen_height);
+        ply_pixel_display_draw_area (view->display, 0, 0,
+                                     screen_width, screen_height);
 }
 
 static void
 redraw_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_redraw (view);
+                view_redraw (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 pause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_pixel_display_pause_updates (view->display);
+                ply_pixel_display_pause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 unpause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_pixel_display_unpause_updates (view->display);
+                ply_pixel_display_unpause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 free_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_free (view);
-      ply_list_remove_node (plugin->views, node);
+                view_free (view);
+                ply_list_remove_node (plugin->views, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  ply_list_free (plugin->views);
-  plugin->views = NULL;
+        ply_list_free (plugin->views);
+        plugin->views = NULL;
 }
 
 static void
 destroy_plugin (ply_boot_splash_plugin_t *plugin)
 {
-  if (plugin == NULL)
-    return;
-
-  if (plugin->loop != NULL)
-    {
-      ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
-
-  free_views (plugin);
-  ply_image_free (plugin->logo_image);
-  ply_image_free (plugin->star_image);
-  ply_image_free (plugin->lock_image);
-  free (plugin);
+        if (plugin == NULL)
+                return;
+
+        if (plugin->loop != NULL) {
+                ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
+
+        free_views (plugin);
+        ply_image_free (plugin->logo_image);
+        ply_image_free (plugin->star_image);
+        ply_image_free (plugin->lock_image);
+        free (plugin);
 }
 
 static void
-view_animate_at_time (view_t  *view,
-                      double   time)
+view_animate_at_time (view_t *view,
+                      double  time)
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_list_node_t *node;
-  double logo_opacity;
-  long logo_x, logo_y;
-  long logo_width, logo_height;
-  unsigned long screen_width, screen_height;
-  unsigned long star_width, star_height;
+        ply_boot_splash_plugin_t *plugin;
+        ply_list_node_t *node;
+        double logo_opacity;
+        long logo_x, logo_y;
+        long logo_width, logo_height;
+        unsigned long screen_width, screen_height;
+        unsigned long star_width, star_height;
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  logo_width = ply_image_get_width (plugin->logo_image);
-  logo_height = ply_image_get_height (plugin->logo_image);
+        logo_width = ply_image_get_width (plugin->logo_image);
+        logo_height = ply_image_get_height (plugin->logo_image);
 
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
 
-  logo_x = (screen_width / 2) - (logo_width / 2);
-  logo_y = (screen_height / 2) - (logo_height / 2);
+        logo_x = (screen_width / 2) - (logo_width / 2);
+        logo_y = (screen_height / 2) - (logo_height / 2);
 
-  star_width = ply_image_get_width (plugin->star_image);
-  star_height = ply_image_get_height (plugin->star_image);
+        star_width = ply_image_get_width (plugin->star_image);
+        star_height = ply_image_get_height (plugin->star_image);
 
-  node = ply_list_get_first_node (view->stars);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      star_t *star;
+        node = ply_list_get_first_node (view->stars);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                star_t *star;
 
-      star = (star_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (view->stars, node);
+                star = (star_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (view->stars, node);
 
-      star->opacity = .5 * sin (((plugin->now - star->start_time) / star->speed) * (2 * M_PI)) + .5;
-      star->opacity = CLAMP (star->opacity, 0, 1.0);
+                star->opacity = .5 * sin (((plugin->now - star->start_time) / star->speed) * (2 * M_PI)) + .5;
+                star->opacity = CLAMP (star->opacity, 0, 1.0);
 
-      ply_pixel_display_draw_area (view->display,
-                                   star->x, star->y,
-                                   star_width, star_height);
-      node = next_node;
-    }
+                ply_pixel_display_draw_area (view->display,
+                                             star->x, star->y,
+                                             star_width, star_height);
+                node = next_node;
+        }
 
-  logo_opacity = .5 * sin ((time / 5) * (2 * M_PI)) + .8;
-  logo_opacity = CLAMP (logo_opacity, 0, 1.0);
+        logo_opacity = .5 * sin ((time / 5) * (2 * M_PI)) + .8;
+        logo_opacity = CLAMP (logo_opacity, 0, 1.0);
 
-  if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
-    logo_opacity = 1.0;
+        if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
+                logo_opacity = 1.0;
 
-  if (fabs (logo_opacity - view->logo_opacity) <= DBL_MIN)
-    return;
+        if (fabs (logo_opacity - view->logo_opacity) <= DBL_MIN)
+                return;
 
-  view->logo_opacity = logo_opacity;
+        view->logo_opacity = logo_opacity;
 
-  ply_pixel_display_draw_area (view->display,
-                               logo_x, logo_y,
-                               logo_width, logo_height);
+        ply_pixel_display_draw_area (view->display,
+                                     logo_x, logo_y,
+                                     logo_width, logo_height);
 }
 
 static void
 animate_at_time (ply_boot_splash_plugin_t *plugin,
                  double                    time)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_animate_at_time (view, time);
+                view_animate_at_time (view, time);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 on_timeout (ply_boot_splash_plugin_t *plugin)
 {
-  double sleep_time;
-
-  plugin->now = ply_get_timestamp ();
-
-  /* The choice below is between
-   *
-   * 1) keeping a constant animation speed, and dropping
-   * frames when necessary
-   * 2) showing every frame, but slowing down the animation
-   * when a frame would be otherwise dropped.
-   *
-   * It turns out there are parts of boot up where the animation
-   * can get sort of choppy.  By default we choose 2, since the
-   * nature of this animation means it looks natural even when it
-   * is slowed down
-   */
+        double sleep_time;
+
+        plugin->now = ply_get_timestamp ();
+
+        /* The choice below is between
+         *
+         * 1) keeping a constant animation speed, and dropping
+         * frames when necessary
+         * 2) showing every frame, but slowing down the animation
+         * when a frame would be otherwise dropped.
+         *
+         * It turns out there are parts of boot up where the animation
+         * can get sort of choppy.  By default we choose 2, since the
+         * nature of this animation means it looks natural even when it
+         * is slowed down
+         */
 #ifdef REAL_TIME_ANIMATION
-  animate_at_time (plugin,
-                   plugin->now - plugin->start_time);
+        animate_at_time (plugin,
+                         plugin->now - plugin->start_time);
 #else
-  static double time = 0.0;
-  time += 1.0 / FRAMES_PER_SECOND;
-  animate_at_time (plugin, time);
+        static double time = 0.0;
+        time += 1.0 / FRAMES_PER_SECOND;
+        animate_at_time (plugin, time);
 #endif
 
-  sleep_time = 1.0 / FRAMES_PER_SECOND;
-  sleep_time = MAX (sleep_time - (ply_get_timestamp () - plugin->now),
-                    0.005);
+        sleep_time = 1.0 / FRAMES_PER_SECOND;
+        sleep_time = MAX (sleep_time - (ply_get_timestamp () - plugin->now),
+                          0.005);
 
-  ply_event_loop_watch_for_timeout (plugin->loop, 
-                                    sleep_time,
-                                    (ply_event_loop_timeout_handler_t)
-                                    on_timeout, plugin);
+        ply_event_loop_watch_for_timeout (plugin->loop,
+                                          sleep_time,
+                                          (ply_event_loop_timeout_handler_t)
+                                          on_timeout, plugin);
 }
 
 static void
 view_start_animation (view_t *view)
 {
-  unsigned long screen_width, screen_height;
-
-  assert (view != NULL);
+        unsigned long screen_width, screen_height;
 
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
+        assert (view != NULL);
 
-  ply_pixel_display_draw_area (view->display, 0, 0,
-                               screen_width, screen_height);
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
 
+        ply_pixel_display_draw_area (view->display, 0, 0,
+                                     screen_width, screen_height);
 }
 
 static void
 start_animation (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (plugin->is_animating)
-     return;
+        if (plugin->is_animating)
+                return;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_start_animation (view);
+                view_start_animation (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
+
+        plugin->is_animating = true;
+
+        plugin->start_time = ply_get_timestamp ();
+        animate_at_time (plugin, plugin->start_time);
 
-  plugin->is_animating = true;
-  
-  plugin->start_time = ply_get_timestamp ();
-  animate_at_time (plugin, plugin->start_time);
-  
-  if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
-    return;
+        if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
+                return;
 
-  ply_event_loop_watch_for_timeout (plugin->loop, 
-                                    1.0 / FRAMES_PER_SECOND,
-                                    (ply_event_loop_timeout_handler_t)
-                                    on_timeout, plugin);
+        ply_event_loop_watch_for_timeout (plugin->loop,
+                                          1.0 / FRAMES_PER_SECOND,
+                                          (ply_event_loop_timeout_handler_t)
+                                          on_timeout, plugin);
 }
 
 static void
 stop_animation (ply_boot_splash_plugin_t *plugin)
 {
-  assert (plugin != NULL);
-  assert (plugin->loop != NULL);
+        assert (plugin != NULL);
+        assert (plugin->loop != NULL);
 
-  if (!plugin->is_animating)
-     return;
+        if (!plugin->is_animating)
+                return;
 
-  plugin->is_animating = false;
+        plugin->is_animating = false;
 
-  if (plugin->loop != NULL)
-    {
-      ply_event_loop_stop_watching_for_timeout (plugin->loop,
-                                                (ply_event_loop_timeout_handler_t)
-                                                on_timeout, plugin);
-    }
-  redraw_views (plugin);
+        if (plugin->loop != NULL) {
+                ply_event_loop_stop_watching_for_timeout (plugin->loop,
+                                                          (ply_event_loop_timeout_handler_t)
+                                                          on_timeout, plugin);
+        }
+        redraw_views (plugin);
 }
 
 static void
 detach_from_event_loop (ply_boot_splash_plugin_t *plugin)
 {
-  plugin->loop = NULL;
+        plugin->loop = NULL;
 }
 
 static void
@@ -628,16 +614,16 @@ draw_background (view_t             *view,
                  int                 width,
                  int                 height)
 {
-  ply_rectangle_t area;
+        ply_rectangle_t area;
 
-  area.x = x;
-  area.y = y;
-  area.width = width;
-  area.height = height;
+        area.x = x;
+        area.y = y;
+        area.width = width;
+        area.height = height;
 
-  ply_pixel_buffer_fill_with_gradient (pixel_buffer, &area,
-                                       PLYMOUTH_BACKGROUND_START_COLOR,
-                                       PLYMOUTH_BACKGROUND_END_COLOR);
+        ply_pixel_buffer_fill_with_gradient (pixel_buffer, &area,
+                                             PLYMOUTH_BACKGROUND_START_COLOR,
+                                             PLYMOUTH_BACKGROUND_END_COLOR);
 }
 
 static void
@@ -648,54 +634,53 @@ draw_normal_view (view_t             *view,
                   int                 width,
                   int                 height)
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_list_node_t *node;
-  ply_rectangle_t logo_area;
-  ply_rectangle_t star_area;
-  uint32_t *logo_data, *star_data;
-  unsigned long screen_width, screen_height;
-
-  plugin = view->plugin;
-
-  if (!plugin->is_animating)
-    return;
-
-  logo_area.width = ply_image_get_width (plugin->logo_image);
-  logo_area.height = ply_image_get_height (plugin->logo_image);
-  logo_data = ply_image_get_data (plugin->logo_image);
-
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
-
-  logo_area.x = (screen_width / 2) - (logo_area.width / 2);
-  logo_area.y = (screen_height / 2) - (logo_area.height / 2);
-
-  star_data = ply_image_get_data (plugin->star_image);
-  star_area.width = ply_image_get_width (plugin->star_image);
-  star_area.height = ply_image_get_height (plugin->star_image);
-
-  node = ply_list_get_first_node (view->stars);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      star_t *star;
-
-      star = (star_t *) ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (view->stars, node);
-
-      star_area.x = star->x;
-      star_area.y = star->y;
-      ply_pixel_buffer_fill_with_argb32_data_at_opacity (pixel_buffer,
-                                                         &star_area,
-                                                         star_data,
-                                                         star->opacity);
-      node = next_node;
-    }
-
-  ply_pixel_buffer_fill_with_argb32_data_at_opacity (pixel_buffer,
-                                                     &logo_area,
-                                                     logo_data,
-                                                     view->logo_opacity);
+        ply_boot_splash_plugin_t *plugin;
+        ply_list_node_t *node;
+        ply_rectangle_t logo_area;
+        ply_rectangle_t star_area;
+        uint32_t *logo_data, *star_data;
+        unsigned long screen_width, screen_height;
+
+        plugin = view->plugin;
+
+        if (!plugin->is_animating)
+                return;
+
+        logo_area.width = ply_image_get_width (plugin->logo_image);
+        logo_area.height = ply_image_get_height (plugin->logo_image);
+        logo_data = ply_image_get_data (plugin->logo_image);
+
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
+
+        logo_area.x = (screen_width / 2) - (logo_area.width / 2);
+        logo_area.y = (screen_height / 2) - (logo_area.height / 2);
+
+        star_data = ply_image_get_data (plugin->star_image);
+        star_area.width = ply_image_get_width (plugin->star_image);
+        star_area.height = ply_image_get_height (plugin->star_image);
+
+        node = ply_list_get_first_node (view->stars);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                star_t *star;
+
+                star = (star_t *) ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (view->stars, node);
+
+                star_area.x = star->x;
+                star_area.y = star->y;
+                ply_pixel_buffer_fill_with_argb32_data_at_opacity (pixel_buffer,
+                                                                   &star_area,
+                                                                   star_data,
+                                                                   star->opacity);
+                node = next_node;
+        }
+
+        ply_pixel_buffer_fill_with_argb32_data_at_opacity (pixel_buffer,
+                                                           &logo_area,
+                                                           logo_data,
+                                                           view->logo_opacity);
 }
 
 static void
@@ -706,89 +691,86 @@ draw_prompt_view (view_t             *view,
                   int                 width,
                   int                 height)
 {
-  ply_boot_splash_plugin_t *plugin;
-  uint32_t *lock_data;
-
-  plugin = view->plugin;
-
-  ply_entry_draw_area (view->entry,
-                       pixel_buffer,
-                       x, y, width, height);
-  ply_label_draw_area (view->label,
-                       pixel_buffer,
-                       x, y, width, height);
-
-  lock_data = ply_image_get_data (plugin->lock_image);
-  ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
-                                          &view->lock_area,
-                                          lock_data);
+        ply_boot_splash_plugin_t *plugin;
+        uint32_t *lock_data;
+
+        plugin = view->plugin;
+
+        ply_entry_draw_area (view->entry,
+                             pixel_buffer,
+                             x, y, width, height);
+        ply_label_draw_area (view->label,
+                             pixel_buffer,
+                             x, y, width, height);
+
+        lock_data = ply_image_get_data (plugin->lock_image);
+        ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
+                                                &view->lock_area,
+                                                lock_data);
 }
 
 static void
-on_draw (view_t                   *view,
-         ply_pixel_buffer_t       *pixel_buffer,
-         int                       x,
-         int                       y,
-         int                       width,
-         int                       height)
+on_draw (view_t             *view,
+         ply_pixel_buffer_t *pixel_buffer,
+         int                 x,
+         int                 y,
+         int                 width,
+         int                 height)
 {
-  ply_boot_splash_plugin_t *plugin;
+        ply_boot_splash_plugin_t *plugin;
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  draw_background (view, pixel_buffer, x, y, width, height);
+        draw_background (view, pixel_buffer, x, y, width, height);
 
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    draw_normal_view (view, pixel_buffer, x, y, width, height);
-  else
-    draw_prompt_view (view, pixel_buffer, x, y, width, height);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                draw_normal_view (view, pixel_buffer, x, y, width, height);
+        else
+                draw_prompt_view (view, pixel_buffer, x, y, width, height);
 
-  ply_label_draw_area (view->message_label,
-                       pixel_buffer,
-                       x, y, width, height);
+        ply_label_draw_area (view->message_label,
+                             pixel_buffer,
+                             x, y, width, height);
 }
 
 static void
 add_pixel_display (ply_boot_splash_plugin_t *plugin,
                    ply_pixel_display_t      *display)
 {
-  view_t *view;
+        view_t *view;
 
-  view = view_new (plugin, display);
+        view = view_new (plugin, display);
 
-  ply_pixel_display_set_draw_handler (view->display,
-                                      (ply_pixel_display_draw_handler_t)
-                                      on_draw, view);
+        ply_pixel_display_set_draw_handler (view->display,
+                                            (ply_pixel_display_draw_handler_t)
+                                            on_draw, view);
 
-  ply_list_append_data (plugin->views, view);
+        ply_list_append_data (plugin->views, view);
 }
 
 static void
 remove_pixel_display (ply_boot_splash_plugin_t *plugin,
                       ply_pixel_display_t      *display)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      view_t *view;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                view_t *view;
+                ply_list_node_t *next_node;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view->display == display)
-        {
+                if (view->display == display) {
+                        ply_pixel_display_set_draw_handler (view->display, NULL, NULL);
+                        view_free (view);
+                        ply_list_remove_node (plugin->views, node);
+                        return;
+                }
 
-          ply_pixel_display_set_draw_handler (view->display, NULL, NULL);
-          view_free (view);
-          ply_list_remove_node (plugin->views, node);
-          return;
+                node = next_node;
         }
-
-      node = next_node;
-    }
 }
 
 static bool
@@ -797,182 +779,175 @@ show_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_buffer_t             *boot_buffer,
                     ply_boot_splash_mode_t    mode)
 {
-  assert (plugin != NULL);
-  assert (plugin->logo_image != NULL);
+        assert (plugin != NULL);
+        assert (plugin->logo_image != NULL);
 
-  plugin->loop = loop;
-  plugin->mode = mode;
+        plugin->loop = loop;
+        plugin->mode = mode;
 
-  ply_trace ("loading logo image");
-  if (!ply_image_load (plugin->logo_image))
-    return false;
+        ply_trace ("loading logo image");
+        if (!ply_image_load (plugin->logo_image))
+                return false;
 
-  ply_trace ("loading star image");
-  if (!ply_image_load (plugin->star_image))
-    return false;
+        ply_trace ("loading star image");
+        if (!ply_image_load (plugin->star_image))
+                return false;
 
-  ply_trace ("loading lock image");
-  if (!ply_image_load (plugin->lock_image))
-    return false;
+        ply_trace ("loading lock image");
+        if (!ply_image_load (plugin->lock_image))
+                return false;
 
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
-                                 detach_from_event_loop,
-                                 plugin);
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       detach_from_event_loop,
+                                       plugin);
 
-  if (!load_views (plugin))
-    {
-      ply_trace ("couldn't load views");
-      return false;
-    }
+        if (!load_views (plugin)) {
+                ply_trace ("couldn't load views");
+                return false;
+        }
 
-  ply_trace ("starting boot animation");
-  start_animation (plugin);
+        ply_trace ("starting boot animation");
+        start_animation (plugin);
 
-  return true;
+        return true;
 }
 
 static void
 view_add_star (view_t *view)
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_rectangle_t logo_area;
-  star_t *star;
-  unsigned int x, y;
-  unsigned int width, height;
-  unsigned long screen_width, screen_height;
-  ply_list_node_t *node;
-
-  assert (view != NULL);
-
-  plugin = view->plugin;
-
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
-  width = ply_image_get_width (plugin->logo_image);
-  height = ply_image_get_height (plugin->logo_image);
-  logo_area.x = (screen_width / 2) - (width / 2);
-  logo_area.y = (screen_height / 2) - (height / 2);
-  logo_area.width = width;
-  logo_area.height = height;
-
-  width = ply_image_get_width (plugin->star_image);
-  height = ply_image_get_height (plugin->star_image);
-
-  node = NULL;
-  do
-    {
-      x = rand () % screen_width;
-      y = rand () % screen_height;
-
-      if ((x <= logo_area.x + logo_area.width)
-           && (x >= logo_area.x)
-          && (y >= logo_area.y)
-           && (y <= logo_area.y + logo_area.height))
-          continue;
-
-      if ((x + width >= logo_area.x)
-           && (x + width <= logo_area.x + logo_area.width)
-          && (y + height >= logo_area.y)
-           && (y + height <= logo_area.y + logo_area.height))
-          continue;
-
-      node = ply_list_get_first_node (view->stars);
-      while (node != NULL)
-        {
-          ply_list_node_t *next_node;
-
-          star = (star_t *) ply_list_node_get_data (node);
-          next_node = ply_list_get_next_node (view->stars, node);
-
-          if ((x <= star->x + width)
-               && (x >= star->x)
-              && (y >= star->y)
-               && (y <= star->y + height))
-              break;
-
-          if ((x + width >= star->x)
-               && (x + width <= star->x + width)
-              && (y + height >= star->y)
-               && (y + height <= star->y + height))
-              break;
-
-          node = next_node;
-        }
-
-    } while (node != NULL);
-
-  star = star_new (x, y, (double) ((rand () % 50) + 1));
-  ply_list_append_data (view->stars, star);
+        ply_boot_splash_plugin_t *plugin;
+        ply_rectangle_t logo_area;
+        star_t *star;
+        unsigned int x, y;
+        unsigned int width, height;
+        unsigned long screen_width, screen_height;
+        ply_list_node_t *node;
+
+        assert (view != NULL);
+
+        plugin = view->plugin;
+
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
+        width = ply_image_get_width (plugin->logo_image);
+        height = ply_image_get_height (plugin->logo_image);
+        logo_area.x = (screen_width / 2) - (width / 2);
+        logo_area.y = (screen_height / 2) - (height / 2);
+        logo_area.width = width;
+        logo_area.height = height;
+
+        width = ply_image_get_width (plugin->star_image);
+        height = ply_image_get_height (plugin->star_image);
+
+        node = NULL;
+        do {
+                x = rand () % screen_width;
+                y = rand () % screen_height;
+
+                if ((x <= logo_area.x + logo_area.width)
+                    && (x >= logo_area.x)
+                    && (y >= logo_area.y)
+                    && (y <= logo_area.y + logo_area.height))
+                        continue;
+
+                if ((x + width >= logo_area.x)
+                    && (x + width <= logo_area.x + logo_area.width)
+                    && (y + height >= logo_area.y)
+                    && (y + height <= logo_area.y + logo_area.height))
+                        continue;
+
+                node = ply_list_get_first_node (view->stars);
+                while (node != NULL) {
+                        ply_list_node_t *next_node;
+
+                        star = (star_t *) ply_list_node_get_data (node);
+                        next_node = ply_list_get_next_node (view->stars, node);
+
+                        if ((x <= star->x + width)
+                            && (x >= star->x)
+                            && (y >= star->y)
+                            && (y <= star->y + height))
+                                break;
+
+                        if ((x + width >= star->x)
+                            && (x + width <= star->x + width)
+                            && (y + height >= star->y)
+                            && (y + height <= star->y + height))
+                                break;
+
+                        node = next_node;
+                }
+        } while (node != NULL);
+
+        star = star_new (x, y, (double) ((rand () % 50) + 1));
+        ply_list_append_data (view->stars, star);
 }
 
 static void
 add_stars (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_add_star (view);
+                view_add_star (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 update_status (ply_boot_splash_plugin_t *plugin,
                const char               *status)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  add_stars (plugin);
+        add_stars (plugin);
 }
 
 static void
 show_message (ply_boot_splash_plugin_t *plugin,
               const char               *message)
 {
-  ply_trace ("Showing message '%s'", message);
-  ply_list_node_t *node;
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
-
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
-      ply_label_set_text (view->message_label, message);
-      ply_label_show (view->message_label, view->display, 10, 10);
-
-      ply_pixel_display_draw_area (view->display, 10, 10,
-                                   ply_label_get_width (view->message_label),
-                                   ply_label_get_height(view->message_label));
-      node = next_node;
-    }
+        ply_trace ("Showing message '%s'", message);
+        ply_list_node_t *node;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
+
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
+                ply_label_set_text (view->message_label, message);
+                ply_label_show (view->message_label, view->display, 10, 10);
+
+                ply_pixel_display_draw_area (view->display, 10, 10,
+                                             ply_label_get_width (view->message_label),
+                                             ply_label_get_height (view->message_label));
+                node = next_node;
+        }
 }
 
 static void
 hide_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_event_loop_t         *loop)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  if (plugin->loop != NULL)
-    {
-      stop_animation (plugin);
+        if (plugin->loop != NULL) {
+                stop_animation (plugin);
 
-      ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
+                ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
 }
 
 static void
@@ -980,22 +955,21 @@ show_password_prompt (ply_boot_splash_plugin_t *plugin,
                       const char               *text,
                       int                       number_of_bullets)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, text);
-      ply_entry_set_bullet_count (view->entry, number_of_bullets);
+                view_show_prompt (view, text);
+                ply_entry_set_bullet_count (view->entry, number_of_bullets);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
@@ -1003,55 +977,53 @@ show_prompt (ply_boot_splash_plugin_t *plugin,
              const char               *prompt,
              const char               *entry_text)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, prompt);
-      ply_entry_set_text (view->entry, entry_text);
+                view_show_prompt (view, prompt);
+                ply_entry_set_text (view->entry, entry_text);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 hide_prompt (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_hide_prompt (view);
+                view_hide_prompt (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 display_normal (ply_boot_splash_plugin_t *plugin)
 {
-  pause_views (plugin);
-  if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    hide_prompt (plugin);
-
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
-  start_animation (plugin);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        pause_views (plugin);
+        if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                hide_prompt (plugin);
+
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
+        start_animation (plugin);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
@@ -1059,14 +1031,14 @@ display_password (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   int                       bullets)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin);
-
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
-  show_password_prompt (plugin, prompt, bullets);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin);
+
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
+        show_password_prompt (plugin, prompt, bullets);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
@@ -1074,14 +1046,14 @@ display_question (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   const char               *entry_text)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin);
-
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY;
-  show_prompt (plugin, prompt, entry_text);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin);
+
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY;
+        show_prompt (plugin, prompt, entry_text);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 
@@ -1089,28 +1061,28 @@ static void
 display_message (ply_boot_splash_plugin_t *plugin,
                  const char               *message)
 {
-  show_message (plugin, message);
+        show_message (plugin, message);
 }
 
 ply_boot_splash_plugin_interface_t *
 ply_boot_splash_plugin_get_interface (void)
 {
-  static ply_boot_splash_plugin_interface_t plugin_interface =
-    {
-      .create_plugin = create_plugin,
-      .destroy_plugin = destroy_plugin,
-      .add_pixel_display = add_pixel_display,
-      .remove_pixel_display = remove_pixel_display,
-      .show_splash_screen = show_splash_screen,
-      .update_status = update_status,
-      .hide_splash_screen = hide_splash_screen,
-      .display_normal = display_normal,
-      .display_password = display_password,
-      .display_question = display_question,
-      .display_message = display_message,
-    };
-
-  return &plugin_interface;
+        static ply_boot_splash_plugin_interface_t plugin_interface =
+        {
+                .create_plugin        = create_plugin,
+                .destroy_plugin       = destroy_plugin,
+                .add_pixel_display    = add_pixel_display,
+                .remove_pixel_display = remove_pixel_display,
+                .show_splash_screen   = show_splash_screen,
+                .update_status        = update_status,
+                .hide_splash_screen   = hide_splash_screen,
+                .display_normal       = display_normal,
+                .display_password     = display_password,
+                .display_question     = display_question,
+                .display_message      = display_message,
+        };
+
+        return &plugin_interface;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/plugins/splash/script/plugin.c b/src/plugins/splash/script/plugin.c
index c5c1e16..a89c114 100644
--- a/src/plugins/splash/script/plugin.c
+++ b/src/plugins/splash/script/plugin.c
@@ -71,31 +71,31 @@
 
 struct _ply_boot_splash_plugin
 {
-  ply_event_loop_t      *loop;
-  ply_boot_splash_mode_t mode;
-  ply_list_t            *displays;
-  ply_keyboard_t        *keyboard;
+        ply_event_loop_t           *loop;
+        ply_boot_splash_mode_t      mode;
+        ply_list_t                 *displays;
+        ply_keyboard_t             *keyboard;
 
-  char *script_filename;
-  char *image_dir;
+        char                       *script_filename;
+        char                       *image_dir;
 
-  ply_list_t                    *script_env_vars;
-  script_op_t                   *script_main_op;
+        ply_list_t                 *script_env_vars;
+        script_op_t                *script_main_op;
 
-  script_state_t                *script_state;
-  script_lib_sprite_data_t      *script_sprite_lib;
-  script_lib_image_data_t       *script_image_lib;
-  script_lib_plymouth_data_t    *script_plymouth_lib;
-  script_lib_math_data_t        *script_math_lib;
-  script_lib_string_data_t      *script_string_lib;
+        script_state_t             *script_state;
+        script_lib_sprite_data_t   *script_sprite_lib;
+        script_lib_image_data_t    *script_image_lib;
+        script_lib_plymouth_data_t *script_plymouth_lib;
+        script_lib_math_data_t     *script_math_lib;
+        script_lib_string_data_t   *script_string_lib;
 
-  uint32_t is_animating : 1;
+        uint32_t                    is_animating : 1;
 };
 
-typedef struct 
+typedef struct
 {
-  char *key;
-  char *value;
+        char *key;
+        char *value;
 } script_env_var_t;
 
 static void detach_from_event_loop (ply_boot_splash_plugin_t *plugin);
@@ -108,134 +108,130 @@ static void on_keyboard_input (ply_boot_splash_plugin_t *plugin,
 static void
 pause_displays (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->displays);
-  while (node != NULL)
-    {
-      ply_pixel_display_t *display;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (plugin->displays);
+        while (node != NULL) {
+                ply_pixel_display_t *display;
+                ply_list_node_t *next_node;
 
-      display = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->displays, node);
+                display = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->displays, node);
 
-      ply_pixel_display_pause_updates (display);
+                ply_pixel_display_pause_updates (display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 unpause_displays (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->displays);
-  while (node != NULL)
-    {
-      ply_pixel_display_t *display;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (plugin->displays);
+        while (node != NULL) {
+                ply_pixel_display_t *display;
+                ply_list_node_t *next_node;
 
-      display = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->displays, node);
+                display = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->displays, node);
 
-      ply_pixel_display_unpause_updates (display);
+                ply_pixel_display_unpause_updates (display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
-static void 
+static void
 add_script_env_var (const char *group_name,
                     const char *key,
                     const char *value,
                     void       *user_data)
 {
-  ply_list_t *script_env_vars;
-  script_env_var_t *new_env_var;
+        ply_list_t *script_env_vars;
+        script_env_var_t *new_env_var;
 
-  if (strcmp (group_name, "script-env-vars") != 0)
-    return;
+        if (strcmp (group_name, "script-env-vars") != 0)
+                return;
 
-  script_env_vars = user_data;
-  new_env_var = malloc (sizeof (script_env_var_t));
-  new_env_var->key = strdup (key);
-  new_env_var->value = strdup (value);
+        script_env_vars = user_data;
+        new_env_var = malloc (sizeof(script_env_var_t));
+        new_env_var->key = strdup (key);
+        new_env_var->value = strdup (value);
 
-  ply_list_append_data (script_env_vars, new_env_var);
+        ply_list_append_data (script_env_vars, new_env_var);
 }
 
 static ply_boot_splash_plugin_t *
 create_plugin (ply_key_file_t *key_file)
 {
-  ply_boot_splash_plugin_t *plugin;
-  plugin = calloc (1, sizeof (ply_boot_splash_plugin_t));
-  plugin->image_dir = ply_key_file_get_value (key_file, 
-                                              "script",
-                                              "ImageDir");
-  plugin->script_filename = ply_key_file_get_value (key_file,
+        ply_boot_splash_plugin_t *plugin;
+
+        plugin = calloc (1, sizeof(ply_boot_splash_plugin_t));
+        plugin->image_dir = ply_key_file_get_value (key_file,
                                                     "script",
-                                                    "ScriptFile");
+                                                    "ImageDir");
+        plugin->script_filename = ply_key_file_get_value (key_file,
+                                                          "script",
+                                                          "ScriptFile");
 
-  plugin->script_env_vars = ply_list_new ();
-  ply_key_file_foreach_entry (key_file, add_script_env_var, plugin->script_env_vars);
+        plugin->script_env_vars = ply_list_new ();
+        ply_key_file_foreach_entry (key_file, add_script_env_var, plugin->script_env_vars);
 
-  plugin->displays = ply_list_new ();
-  return plugin;
+        plugin->displays = ply_list_new ();
+        return plugin;
 }
 
 static void
 destroy_plugin (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
-  script_env_var_t *env_var;
-
-  if (plugin == NULL)
-    return;
-
-  if (plugin->loop != NULL)
-    {
-      stop_animation (plugin);
-      ply_event_loop_stop_watching_for_exit (plugin->loop,
-                                             (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
-
-  for (node = ply_list_get_first_node (plugin->script_env_vars);
-       node != NULL;
-       node = ply_list_get_next_node (plugin->script_env_vars, node))
-    {
-      env_var = ply_list_node_get_data (node);
-      free (env_var->key);
-      free (env_var->value);
-      free (env_var);
-    }
-  ply_list_free (plugin->script_env_vars);
-  free (plugin->script_filename);
-  free (plugin->image_dir);
-  free (plugin);
+        ply_list_node_t *node;
+        script_env_var_t *env_var;
+
+        if (plugin == NULL)
+                return;
+
+        if (plugin->loop != NULL) {
+                stop_animation (plugin);
+                ply_event_loop_stop_watching_for_exit (plugin->loop,
+                                                       (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
+
+        for (node = ply_list_get_first_node (plugin->script_env_vars);
+             node != NULL;
+             node = ply_list_get_next_node (plugin->script_env_vars, node)) {
+                env_var = ply_list_node_get_data (node);
+                free (env_var->key);
+                free (env_var->value);
+                free (env_var);
+        }
+        ply_list_free (plugin->script_env_vars);
+        free (plugin->script_filename);
+        free (plugin->image_dir);
+        free (plugin);
 }
 
 static void
 on_timeout (ply_boot_splash_plugin_t *plugin)
 {
-  double sleep_time;
+        double sleep_time;
 
-  sleep_time = 1.0 / FRAMES_PER_SECOND;
-  ply_event_loop_watch_for_timeout (plugin->loop,
-                                    sleep_time,
-                                    (ply_event_loop_timeout_handler_t)
-                                    on_timeout, plugin);
+        sleep_time = 1.0 / FRAMES_PER_SECOND;
+        ply_event_loop_watch_for_timeout (plugin->loop,
+                                          sleep_time,
+                                          (ply_event_loop_timeout_handler_t)
+                                          on_timeout, plugin);
 
-  script_lib_plymouth_on_refresh (plugin->script_state,
-                                  plugin->script_plymouth_lib);
-                                  
-  pause_displays (plugin);
-  script_lib_sprite_refresh (plugin->script_sprite_lib);
-  unpause_displays (plugin);
+        script_lib_plymouth_on_refresh (plugin->script_state,
+                                        plugin->script_plymouth_lib);
 
+        pause_displays (plugin);
+        script_lib_sprite_refresh (plugin->script_sprite_lib);
+        unpause_displays (plugin);
 }
 
 static void
@@ -243,122 +239,120 @@ on_boot_progress (ply_boot_splash_plugin_t *plugin,
                   double                    duration,
                   double                    percent_done)
 {
-  script_lib_plymouth_on_boot_progress (plugin->script_state,
-                                        plugin->script_plymouth_lib,
-                                        duration,
-                                        percent_done);
+        script_lib_plymouth_on_boot_progress (plugin->script_state,
+                                              plugin->script_plymouth_lib,
+                                              duration,
+                                              percent_done);
 }
 
 static bool
 start_script_animation (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
-  script_obj_t *target_obj;
-  script_obj_t *value_obj;
-  script_env_var_t *env_var;
-  
-  assert (plugin != NULL);
-
-  plugin->script_state = script_state_new (plugin);
-  
-  for (node = ply_list_get_first_node (plugin->script_env_vars);
-       node != NULL;
-       node = ply_list_get_next_node (plugin->script_env_vars, node))
-    {
-      env_var = ply_list_node_get_data (node);
-      target_obj = script_obj_hash_get_element (plugin->script_state->global,
-                                                env_var->key);
-      value_obj = script_obj_new_string (env_var->value);
-      script_obj_assign (target_obj, value_obj);
-    }
-  
-  plugin->script_image_lib = script_lib_image_setup (plugin->script_state,
-                                                     plugin->image_dir);
-  plugin->script_sprite_lib = script_lib_sprite_setup (plugin->script_state,
-                                                       plugin->displays);
-  plugin->script_plymouth_lib = script_lib_plymouth_setup (plugin->script_state,
-                                                           plugin->mode);
-  plugin->script_math_lib = script_lib_math_setup (plugin->script_state);
-  plugin->script_string_lib = script_lib_string_setup (plugin->script_state);
-
-  ply_trace ("executing script file");
-  script_return_t ret = script_execute (plugin->script_state,
-                                        plugin->script_main_op);
-  script_obj_unref (ret.object);
-  if (plugin->keyboard != NULL)
-    ply_keyboard_add_input_handler (plugin->keyboard,
-                                    (ply_keyboard_input_handler_t)
-                                    on_keyboard_input, plugin);
-  on_timeout (plugin);
-
-  return true;
+        ply_list_node_t *node;
+        script_obj_t *target_obj;
+        script_obj_t *value_obj;
+        script_env_var_t *env_var;
+
+        assert (plugin != NULL);
+
+        plugin->script_state = script_state_new (plugin);
+
+        for (node = ply_list_get_first_node (plugin->script_env_vars);
+             node != NULL;
+             node = ply_list_get_next_node (plugin->script_env_vars, node)) {
+                env_var = ply_list_node_get_data (node);
+                target_obj = script_obj_hash_get_element (plugin->script_state->global,
+                                                          env_var->key);
+                value_obj = script_obj_new_string (env_var->value);
+                script_obj_assign (target_obj, value_obj);
+        }
+
+        plugin->script_image_lib = script_lib_image_setup (plugin->script_state,
+                                                           plugin->image_dir);
+        plugin->script_sprite_lib = script_lib_sprite_setup (plugin->script_state,
+                                                             plugin->displays);
+        plugin->script_plymouth_lib = script_lib_plymouth_setup (plugin->script_state,
+                                                                 plugin->mode);
+        plugin->script_math_lib = script_lib_math_setup (plugin->script_state);
+        plugin->script_string_lib = script_lib_string_setup (plugin->script_state);
+
+        ply_trace ("executing script file");
+        script_return_t ret = script_execute (plugin->script_state,
+                                              plugin->script_main_op);
+        script_obj_unref (ret.object);
+        if (plugin->keyboard != NULL)
+                ply_keyboard_add_input_handler (plugin->keyboard,
+                                                (ply_keyboard_input_handler_t)
+                                                on_keyboard_input, plugin);
+        on_timeout (plugin);
+
+        return true;
 }
 
 static bool
 start_animation (ply_boot_splash_plugin_t *plugin)
 {
-  assert (plugin != NULL);
-  assert (plugin->loop != NULL);
+        assert (plugin != NULL);
+        assert (plugin->loop != NULL);
+
+        if (plugin->is_animating)
+                return true;
 
-  if (plugin->is_animating)
-    return true;
+        ply_trace ("parsing script file");
+        plugin->script_main_op = script_parse_file (plugin->script_filename);
 
-  ply_trace ("parsing script file");
-  plugin->script_main_op = script_parse_file (plugin->script_filename);
-  
-  start_script_animation (plugin);
+        start_script_animation (plugin);
 
-  plugin->is_animating = true;
-  return true;
+        plugin->is_animating = true;
+        return true;
 }
 
 static void
 stop_script_animation (ply_boot_splash_plugin_t *plugin)
 {
-  script_lib_plymouth_on_quit (plugin->script_state,
-                               plugin->script_plymouth_lib);
-  script_lib_sprite_refresh (plugin->script_sprite_lib);
-
-  if (plugin->loop != NULL)
-    ply_event_loop_stop_watching_for_timeout (plugin->loop,
-                                              (ply_event_loop_timeout_handler_t)
-                                              on_timeout, plugin);
-
-  if (plugin->keyboard != NULL)
-    {
-      ply_keyboard_remove_input_handler (plugin->keyboard,
-                                         (ply_keyboard_input_handler_t)
-                                         on_keyboard_input);
-      plugin->keyboard = NULL;
-    }
-
-  script_state_destroy (plugin->script_state);
-  script_lib_sprite_destroy (plugin->script_sprite_lib);
-  script_lib_image_destroy (plugin->script_image_lib);
-  script_lib_plymouth_destroy (plugin->script_plymouth_lib);
-  script_lib_math_destroy (plugin->script_math_lib);
-  script_lib_string_destroy (plugin->script_string_lib);
+        script_lib_plymouth_on_quit (plugin->script_state,
+                                     plugin->script_plymouth_lib);
+        script_lib_sprite_refresh (plugin->script_sprite_lib);
+
+        if (plugin->loop != NULL)
+                ply_event_loop_stop_watching_for_timeout (plugin->loop,
+                                                          (ply_event_loop_timeout_handler_t)
+                                                          on_timeout, plugin);
+
+        if (plugin->keyboard != NULL) {
+                ply_keyboard_remove_input_handler (plugin->keyboard,
+                                                   (ply_keyboard_input_handler_t)
+                                                   on_keyboard_input);
+                plugin->keyboard = NULL;
+        }
+
+        script_state_destroy (plugin->script_state);
+        script_lib_sprite_destroy (plugin->script_sprite_lib);
+        script_lib_image_destroy (plugin->script_image_lib);
+        script_lib_plymouth_destroy (plugin->script_plymouth_lib);
+        script_lib_math_destroy (plugin->script_math_lib);
+        script_lib_string_destroy (plugin->script_string_lib);
 }
 
 static void
 stop_animation (ply_boot_splash_plugin_t *plugin)
 {
-  assert (plugin != NULL);
-  assert (plugin->loop != NULL);
+        assert (plugin != NULL);
+        assert (plugin->loop != NULL);
 
-  if (!plugin->is_animating)
-    return;
-  plugin->is_animating = false;
+        if (!plugin->is_animating)
+                return;
+        plugin->is_animating = false;
 
-  stop_script_animation (plugin);
+        stop_script_animation (plugin);
 
-  script_parse_op_free (plugin->script_main_op);
+        script_parse_op_free (plugin->script_main_op);
 }
 
 static void
 detach_from_event_loop (ply_boot_splash_plugin_t *plugin)
 {
-  plugin->loop = NULL;
+        plugin->loop = NULL;
 }
 
 static void
@@ -366,42 +360,42 @@ on_keyboard_input (ply_boot_splash_plugin_t *plugin,
                    const char               *keyboard_input,
                    size_t                    character_size)
 {
-  char keyboard_string[character_size + 1];
+        char keyboard_string[character_size + 1];
 
-  memcpy (keyboard_string, keyboard_input, character_size);
-  keyboard_string[character_size] = '\0';
+        memcpy (keyboard_string, keyboard_input, character_size);
+        keyboard_string[character_size] = '\0';
 
-  script_lib_plymouth_on_keyboard_input (plugin->script_state,
-                                         plugin->script_plymouth_lib,
-                                         keyboard_string);
+        script_lib_plymouth_on_keyboard_input (plugin->script_state,
+                                               plugin->script_plymouth_lib,
+                                               keyboard_string);
 }
 
 static void
 set_keyboard (ply_boot_splash_plugin_t *plugin,
               ply_keyboard_t           *keyboard)
 {
-  plugin->keyboard = keyboard;
+        plugin->keyboard = keyboard;
 }
 
 static void
 unset_keyboard (ply_boot_splash_plugin_t *plugin,
                 ply_keyboard_t           *keyboard)
 {
-  plugin->keyboard = NULL;
+        plugin->keyboard = NULL;
 }
 
 static void
 add_pixel_display (ply_boot_splash_plugin_t *plugin,
                    ply_pixel_display_t      *display)
 {
-  ply_list_append_data (plugin->displays, display);
+        ply_list_append_data (plugin->displays, display);
 }
 
 static void
 remove_pixel_display (ply_boot_splash_plugin_t *plugin,
                       ply_pixel_display_t      *display)
 {
-  ply_list_remove_data(plugin->displays, display);
+        ply_list_remove_data (plugin->displays, display);
 }
 
 static bool
@@ -410,73 +404,71 @@ show_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_buffer_t             *boot_buffer,
                     ply_boot_splash_mode_t    mode)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  if (ply_list_get_length (plugin->displays) == 0)
-    {
-      ply_trace ("no pixel displays");
-      return false;
-    }
+        if (ply_list_get_length (plugin->displays) == 0) {
+                ply_trace ("no pixel displays");
+                return false;
+        }
 
-  plugin->loop = loop;
-  plugin->mode = mode;
+        plugin->loop = loop;
+        plugin->mode = mode;
 
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
-                                 detach_from_event_loop,
-                                 plugin);
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       detach_from_event_loop,
+                                       plugin);
 
-  ply_trace ("starting boot animation");
-  return start_animation (plugin);
+        ply_trace ("starting boot animation");
+        return start_animation (plugin);
 }
 
 static void
 update_status (ply_boot_splash_plugin_t *plugin,
                const char               *status)
 {
-  script_lib_plymouth_on_update_status (plugin->script_state,
-                                        plugin->script_plymouth_lib,
-                                        status);
+        script_lib_plymouth_on_update_status (plugin->script_state,
+                                              plugin->script_plymouth_lib,
+                                              status);
 }
 
 static void
 hide_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_event_loop_t         *loop)
 {
-  assert (plugin != NULL);
-
-  if (plugin->loop != NULL)
-    {
-      stop_animation (plugin);
-
-      ply_event_loop_stop_watching_for_exit (plugin->loop,
-                                             (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
+        assert (plugin != NULL);
+
+        if (plugin->loop != NULL) {
+                stop_animation (plugin);
+
+                ply_event_loop_stop_watching_for_exit (plugin->loop,
+                                                       (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
 }
 
 static void
 on_root_mounted (ply_boot_splash_plugin_t *plugin)
 {
-  script_lib_plymouth_on_root_mounted (plugin->script_state,
-                                       plugin->script_plymouth_lib);
+        script_lib_plymouth_on_root_mounted (plugin->script_state,
+                                             plugin->script_plymouth_lib);
 }
 
 static void
 become_idle (ply_boot_splash_plugin_t *plugin,
              ply_trigger_t            *idle_trigger)
 {
-  ply_trigger_pull (idle_trigger, NULL);
+        ply_trigger_pull (idle_trigger, NULL);
 }
 
 static void
 display_normal (ply_boot_splash_plugin_t *plugin)
 {
-  pause_displays (plugin);
-  script_lib_plymouth_on_display_normal (plugin->script_state,
-                                         plugin->script_plymouth_lib);
-  unpause_displays (plugin);
+        pause_displays (plugin);
+        script_lib_plymouth_on_display_normal (plugin->script_state,
+                                               plugin->script_plymouth_lib);
+        unpause_displays (plugin);
 }
 
 static void
@@ -484,12 +476,12 @@ display_password (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   int                       bullets)
 {
-  pause_displays (plugin);
-  script_lib_plymouth_on_display_password (plugin->script_state,
-                                           plugin->script_plymouth_lib,
-                                           prompt,
-                                           bullets);
-  unpause_displays (plugin);
+        pause_displays (plugin);
+        script_lib_plymouth_on_display_password (plugin->script_state,
+                                                 plugin->script_plymouth_lib,
+                                                 prompt,
+                                                 bullets);
+        unpause_displays (plugin);
 }
 
 static void
@@ -497,61 +489,61 @@ display_question (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   const char               *entry_text)
 {
-  pause_displays (plugin);
-  script_lib_plymouth_on_display_question (plugin->script_state,
-                                           plugin->script_plymouth_lib,
-                                           prompt,
-                                           entry_text);
-  unpause_displays (plugin);
+        pause_displays (plugin);
+        script_lib_plymouth_on_display_question (plugin->script_state,
+                                                 plugin->script_plymouth_lib,
+                                                 prompt,
+                                                 entry_text);
+        unpause_displays (plugin);
 }
 
 static void
 display_message (ply_boot_splash_plugin_t *plugin,
                  const char               *message)
 {
-  pause_displays (plugin);
-  script_lib_plymouth_on_display_message (plugin->script_state,
-                                          plugin->script_plymouth_lib,
-                                          message);
-  unpause_displays (plugin);
+        pause_displays (plugin);
+        script_lib_plymouth_on_display_message (plugin->script_state,
+                                                plugin->script_plymouth_lib,
+                                                message);
+        unpause_displays (plugin);
 }
 
 static void
 hide_message (ply_boot_splash_plugin_t *plugin,
-                 const char               *message)
+              const char               *message)
 {
-  pause_displays (plugin);
-  script_lib_plymouth_on_hide_message (plugin->script_state,
-                                       plugin->script_plymouth_lib,
-                                       message);
-  unpause_displays (plugin);
+        pause_displays (plugin);
+        script_lib_plymouth_on_hide_message (plugin->script_state,
+                                             plugin->script_plymouth_lib,
+                                             message);
+        unpause_displays (plugin);
 }
 
 ply_boot_splash_plugin_interface_t *
 ply_boot_splash_plugin_get_interface (void)
 {
-  static ply_boot_splash_plugin_interface_t plugin_interface =
-  {
-    .create_plugin = create_plugin,
-    .destroy_plugin = destroy_plugin,
-    .set_keyboard = set_keyboard,
-    .unset_keyboard = unset_keyboard,
-    .add_pixel_display = add_pixel_display,
-    .remove_pixel_display = remove_pixel_display,
-    .show_splash_screen = show_splash_screen,
-    .update_status = update_status,
-    .on_boot_progress = on_boot_progress,
-    .hide_splash_screen = hide_splash_screen,
-    .on_root_mounted = on_root_mounted,
-    .become_idle = become_idle,
-    .display_normal = display_normal,
-    .display_password = display_password,
-    .display_question = display_question,
-    .display_message = display_message,
-    .hide_message = hide_message,
-  };
-
-  return &plugin_interface;
+        static ply_boot_splash_plugin_interface_t plugin_interface =
+        {
+                .create_plugin        = create_plugin,
+                .destroy_plugin       = destroy_plugin,
+                .set_keyboard         = set_keyboard,
+                .unset_keyboard       = unset_keyboard,
+                .add_pixel_display    = add_pixel_display,
+                .remove_pixel_display = remove_pixel_display,
+                .show_splash_screen   = show_splash_screen,
+                .update_status        = update_status,
+                .on_boot_progress     = on_boot_progress,
+                .hide_splash_screen   = hide_splash_screen,
+                .on_root_mounted      = on_root_mounted,
+                .become_idle          = become_idle,
+                .display_normal       = display_normal,
+                .display_password     = display_password,
+                .display_question     = display_question,
+                .display_message      = display_message,
+                .hide_message         = hide_message,
+        };
+
+        return &plugin_interface;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/plugins/splash/script/script-debug.c b/src/plugins/splash/script/script-debug.c
index 118574b..245ee79 100644
--- a/src/plugins/splash/script/script-debug.c
+++ b/src/plugins/splash/script/script-debug.c
@@ -34,42 +34,40 @@ static ply_hashtable_t *script_debug_name_hash = NULL;
 
 static void script_debug_setup (void)
 {
-  if (!script_debug_location_hash)
-  {
-    script_debug_location_hash = ply_hashtable_new(NULL, NULL);
-    script_debug_name_hash = ply_hashtable_new(ply_hashtable_string_hash,
-                                               ply_hashtable_string_compare);
-  }
+        if (!script_debug_location_hash) {
+                script_debug_location_hash = ply_hashtable_new (NULL, NULL);
+                script_debug_name_hash = ply_hashtable_new (ply_hashtable_string_hash,
+                                                            ply_hashtable_string_compare);
+        }
 }
 
 void script_debug_add_element (void                    *element,
                                script_debug_location_t *location)
 {
-  script_debug_setup();
-  script_debug_location_t *new_location = malloc (sizeof(script_debug_location_t));
-  new_location->line_index = location->line_index;
-  new_location->column_index = location->column_index;
-  new_location->name = ply_hashtable_lookup (script_debug_name_hash, location->name);
-  if (!new_location->name)
-    {
-      new_location->name = strdup(location->name);
-      ply_hashtable_insert (script_debug_name_hash, new_location->name, new_location->name);
-    }
-  ply_hashtable_insert (script_debug_location_hash, element, new_location);
+        script_debug_setup ();
+        script_debug_location_t *new_location = malloc (sizeof(script_debug_location_t));
+        new_location->line_index = location->line_index;
+        new_location->column_index = location->column_index;
+        new_location->name = ply_hashtable_lookup (script_debug_name_hash, location->name);
+        if (!new_location->name) {
+                new_location->name = strdup (location->name);
+                ply_hashtable_insert (script_debug_name_hash, new_location->name, new_location->name);
+        }
+        ply_hashtable_insert (script_debug_location_hash, element, new_location);
 }
 
 void script_debug_remove_element (void *element)
 {
-  script_debug_setup();
-  script_debug_location_t *old_location = ply_hashtable_remove (script_debug_location_hash,
-                                                                element);
-  free(old_location);
+        script_debug_setup ();
+        script_debug_location_t *old_location = ply_hashtable_remove (script_debug_location_hash,
+                                                                      element);
+        free (old_location);
 }
 
 script_debug_location_t *script_debug_lookup_element (void *element)
 {
-  script_debug_setup();
-  script_debug_location_t *location = ply_hashtable_lookup (script_debug_location_hash,
-                                                            element);
-  return location;
+        script_debug_setup ();
+        script_debug_location_t *location = ply_hashtable_lookup (script_debug_location_hash,
+                                                                  element);
+        return location;
 }
diff --git a/src/plugins/splash/script/script-debug.h b/src/plugins/splash/script/script-debug.h
index a9ddf0c..b4eaa5b 100644
--- a/src/plugins/splash/script/script-debug.h
+++ b/src/plugins/splash/script/script-debug.h
@@ -25,9 +25,9 @@
 
 typedef struct
 {
-  int line_index;
-  int column_index;
-  char* name;
+        int   line_index;
+        int   column_index;
+        char *name;
 } script_debug_location_t;
 
 
diff --git a/src/plugins/splash/script/script-execute.c b/src/plugins/splash/script/script-execute.c
index c06959b..75b0727 100644
--- a/src/plugins/splash/script/script-execute.c
+++ b/src/plugins/splash/script/script-execute.c
@@ -53,537 +53,519 @@ static script_return_t script_execute_function_with_parlist (script_state_t    *
 static void script_execute_error (void       *element,
                                   const char *message)
 {
-  script_debug_location_t *location = script_debug_lookup_element (element);
-  if (location)
-    ply_error ("Execution error \"%s\" L:%d C:%d : %s\n",
-               location->name,
-               location->line_index,
-               location->column_index,
-               message);
-  else
-    ply_error ("Execution error: %s\n", message);
+        script_debug_location_t *location = script_debug_lookup_element (element);
+
+        if (location) {
+                ply_error ("Execution error \"%s\" L:%d C:%d : %s\n",
+                           location->name,
+                           location->line_index,
+                           location->column_index,
+                           message);
+        } else {
+                ply_error ("Execution error: %s\n", message);
+        }
 }
 
 
-static script_obj_t *script_evaluate_apply_function (script_state_t *state,
-                                                     script_exp_t   *exp,
-                                                     script_obj_t   *(*function)(script_obj_t *, script_obj_t *))
+static script_obj_t *script_evaluate_apply_function (script_state_t                                                  *state,
+                                                     script_exp_t                                                    *exp,
+                                                     script_obj_t                                                     *(*function)(script_obj_t *,
+                                                                                                         script_obj_t *))
 {
-  script_obj_t *script_obj_a = script_evaluate (state, exp->data.dual.sub_a);
-  script_obj_t *script_obj_b = script_evaluate (state, exp->data.dual.sub_b);
-  script_obj_t *obj = function (script_obj_a, script_obj_b);
+        script_obj_t *script_obj_a = script_evaluate (state, exp->data.dual.sub_a);
+        script_obj_t *script_obj_b = script_evaluate (state, exp->data.dual.sub_b);
+        script_obj_t *obj = function (script_obj_a, script_obj_b);
 
-  script_obj_unref (script_obj_a);
-  script_obj_unref (script_obj_b);
-  return obj;
+        script_obj_unref (script_obj_a);
+        script_obj_unref (script_obj_b);
+        return obj;
 }
 
-static script_obj_t *script_evaluate_apply_function_and_assign (script_state_t *state,
-                                                                script_exp_t   *exp,
-                                                                script_obj_t   *(*function)(script_obj_t *, script_obj_t *))
+static script_obj_t *script_evaluate_apply_function_and_assign (script_state_t                                                  *state,
+                                                                script_exp_t                                                    *exp,
+                                                                script_obj_t                                                     *(*function)(script_obj_t *,
+                                                                                                                    script_obj_t *))
 {
-  script_obj_t *script_obj_a = script_evaluate (state, exp->data.dual.sub_a);
-  script_obj_t *script_obj_b = script_evaluate (state, exp->data.dual.sub_b);
-  script_obj_t *obj = function (script_obj_a, script_obj_b);
-
-  script_obj_assign (script_obj_a, obj);
-  script_obj_unref (script_obj_a);
-  script_obj_unref (script_obj_b);
-  return obj;
+        script_obj_t *script_obj_a = script_evaluate (state, exp->data.dual.sub_a);
+        script_obj_t *script_obj_b = script_evaluate (state, exp->data.dual.sub_b);
+        script_obj_t *obj = function (script_obj_a, script_obj_b);
+
+        script_obj_assign (script_obj_a, obj);
+        script_obj_unref (script_obj_a);
+        script_obj_unref (script_obj_b);
+        return obj;
 }
 
 static script_obj_t *script_evaluate_hash (script_state_t *state,
                                            script_exp_t   *exp)
 {
-  script_obj_t *hash = script_evaluate (state, exp->data.dual.sub_a);
-  script_obj_t *key  = script_evaluate (state, exp->data.dual.sub_b);
-  script_obj_t *obj;
-  char *name = script_obj_as_string (key);
-
-  if (!script_obj_is_hash(hash))
-    {
-      script_obj_t *newhash  = script_obj_new_hash ();
-      script_obj_assign (hash, newhash);
-      script_obj_unref (newhash);
-    }
-  
-  obj = script_obj_hash_get_element (hash, name);
-  free(name);
-  
-  script_obj_unref (hash);
-  script_obj_unref (key);
-  return obj;
+        script_obj_t *hash = script_evaluate (state, exp->data.dual.sub_a);
+        script_obj_t *key = script_evaluate (state, exp->data.dual.sub_b);
+        script_obj_t *obj;
+        char *name = script_obj_as_string (key);
+
+        if (!script_obj_is_hash (hash)) {
+                script_obj_t *newhash = script_obj_new_hash ();
+                script_obj_assign (hash, newhash);
+                script_obj_unref (newhash);
+        }
+
+        obj = script_obj_hash_get_element (hash, name);
+        free (name);
+
+        script_obj_unref (hash);
+        script_obj_unref (key);
+        return obj;
 }
 
 static script_obj_t *script_evaluate_var (script_state_t *state,
                                           script_exp_t   *exp)
 {
-  char *name = exp->data.string;
-  script_obj_t *obj = script_obj_hash_peek_element (state->local, name);
-  if (obj) return obj;
-  obj = script_obj_hash_peek_element (state->this, name);
-  if (obj) return obj;
-  obj = script_obj_hash_peek_element (state->global, name);
-  if (obj) return obj;
-  obj = script_obj_hash_get_element (state->local, name);
-  return obj;
+        char *name = exp->data.string;
+        script_obj_t *obj = script_obj_hash_peek_element (state->local, name);
+
+        if (obj) return obj;
+        obj = script_obj_hash_peek_element (state->this, name);
+        if (obj) return obj;
+        obj = script_obj_hash_peek_element (state->global, name);
+        if (obj) return obj;
+        obj = script_obj_hash_get_element (state->local, name);
+        return obj;
 }
 
 static script_obj_t *script_evaluate_set (script_state_t *state,
                                           script_exp_t   *exp)
 {
-
-  ply_list_t *parameter_data = exp->data.parameters;
-  ply_list_node_t *node_data = ply_list_get_first_node (parameter_data);
-  int index = 0;
-  script_obj_t *obj = script_obj_new_hash ();
-  while (node_data)
-    {
-      script_exp_t *data_exp = ply_list_node_get_data (node_data);
-      script_obj_t *data_obj = script_evaluate (state, data_exp);
-      char *name;
-      asprintf (&name, "%d", index);
-      index++;
-      script_obj_hash_add_element (obj, data_obj, name);
-      free(name);
-      
-      node_data = ply_list_get_next_node (parameter_data, node_data);
-    }
-  return obj;
+        ply_list_t *parameter_data = exp->data.parameters;
+        ply_list_node_t *node_data = ply_list_get_first_node (parameter_data);
+        int index = 0;
+        script_obj_t *obj = script_obj_new_hash ();
+
+        while (node_data) {
+                script_exp_t *data_exp = ply_list_node_get_data (node_data);
+                script_obj_t *data_obj = script_evaluate (state, data_exp);
+                char *name;
+                asprintf (&name, "%d", index);
+                index++;
+                script_obj_hash_add_element (obj, data_obj, name);
+                free (name);
+
+                node_data = ply_list_get_next_node (parameter_data, node_data);
+        }
+        return obj;
 }
 
 static script_obj_t *script_evaluate_assign (script_state_t *state,
                                              script_exp_t   *exp)
 {
-  script_obj_t *script_obj_a = script_evaluate (state, exp->data.dual.sub_a);
-  script_obj_t *script_obj_b = script_evaluate (state, exp->data.dual.sub_b);
+        script_obj_t *script_obj_a = script_evaluate (state, exp->data.dual.sub_a);
+        script_obj_t *script_obj_b = script_evaluate (state, exp->data.dual.sub_b);
 
-  script_obj_assign (script_obj_a, script_obj_b);
+        script_obj_assign (script_obj_a, script_obj_b);
 
-  script_obj_unref (script_obj_b);
-  return script_obj_a;
+        script_obj_unref (script_obj_b);
+        return script_obj_a;
 }
 
-static script_obj_t *script_evaluate_cmp (script_state_t           *state,
-                                          script_exp_t             *exp,
-                                          script_obj_cmp_result_t   condition)
+static script_obj_t *script_evaluate_cmp (script_state_t         *state,
+                                          script_exp_t           *exp,
+                                          script_obj_cmp_result_t condition)
 {
-  script_obj_t *script_obj_a = script_evaluate (state, exp->data.dual.sub_a);
-  script_obj_t *script_obj_b = script_evaluate (state, exp->data.dual.sub_b);
-  script_obj_cmp_result_t cmp_result = script_obj_cmp(script_obj_a, script_obj_b);
-  script_obj_unref (script_obj_a);
-  script_obj_unref (script_obj_b);
-  
-  if (cmp_result & condition)
-    return script_obj_new_number (1);
-  return script_obj_new_number (0);
+        script_obj_t *script_obj_a = script_evaluate (state, exp->data.dual.sub_a);
+        script_obj_t *script_obj_b = script_evaluate (state, exp->data.dual.sub_b);
+        script_obj_cmp_result_t cmp_result = script_obj_cmp (script_obj_a, script_obj_b);
+
+        script_obj_unref (script_obj_a);
+        script_obj_unref (script_obj_b);
+
+        if (cmp_result & condition)
+                return script_obj_new_number (1);
+        return script_obj_new_number (0);
 }
 
 static script_obj_t *script_evaluate_logic (script_state_t *state,
                                             script_exp_t   *exp)
 {
-  script_obj_t *obj = script_evaluate (state, exp->data.dual.sub_a);
-
-  if ((exp->type == SCRIPT_EXP_TYPE_AND) && !script_obj_as_bool (obj))
-    return obj;
-  else if (exp->type == SCRIPT_EXP_TYPE_OR && script_obj_as_bool (obj))
-    return obj;
-  script_obj_unref (obj);
-  obj = script_evaluate (state, exp->data.dual.sub_b);
-  return obj;
+        script_obj_t *obj = script_evaluate (state, exp->data.dual.sub_a);
+
+        if ((exp->type == SCRIPT_EXP_TYPE_AND) && !script_obj_as_bool (obj))
+                return obj;
+        else if (exp->type == SCRIPT_EXP_TYPE_OR && script_obj_as_bool (obj))
+                return obj;
+        script_obj_unref (obj);
+        obj = script_evaluate (state, exp->data.dual.sub_b);
+        return obj;
 }
 
 static script_obj_t *script_evaluate_unary (script_state_t *state,
                                             script_exp_t   *exp)
 {
-  script_obj_t *obj = script_evaluate (state, exp->data.sub);
-  script_obj_t *new_obj;
-
-  if (exp->type == SCRIPT_EXP_TYPE_NOT)
-    {
-      new_obj = script_obj_new_number (!script_obj_as_bool (obj));
-      script_obj_unref (obj);
-      return new_obj;
-    }
-  if (exp->type == SCRIPT_EXP_TYPE_POS)     /* FIXME what should happen on non number operands? */
-    return obj;                             /* Does nothing, maybe just remove at parse stage */
-  if (exp->type == SCRIPT_EXP_TYPE_NEG)
-    {
-      if (script_obj_is_number(obj))
-        new_obj = script_obj_new_number (-script_obj_as_number (obj));
-      else
-        {
-          script_execute_error(exp, "Cannot negate non number objects");
-          new_obj = script_obj_new_null ();
-        }
-      script_obj_unref (obj);
-      return new_obj;
-    }
-  int change_pre = 0;
-  int change = -1;
-
-  if ((exp->type == SCRIPT_EXP_TYPE_PRE_INC) ||
-      (exp->type == SCRIPT_EXP_TYPE_POST_INC))
-    change = 1;
-  if ((exp->type == SCRIPT_EXP_TYPE_PRE_INC) ||
-      (exp->type == SCRIPT_EXP_TYPE_PRE_DEC))
-    change_pre = 1;
-
-  if (script_obj_is_number(obj))
-    {
-      if (change_pre)
-        {
-          new_obj = script_obj_new_number (script_obj_as_number(obj) + change);
-          script_obj_assign (obj, new_obj);
-        }
-      else
-        {
-          new_obj = script_obj_deref_direct (obj);
-          script_obj_ref (new_obj);
-          script_obj_t *new_obj2 = script_obj_new_number (script_obj_as_number(obj) + change);
-          script_obj_assign (obj, new_obj2);
-          script_obj_unref (new_obj2);
-        }
-    }
-  else
-    {
-      script_execute_error(exp, "Cannot increment/decrement non number objects");
-      new_obj = script_obj_new_null (); /* If performeing something like a=hash++; a and hash become NULL */
-      script_obj_reset (obj);
-    }
-  script_obj_unref (obj);
-  return new_obj;
+        script_obj_t *obj = script_evaluate (state, exp->data.sub);
+        script_obj_t *new_obj;
+
+        if (exp->type == SCRIPT_EXP_TYPE_NOT) {
+                new_obj = script_obj_new_number (!script_obj_as_bool (obj));
+                script_obj_unref (obj);
+                return new_obj;
+        }
+        if (exp->type == SCRIPT_EXP_TYPE_POS) /* FIXME what should happen on non number operands? */
+                return obj;                   /* Does nothing, maybe just remove at parse stage */
+        if (exp->type == SCRIPT_EXP_TYPE_NEG) {
+                if (script_obj_is_number (obj)) {
+                        new_obj = script_obj_new_number (-script_obj_as_number (obj));
+                } else {
+                        script_execute_error (exp, "Cannot negate non number objects");
+                        new_obj = script_obj_new_null ();
+                }
+                script_obj_unref (obj);
+                return new_obj;
+        }
+        int change_pre = 0;
+        int change = -1;
+
+        if ((exp->type == SCRIPT_EXP_TYPE_PRE_INC) ||
+            (exp->type == SCRIPT_EXP_TYPE_POST_INC))
+                change = 1;
+        if ((exp->type == SCRIPT_EXP_TYPE_PRE_INC) ||
+            (exp->type == SCRIPT_EXP_TYPE_PRE_DEC))
+                change_pre = 1;
+
+        if (script_obj_is_number (obj)) {
+                if (change_pre) {
+                        new_obj = script_obj_new_number (script_obj_as_number (obj) + change);
+                        script_obj_assign (obj, new_obj);
+                } else {
+                        new_obj = script_obj_deref_direct (obj);
+                        script_obj_ref (new_obj);
+                        script_obj_t *new_obj2 = script_obj_new_number (script_obj_as_number (obj) + change);
+                        script_obj_assign (obj, new_obj2);
+                        script_obj_unref (new_obj2);
+                }
+        } else {
+                script_execute_error (exp, "Cannot increment/decrement non number objects");
+                new_obj = script_obj_new_null (); /* If performeing something like a=hash++; a and hash become NULL */
+                script_obj_reset (obj);
+        }
+        script_obj_unref (obj);
+        return new_obj;
 }
-typedef struct 
+typedef struct
 {
-  script_state_t    *state;
-  script_obj_t      *this;
-  ply_list_t        *parameter_data;
+        script_state_t *state;
+        script_obj_t   *this;
+        ply_list_t     *parameter_data;
 } script_obj_execute_data_t;
 
 static void *script_obj_execute (script_obj_t *obj,
                                  void         *user_data)
 {
-  script_obj_execute_data_t *execute_data = user_data;
-  if (obj->type == SCRIPT_OBJ_TYPE_FUNCTION){
-      script_function_t *function = obj->data.function;
-      script_return_t reply = script_execute_function_with_parlist (execute_data->state,
-                                                                    function,
-                                                                    execute_data->this,
-                                                                    execute_data->parameter_data);
-      if (reply.type != SCRIPT_RETURN_TYPE_FAIL)
-        return reply.object ? reply.object : script_obj_new_null ();
-    }
-  return NULL;
+        script_obj_execute_data_t *execute_data = user_data;
+
+        if (obj->type == SCRIPT_OBJ_TYPE_FUNCTION) {
+                script_function_t *function = obj->data.function;
+                script_return_t reply = script_execute_function_with_parlist (execute_data->state,
+                                                                              function,
+                                                                              execute_data->this,
+                                                                              execute_data->parameter_data);
+                if (reply.type != SCRIPT_RETURN_TYPE_FAIL)
+                        return reply.object ? reply.object : script_obj_new_null ();
+        }
+        return NULL;
 }
 
-static script_return_t script_execute_object_with_parlist (script_state_t    *state,
-                                                           script_obj_t      *obj,
-                                                           script_obj_t      *this,
-                                                           ply_list_t        *parameter_data)
+static script_return_t script_execute_object_with_parlist (script_state_t *state,
+                                                           script_obj_t   *obj,
+                                                           script_obj_t   *this,
+                                                           ply_list_t     *parameter_data)
 {
-  script_obj_execute_data_t execute_data;
-  execute_data.state = state;
-  execute_data.this = this;
-  execute_data.parameter_data = parameter_data;
+        script_obj_execute_data_t execute_data;
+
+        execute_data.state = state;
+        execute_data.this = this;
+        execute_data.parameter_data = parameter_data;
 
-  obj = script_obj_as_custom (obj, script_obj_execute, &execute_data);
+        obj = script_obj_as_custom (obj, script_obj_execute, &execute_data);
 
-  if (obj) return script_return_obj(obj);
-  return script_return_fail();
+        if (obj) return script_return_obj (obj);
+        return script_return_fail ();
 }
 
 static script_obj_t *script_evaluate_func (script_state_t *state,
                                            script_exp_t   *exp)
 {
-  script_obj_t *this_obj = NULL; ;
-  script_obj_t *func_obj;
-  script_exp_t *name_exp = exp->data.function_exe.name;
-  
-  if (name_exp->type == SCRIPT_EXP_TYPE_HASH)
-    {
-      script_obj_t *this_key  = script_evaluate (state, name_exp->data.dual.sub_b);
-      this_obj = script_evaluate (state, name_exp->data.dual.sub_a);
-      char *this_key_name = script_obj_as_string (this_key);
-      script_obj_unref (this_key);
-      func_obj = script_obj_hash_peek_element (this_obj, this_key_name);
-
-      if (!func_obj && script_obj_is_string (this_obj))
-        {
-          script_obj_t *string_hash = script_obj_hash_peek_element (state->global, "String");
-          func_obj = script_obj_hash_peek_element (string_hash, this_key_name);
-          script_obj_unref (string_hash);
-        }
-
-      if (!func_obj)
-        func_obj = script_obj_hash_get_element (this_obj, this_key_name);
-
-      free(this_key_name);
-    }
-  else if (name_exp->type == SCRIPT_EXP_TYPE_TERM_VAR)
-    {
-      char *name = name_exp->data.string;
-      func_obj = script_obj_hash_peek_element (state->local, name);
-      if (!func_obj)
-        {
-          func_obj = script_obj_hash_peek_element (state->this, name);
-          if (func_obj)
-            {
-              this_obj = state->this;
-              script_obj_ref(this_obj);
-            }
-          else
-            {
-              func_obj = script_obj_hash_peek_element (state->global, name);
-              if (!func_obj) func_obj = script_obj_new_null ();
-            }
-        }
-    }
-  else
-    {
-      func_obj = script_evaluate (state, name_exp);
-    }
-  
-  ply_list_t *parameter_expressions = exp->data.function_exe.parameters;
-  ply_list_t *parameter_data = ply_list_new ();
-
-  ply_list_node_t *node_expression = ply_list_get_first_node (parameter_expressions);
-  while (node_expression)
-    {
-      script_exp_t *data_exp = ply_list_node_get_data (node_expression);
-      script_obj_t *data_obj = script_evaluate (state, data_exp);
-      ply_list_append_data (parameter_data, data_obj);
-      node_expression = ply_list_get_next_node (parameter_expressions,
-                                                node_expression);
-    }
-
-  script_return_t reply = script_execute_object_with_parlist (state, func_obj, this_obj, parameter_data);
-    
-  ply_list_node_t *node_data = ply_list_get_first_node (parameter_data);
-  while (node_data)
-    {
-      script_obj_t *data_obj = ply_list_node_get_data (node_data);
-      script_obj_unref (data_obj);
-      node_data = ply_list_get_next_node (parameter_data, node_data);
-    }
-  ply_list_free (parameter_data);
-
-  script_obj_unref (func_obj);
-  if (this_obj) script_obj_unref (this_obj);
-
-  return reply.object ? reply.object : script_obj_new_null ();
+        script_obj_t *this_obj = NULL;
+        script_obj_t *func_obj;
+        script_exp_t *name_exp = exp->data.function_exe.name;
+
+        if (name_exp->type == SCRIPT_EXP_TYPE_HASH) {
+                script_obj_t *this_key = script_evaluate (state, name_exp->data.dual.sub_b);
+                this_obj = script_evaluate (state, name_exp->data.dual.sub_a);
+                char *this_key_name = script_obj_as_string (this_key);
+                script_obj_unref (this_key);
+                func_obj = script_obj_hash_peek_element (this_obj, this_key_name);
+
+                if (!func_obj && script_obj_is_string (this_obj)) {
+                        script_obj_t *string_hash = script_obj_hash_peek_element (state->global, "String");
+                        func_obj = script_obj_hash_peek_element (string_hash, this_key_name);
+                        script_obj_unref (string_hash);
+                }
+
+                if (!func_obj)
+                        func_obj = script_obj_hash_get_element (this_obj, this_key_name);
+
+                free (this_key_name);
+        } else if (name_exp->type == SCRIPT_EXP_TYPE_TERM_VAR) {
+                char *name = name_exp->data.string;
+                func_obj = script_obj_hash_peek_element (state->local, name);
+                if (!func_obj) {
+                        func_obj = script_obj_hash_peek_element (state->this, name);
+                        if (func_obj) {
+                                this_obj = state->this;
+                                script_obj_ref (this_obj);
+                        } else {
+                                func_obj = script_obj_hash_peek_element (state->global, name);
+                                if (!func_obj) func_obj = script_obj_new_null ();
+                        }
+                }
+        } else {
+                func_obj = script_evaluate (state, name_exp);
+        }
+
+        ply_list_t *parameter_expressions = exp->data.function_exe.parameters;
+        ply_list_t *parameter_data = ply_list_new ();
+
+        ply_list_node_t *node_expression = ply_list_get_first_node (parameter_expressions);
+        while (node_expression) {
+                script_exp_t *data_exp = ply_list_node_get_data (node_expression);
+                script_obj_t *data_obj = script_evaluate (state, data_exp);
+                ply_list_append_data (parameter_data, data_obj);
+                node_expression = ply_list_get_next_node (parameter_expressions,
+                                                          node_expression);
+        }
+
+        script_return_t reply = script_execute_object_with_parlist (state, func_obj, this_obj, parameter_data);
+
+        ply_list_node_t *node_data = ply_list_get_first_node (parameter_data);
+        while (node_data) {
+                script_obj_t *data_obj = ply_list_node_get_data (node_data);
+                script_obj_unref (data_obj);
+                node_data = ply_list_get_next_node (parameter_data, node_data);
+        }
+        ply_list_free (parameter_data);
+
+        script_obj_unref (func_obj);
+        if (this_obj) script_obj_unref (this_obj);
+
+        return reply.object ? reply.object : script_obj_new_null ();
 }
 
 static script_obj_t *script_evaluate (script_state_t *state,
                                       script_exp_t   *exp)
 {
-  switch (exp->type)
-    {
-      case SCRIPT_EXP_TYPE_PLUS:
+        switch (exp->type) {
+        case SCRIPT_EXP_TYPE_PLUS:
         {
-          return script_evaluate_apply_function (state, exp, script_obj_plus);
+                return script_evaluate_apply_function (state, exp, script_obj_plus);
         }
-      case SCRIPT_EXP_TYPE_MINUS:
+        case SCRIPT_EXP_TYPE_MINUS:
         {
-          return script_evaluate_apply_function (state, exp, script_obj_minus);
+                return script_evaluate_apply_function (state, exp, script_obj_minus);
         }
 
-      case SCRIPT_EXP_TYPE_MUL:
+        case SCRIPT_EXP_TYPE_MUL:
         {
-          return script_evaluate_apply_function (state, exp, script_obj_mul);
+                return script_evaluate_apply_function (state, exp, script_obj_mul);
         }
-      case SCRIPT_EXP_TYPE_DIV:
+        case SCRIPT_EXP_TYPE_DIV:
         {
-          return script_evaluate_apply_function (state, exp, script_obj_div);
+                return script_evaluate_apply_function (state, exp, script_obj_div);
         }
-      case SCRIPT_EXP_TYPE_MOD:
+        case SCRIPT_EXP_TYPE_MOD:
         {
-          return script_evaluate_apply_function (state, exp, script_obj_mod);
+                return script_evaluate_apply_function (state, exp, script_obj_mod);
         }
 
-      case SCRIPT_EXP_TYPE_EQ:
+        case SCRIPT_EXP_TYPE_EQ:
         {
-          return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_EQ);
+                return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_EQ);
         }
-      case SCRIPT_EXP_TYPE_NE:
+        case SCRIPT_EXP_TYPE_NE:
         {
-          return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_NE |
-                                                  SCRIPT_OBJ_CMP_RESULT_LT |
-                                                  SCRIPT_OBJ_CMP_RESULT_GT);
+                return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_NE |
+                                            SCRIPT_OBJ_CMP_RESULT_LT |
+                                            SCRIPT_OBJ_CMP_RESULT_GT);
         }
-      case SCRIPT_EXP_TYPE_GT:
+        case SCRIPT_EXP_TYPE_GT:
         {
-          return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_GT);
+                return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_GT);
         }
-      case SCRIPT_EXP_TYPE_GE:
+        case SCRIPT_EXP_TYPE_GE:
         {
-          return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_GT |
-                                                  SCRIPT_OBJ_CMP_RESULT_EQ);
+                return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_GT |
+                                            SCRIPT_OBJ_CMP_RESULT_EQ);
         }
-      case SCRIPT_EXP_TYPE_LT:
+        case SCRIPT_EXP_TYPE_LT:
         {
-          return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_LT);
+                return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_LT);
         }
-      case SCRIPT_EXP_TYPE_LE:
+        case SCRIPT_EXP_TYPE_LE:
         {
-          return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_LT |
-                                                  SCRIPT_OBJ_CMP_RESULT_EQ);
+                return script_evaluate_cmp (state, exp, SCRIPT_OBJ_CMP_RESULT_LT |
+                                            SCRIPT_OBJ_CMP_RESULT_EQ);
         }
 
-      case SCRIPT_EXP_TYPE_AND:
-      case SCRIPT_EXP_TYPE_OR:
+        case SCRIPT_EXP_TYPE_AND:
+        case SCRIPT_EXP_TYPE_OR:
         {
-          return script_evaluate_logic (state, exp);
+                return script_evaluate_logic (state, exp);
         }
 
-      case SCRIPT_EXP_TYPE_EXTEND:
+        case SCRIPT_EXP_TYPE_EXTEND:
         {
-          return script_evaluate_apply_function (state, exp, script_obj_new_extend);
+                return script_evaluate_apply_function (state, exp, script_obj_new_extend);
         }
 
-      case SCRIPT_EXP_TYPE_NOT:
-      case SCRIPT_EXP_TYPE_POS:
-      case SCRIPT_EXP_TYPE_NEG:
-      case SCRIPT_EXP_TYPE_PRE_INC:
-      case SCRIPT_EXP_TYPE_PRE_DEC:
-      case SCRIPT_EXP_TYPE_POST_INC:
-      case SCRIPT_EXP_TYPE_POST_DEC:
+        case SCRIPT_EXP_TYPE_NOT:
+        case SCRIPT_EXP_TYPE_POS:
+        case SCRIPT_EXP_TYPE_NEG:
+        case SCRIPT_EXP_TYPE_PRE_INC:
+        case SCRIPT_EXP_TYPE_PRE_DEC:
+        case SCRIPT_EXP_TYPE_POST_INC:
+        case SCRIPT_EXP_TYPE_POST_DEC:
         {
-          return script_evaluate_unary (state, exp);
+                return script_evaluate_unary (state, exp);
         }
 
-      case SCRIPT_EXP_TYPE_TERM_NUMBER:
+        case SCRIPT_EXP_TYPE_TERM_NUMBER:
         {
-          return script_obj_new_number (exp->data.number);
+                return script_obj_new_number (exp->data.number);
         }
 
-      case SCRIPT_EXP_TYPE_TERM_STRING:
+        case SCRIPT_EXP_TYPE_TERM_STRING:
         {
-          return script_obj_new_string (exp->data.string);
+                return script_obj_new_string (exp->data.string);
         }
 
-      case SCRIPT_EXP_TYPE_TERM_NULL:
+        case SCRIPT_EXP_TYPE_TERM_NULL:
         {
-          return script_obj_new_null ();
+                return script_obj_new_null ();
         }
 
-      case SCRIPT_EXP_TYPE_TERM_LOCAL:
+        case SCRIPT_EXP_TYPE_TERM_LOCAL:
         {
-          script_obj_ref (state->local);
-          return state->local;
+                script_obj_ref (state->local);
+                return state->local;
         }
 
-      case SCRIPT_EXP_TYPE_TERM_GLOBAL:
+        case SCRIPT_EXP_TYPE_TERM_GLOBAL:
         {
-          script_obj_ref (state->global);
-          return state->global;
+                script_obj_ref (state->global);
+                return state->global;
         }
 
-      case SCRIPT_EXP_TYPE_TERM_THIS:
+        case SCRIPT_EXP_TYPE_TERM_THIS:
         {
-          script_obj_ref (state->this);
-          return state->this;
+                script_obj_ref (state->this);
+                return state->this;
         }
 
-      case SCRIPT_EXP_TYPE_TERM_SET:
+        case SCRIPT_EXP_TYPE_TERM_SET:
         {
-          return script_evaluate_set (state, exp);
+                return script_evaluate_set (state, exp);
         }
 
-      case SCRIPT_EXP_TYPE_TERM_VAR:
+        case SCRIPT_EXP_TYPE_TERM_VAR:
         {
-          return script_evaluate_var (state, exp);
+                return script_evaluate_var (state, exp);
         }
 
-      case SCRIPT_EXP_TYPE_ASSIGN:
+        case SCRIPT_EXP_TYPE_ASSIGN:
         {
-          return script_evaluate_assign (state, exp);
+                return script_evaluate_assign (state, exp);
         }
 
-      case SCRIPT_EXP_TYPE_ASSIGN_PLUS:
+        case SCRIPT_EXP_TYPE_ASSIGN_PLUS:
         {
-          return script_evaluate_apply_function_and_assign (state,
-                                                            exp,
-                                                            script_obj_plus);
+                return script_evaluate_apply_function_and_assign (state,
+                                                                  exp,
+                                                                  script_obj_plus);
         }
 
-      case SCRIPT_EXP_TYPE_ASSIGN_MINUS:
+        case SCRIPT_EXP_TYPE_ASSIGN_MINUS:
         {
-          return script_evaluate_apply_function_and_assign (state,
-                                                            exp,
-                                                            script_obj_minus);
+                return script_evaluate_apply_function_and_assign (state,
+                                                                  exp,
+                                                                  script_obj_minus);
         }
 
-      case SCRIPT_EXP_TYPE_ASSIGN_MUL:
+        case SCRIPT_EXP_TYPE_ASSIGN_MUL:
         {
-          return script_evaluate_apply_function_and_assign (state,
-                                                            exp,
-                                                            script_obj_mul);
+                return script_evaluate_apply_function_and_assign (state,
+                                                                  exp,
+                                                                  script_obj_mul);
         }
 
-      case SCRIPT_EXP_TYPE_ASSIGN_DIV:
+        case SCRIPT_EXP_TYPE_ASSIGN_DIV:
         {
-          return script_evaluate_apply_function_and_assign (state,
-                                                            exp,
-                                                            script_obj_div);
+                return script_evaluate_apply_function_and_assign (state,
+                                                                  exp,
+                                                                  script_obj_div);
         }
 
-      case SCRIPT_EXP_TYPE_ASSIGN_MOD:
+        case SCRIPT_EXP_TYPE_ASSIGN_MOD:
         {
-          return script_evaluate_apply_function_and_assign (state,
-                                                            exp,
-                                                            script_obj_mod);
+                return script_evaluate_apply_function_and_assign (state,
+                                                                  exp,
+                                                                  script_obj_mod);
         }
 
-      case SCRIPT_EXP_TYPE_ASSIGN_EXTEND:
+        case SCRIPT_EXP_TYPE_ASSIGN_EXTEND:
         {
-          return script_evaluate_apply_function_and_assign (state,
-                                                            exp,
-                                                            script_obj_new_extend);
+                return script_evaluate_apply_function_and_assign (state,
+                                                                  exp,
+                                                                  script_obj_new_extend);
         }
 
-      case SCRIPT_EXP_TYPE_HASH:
+        case SCRIPT_EXP_TYPE_HASH:
         {
-          return script_evaluate_hash (state, exp);
+                return script_evaluate_hash (state, exp);
         }
 
-      case SCRIPT_EXP_TYPE_FUNCTION_EXE:
+        case SCRIPT_EXP_TYPE_FUNCTION_EXE:
         {
-          return script_evaluate_func (state, exp);
+                return script_evaluate_func (state, exp);
         }
-      case SCRIPT_EXP_TYPE_FUNCTION_DEF:
+        case SCRIPT_EXP_TYPE_FUNCTION_DEF:
         {
-          return script_obj_new_function (exp->data.function_def);
+                return script_obj_new_function (exp->data.function_def);
+        }
         }
-    }
-  return script_obj_new_null ();
+        return script_obj_new_null ();
 }
 
 static script_return_t script_execute_list (script_state_t *state,
-                                            ply_list_t   *op_list)                        /* FIXME script_execute returns the return obj */
+                                            ply_list_t     *op_list)                      /* FIXME script_execute returns the return obj */
 {
-  script_return_t reply = script_return_normal ();
-  ply_list_node_t *node = ply_list_get_first_node (op_list);
-
-  for (node = ply_list_get_first_node (op_list);
-       node;
-       node = ply_list_get_next_node (op_list, node))
-    {
-      script_op_t *op = ply_list_node_get_data (node);
-      script_obj_unref (reply.object);
-      reply = script_execute (state, op);
-      switch (reply.type)
-        {
-          case SCRIPT_RETURN_TYPE_NORMAL:
-            break;
-          case SCRIPT_RETURN_TYPE_RETURN:
-          case SCRIPT_RETURN_TYPE_FAIL:
-          case SCRIPT_RETURN_TYPE_BREAK:
-          case SCRIPT_RETURN_TYPE_CONTINUE:
-            return reply;
-        }
-    }
-  return reply;
+        script_return_t reply = script_return_normal ();
+        ply_list_node_t *node = ply_list_get_first_node (op_list);
+
+        for (node = ply_list_get_first_node (op_list);
+             node;
+             node = ply_list_get_next_node (op_list, node)) {
+                script_op_t *op = ply_list_node_get_data (node);
+                script_obj_unref (reply.object);
+                reply = script_execute (state, op);
+                switch (reply.type) {
+                case SCRIPT_RETURN_TYPE_NORMAL:
+                        break;
+                case SCRIPT_RETURN_TYPE_RETURN:
+                case SCRIPT_RETURN_TYPE_FAIL:
+                case SCRIPT_RETURN_TYPE_BREAK:
+                case SCRIPT_RETURN_TYPE_CONTINUE:
+                        return reply;
+                }
+        }
+        return reply;
 }
 
 /* parameter_data list should be freed by caller */
@@ -592,195 +574,183 @@ static script_return_t script_execute_function_with_parlist (script_state_t    *
                                                              script_obj_t      *this,
                                                              ply_list_t        *parameter_data)
 {
-  script_state_t *sub_state = script_state_init_sub (state, this);
-  ply_list_t *parameter_names = function->parameters;
-  ply_list_node_t *node_name = ply_list_get_first_node (parameter_names);
-  ply_list_node_t *node_data = ply_list_get_first_node (parameter_data);
-  int index = 0;;
-  script_obj_t *arg_obj = script_obj_new_hash ();
-  
-  while (node_data)
-    {
-      script_obj_t *data_obj = ply_list_node_get_data (node_data);
-      char *name;
-      asprintf (&name, "%d", index);
-      index++;
-      script_obj_hash_add_element (arg_obj, data_obj, name);
-      free(name);
-      
-      if (node_name)
-        {
-          name = ply_list_node_get_data (node_name);
-          script_obj_hash_add_element (sub_state->local, data_obj, name);
-          node_name = ply_list_get_next_node (parameter_names, node_name);
-        }
-      node_data = ply_list_get_next_node (parameter_data, node_data);
-    }
-
-  script_obj_t *count_obj = script_obj_new_number (index);
-  script_obj_hash_add_element (arg_obj, count_obj, "count");
-  script_obj_hash_add_element (sub_state->local, arg_obj, "_args");
-  script_obj_unref (count_obj);
-  script_obj_unref (arg_obj);
-
-  if (this)
-    script_obj_hash_add_element (sub_state->local, this, "this");
-
-  script_return_t reply;
-  switch (function->type)
-    {
-      case SCRIPT_FUNCTION_TYPE_SCRIPT:
-        {
-          script_op_t *op = function->data.script;
-          reply = script_execute (sub_state, op);
-          break;
-        }
-
-      case SCRIPT_FUNCTION_TYPE_NATIVE:
-        {
-          reply = function->data.native (sub_state, function->user_data);
-          break;
-        }
-    }
-  script_state_destroy (sub_state);
-  if (reply.type != SCRIPT_RETURN_TYPE_FAIL)
-    reply.type = SCRIPT_RETURN_TYPE_RETURN;
-  return reply;
-}
+        script_state_t *sub_state = script_state_init_sub (state, this);
+        ply_list_t *parameter_names = function->parameters;
+        ply_list_node_t *node_name = ply_list_get_first_node (parameter_names);
+        ply_list_node_t *node_data = ply_list_get_first_node (parameter_data);
+        int index = 0;
+        script_obj_t *arg_obj = script_obj_new_hash ();
+
+        while (node_data) {
+                script_obj_t *data_obj = ply_list_node_get_data (node_data);
+                char *name;
+                asprintf (&name, "%d", index);
+                index++;
+                script_obj_hash_add_element (arg_obj, data_obj, name);
+                free (name);
+
+                if (node_name) {
+                        name = ply_list_node_get_data (node_name);
+                        script_obj_hash_add_element (sub_state->local, data_obj, name);
+                        node_name = ply_list_get_next_node (parameter_names, node_name);
+                }
+                node_data = ply_list_get_next_node (parameter_data, node_data);
+        }
 
-script_return_t script_execute_object (script_state_t    *state,
-                                       script_obj_t      *function,
-                                       script_obj_t      *this,
-                                       script_obj_t      *first_arg,
-                                       ...)
-{
-  script_return_t reply;
-  va_list args;
-  script_obj_t *arg;
-  ply_list_t *parameter_data = ply_list_new ();
-
-  arg = first_arg;
-  va_start (args, first_arg);
-  while (arg)
-    {
-      ply_list_append_data (parameter_data, arg);
-      arg = va_arg (args, script_obj_t *);
-    }
-  va_end (args);
-
-  reply = script_execute_object_with_parlist (state, function, this, parameter_data);
-  ply_list_free (parameter_data);
-
-  return reply;
-}
+        script_obj_t *count_obj = script_obj_new_number (index);
+        script_obj_hash_add_element (arg_obj, count_obj, "count");
+        script_obj_hash_add_element (sub_state->local, arg_obj, "_args");
+        script_obj_unref (count_obj);
+        script_obj_unref (arg_obj);
 
-script_return_t script_execute (script_state_t *state,
-                                script_op_t    *op)
-{
-  script_return_t reply = script_return_normal ();
-  if (!op) return reply;
-  switch (op->type)
-    {
-      case SCRIPT_OP_TYPE_EXPRESSION:
-        {
-          reply.object = script_evaluate (state, op->data.exp);
-          break;
-        }
+        if (this)
+                script_obj_hash_add_element (sub_state->local, this, "this");
 
-      case SCRIPT_OP_TYPE_OP_BLOCK:
+        script_return_t reply;
+        switch (function->type) {
+        case SCRIPT_FUNCTION_TYPE_SCRIPT:
         {
-          reply = script_execute_list (state, op->data.list);
-          break;
+                script_op_t *op = function->data.script;
+                reply = script_execute (sub_state, op);
+                break;
         }
 
-      case SCRIPT_OP_TYPE_IF:
+        case SCRIPT_FUNCTION_TYPE_NATIVE:
         {
-          script_obj_t *obj = script_evaluate (state, op->data.cond_op.cond);
-          if (script_obj_as_bool (obj))
-            reply = script_execute (state, op->data.cond_op.op1);
-          else
-            reply = script_execute (state, op->data.cond_op.op2);
-          script_obj_unref (obj);
-          break;
+                reply = function->data.native (sub_state, function->user_data);
+                break;
         }
+        }
+        script_state_destroy (sub_state);
+        if (reply.type != SCRIPT_RETURN_TYPE_FAIL)
+                reply.type = SCRIPT_RETURN_TYPE_RETURN;
+        return reply;
+}
 
-      case SCRIPT_OP_TYPE_DO_WHILE:
-      case SCRIPT_OP_TYPE_WHILE:
-      case SCRIPT_OP_TYPE_FOR:
-        {
-          script_obj_t *obj = NULL;
-          bool cond = false;
-          if (op->type == SCRIPT_OP_TYPE_DO_WHILE) cond = true;
-          while (1)
-            {
-              if (!cond)
-                {
-                  obj = script_evaluate (state, op->data.cond_op.cond);
-                  cond = script_obj_as_bool (obj);
-                  script_obj_unref (obj);
-                }
-               
-              if (cond)
-                {
-                  script_obj_unref (reply.object);
-                  reply = script_execute (state, op->data.cond_op.op1);
-                  switch (reply.type)
-                    {
-                      case SCRIPT_RETURN_TYPE_NORMAL:
-                        break;
+script_return_t script_execute_object (script_state_t *state,
+                                       script_obj_t   *function,
+                                       script_obj_t   *this,
+                                       script_obj_t   *first_arg,
+                                       ...)
+{
+        script_return_t reply;
+        va_list args;
+        script_obj_t *arg;
+        ply_list_t *parameter_data = ply_list_new ();
 
-                      case SCRIPT_RETURN_TYPE_RETURN:
-                      case SCRIPT_RETURN_TYPE_FAIL:
-                        return reply;
+        arg = first_arg;
+        va_start (args, first_arg);
+        while (arg) {
+                ply_list_append_data (parameter_data, arg);
+                arg = va_arg (args, script_obj_t *);
+        }
+        va_end (args);
 
-                      case SCRIPT_RETURN_TYPE_BREAK:
-                        return script_return_normal();
+        reply = script_execute_object_with_parlist (state, function, this, parameter_data);
+        ply_list_free (parameter_data);
 
-                      case SCRIPT_RETURN_TYPE_CONTINUE:
-                        break;
-                    }
-                  if (op->data.cond_op.op2)
-                    {
-                      script_obj_unref (reply.object);
-                      reply = script_execute (state, op->data.cond_op.op2);
-                    }
-                }
-              else
-                {
-                  break;
+        return reply;
+}
+
+script_return_t script_execute (script_state_t *state,
+                                script_op_t    *op)
+{
+        script_return_t reply = script_return_normal ();
+
+        if (!op) return reply;
+        switch (op->type) {
+        case SCRIPT_OP_TYPE_EXPRESSION:
+        {
+                reply.object = script_evaluate (state, op->data.exp);
+                break;
+        }
+
+        case SCRIPT_OP_TYPE_OP_BLOCK:
+        {
+                reply = script_execute_list (state, op->data.list);
+                break;
+        }
+
+        case SCRIPT_OP_TYPE_IF:
+        {
+                script_obj_t *obj = script_evaluate (state, op->data.cond_op.cond);
+                if (script_obj_as_bool (obj))
+                        reply = script_execute (state, op->data.cond_op.op1);
+                else
+                        reply = script_execute (state, op->data.cond_op.op2);
+                script_obj_unref (obj);
+                break;
+        }
+
+        case SCRIPT_OP_TYPE_DO_WHILE:
+        case SCRIPT_OP_TYPE_WHILE:
+        case SCRIPT_OP_TYPE_FOR:
+        {
+                script_obj_t *obj = NULL;
+                bool cond = false;
+                if (op->type == SCRIPT_OP_TYPE_DO_WHILE) cond = true;
+                while (1) {
+                        if (!cond) {
+                                obj = script_evaluate (state, op->data.cond_op.cond);
+                                cond = script_obj_as_bool (obj);
+                                script_obj_unref (obj);
+                        }
+
+                        if (cond) {
+                                script_obj_unref (reply.object);
+                                reply = script_execute (state, op->data.cond_op.op1);
+                                switch (reply.type) {
+                                case SCRIPT_RETURN_TYPE_NORMAL:
+                                        break;
+
+                                case SCRIPT_RETURN_TYPE_RETURN:
+                                case SCRIPT_RETURN_TYPE_FAIL:
+                                        return reply;
+
+                                case SCRIPT_RETURN_TYPE_BREAK:
+                                        return script_return_normal ();
+
+                                case SCRIPT_RETURN_TYPE_CONTINUE:
+                                        break;
+                                }
+                                if (op->data.cond_op.op2) {
+                                        script_obj_unref (reply.object);
+                                        reply = script_execute (state, op->data.cond_op.op2);
+                                }
+                        } else {
+                                break;
+                        }
+                        cond = false;
                 }
-              cond = false;
-            }
-          break;
+                break;
         }
 
-      case SCRIPT_OP_TYPE_RETURN:
+        case SCRIPT_OP_TYPE_RETURN:
         {
-          script_obj_t *obj;
-          if (op->data.exp) obj = script_evaluate (state, op->data.exp);
-          else obj = script_obj_new_null ();
-          reply = script_return_obj (obj);
-          break;
+                script_obj_t *obj;
+                if (op->data.exp) obj = script_evaluate (state, op->data.exp);
+                else obj = script_obj_new_null ();
+                reply = script_return_obj (obj);
+                break;
         }
 
-      case SCRIPT_OP_TYPE_FAIL:
+        case SCRIPT_OP_TYPE_FAIL:
         {
-          reply = script_return_fail ();
-          break;
+                reply = script_return_fail ();
+                break;
         }
 
-      case SCRIPT_OP_TYPE_BREAK:
+        case SCRIPT_OP_TYPE_BREAK:
         {
-          reply = script_return_break ();
-          break;
+                reply = script_return_break ();
+                break;
         }
 
-      case SCRIPT_OP_TYPE_CONTINUE:
+        case SCRIPT_OP_TYPE_CONTINUE:
         {
-          reply = script_return_continue ();
-          break;
+                reply = script_return_continue ();
+                break;
+        }
         }
-    }
-  return reply;
+        return reply;
 }
-
diff --git a/src/plugins/splash/script/script-execute.h b/src/plugins/splash/script/script-execute.h
index efba3ed..74a0a47 100644
--- a/src/plugins/splash/script/script-execute.h
+++ b/src/plugins/splash/script/script-execute.h
@@ -26,10 +26,10 @@
 
 script_return_t script_execute (script_state_t *state,
                                 script_op_t    *op);
-script_return_t script_execute_object (script_state_t    *state,
-                                       script_obj_t      *function,
-                                       script_obj_t      *this,
-                                       script_obj_t      *first_arg,
+script_return_t script_execute_object (script_state_t * state,
+                                       script_obj_t * function,
+                                       script_obj_t * this,
+                                       script_obj_t * first_arg,
                                        ...);
 
 #endif /* SCRIPT_EXECUTE_H */
diff --git a/src/plugins/splash/script/script-lib-image.c b/src/plugins/splash/script/script-lib-image.c
index f08be31..a202702 100644
--- a/src/plugins/splash/script/script-lib-image.c
+++ b/src/plugins/splash/script/script-lib-image.c
@@ -42,260 +42,250 @@
 
 static void image_free (script_obj_t *obj)
 {
-  ply_pixel_buffer_t *image = obj->data.native.object_data;
+        ply_pixel_buffer_t *image = obj->data.native.object_data;
 
-  ply_pixel_buffer_free (image);
+        ply_pixel_buffer_free (image);
 }
 
 static script_return_t image_new (script_state_t *state,
                                   void           *user_data)
 {
-  script_lib_image_data_t *data = user_data;
-  script_obj_t *reply;
-  char *path_filename;
-  char *filename = script_obj_hash_get_string (state->local, "filename");
-  char *test_string = filename;
-  const char *prefix_string = "special://";
-
-  while (*test_string && *prefix_string && *test_string == *prefix_string)
-    {
-      test_string++;
-      prefix_string++;
-    }
-  if (!*prefix_string)
-    {
-      if (strcmp (test_string, "logo") == 0)
-        path_filename = strdup (PLYMOUTH_LOGO_FILE);
-      else
-        path_filename = strdup ("");
-    }
-  else
-    asprintf (&path_filename, "%s/%s", data->image_dir, filename);
-  ply_image_t *file_image = ply_image_new (path_filename);
-  if (ply_image_load (file_image))
-    {
-      ply_pixel_buffer_t *buffer = ply_image_convert_to_pixel_buffer (file_image);
-      reply = script_obj_new_native (buffer, data->class);
-    }
-  else
-    {
-      ply_image_free (file_image);
-      reply = script_obj_new_null ();
-    }
-  free (filename);
-  free (path_filename);
-  return script_return_obj (reply);
+        script_lib_image_data_t *data = user_data;
+        script_obj_t *reply;
+        char *path_filename;
+        char *filename = script_obj_hash_get_string (state->local, "filename");
+        char *test_string = filename;
+        const char *prefix_string = "special://";
+
+        while (*test_string && *prefix_string && *test_string == *prefix_string) {
+                test_string++;
+                prefix_string++;
+        }
+        if (!*prefix_string) {
+                if (strcmp (test_string, "logo") == 0)
+                        path_filename = strdup (PLYMOUTH_LOGO_FILE);
+                else
+                        path_filename = strdup ("");
+        } else {
+                asprintf (&path_filename, "%s/%s", data->image_dir, filename);
+        }
+        ply_image_t *file_image = ply_image_new (path_filename);
+        if (ply_image_load (file_image)) {
+                ply_pixel_buffer_t *buffer = ply_image_convert_to_pixel_buffer (file_image);
+                reply = script_obj_new_native (buffer, data->class);
+        } else {
+                ply_image_free (file_image);
+                reply = script_obj_new_null ();
+        }
+        free (filename);
+        free (path_filename);
+        return script_return_obj (reply);
 }
 
 static script_return_t image_get_width (script_state_t *state,
                                         void           *user_data)
 {
-  script_lib_image_data_t *data = user_data;
-  ply_rectangle_t size;
-  ply_pixel_buffer_t *image;
-  
-  image = script_obj_as_native_of_class (state->this, data->class);
-  if (!image) return script_return_obj_null ();
-  
-  ply_pixel_buffer_get_size (image, &size);
-  
-  return script_return_obj (script_obj_new_number (size.width));
+        script_lib_image_data_t *data = user_data;
+        ply_rectangle_t size;
+        ply_pixel_buffer_t *image;
+
+        image = script_obj_as_native_of_class (state->this, data->class);
+        if (!image) return script_return_obj_null ();
+
+        ply_pixel_buffer_get_size (image, &size);
+
+        return script_return_obj (script_obj_new_number (size.width));
 }
 
 static script_return_t image_get_height (script_state_t *state,
                                          void           *user_data)
 {
-  script_lib_image_data_t *data = user_data;
-  ply_rectangle_t size;
-  ply_pixel_buffer_t *image;
-  
-  image = script_obj_as_native_of_class (state->this, data->class);
-  if (!image) return script_return_obj_null ();
-  
-  ply_pixel_buffer_get_size (image, &size);
-  
-  return script_return_obj (script_obj_new_number (size.height));
+        script_lib_image_data_t *data = user_data;
+        ply_rectangle_t size;
+        ply_pixel_buffer_t *image;
+
+        image = script_obj_as_native_of_class (state->this, data->class);
+        if (!image) return script_return_obj_null ();
+
+        ply_pixel_buffer_get_size (image, &size);
+
+        return script_return_obj (script_obj_new_number (size.height));
 }
 
 static script_return_t image_rotate (script_state_t *state,
                                      void           *user_data)
 {
-  script_lib_image_data_t *data = user_data;
-  ply_pixel_buffer_t *image = script_obj_as_native_of_class (state->this, data->class);
-  float angle = script_obj_hash_get_number (state->local, "angle");
-  ply_rectangle_t size;
-  
-  if (image)
-    {
-      ply_pixel_buffer_get_size (image, &size);
-      ply_pixel_buffer_t *new_image = ply_pixel_buffer_rotate (image,
-                                                               size.width / 2,
-                                                               size.height / 2,
-                                                               angle);
-      return script_return_obj (script_obj_new_native (new_image, data->class));
-    }
-  return script_return_obj_null ();
+        script_lib_image_data_t *data = user_data;
+        ply_pixel_buffer_t *image = script_obj_as_native_of_class (state->this, data->class);
+        float angle = script_obj_hash_get_number (state->local, "angle");
+        ply_rectangle_t size;
+
+        if (image) {
+                ply_pixel_buffer_get_size (image, &size);
+                ply_pixel_buffer_t *new_image = ply_pixel_buffer_rotate (image,
+                                                                         size.width / 2,
+                                                                         size.height / 2,
+                                                                         angle);
+                return script_return_obj (script_obj_new_native (new_image, data->class));
+        }
+        return script_return_obj_null ();
 }
 
 static script_return_t image_scale (script_state_t *state,
                                     void           *user_data)
 {
-  script_lib_image_data_t *data = user_data;
-  ply_pixel_buffer_t *image = script_obj_as_native_of_class (state->this, data->class);
-  int width = script_obj_hash_get_number (state->local, "width");
-  int height = script_obj_hash_get_number (state->local, "height");
-
-  if (image)
-    {
-      ply_pixel_buffer_t *new_image = ply_pixel_buffer_resize (image, width, height);
-      return script_return_obj (script_obj_new_native (new_image, data->class));
-    }
-  return script_return_obj_null ();
+        script_lib_image_data_t *data = user_data;
+        ply_pixel_buffer_t *image = script_obj_as_native_of_class (state->this, data->class);
+        int width = script_obj_hash_get_number (state->local, "width");
+        int height = script_obj_hash_get_number (state->local, "height");
+
+        if (image) {
+                ply_pixel_buffer_t *new_image = ply_pixel_buffer_resize (image, width, height);
+                return script_return_obj (script_obj_new_native (new_image, data->class));
+        }
+        return script_return_obj_null ();
 }
 
 static script_return_t image_text (script_state_t *state,
                                    void           *user_data)
 {
-  script_lib_image_data_t *data = user_data;
-  ply_pixel_buffer_t *image;
-  ply_label_t *label;
-  script_obj_t *alpha_obj, *font_obj, *align_obj;
-  int width, height;
-  int align = PLY_LABEL_ALIGN_LEFT;
-  char *font;
-  
-  char *text = script_obj_hash_get_string (state->local, "text");
-  
-  float alpha;
-  float red = CLAMP(script_obj_hash_get_number (state->local, "red"), 0, 1);
-  float green = CLAMP(script_obj_hash_get_number (state->local, "green"), 0, 1);
-  float blue = CLAMP(script_obj_hash_get_number (state->local, "blue"), 0, 1);
-
-  alpha_obj = script_obj_hash_peek_element (state->local, "alpha");
-
-  if (script_obj_is_number (alpha_obj))
-    {
-      alpha = CLAMP(script_obj_as_number (alpha_obj), 0, 1);
-    }
-  else
-    alpha = 1;
-  script_obj_unref(alpha_obj);
-
-  font_obj = script_obj_hash_peek_element (state->local, "font");
-
-  if (script_obj_is_string (font_obj))
-    font = script_obj_as_string (font_obj);
-  else
-    font = NULL;
-
-  script_obj_unref(font_obj);
-
-  align_obj = script_obj_hash_peek_element(state->local, "align");
-
-  if (script_obj_is_string(align_obj)) {
-    char *align_str = script_obj_as_string(align_obj);
-
-    if(!strcmp("left", align_str))
-      align = PLY_LABEL_ALIGN_LEFT;
-    else if(!strcmp("center", align_str))
-      align = PLY_LABEL_ALIGN_CENTER;
-    else if(!strcmp("right", align_str))
-      align = PLY_LABEL_ALIGN_RIGHT;
-    else
-      ply_error("Unrecognized Image.Text alignment string '%s'. "
-	      "Expecting 'left', 'center', or 'right'\n",
-		align_str);
-    free(align_str);
-  }
-  script_obj_unref(align_obj);
-
-  if (!text) return script_return_obj_null ();
-
-  label = ply_label_new ();
-  ply_label_set_text (label, text);
-  if (font)
-    ply_label_set_font (label, font);
-  ply_label_set_alignment(label, align);
-  ply_label_set_color (label, red, green, blue, alpha);
-  ply_label_show (label, NULL, 0, 0);
-  
-  width = ply_label_get_width (label);
-  height = ply_label_get_height (label);
-  
-  image = ply_pixel_buffer_new (width, height);
-  ply_label_draw_area (label, image, 0, 0, width, height);
-  
-  free (text);
-  free (font);
-  ply_label_free (label);
-  
-  return script_return_obj (script_obj_new_native (image, data->class));
+        script_lib_image_data_t *data = user_data;
+        ply_pixel_buffer_t *image;
+        ply_label_t *label;
+        script_obj_t *alpha_obj, *font_obj, *align_obj;
+        int width, height;
+        int align = PLY_LABEL_ALIGN_LEFT;
+        char *font;
+
+        char *text = script_obj_hash_get_string (state->local, "text");
+
+        float alpha;
+        float red = CLAMP (script_obj_hash_get_number (state->local, "red"), 0, 1);
+        float green = CLAMP (script_obj_hash_get_number (state->local, "green"), 0, 1);
+        float blue = CLAMP (script_obj_hash_get_number (state->local, "blue"), 0, 1);
+
+        alpha_obj = script_obj_hash_peek_element (state->local, "alpha");
+
+        if (script_obj_is_number (alpha_obj))
+                alpha = CLAMP (script_obj_as_number (alpha_obj), 0, 1);
+        else
+                alpha = 1;
+        script_obj_unref (alpha_obj);
+
+        font_obj = script_obj_hash_peek_element (state->local, "font");
+
+        if (script_obj_is_string (font_obj))
+                font = script_obj_as_string (font_obj);
+        else
+                font = NULL;
+
+        script_obj_unref (font_obj);
+
+        align_obj = script_obj_hash_peek_element (state->local, "align");
+
+        if (script_obj_is_string (align_obj)) {
+                char *align_str = script_obj_as_string (align_obj);
+
+                if (!strcmp ("left", align_str))
+                        align = PLY_LABEL_ALIGN_LEFT;
+                else if (!strcmp ("center", align_str))
+                        align = PLY_LABEL_ALIGN_CENTER;
+                else if (!strcmp ("right", align_str))
+                        align = PLY_LABEL_ALIGN_RIGHT;
+                else
+                        ply_error ("Unrecognized Image.Text alignment string '%s'. "
+                                   "Expecting 'left', 'center', or 'right'\n",
+                                   align_str);
+                free (align_str);
+        }
+        script_obj_unref (align_obj);
+
+        if (!text) return script_return_obj_null ();
+
+        label = ply_label_new ();
+        ply_label_set_text (label, text);
+        if (font)
+                ply_label_set_font (label, font);
+        ply_label_set_alignment (label, align);
+        ply_label_set_color (label, red, green, blue, alpha);
+        ply_label_show (label, NULL, 0, 0);
+
+        width = ply_label_get_width (label);
+        height = ply_label_get_height (label);
+
+        image = ply_pixel_buffer_new (width, height);
+        ply_label_draw_area (label, image, 0, 0, width, height);
+
+        free (text);
+        free (font);
+        ply_label_free (label);
+
+        return script_return_obj (script_obj_new_native (image, data->class));
 }
 
 script_lib_image_data_t *script_lib_image_setup (script_state_t *state,
-                                                 char         *image_dir)
+                                                 char           *image_dir)
 {
-  script_lib_image_data_t *data = malloc (sizeof (script_lib_image_data_t));
-
-  data->class = script_obj_native_class_new (image_free, "image", data);
-  data->image_dir = strdup (image_dir);
-
-  script_obj_t *image_hash = script_obj_hash_get_element (state->global, "Image");
-  
-  script_add_native_function (image_hash,
-                              "_New",
-                              image_new,
-                              data,
-                              "filename",
-                              NULL);
-  script_add_native_function (image_hash,
-                              "_Rotate",
-                              image_rotate,
-                              data,
-                              "angle",
-                              NULL);
-  script_add_native_function (image_hash,
-                              "_Scale",
-                              image_scale,
-                              data,
-                              "width",
-                              "height",
-                              NULL);
-  script_add_native_function (image_hash,
-                              "GetWidth",
-                              image_get_width,
-                              data,
-                              NULL);
-  script_add_native_function (image_hash,
-                              "GetHeight",
-                              image_get_height,
-                              data,
-                              NULL);
-  script_add_native_function (image_hash,
-                              "_Text",
-                              image_text,
-                              data,
-                              "text",
-                              "red",
-                              "green",
-                              "blue",
-                              "alpha",
-                              "font",
-                              "align",
-                              NULL);
-
-  script_obj_unref (image_hash);
-  data->script_main_op = script_parse_string (script_lib_image_string, "script-lib-image.script");
-  script_return_t ret = script_execute (state, data->script_main_op);
-  script_obj_unref (ret.object);
-  return data;
+        script_lib_image_data_t *data = malloc (sizeof(script_lib_image_data_t));
+
+        data->class = script_obj_native_class_new (image_free, "image", data);
+        data->image_dir = strdup (image_dir);
+
+        script_obj_t *image_hash = script_obj_hash_get_element (state->global, "Image");
+
+        script_add_native_function (image_hash,
+                                    "_New",
+                                    image_new,
+                                    data,
+                                    "filename",
+                                    NULL);
+        script_add_native_function (image_hash,
+                                    "_Rotate",
+                                    image_rotate,
+                                    data,
+                                    "angle",
+                                    NULL);
+        script_add_native_function (image_hash,
+                                    "_Scale",
+                                    image_scale,
+                                    data,
+                                    "width",
+                                    "height",
+                                    NULL);
+        script_add_native_function (image_hash,
+                                    "GetWidth",
+                                    image_get_width,
+                                    data,
+                                    NULL);
+        script_add_native_function (image_hash,
+                                    "GetHeight",
+                                    image_get_height,
+                                    data,
+                                    NULL);
+        script_add_native_function (image_hash,
+                                    "_Text",
+                                    image_text,
+                                    data,
+                                    "text",
+                                    "red",
+                                    "green",
+                                    "blue",
+                                    "alpha",
+                                    "font",
+                                    "align",
+                                    NULL);
+
+        script_obj_unref (image_hash);
+        data->script_main_op = script_parse_string (script_lib_image_string, "script-lib-image.script");
+        script_return_t ret = script_execute (state, data->script_main_op);
+        script_obj_unref (ret.object);
+        return data;
 }
 
 void script_lib_image_destroy (script_lib_image_data_t *data)
 {
-  script_obj_native_class_destroy (data->class);
-  free (data->image_dir);
-  script_parse_op_free (data->script_main_op);
-  free (data);
+        script_obj_native_class_destroy (data->class);
+        free (data->image_dir);
+        script_parse_op_free (data->script_main_op);
+        free (data);
 }
-
diff --git a/src/plugins/splash/script/script-lib-image.h b/src/plugins/splash/script/script-lib-image.h
index d6b9508..7a1371a 100644
--- a/src/plugins/splash/script/script-lib-image.h
+++ b/src/plugins/splash/script/script-lib-image.h
@@ -26,9 +26,9 @@
 
 typedef struct
 {
-  script_obj_native_class_t *class;
-  script_op_t               *script_main_op;
-  char *image_dir;
+        script_obj_native_class_t *class;
+        script_op_t               *script_main_op;
+        char                      *image_dir;
 } script_lib_image_data_t;
 
 script_lib_image_data_t *script_lib_image_setup (script_state_t *state,
diff --git a/src/plugins/splash/script/script-lib-math.c b/src/plugins/splash/script/script-lib-math.c
index 3f2dc79..db763b2 100644
--- a/src/plugins/splash/script/script-lib-math.c
+++ b/src/plugins/splash/script/script-lib-math.c
@@ -40,90 +40,91 @@
 static script_return_t script_lib_math_double_from_double_function (script_state_t *state,
                                                                     void           *user_data)
 {
-  double (*function)(double) = user_data;
-  double value = script_obj_hash_get_number (state->local, "value");
-  double reply_double = function (value);
-  return script_return_obj (script_obj_new_number (reply_double));
+        double (*function)(double) = user_data;
+        double value = script_obj_hash_get_number (state->local, "value");
+        double reply_double = function (value);
+        return script_return_obj (script_obj_new_number (reply_double));
 }
 
 static script_return_t script_lib_math_double_from_double_double_function (script_state_t *state,
                                                                            void           *user_data)
 {
-  double (*function)(double, double) = user_data;
-  double value1 = script_obj_hash_get_number (state->local, "value_a");
-  double value2 = script_obj_hash_get_number (state->local, "value_b");
-  double reply_double = function (value1, value2);
-  return script_return_obj (script_obj_new_number (reply_double));
+        double (*function)(double,
+                           double) = user_data;
+        double value1 = script_obj_hash_get_number (state->local, "value_a");
+        double value2 = script_obj_hash_get_number (state->local, "value_b");
+        double reply_double = function (value1, value2);
+        return script_return_obj (script_obj_new_number (reply_double));
 }
 
 static script_return_t script_lib_math_random (script_state_t *state,
                                                void           *user_data)
 {
-  double reply_double = random() / ((double)RAND_MAX + 1);
-  return script_return_obj (script_obj_new_number (reply_double));
+        double reply_double = random () / ((double) RAND_MAX + 1);
+
+        return script_return_obj (script_obj_new_number (reply_double));
 }
 
 script_lib_math_data_t *script_lib_math_setup (script_state_t *state)
 {
-  script_lib_math_data_t *data = malloc (sizeof (script_lib_math_data_t));
+        script_lib_math_data_t *data = malloc (sizeof(script_lib_math_data_t));
 
-  srand ((int) ply_get_timestamp ());
+        srand ((int) ply_get_timestamp ());
 
-  script_obj_t *math_hash = script_obj_hash_get_element (state->global, "Math");
-  script_add_native_function (math_hash,
-                              "Cos",
-                              script_lib_math_double_from_double_function,
-                              cos,
-                              "value",
-                              NULL);
-  script_add_native_function (math_hash,
-                              "Sin",
-                              script_lib_math_double_from_double_function,
-                              sin,
-                              "value",
-                              NULL);
-  script_add_native_function (math_hash,
-                              "Tan",
-                              script_lib_math_double_from_double_function,
-                              tan,
-                              "value",
-                              NULL);
-  script_add_native_function (math_hash,
-                              "ATan2",
-                              script_lib_math_double_from_double_double_function,
-                              atan2,
-                              "value_a",
-                              "value_b",
-                              NULL);
-  script_add_native_function (math_hash,
-                              "Sqrt",
-                              script_lib_math_double_from_double_function,
-                              sqrt,
-                              "value",
-                              NULL);
-  script_add_native_function (math_hash,
-                              "Int",
-                              script_lib_math_double_from_double_function,
-                              floor,
-                              "value",
-                              NULL);
-  script_add_native_function (math_hash,
-                              "Random",
-                              script_lib_math_random,
-                              NULL,
-                              NULL);
-  script_obj_unref (math_hash);
+        script_obj_t *math_hash = script_obj_hash_get_element (state->global, "Math");
+        script_add_native_function (math_hash,
+                                    "Cos",
+                                    script_lib_math_double_from_double_function,
+                                    cos,
+                                    "value",
+                                    NULL);
+        script_add_native_function (math_hash,
+                                    "Sin",
+                                    script_lib_math_double_from_double_function,
+                                    sin,
+                                    "value",
+                                    NULL);
+        script_add_native_function (math_hash,
+                                    "Tan",
+                                    script_lib_math_double_from_double_function,
+                                    tan,
+                                    "value",
+                                    NULL);
+        script_add_native_function (math_hash,
+                                    "ATan2",
+                                    script_lib_math_double_from_double_double_function,
+                                    atan2,
+                                    "value_a",
+                                    "value_b",
+                                    NULL);
+        script_add_native_function (math_hash,
+                                    "Sqrt",
+                                    script_lib_math_double_from_double_function,
+                                    sqrt,
+                                    "value",
+                                    NULL);
+        script_add_native_function (math_hash,
+                                    "Int",
+                                    script_lib_math_double_from_double_function,
+                                    floor,
+                                    "value",
+                                    NULL);
+        script_add_native_function (math_hash,
+                                    "Random",
+                                    script_lib_math_random,
+                                    NULL,
+                                    NULL);
+        script_obj_unref (math_hash);
 
-  data->script_main_op = script_parse_string (script_lib_math_string, "script-lib-math.script");
-  script_return_t ret = script_execute (state, data->script_main_op);
-  script_obj_unref (ret.object);
+        data->script_main_op = script_parse_string (script_lib_math_string, "script-lib-math.script");
+        script_return_t ret = script_execute (state, data->script_main_op);
+        script_obj_unref (ret.object);
 
-  return data;
+        return data;
 }
 
 void script_lib_math_destroy (script_lib_math_data_t *data)
 {
-  script_parse_op_free (data->script_main_op);
-  free (data);
+        script_parse_op_free (data->script_main_op);
+        free (data);
 }
-
diff --git a/src/plugins/splash/script/script-lib-math.h b/src/plugins/splash/script/script-lib-math.h
index 10204b7..b13c824 100644
--- a/src/plugins/splash/script/script-lib-math.h
+++ b/src/plugins/splash/script/script-lib-math.h
@@ -26,7 +26,7 @@
 
 typedef struct
 {
-  script_op_t      *script_main_op;
+        script_op_t *script_main_op;
 } script_lib_math_data_t;
 
 script_lib_math_data_t *script_lib_math_setup (script_state_t *state);
diff --git a/src/plugins/splash/script/script-lib-plymouth.c b/src/plugins/splash/script/script-lib-plymouth.c
index ab2ec44..5705079 100644
--- a/src/plugins/splash/script/script-lib-plymouth.c
+++ b/src/plugins/splash/script/script-lib-plymouth.c
@@ -39,229 +39,235 @@
 static script_return_t plymouth_set_function (script_state_t *state,
                                               void           *user_data)
 {
-  script_obj_t **script_func = user_data;
-  script_obj_t *obj = script_obj_hash_get_element (state->local, "function");
+        script_obj_t **script_func = user_data;
+        script_obj_t *obj = script_obj_hash_get_element (state->local, "function");
 
-  script_obj_deref (&obj);
-  script_obj_unref (*script_func);
-  *script_func = obj;
-  return script_return_obj_null ();
+        script_obj_deref (&obj);
+        script_obj_unref (*script_func);
+        *script_func = obj;
+        return script_return_obj_null ();
 }
 
 static script_return_t plymouth_get_mode (script_state_t *state,
                                           void           *user_data)
 {
-  script_lib_plymouth_data_t *data = user_data;
-  script_obj_t *obj;
-  switch (data->mode)
-    {
-      case PLY_BOOT_SPLASH_MODE_BOOT_UP:
-        obj = script_obj_new_string ("boot");
-        break;
-      case PLY_BOOT_SPLASH_MODE_SHUTDOWN:
-        obj = script_obj_new_string ("shutdown");
-        break;
-      case PLY_BOOT_SPLASH_MODE_UPDATES:
-        obj = script_obj_new_string ("updates");
-        break;
-      case PLY_BOOT_SPLASH_MODE_INVALID:
-      default:
-        obj = script_obj_new_string ("unknown");
-        break;
-    }
-  return script_return_obj (obj);
+        script_lib_plymouth_data_t *data = user_data;
+        script_obj_t *obj;
+
+        switch (data->mode) {
+        case PLY_BOOT_SPLASH_MODE_BOOT_UP:
+                obj = script_obj_new_string ("boot");
+                break;
+        case PLY_BOOT_SPLASH_MODE_SHUTDOWN:
+                obj = script_obj_new_string ("shutdown");
+                break;
+        case PLY_BOOT_SPLASH_MODE_UPDATES:
+                obj = script_obj_new_string ("updates");
+                break;
+        case PLY_BOOT_SPLASH_MODE_INVALID:
+        default:
+                obj = script_obj_new_string ("unknown");
+                break;
+        }
+        return script_return_obj (obj);
 }
 
-script_lib_plymouth_data_t *script_lib_plymouth_setup (script_state_t         *state,
-                                                       ply_boot_splash_mode_t  mode)
+script_lib_plymouth_data_t *script_lib_plymouth_setup (script_state_t        *state,
+                                                       ply_boot_splash_mode_t mode)
 {
-  script_lib_plymouth_data_t *data = malloc (sizeof (script_lib_plymouth_data_t));
-
-  data->script_refresh_func = script_obj_new_null ();
-  data->script_boot_progress_func = script_obj_new_null ();
-  data->script_root_mounted_func = script_obj_new_null ();
-  data->script_keyboard_input_func = script_obj_new_null ();
-  data->script_update_status_func = script_obj_new_null ();
-  data->script_display_normal_func = script_obj_new_null ();
-  data->script_display_password_func = script_obj_new_null ();
-  data->script_display_question_func = script_obj_new_null ();
-  data->script_display_message_func = script_obj_new_null ();
-  data->script_hide_message_func = script_obj_new_null ();
-  data->script_quit_func = script_obj_new_null ();
-  data->mode = mode;
-  
-  script_obj_t *plymouth_hash = script_obj_hash_get_element (state->global, "Plymouth");
-  script_add_native_function (plymouth_hash,
-                              "SetRefreshFunction",
-                              plymouth_set_function,
-                              &data->script_refresh_func,
-                              "function",
-                              NULL);
-  script_add_native_function (plymouth_hash,
-                              "SetBootProgressFunction",
-                              plymouth_set_function,
-                              &data->script_boot_progress_func,
-                              "function",
-                              NULL);
-  script_add_native_function (plymouth_hash,
-                              "SetRootMountedFunction",
-                              plymouth_set_function,
-                              &data->script_root_mounted_func,
-                              "function",
-                              NULL);
-  script_add_native_function (plymouth_hash,
-                              "SetKeyboardInputFunction",
-                              plymouth_set_function,
-                              &data->script_keyboard_input_func,
-                              "function",
-                              NULL);
-  script_add_native_function (plymouth_hash,
-                              "SetUpdateStatusFunction",
-                              plymouth_set_function,
-                              &data->script_update_status_func,
-                              "function",
-                              NULL);
-  script_add_native_function (plymouth_hash,
-                              "SetDisplayNormalFunction",
-                              plymouth_set_function,
-                              &data->script_display_normal_func,
-                              "function",
-                              NULL);
-  script_add_native_function (plymouth_hash,
-                              "SetDisplayPasswordFunction",
-                              plymouth_set_function,
-                              &data->script_display_password_func,
-                              "function",
-                              NULL);
-  script_add_native_function (plymouth_hash,
-                              "SetDisplayQuestionFunction",
-                              plymouth_set_function,
-                              &data->script_display_question_func,
-                              "function",
-                              NULL);
-  script_add_native_function (plymouth_hash,
-                              "SetDisplayMessageFunction",
-                              plymouth_set_function,
-                              &data->script_display_message_func,
-                              "function",
-                              NULL);
-  script_add_native_function (plymouth_hash,
-                              "SetHideMessageFunction",
-                              plymouth_set_function,
-                              &data->script_hide_message_func,
-                              "function",
-                              NULL);
-  script_add_native_function (plymouth_hash,
-                              "SetQuitFunction",
-                              plymouth_set_function,
-                              &data->script_quit_func,
-                              "function",
-                              NULL);
-  script_add_native_function (plymouth_hash,
-                              "GetMode",
-                              plymouth_get_mode,
-                              data,
-                              NULL);
-  script_obj_unref (plymouth_hash);
-
-  data->script_main_op = script_parse_string (script_lib_plymouth_string, "script-lib-plymouth.script");
-  script_return_t ret = script_execute (state, data->script_main_op);
-  script_obj_unref (ret.object);                /* Throw anything sent back away */
-
-  return data;
+        script_lib_plymouth_data_t *data = malloc (sizeof(script_lib_plymouth_data_t));
+
+        data->script_refresh_func = script_obj_new_null ();
+        data->script_boot_progress_func = script_obj_new_null ();
+        data->script_root_mounted_func = script_obj_new_null ();
+        data->script_keyboard_input_func = script_obj_new_null ();
+        data->script_update_status_func = script_obj_new_null ();
+        data->script_display_normal_func = script_obj_new_null ();
+        data->script_display_password_func = script_obj_new_null ();
+        data->script_display_question_func = script_obj_new_null ();
+        data->script_display_message_func = script_obj_new_null ();
+        data->script_hide_message_func = script_obj_new_null ();
+        data->script_quit_func = script_obj_new_null ();
+        data->mode = mode;
+
+        script_obj_t *plymouth_hash = script_obj_hash_get_element (state->global, "Plymouth");
+        script_add_native_function (plymouth_hash,
+                                    "SetRefreshFunction",
+                                    plymouth_set_function,
+                                    &data->script_refresh_func,
+                                    "function",
+                                    NULL);
+        script_add_native_function (plymouth_hash,
+                                    "SetBootProgressFunction",
+                                    plymouth_set_function,
+                                    &data->script_boot_progress_func,
+                                    "function",
+                                    NULL);
+        script_add_native_function (plymouth_hash,
+                                    "SetRootMountedFunction",
+                                    plymouth_set_function,
+                                    &data->script_root_mounted_func,
+                                    "function",
+                                    NULL);
+        script_add_native_function (plymouth_hash,
+                                    "SetKeyboardInputFunction",
+                                    plymouth_set_function,
+                                    &data->script_keyboard_input_func,
+                                    "function",
+                                    NULL);
+        script_add_native_function (plymouth_hash,
+                                    "SetUpdateStatusFunction",
+                                    plymouth_set_function,
+                                    &data->script_update_status_func,
+                                    "function",
+                                    NULL);
+        script_add_native_function (plymouth_hash,
+                                    "SetDisplayNormalFunction",
+                                    plymouth_set_function,
+                                    &data->script_display_normal_func,
+                                    "function",
+                                    NULL);
+        script_add_native_function (plymouth_hash,
+                                    "SetDisplayPasswordFunction",
+                                    plymouth_set_function,
+                                    &data->script_display_password_func,
+                                    "function",
+                                    NULL);
+        script_add_native_function (plymouth_hash,
+                                    "SetDisplayQuestionFunction",
+                                    plymouth_set_function,
+                                    &data->script_display_question_func,
+                                    "function",
+                                    NULL);
+        script_add_native_function (plymouth_hash,
+                                    "SetDisplayMessageFunction",
+                                    plymouth_set_function,
+                                    &data->script_display_message_func,
+                                    "function",
+                                    NULL);
+        script_add_native_function (plymouth_hash,
+                                    "SetHideMessageFunction",
+                                    plymouth_set_function,
+                                    &data->script_hide_message_func,
+                                    "function",
+                                    NULL);
+        script_add_native_function (plymouth_hash,
+                                    "SetQuitFunction",
+                                    plymouth_set_function,
+                                    &data->script_quit_func,
+                                    "function",
+                                    NULL);
+        script_add_native_function (plymouth_hash,
+                                    "GetMode",
+                                    plymouth_get_mode,
+                                    data,
+                                    NULL);
+        script_obj_unref (plymouth_hash);
+
+        data->script_main_op = script_parse_string (script_lib_plymouth_string, "script-lib-plymouth.script");
+        script_return_t ret = script_execute (state, data->script_main_op);
+        script_obj_unref (ret.object);          /* Throw anything sent back away */
+
+        return data;
 }
 
 void script_lib_plymouth_destroy (script_lib_plymouth_data_t *data)
 {
-  script_parse_op_free (data->script_main_op);
-  script_obj_unref (data->script_refresh_func);
-  script_obj_unref (data->script_boot_progress_func);
-  script_obj_unref (data->script_root_mounted_func);
-  script_obj_unref (data->script_keyboard_input_func);
-  script_obj_unref (data->script_update_status_func);
-  script_obj_unref (data->script_display_normal_func);
-  script_obj_unref (data->script_display_password_func);
-  script_obj_unref (data->script_display_question_func);
-  script_obj_unref (data->script_display_message_func);
-  script_obj_unref (data->script_hide_message_func);
-  script_obj_unref (data->script_quit_func);
-  free (data);
+        script_parse_op_free (data->script_main_op);
+        script_obj_unref (data->script_refresh_func);
+        script_obj_unref (data->script_boot_progress_func);
+        script_obj_unref (data->script_root_mounted_func);
+        script_obj_unref (data->script_keyboard_input_func);
+        script_obj_unref (data->script_update_status_func);
+        script_obj_unref (data->script_display_normal_func);
+        script_obj_unref (data->script_display_password_func);
+        script_obj_unref (data->script_display_question_func);
+        script_obj_unref (data->script_display_message_func);
+        script_obj_unref (data->script_hide_message_func);
+        script_obj_unref (data->script_quit_func);
+        free (data);
 }
 
 void script_lib_plymouth_on_refresh (script_state_t             *state,
                                      script_lib_plymouth_data_t *data)
 {
-    script_return_t ret = script_execute_object (state,
-                                                 data->script_refresh_func,
-                                                 NULL,
-                                                 NULL);
-    script_obj_unref (ret.object);
+        script_return_t ret = script_execute_object (state,
+                                                     data->script_refresh_func,
+                                                     NULL,
+                                                     NULL);
+
+        script_obj_unref (ret.object);
 }
 
 void script_lib_plymouth_on_boot_progress (script_state_t             *state,
                                            script_lib_plymouth_data_t *data,
-                                           double                     duration,
-                                           double                     progress)
+                                           double                      duration,
+                                           double                      progress)
 {
-  script_obj_t *duration_obj = script_obj_new_number (duration);
-  script_obj_t *progress_obj = script_obj_new_number (progress);
-  script_return_t ret = script_execute_object (state,
-                                               data->script_boot_progress_func,
-                                               NULL,
-                                               duration_obj,
-                                               progress_obj,
-                                               NULL);
-  script_obj_unref (ret.object);
-  script_obj_unref (duration_obj);
-  script_obj_unref (progress_obj);
+        script_obj_t *duration_obj = script_obj_new_number (duration);
+        script_obj_t *progress_obj = script_obj_new_number (progress);
+        script_return_t ret = script_execute_object (state,
+                                                     data->script_boot_progress_func,
+                                                     NULL,
+                                                     duration_obj,
+                                                     progress_obj,
+                                                     NULL);
+
+        script_obj_unref (ret.object);
+        script_obj_unref (duration_obj);
+        script_obj_unref (progress_obj);
 }
 
 void script_lib_plymouth_on_root_mounted (script_state_t             *state,
                                           script_lib_plymouth_data_t *data)
 {
-  script_return_t ret = script_execute_object (state,
-                                               data->script_root_mounted_func,
-                                               NULL,
-                                               NULL);
-  script_obj_unref (ret.object);
+        script_return_t ret = script_execute_object (state,
+                                                     data->script_root_mounted_func,
+                                                     NULL,
+                                                     NULL);
+
+        script_obj_unref (ret.object);
 }
 
 void script_lib_plymouth_on_keyboard_input (script_state_t             *state,
                                             script_lib_plymouth_data_t *data,
                                             const char                 *keyboard_input)
 {
-  script_obj_t *keyboard_input_obj = script_obj_new_string (keyboard_input);
-  script_return_t ret = script_execute_object (state,
-                                                 data->script_keyboard_input_func,
-                                                 NULL,
-                                                 keyboard_input_obj,
-                                                 NULL);
-  script_obj_unref (keyboard_input_obj);
-  script_obj_unref (ret.object);
+        script_obj_t *keyboard_input_obj = script_obj_new_string (keyboard_input);
+        script_return_t ret = script_execute_object (state,
+                                                     data->script_keyboard_input_func,
+                                                     NULL,
+                                                     keyboard_input_obj,
+                                                     NULL);
+
+        script_obj_unref (keyboard_input_obj);
+        script_obj_unref (ret.object);
 }
 
 void script_lib_plymouth_on_update_status (script_state_t             *state,
                                            script_lib_plymouth_data_t *data,
                                            const char                 *new_status)
 {
-  script_obj_t *new_status_obj = script_obj_new_string (new_status);
-  script_return_t ret = script_execute_object (state,
-                                               data->script_update_status_func,
-                                               NULL,
-                                               new_status_obj,
-                                               NULL);
-  script_obj_unref (new_status_obj);
-  script_obj_unref (ret.object);
+        script_obj_t *new_status_obj = script_obj_new_string (new_status);
+        script_return_t ret = script_execute_object (state,
+                                                     data->script_update_status_func,
+                                                     NULL,
+                                                     new_status_obj,
+                                                     NULL);
+
+        script_obj_unref (new_status_obj);
+        script_obj_unref (ret.object);
 }
 
 void script_lib_plymouth_on_display_normal (script_state_t             *state,
                                             script_lib_plymouth_data_t *data)
 {
-  script_return_t ret = script_execute_object (state,
-                                               data->script_display_normal_func,
-                                               NULL,
-                                               NULL);
-  script_obj_unref (ret.object);
+        script_return_t ret = script_execute_object (state,
+                                                     data->script_display_normal_func,
+                                                     NULL,
+                                                     NULL);
+
+        script_obj_unref (ret.object);
 }
 
 void script_lib_plymouth_on_display_password (script_state_t             *state,
@@ -269,17 +275,18 @@ void script_lib_plymouth_on_display_password (script_state_t             *state,
                                               const char                 *prompt,
                                               int                         bullets)
 {
-  script_obj_t *prompt_obj = script_obj_new_string (prompt);
-  script_obj_t *bullets_obj = script_obj_new_number (bullets);
-  script_return_t ret = script_execute_object (state,
-                                               data->script_display_password_func,
-                                               NULL,
-                                               prompt_obj,
-                                               bullets_obj,
-                                               NULL);
-  script_obj_unref (prompt_obj);
-  script_obj_unref (bullets_obj);
-  script_obj_unref (ret.object);
+        script_obj_t *prompt_obj = script_obj_new_string (prompt);
+        script_obj_t *bullets_obj = script_obj_new_number (bullets);
+        script_return_t ret = script_execute_object (state,
+                                                     data->script_display_password_func,
+                                                     NULL,
+                                                     prompt_obj,
+                                                     bullets_obj,
+                                                     NULL);
+
+        script_obj_unref (prompt_obj);
+        script_obj_unref (bullets_obj);
+        script_obj_unref (ret.object);
 }
 
 void script_lib_plymouth_on_display_question (script_state_t             *state,
@@ -287,53 +294,57 @@ void script_lib_plymouth_on_display_question (script_state_t             *state,
                                               const char                 *prompt,
                                               const char                 *entry_text)
 {
-  script_obj_t *prompt_obj = script_obj_new_string (prompt);
-  script_obj_t *entry_text_obj = script_obj_new_string (entry_text);
-  script_return_t ret = script_execute_object (state,
-                                               data->script_display_question_func,
-                                               NULL,
-                                               prompt_obj,
-                                               entry_text_obj,
-                                               NULL);
-  script_obj_unref (prompt_obj);
-  script_obj_unref (entry_text_obj);
-  script_obj_unref (ret.object);
+        script_obj_t *prompt_obj = script_obj_new_string (prompt);
+        script_obj_t *entry_text_obj = script_obj_new_string (entry_text);
+        script_return_t ret = script_execute_object (state,
+                                                     data->script_display_question_func,
+                                                     NULL,
+                                                     prompt_obj,
+                                                     entry_text_obj,
+                                                     NULL);
+
+        script_obj_unref (prompt_obj);
+        script_obj_unref (entry_text_obj);
+        script_obj_unref (ret.object);
 }
 
 void script_lib_plymouth_on_display_message (script_state_t             *state,
                                              script_lib_plymouth_data_t *data,
                                              const char                 *message)
 {
-  script_obj_t *new_message_obj = script_obj_new_string (message);
-  script_return_t ret = script_execute_object (state,
-                                               data->script_display_message_func,
-                                               NULL,
-                                               new_message_obj,
-                                               NULL);
-  script_obj_unref (new_message_obj);
-  script_obj_unref (ret.object);
+        script_obj_t *new_message_obj = script_obj_new_string (message);
+        script_return_t ret = script_execute_object (state,
+                                                     data->script_display_message_func,
+                                                     NULL,
+                                                     new_message_obj,
+                                                     NULL);
+
+        script_obj_unref (new_message_obj);
+        script_obj_unref (ret.object);
 }
 
 void script_lib_plymouth_on_hide_message (script_state_t             *state,
                                           script_lib_plymouth_data_t *data,
                                           const char                 *message)
 {
-  script_obj_t *new_message_obj = script_obj_new_string (message);
-  script_return_t ret = script_execute_object (state,
-                                               data->script_hide_message_func,
-                                               NULL,
-                                               new_message_obj,
-                                               NULL);
-  script_obj_unref (new_message_obj);
-  script_obj_unref (ret.object);
+        script_obj_t *new_message_obj = script_obj_new_string (message);
+        script_return_t ret = script_execute_object (state,
+                                                     data->script_hide_message_func,
+                                                     NULL,
+                                                     new_message_obj,
+                                                     NULL);
+
+        script_obj_unref (new_message_obj);
+        script_obj_unref (ret.object);
 }
 
 void script_lib_plymouth_on_quit (script_state_t             *state,
                                   script_lib_plymouth_data_t *data)
 {
-  script_return_t ret = script_execute_object (state,
-                                               data->script_quit_func,
-                                               NULL,
-                                               NULL);
-  script_obj_unref (ret.object);
+        script_return_t ret = script_execute_object (state,
+                                                     data->script_quit_func,
+                                                     NULL,
+                                                     NULL);
+
+        script_obj_unref (ret.object);
 }
diff --git a/src/plugins/splash/script/script-lib-plymouth.h b/src/plugins/splash/script/script-lib-plymouth.h
index c4ec5a6..dafdec3 100644
--- a/src/plugins/splash/script/script-lib-plymouth.h
+++ b/src/plugins/splash/script/script-lib-plymouth.h
@@ -27,31 +27,31 @@
 
 typedef struct
 {
-  script_op_t            *script_main_op;
-  script_obj_t           *script_refresh_func;
-  script_obj_t           *script_boot_progress_func;
-  script_obj_t           *script_root_mounted_func;
-  script_obj_t           *script_keyboard_input_func;
-  script_obj_t           *script_update_status_func;
-  script_obj_t           *script_display_normal_func;
-  script_obj_t           *script_display_password_func;
-  script_obj_t           *script_display_question_func;
-  script_obj_t           *script_display_message_func;
-  script_obj_t           *script_hide_message_func;
-  script_obj_t           *script_quit_func;
-  ply_boot_splash_mode_t  mode;
+        script_op_t           *script_main_op;
+        script_obj_t          *script_refresh_func;
+        script_obj_t          *script_boot_progress_func;
+        script_obj_t          *script_root_mounted_func;
+        script_obj_t          *script_keyboard_input_func;
+        script_obj_t          *script_update_status_func;
+        script_obj_t          *script_display_normal_func;
+        script_obj_t          *script_display_password_func;
+        script_obj_t          *script_display_question_func;
+        script_obj_t          *script_display_message_func;
+        script_obj_t          *script_hide_message_func;
+        script_obj_t          *script_quit_func;
+        ply_boot_splash_mode_t mode;
 } script_lib_plymouth_data_t;
 
-script_lib_plymouth_data_t *script_lib_plymouth_setup (script_state_t         *state,
-                                                       ply_boot_splash_mode_t  mode);
+script_lib_plymouth_data_t *script_lib_plymouth_setup (script_state_t        *state,
+                                                       ply_boot_splash_mode_t mode);
 void script_lib_plymouth_destroy (script_lib_plymouth_data_t *data);
 
 void script_lib_plymouth_on_refresh (script_state_t             *state,
                                      script_lib_plymouth_data_t *data);
 void script_lib_plymouth_on_boot_progress (script_state_t             *state,
                                            script_lib_plymouth_data_t *data,
-                                           double                     duration,
-                                           double                     progress);
+                                           double                      duration,
+                                           double                      progress);
 void script_lib_plymouth_on_root_mounted (script_state_t             *state,
                                           script_lib_plymouth_data_t *data);
 void script_lib_plymouth_on_keyboard_input (script_state_t             *state,
diff --git a/src/plugins/splash/script/script-lib-sprite.c b/src/plugins/splash/script/script-lib-sprite.c
index e0ced7e..a4772e8 100644
--- a/src/plugins/splash/script/script-lib-sprite.c
+++ b/src/plugins/splash/script/script-lib-sprite.c
@@ -40,392 +40,380 @@
 
 static void sprite_free (script_obj_t *obj)
 {
-  sprite_t *sprite = obj->data.native.object_data;
-  sprite->remove_me = true;
+        sprite_t *sprite = obj->data.native.object_data;
+
+        sprite->remove_me = true;
 }
 
 static script_return_t sprite_new (script_state_t *state,
                                    void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  script_obj_t *reply;
-
-  sprite_t *sprite = calloc (1, sizeof (sprite_t));
-
-  sprite->x = 0;
-  sprite->y = 0;
-  sprite->z = 0;
-  sprite->opacity = 1.0;
-  sprite->old_x = 0;
-  sprite->old_y = 0;
-  sprite->old_z = 0;
-  sprite->old_width = 0;
-  sprite->old_height = 0;
-  sprite->old_opacity = 1.0;
-  sprite->refresh_me = false;
-  sprite->remove_me = false;
-  sprite->image = NULL;
-  sprite->image_obj = NULL;
-  ply_list_append_data (data->sprite_list, sprite);
-
-  reply = script_obj_new_native (sprite, data->class);
-  return script_return_obj (reply);
+        script_lib_sprite_data_t *data = user_data;
+        script_obj_t *reply;
+
+        sprite_t *sprite = calloc (1, sizeof(sprite_t));
+
+        sprite->x = 0;
+        sprite->y = 0;
+        sprite->z = 0;
+        sprite->opacity = 1.0;
+        sprite->old_x = 0;
+        sprite->old_y = 0;
+        sprite->old_z = 0;
+        sprite->old_width = 0;
+        sprite->old_height = 0;
+        sprite->old_opacity = 1.0;
+        sprite->refresh_me = false;
+        sprite->remove_me = false;
+        sprite->image = NULL;
+        sprite->image_obj = NULL;
+        ply_list_append_data (data->sprite_list, sprite);
+
+        reply = script_obj_new_native (sprite, data->class);
+        return script_return_obj (reply);
 }
 
 static script_return_t sprite_get_image (script_state_t *state,
                                          void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
-  
-  if (sprite && sprite->image_obj)
-    {
-      script_obj_ref (sprite->image_obj);
-      return script_return_obj (sprite->image_obj);
-    }
-  return script_return_obj_null ();
+        script_lib_sprite_data_t *data = user_data;
+        sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
+
+        if (sprite && sprite->image_obj) {
+                script_obj_ref (sprite->image_obj);
+                return script_return_obj (sprite->image_obj);
+        }
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_set_image (script_state_t *state,
                                          void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
-  script_obj_t *script_obj_image = script_obj_hash_get_element (state->local,
-                                                                "image");
-  script_obj_deref (&script_obj_image);
-  ply_pixel_buffer_t *image = script_obj_as_native_of_class_name (script_obj_image,
-                                                                  "image");
-
-  if (image && sprite)
-    {
-      script_obj_unref (sprite->image_obj);
-      script_obj_ref (script_obj_image);
-      sprite->image = image;
-      sprite->image_obj = script_obj_image;
-      sprite->refresh_me = true;
-    }
-  script_obj_unref (script_obj_image);
-
-  return script_return_obj_null ();
+        script_lib_sprite_data_t *data = user_data;
+        sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
+        script_obj_t *script_obj_image = script_obj_hash_get_element (state->local,
+                                                                      "image");
+
+        script_obj_deref (&script_obj_image);
+        ply_pixel_buffer_t *image = script_obj_as_native_of_class_name (script_obj_image,
+                                                                        "image");
+
+        if (image && sprite) {
+                script_obj_unref (sprite->image_obj);
+                script_obj_ref (script_obj_image);
+                sprite->image = image;
+                sprite->image_obj = script_obj_image;
+                sprite->refresh_me = true;
+        }
+        script_obj_unref (script_obj_image);
+
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_get_x (script_state_t *state,
                                      void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
+        script_lib_sprite_data_t *data = user_data;
+        sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
 
-  if (sprite)
-    return script_return_obj (script_obj_new_number (sprite->x));
-  return script_return_obj_null ();
+        if (sprite)
+                return script_return_obj (script_obj_new_number (sprite->x));
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_get_y (script_state_t *state,
                                      void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
+        script_lib_sprite_data_t *data = user_data;
+        sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
 
-  if (sprite)
-    return script_return_obj (script_obj_new_number (sprite->y));
-  return script_return_obj_null ();
+        if (sprite)
+                return script_return_obj (script_obj_new_number (sprite->y));
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_get_z (script_state_t *state,
                                      void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
+        script_lib_sprite_data_t *data = user_data;
+        sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
 
-  if (sprite)
-    return script_return_obj (script_obj_new_number (sprite->z));
-  return script_return_obj_null ();
+        if (sprite)
+                return script_return_obj (script_obj_new_number (sprite->z));
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_get_opacity (script_state_t *state,
                                            void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
+        script_lib_sprite_data_t *data = user_data;
+        sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
 
-  if (sprite)
-    return script_return_obj (script_obj_new_number (sprite->opacity));
-  return script_return_obj_null ();
+        if (sprite)
+                return script_return_obj (script_obj_new_number (sprite->opacity));
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_set_x (script_state_t *state,
                                      void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
+        script_lib_sprite_data_t *data = user_data;
+        sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
 
-  if (sprite)
-    sprite->x = script_obj_hash_get_number (state->local, "value");
-  return script_return_obj_null ();
+        if (sprite)
+                sprite->x = script_obj_hash_get_number (state->local, "value");
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_set_y (script_state_t *state,
                                      void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
+        script_lib_sprite_data_t *data = user_data;
+        sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
 
-  if (sprite)
-    sprite->y = script_obj_hash_get_number (state->local, "value");
-  return script_return_obj_null ();
+        if (sprite)
+                sprite->y = script_obj_hash_get_number (state->local, "value");
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_set_z (script_state_t *state,
                                      void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
+        script_lib_sprite_data_t *data = user_data;
+        sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
 
-  if (sprite)
-    sprite->z = script_obj_hash_get_number (state->local, "value");
-  return script_return_obj_null ();
+        if (sprite)
+                sprite->z = script_obj_hash_get_number (state->local, "value");
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_set_opacity (script_state_t *state,
                                            void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
+        script_lib_sprite_data_t *data = user_data;
+        sprite_t *sprite = script_obj_as_native_of_class (state->this, data->class);
 
-  if (sprite)
-    sprite->opacity = script_obj_hash_get_number (state->local, "value");
-  return script_return_obj_null ();
+        if (sprite)
+                sprite->opacity = script_obj_hash_get_number (state->local, "value");
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_window_get_width (script_state_t *state,
                                                 void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  ply_list_node_t *node;
-  int index;
-  script_obj_t *index_obj;
-  script_lib_display_t *display;
-  unsigned int width;
-
-  index_obj = script_obj_hash_peek_element (state->local, "window");
-
-  if (index_obj)
-    {
-      index = script_obj_as_number (index_obj);
-      script_obj_unref(index_obj);
-      if (index < 0)
-        return script_return_obj_null ();
-      node = ply_list_get_nth_node (data->displays, index);
-      if (node == NULL)
-        return script_return_obj_null ();
-      display = ply_list_node_get_data (node);
-      width = ply_pixel_display_get_width (display->pixel_display);
-      return script_return_obj (script_obj_new_number (width));
-    }
-
-  width = 0;
-  for (node = ply_list_get_first_node (data->displays);
-       node;
-       node = ply_list_get_next_node (data->displays, node))
-    {
-      display = ply_list_node_get_data (node);
-      if (width == 0)
-        width = ply_pixel_display_get_width (display->pixel_display);
-      else
-        width = MIN (width, ply_pixel_display_get_width (display->pixel_display));
-    }
-  return script_return_obj (script_obj_new_number (width));
+        script_lib_sprite_data_t *data = user_data;
+        ply_list_node_t *node;
+        int index;
+        script_obj_t *index_obj;
+        script_lib_display_t *display;
+        unsigned int width;
+
+        index_obj = script_obj_hash_peek_element (state->local, "window");
+
+        if (index_obj) {
+                index = script_obj_as_number (index_obj);
+                script_obj_unref (index_obj);
+                if (index < 0)
+                        return script_return_obj_null ();
+                node = ply_list_get_nth_node (data->displays, index);
+                if (node == NULL)
+                        return script_return_obj_null ();
+                display = ply_list_node_get_data (node);
+                width = ply_pixel_display_get_width (display->pixel_display);
+                return script_return_obj (script_obj_new_number (width));
+        }
+
+        width = 0;
+        for (node = ply_list_get_first_node (data->displays);
+             node;
+             node = ply_list_get_next_node (data->displays, node)) {
+                display = ply_list_node_get_data (node);
+                if (width == 0)
+                        width = ply_pixel_display_get_width (display->pixel_display);
+                else
+                        width = MIN (width, ply_pixel_display_get_width (display->pixel_display));
+        }
+        return script_return_obj (script_obj_new_number (width));
 }
 
 static script_return_t sprite_window_get_height (script_state_t *state,
                                                  void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  ply_list_node_t *node;
-  int index;
-  script_obj_t *index_obj;
-  script_lib_display_t *display;
-  unsigned int height;
-
-  index_obj = script_obj_hash_peek_element (state->local, "window");
-
-  if (index_obj)
-    {
-      index = script_obj_as_number (index_obj);
-      script_obj_unref(index_obj);
-      if (index < 0)
-        return script_return_obj_null ();
-      node = ply_list_get_nth_node (data->displays, index);
-      if (node == NULL)
-        return script_return_obj_null ();
-      display = ply_list_node_get_data (node);
-      height = ply_pixel_display_get_height (display->pixel_display);
-      return script_return_obj (script_obj_new_number (height));
-    }
-
-  height = 0;
-  for (node = ply_list_get_first_node (data->displays);
-       node;
-       node = ply_list_get_next_node (data->displays, node))
-    {
-      display = ply_list_node_get_data (node);
-      if (height == 0)
-        height = ply_pixel_display_get_height (display->pixel_display);
-      else
-        height = MIN (height, ply_pixel_display_get_height (display->pixel_display));
-    }
-  return script_return_obj (script_obj_new_number (height));
+        script_lib_sprite_data_t *data = user_data;
+        ply_list_node_t *node;
+        int index;
+        script_obj_t *index_obj;
+        script_lib_display_t *display;
+        unsigned int height;
+
+        index_obj = script_obj_hash_peek_element (state->local, "window");
+
+        if (index_obj) {
+                index = script_obj_as_number (index_obj);
+                script_obj_unref (index_obj);
+                if (index < 0)
+                        return script_return_obj_null ();
+                node = ply_list_get_nth_node (data->displays, index);
+                if (node == NULL)
+                        return script_return_obj_null ();
+                display = ply_list_node_get_data (node);
+                height = ply_pixel_display_get_height (display->pixel_display);
+                return script_return_obj (script_obj_new_number (height));
+        }
+
+        height = 0;
+        for (node = ply_list_get_first_node (data->displays);
+             node;
+             node = ply_list_get_next_node (data->displays, node)) {
+                display = ply_list_node_get_data (node);
+                if (height == 0)
+                        height = ply_pixel_display_get_height (display->pixel_display);
+                else
+                        height = MIN (height, ply_pixel_display_get_height (display->pixel_display));
+        }
+        return script_return_obj (script_obj_new_number (height));
 }
 
 static script_return_t sprite_window_get_x (script_state_t *state,
                                             void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  ply_list_node_t *node;
-  int index;
-  script_obj_t *index_obj;
-  script_lib_display_t *display;
-  int x;
-
-  index_obj = script_obj_hash_peek_element (state->local, "window");
-
-  if (index_obj)
-    {
-      index = script_obj_as_number (index_obj);
-      script_obj_unref(index_obj);
-      if (index < 0)
-        return script_return_obj_null ();
-      node = ply_list_get_nth_node (data->displays, index);
-      if (node == NULL)
-        return script_return_obj_null ();
-      display = ply_list_node_get_data (node);
-      return script_return_obj (script_obj_new_number (display->x));
-    }
-
-  x = 0;
-  for (node = ply_list_get_first_node (data->displays);
-       node;
-       node = ply_list_get_next_node (data->displays, node))
-    {
-      display = ply_list_node_get_data (node);
-      x = MAX (x, display->x);
-    }
-  return script_return_obj (script_obj_new_number (x));
+        script_lib_sprite_data_t *data = user_data;
+        ply_list_node_t *node;
+        int index;
+        script_obj_t *index_obj;
+        script_lib_display_t *display;
+        int x;
+
+        index_obj = script_obj_hash_peek_element (state->local, "window");
+
+        if (index_obj) {
+                index = script_obj_as_number (index_obj);
+                script_obj_unref (index_obj);
+                if (index < 0)
+                        return script_return_obj_null ();
+                node = ply_list_get_nth_node (data->displays, index);
+                if (node == NULL)
+                        return script_return_obj_null ();
+                display = ply_list_node_get_data (node);
+                return script_return_obj (script_obj_new_number (display->x));
+        }
+
+        x = 0;
+        for (node = ply_list_get_first_node (data->displays);
+             node;
+             node = ply_list_get_next_node (data->displays, node)) {
+                display = ply_list_node_get_data (node);
+                x = MAX (x, display->x);
+        }
+        return script_return_obj (script_obj_new_number (x));
 }
 
 
 static script_return_t sprite_window_get_y (script_state_t *state,
                                             void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  ply_list_node_t *node;
-  int index;
-  script_obj_t *index_obj;
-  script_lib_display_t *display;
-  int y;
-
-  index_obj = script_obj_hash_peek_element (state->local, "window");
-
-  if (index_obj)
-    {
-      index = script_obj_as_number (index_obj);
-      script_obj_unref(index_obj);
-      if (index < 0)
-        return script_return_obj_null ();
-      node = ply_list_get_nth_node (data->displays, index);
-      if (node == NULL)
-        return script_return_obj_null ();
-      display = ply_list_node_get_data (node);
-      return script_return_obj (script_obj_new_number (display->y));
-    }
-
-  y = 0;
-  for (node = ply_list_get_first_node (data->displays);
-       node;
-       node = ply_list_get_next_node (data->displays, node))
-    {
-      display = ply_list_node_get_data (node);
-      y = MAX (y, display->y);
-    }
-  return script_return_obj (script_obj_new_number (y));
+        script_lib_sprite_data_t *data = user_data;
+        ply_list_node_t *node;
+        int index;
+        script_obj_t *index_obj;
+        script_lib_display_t *display;
+        int y;
+
+        index_obj = script_obj_hash_peek_element (state->local, "window");
+
+        if (index_obj) {
+                index = script_obj_as_number (index_obj);
+                script_obj_unref (index_obj);
+                if (index < 0)
+                        return script_return_obj_null ();
+                node = ply_list_get_nth_node (data->displays, index);
+                if (node == NULL)
+                        return script_return_obj_null ();
+                display = ply_list_node_get_data (node);
+                return script_return_obj (script_obj_new_number (display->y));
+        }
+
+        y = 0;
+        for (node = ply_list_get_first_node (data->displays);
+             node;
+             node = ply_list_get_next_node (data->displays, node)) {
+                display = ply_list_node_get_data (node);
+                y = MAX (y, display->y);
+        }
+        return script_return_obj (script_obj_new_number (y));
 }
 
 static script_return_t sprite_window_set_x (script_state_t *state,
                                             void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  ply_list_node_t *node;
-  script_lib_display_t *display;
-  int index;
-  int x;
-
-  index = script_obj_hash_get_number (state->local, "window");
-  x = script_obj_hash_get_number (state->local, "value");
-  node = ply_list_get_nth_node (data->displays, index);
-  if (node)
-    {
-      display = ply_list_node_get_data (node);
-      if (display->x != x)
-        {
-          display->x = x;
-          data->full_refresh = true;
+        script_lib_sprite_data_t *data = user_data;
+        ply_list_node_t *node;
+        script_lib_display_t *display;
+        int index;
+        int x;
+
+        index = script_obj_hash_get_number (state->local, "window");
+        x = script_obj_hash_get_number (state->local, "value");
+        node = ply_list_get_nth_node (data->displays, index);
+        if (node) {
+                display = ply_list_node_get_data (node);
+                if (display->x != x) {
+                        display->x = x;
+                        data->full_refresh = true;
+                }
         }
-    }
-  return script_return_obj_null ();
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_window_set_y (script_state_t *state,
                                             void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
-  ply_list_node_t *node;
-  script_lib_display_t *display;
-  int index;
-  int y;
-
-  index = script_obj_hash_get_number (state->local, "window");
-  y = script_obj_hash_get_number (state->local, "value");
-  node = ply_list_get_nth_node (data->displays, index);
-  if (node)
-    {
-      display = ply_list_node_get_data (node);
-      if (display->y != y)
-        {
-          display->y = y;
-          data->full_refresh = true;
+        script_lib_sprite_data_t *data = user_data;
+        ply_list_node_t *node;
+        script_lib_display_t *display;
+        int index;
+        int y;
+
+        index = script_obj_hash_get_number (state->local, "window");
+        y = script_obj_hash_get_number (state->local, "value");
+        node = ply_list_get_nth_node (data->displays, index);
+        if (node) {
+                display = ply_list_node_get_data (node);
+                if (display->y != y) {
+                        display->y = y;
+                        data->full_refresh = true;
+                }
         }
-    }
-  return script_return_obj_null ();
+        return script_return_obj_null ();
 }
 
 static uint32_t extract_rgb_color (script_state_t *state)
 {
-  uint8_t red =   CLAMP (255 * script_obj_hash_get_number (state->local, "red"),   0, 255);
-  uint8_t green = CLAMP (255 * script_obj_hash_get_number (state->local, "green"), 0, 255);
-  uint8_t blue =  CLAMP (255 * script_obj_hash_get_number (state->local, "blue"),  0, 255);
+        uint8_t red = CLAMP (255 * script_obj_hash_get_number (state->local, "red"), 0, 255);
+        uint8_t green = CLAMP (255 * script_obj_hash_get_number (state->local, "green"), 0, 255);
+        uint8_t blue = CLAMP (255 * script_obj_hash_get_number (state->local, "blue"), 0, 255);
 
-  return (uint32_t) red << 16 | green << 8 | blue;
+        return (uint32_t) red << 16 | green << 8 | blue;
 }
 
 static script_return_t sprite_window_set_background_top_color (script_state_t *state,
                                                                void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
+        script_lib_sprite_data_t *data = user_data;
 
-  data->background_color_start = extract_rgb_color (state);
-  data->full_refresh = true;
-  return script_return_obj_null ();
+        data->background_color_start = extract_rgb_color (state);
+        data->full_refresh = true;
+        return script_return_obj_null ();
 }
 
 static script_return_t sprite_window_set_background_bottom_color (script_state_t *state,
                                                                   void           *user_data)
 {
-  script_lib_sprite_data_t *data = user_data;
+        script_lib_sprite_data_t *data = user_data;
 
-  data->background_color_end = extract_rgb_color (state);
-  data->full_refresh = true;
-  return script_return_obj_null ();
+        data->background_color_end = extract_rgb_color (state);
+        data->full_refresh = true;
+        return script_return_obj_null ();
 }
 
 static void script_lib_sprite_draw_area (script_lib_display_t *display,
@@ -435,398 +423,389 @@ static void script_lib_sprite_draw_area (script_lib_display_t *display,
                                          int                   width,
                                          int                   height)
 {
-  ply_rectangle_t clip_area;
-  ply_list_node_t *node;
-  script_lib_sprite_data_t *data = display->data;
-
-  clip_area.x = x;
-  clip_area.y = y;
-  clip_area.width = width;
-  clip_area.height = height;
-
-  if (data->background_color_start == data->background_color_end)
-    ply_pixel_buffer_fill_with_hex_color (pixel_buffer,
-                                          &clip_area,
-                                          data->background_color_start);
-  else
-    ply_pixel_buffer_fill_with_gradient (pixel_buffer,
-                                         &clip_area,
-                                         data->background_color_start,
-                                         data->background_color_end);
-  for (node = ply_list_get_first_node (data->sprite_list);
-       node;
-       node = ply_list_get_next_node (data->sprite_list, node))
-    {
-      sprite_t *sprite = ply_list_node_get_data (node);
-      int position_x, position_y;
-
-      if (!sprite->image) continue;
-      if (sprite->remove_me) continue;
-      if (sprite->opacity < 0.011) continue;
-
-      position_x = sprite->x - display->x;
-      position_y = sprite->y - display->y;
-
-      if (position_x >= (x + width)) continue;
-      if (position_y >= (y + height)) continue;
-
-      if ((position_x + (int) ply_pixel_buffer_get_width (sprite->image)) <= x) continue;
-      if ((position_y + (int) ply_pixel_buffer_get_height (sprite->image)) <= y) continue;
-      ply_pixel_buffer_fill_with_buffer_at_opacity_with_clip (pixel_buffer,
-                                                              sprite->image,
-                                                              position_x,
-                                                              position_y,
-                                                              &clip_area,
-                                                              sprite->opacity);
-    }
+        ply_rectangle_t clip_area;
+        ply_list_node_t *node;
+        script_lib_sprite_data_t *data = display->data;
+
+        clip_area.x = x;
+        clip_area.y = y;
+        clip_area.width = width;
+        clip_area.height = height;
+
+        if (data->background_color_start == data->background_color_end) {
+                ply_pixel_buffer_fill_with_hex_color (pixel_buffer,
+                                                      &clip_area,
+                                                      data->background_color_start);
+        } else {
+                ply_pixel_buffer_fill_with_gradient (pixel_buffer,
+                                                     &clip_area,
+                                                     data->background_color_start,
+                                                     data->background_color_end);
+        }
+        for (node = ply_list_get_first_node (data->sprite_list);
+             node;
+             node = ply_list_get_next_node (data->sprite_list, node)) {
+                sprite_t *sprite = ply_list_node_get_data (node);
+                int position_x, position_y;
+
+                if (!sprite->image) continue;
+                if (sprite->remove_me) continue;
+                if (sprite->opacity < 0.011) continue;
+
+                position_x = sprite->x - display->x;
+                position_y = sprite->y - display->y;
+
+                if (position_x >= (x + width)) continue;
+                if (position_y >= (y + height)) continue;
+
+                if ((position_x + (int) ply_pixel_buffer_get_width (sprite->image)) <= x) continue;
+                if ((position_y + (int) ply_pixel_buffer_get_height (sprite->image)) <= y) continue;
+                ply_pixel_buffer_fill_with_buffer_at_opacity_with_clip (pixel_buffer,
+                                                                        sprite->image,
+                                                                        position_x,
+                                                                        position_y,
+                                                                        &clip_area,
+                                                                        sprite->opacity);
+        }
 }
 
-static void 
+static void
 draw_area (script_lib_sprite_data_t *data,
            int                       x,
            int                       y,
            int                       width,
            int                       height)
 {
-  ply_list_node_t *node;
-  for (node = ply_list_get_first_node (data->displays);
-       node;
-       node = ply_list_get_next_node (data->displays, node))
-    {
-      script_lib_display_t* display = ply_list_node_get_data (node);
-
-      ply_pixel_display_draw_area (display->pixel_display,
-                                   x - display->x,
-                                   y - display->y,
-                                   width,
-                                   height);
-    }
+        ply_list_node_t *node;
+
+        for (node = ply_list_get_first_node (data->displays);
+             node;
+             node = ply_list_get_next_node (data->displays, node)) {
+                script_lib_display_t *display = ply_list_node_get_data (node);
+
+                ply_pixel_display_draw_area (display->pixel_display,
+                                             x - display->x,
+                                             y - display->y,
+                                             width,
+                                             height);
+        }
 }
 
 script_lib_sprite_data_t *script_lib_sprite_setup (script_state_t *state,
                                                    ply_list_t     *pixel_displays)
 {
-  ply_list_node_t *node;
-  unsigned int max_width, max_height;
-  script_lib_sprite_data_t *data = malloc (sizeof (script_lib_sprite_data_t));
-
-  data->class = script_obj_native_class_new (sprite_free, "sprite", data);
-  data->sprite_list = ply_list_new ();
-  data->displays = ply_list_new ();
-
-  max_width = 0;
-  max_height = 0;
-
-  for (node = ply_list_get_first_node (pixel_displays);
-       node;
-       node = ply_list_get_next_node (pixel_displays, node))
-    {
-      ply_pixel_display_t *pixel_display = ply_list_node_get_data (node);
-      max_width = MAX(max_width, ply_pixel_display_get_width (pixel_display));
-      max_height = MAX(max_height, ply_pixel_display_get_height (pixel_display));
-    }
-
-  for (node = ply_list_get_first_node (pixel_displays);
-       node;
-       node = ply_list_get_next_node (pixel_displays, node))
-    {
-      ply_pixel_display_t *pixel_display = ply_list_node_get_data (node);
-      script_lib_display_t *script_display = malloc (sizeof(script_lib_display_t));
-      script_display->pixel_display = pixel_display;
-      
-      script_display->x = (max_width - ply_pixel_display_get_width (pixel_display)) / 2;
-      script_display->y = (max_height - ply_pixel_display_get_height (pixel_display)) / 2;
-      
-      script_display->data = data;
-      ply_pixel_display_set_draw_handler (pixel_display,
-                                          (ply_pixel_display_draw_handler_t)
-                                          script_lib_sprite_draw_area, script_display);
-
-      ply_list_append_data (data->displays, script_display);
-    }
-
-  script_obj_t *sprite_hash = script_obj_hash_get_element (state->global, "Sprite");
-  script_add_native_function (sprite_hash,
-                              "_New",
-                              sprite_new,
-                              data,
-                              NULL);
-  script_add_native_function (sprite_hash,
-                              "GetImage",
-                              sprite_get_image,
-                              data,
-                              NULL);
-  script_add_native_function (sprite_hash,
-                              "SetImage",
-                              sprite_set_image,
-                              data,
-                              "image",
-                              NULL);
-  script_add_native_function (sprite_hash,
-                              "GetX",
-                              sprite_get_x,
-                              data,
-                              NULL);
-  script_add_native_function (sprite_hash,
-                              "SetX",
-                              sprite_set_x,
-                              data,
-                              "value",
-                              NULL);
-  script_add_native_function (sprite_hash,
-                              "GetY",
-                              sprite_get_y,
-                              data,
-                              NULL);
-  script_add_native_function (sprite_hash,
-                              "SetY",
-                              sprite_set_y,
-                              data,
-                              "value",
-                              NULL);
-  script_add_native_function (sprite_hash,
-                              "GetZ",
-                              sprite_get_z,
-                              data,
-                              NULL);
-  script_add_native_function (sprite_hash,
-                              "SetZ",
-                              sprite_set_z,
-                              data,
-                              "value",
-                              NULL);
-  script_add_native_function (sprite_hash,
-                              "GetOpacity",
-                              sprite_get_opacity,
-                              data,
-                              NULL);
-  script_add_native_function (sprite_hash,
-                              "SetOpacity",
-                              sprite_set_opacity,
-                              data,
-                              "value",
-                              NULL);
-  script_obj_unref (sprite_hash);
-
-
-  script_obj_t *window_hash = script_obj_hash_get_element (state->global, "Window");
-  script_add_native_function (window_hash,
-                              "GetWidth",
-                              sprite_window_get_width,
-                              data,
-                              "window",
-                              NULL);
-  script_add_native_function (window_hash,
-                              "GetHeight",
-                              sprite_window_get_height,
-                              data,
-                              "window",
-                              NULL);
-  script_add_native_function (window_hash,
-                              "GetX",
-                              sprite_window_get_x,
-                              data,
-                              "window",
-                              NULL);
-  script_add_native_function (window_hash,
-                              "GetY",
-                              sprite_window_get_y,
-                              data,
-                              "window",
-                              NULL);
-  script_add_native_function (window_hash,
-                              "SetX",
-                              sprite_window_set_x,
-                              data,
-                              "window",
-                              "value",
-                              NULL);
-  script_add_native_function (window_hash,
-                              "SetY",
-                              sprite_window_set_y,
-                              data,
-                              "window",
-                              "value",
-                              NULL);
-  script_add_native_function (window_hash,
-                              "SetBackgroundTopColor",
-                              sprite_window_set_background_top_color,
-                              data,
-                              "red",
-                              "green",
-                              "blue",
-                              NULL);
-  script_add_native_function (window_hash,
-                              "SetBackgroundBottomColor",
-                              sprite_window_set_background_bottom_color,
-                              data,
-                              "red",
-                              "green",
-                              "blue",
-                              NULL);
-  script_obj_unref (window_hash);
-
-  data->script_main_op = script_parse_string (script_lib_sprite_string, "script-lib-sprite.script");
-  data->background_color_start = 0x000000;
-  data->background_color_end   = 0x000000;
-  data->full_refresh = true;
-  script_return_t ret = script_execute (state, data->script_main_op);
-  script_obj_unref (ret.object);
-  return data;
+        ply_list_node_t *node;
+        unsigned int max_width, max_height;
+        script_lib_sprite_data_t *data = malloc (sizeof(script_lib_sprite_data_t));
+
+        data->class = script_obj_native_class_new (sprite_free, "sprite", data);
+        data->sprite_list = ply_list_new ();
+        data->displays = ply_list_new ();
+
+        max_width = 0;
+        max_height = 0;
+
+        for (node = ply_list_get_first_node (pixel_displays);
+             node;
+             node = ply_list_get_next_node (pixel_displays, node)) {
+                ply_pixel_display_t *pixel_display = ply_list_node_get_data (node);
+                max_width = MAX (max_width, ply_pixel_display_get_width (pixel_display));
+                max_height = MAX (max_height, ply_pixel_display_get_height (pixel_display));
+        }
+
+        for (node = ply_list_get_first_node (pixel_displays);
+             node;
+             node = ply_list_get_next_node (pixel_displays, node)) {
+                ply_pixel_display_t *pixel_display = ply_list_node_get_data (node);
+                script_lib_display_t *script_display = malloc (sizeof(script_lib_display_t));
+                script_display->pixel_display = pixel_display;
+
+                script_display->x = (max_width - ply_pixel_display_get_width (pixel_display)) / 2;
+                script_display->y = (max_height - ply_pixel_display_get_height (pixel_display)) / 2;
+
+                script_display->data = data;
+                ply_pixel_display_set_draw_handler (pixel_display,
+                                                    (ply_pixel_display_draw_handler_t)
+                                                    script_lib_sprite_draw_area, script_display);
+
+                ply_list_append_data (data->displays, script_display);
+        }
+
+        script_obj_t *sprite_hash = script_obj_hash_get_element (state->global, "Sprite");
+        script_add_native_function (sprite_hash,
+                                    "_New",
+                                    sprite_new,
+                                    data,
+                                    NULL);
+        script_add_native_function (sprite_hash,
+                                    "GetImage",
+                                    sprite_get_image,
+                                    data,
+                                    NULL);
+        script_add_native_function (sprite_hash,
+                                    "SetImage",
+                                    sprite_set_image,
+                                    data,
+                                    "image",
+                                    NULL);
+        script_add_native_function (sprite_hash,
+                                    "GetX",
+                                    sprite_get_x,
+                                    data,
+                                    NULL);
+        script_add_native_function (sprite_hash,
+                                    "SetX",
+                                    sprite_set_x,
+                                    data,
+                                    "value",
+                                    NULL);
+        script_add_native_function (sprite_hash,
+                                    "GetY",
+                                    sprite_get_y,
+                                    data,
+                                    NULL);
+        script_add_native_function (sprite_hash,
+                                    "SetY",
+                                    sprite_set_y,
+                                    data,
+                                    "value",
+                                    NULL);
+        script_add_native_function (sprite_hash,
+                                    "GetZ",
+                                    sprite_get_z,
+                                    data,
+                                    NULL);
+        script_add_native_function (sprite_hash,
+                                    "SetZ",
+                                    sprite_set_z,
+                                    data,
+                                    "value",
+                                    NULL);
+        script_add_native_function (sprite_hash,
+                                    "GetOpacity",
+                                    sprite_get_opacity,
+                                    data,
+                                    NULL);
+        script_add_native_function (sprite_hash,
+                                    "SetOpacity",
+                                    sprite_set_opacity,
+                                    data,
+                                    "value",
+                                    NULL);
+        script_obj_unref (sprite_hash);
+
+
+        script_obj_t *window_hash = script_obj_hash_get_element (state->global, "Window");
+        script_add_native_function (window_hash,
+                                    "GetWidth",
+                                    sprite_window_get_width,
+                                    data,
+                                    "window",
+                                    NULL);
+        script_add_native_function (window_hash,
+                                    "GetHeight",
+                                    sprite_window_get_height,
+                                    data,
+                                    "window",
+                                    NULL);
+        script_add_native_function (window_hash,
+                                    "GetX",
+                                    sprite_window_get_x,
+                                    data,
+                                    "window",
+                                    NULL);
+        script_add_native_function (window_hash,
+                                    "GetY",
+                                    sprite_window_get_y,
+                                    data,
+                                    "window",
+                                    NULL);
+        script_add_native_function (window_hash,
+                                    "SetX",
+                                    sprite_window_set_x,
+                                    data,
+                                    "window",
+                                    "value",
+                                    NULL);
+        script_add_native_function (window_hash,
+                                    "SetY",
+                                    sprite_window_set_y,
+                                    data,
+                                    "window",
+                                    "value",
+                                    NULL);
+        script_add_native_function (window_hash,
+                                    "SetBackgroundTopColor",
+                                    sprite_window_set_background_top_color,
+                                    data,
+                                    "red",
+                                    "green",
+                                    "blue",
+                                    NULL);
+        script_add_native_function (window_hash,
+                                    "SetBackgroundBottomColor",
+                                    sprite_window_set_background_bottom_color,
+                                    data,
+                                    "red",
+                                    "green",
+                                    "blue",
+                                    NULL);
+        script_obj_unref (window_hash);
+
+        data->script_main_op = script_parse_string (script_lib_sprite_string, "script-lib-sprite.script");
+        data->background_color_start = 0x000000;
+        data->background_color_end = 0x000000;
+        data->full_refresh = true;
+        script_return_t ret = script_execute (state, data->script_main_op);
+        script_obj_unref (ret.object);
+        return data;
 }
 
 static int
 sprite_compare_z (void *data_a, void *data_b)
 {
- sprite_t *sprite_a = data_a;
- sprite_t *sprite_b = data_b;
- return sprite_a->z - sprite_b->z;
+        sprite_t *sprite_a = data_a;
+        sprite_t *sprite_b = data_b;
+
+        return sprite_a->z - sprite_b->z;
 }
 
 static void
-region_add_area      (ply_region_t *region,
-                      long          x,
-                      long          y,
-                      unsigned long width,
-                      unsigned long height)
+region_add_area (ply_region_t *region,
+                 long          x,
+                 long          y,
+                 unsigned long width,
+                 unsigned long height)
 {
-  ply_rectangle_t rectangle;
-  rectangle.x = x;
-  rectangle.y = y;
-  rectangle.width = width;
-  rectangle.height = height;
-  ply_region_add_rectangle (region, &rectangle);
+        ply_rectangle_t rectangle;
+
+        rectangle.x = x;
+        rectangle.y = y;
+        rectangle.width = width;
+        rectangle.height = height;
+        ply_region_add_rectangle (region, &rectangle);
 }
 
 void
 script_lib_sprite_refresh (script_lib_sprite_data_t *data)
 {
-  ply_list_node_t *node;
-  ply_region_t *region = ply_region_new ();
-  ply_list_t *rectable_list;
-
-  ply_list_sort_stable (data->sprite_list, &sprite_compare_z);
-
-  node = ply_list_get_first_node (data->sprite_list);
-
-
-  if (data->full_refresh)
-    {
-      for (node = ply_list_get_first_node (data->displays);
-           node;
-           node = ply_list_get_next_node (data->displays, node))
-        {
-          script_lib_display_t* display = ply_list_node_get_data (node);
-          region_add_area (region,
-                           display->x,
-                           display->y,
-                           ply_pixel_display_get_width (display->pixel_display),
-                           ply_pixel_display_get_height (display->pixel_display));
+        ply_list_node_t *node;
+        ply_region_t *region = ply_region_new ();
+        ply_list_t *rectable_list;
+
+        ply_list_sort_stable (data->sprite_list, &sprite_compare_z);
+
+        node = ply_list_get_first_node (data->sprite_list);
+
+
+        if (data->full_refresh) {
+                for (node = ply_list_get_first_node (data->displays);
+                     node;
+                     node = ply_list_get_next_node (data->displays, node)) {
+                        script_lib_display_t *display = ply_list_node_get_data (node);
+                        region_add_area (region,
+                                         display->x,
+                                         display->y,
+                                         ply_pixel_display_get_width (display->pixel_display),
+                                         ply_pixel_display_get_height (display->pixel_display));
+                }
+
+                data->full_refresh = false;
+        }
+
+        while (node) {
+                sprite_t *sprite = ply_list_node_get_data (node);
+                ply_list_node_t *next_node = ply_list_get_next_node (data->sprite_list,
+                                                                     node);
+                if (sprite->remove_me) {
+                        if (sprite->image) {
+                                region_add_area (region,
+                                                 sprite->old_x,
+                                                 sprite->old_y,
+                                                 sprite->old_width,
+                                                 sprite->old_height);
+                        }
+                        ply_list_remove_node (data->sprite_list, node);
+                        script_obj_unref (sprite->image_obj);
+                        free (sprite);
+                }
+                node = next_node;
         }
 
-      data->full_refresh = false;
-    }
-
-  while (node)
-    {
-      sprite_t *sprite = ply_list_node_get_data (node);
-      ply_list_node_t *next_node = ply_list_get_next_node (data->sprite_list,
-                                                           node);
-      if (sprite->remove_me)
-        {
-          if (sprite->image)
-            region_add_area (region,
-                             sprite->old_x,
-                             sprite->old_y,
-                             sprite->old_width,
-                             sprite->old_height);
-          ply_list_remove_node (data->sprite_list, node);
-          script_obj_unref (sprite->image_obj);
-          free (sprite);
+        for (node = ply_list_get_first_node (data->sprite_list);
+             node;
+             node = ply_list_get_next_node (data->sprite_list, node)) {
+                sprite_t *sprite = ply_list_node_get_data (node);
+                if (!sprite->image) continue;
+                if ((sprite->x != sprite->old_x)
+                    || (sprite->y != sprite->old_y)
+                    || (sprite->z != sprite->old_z)
+                    || (fabs (sprite->old_opacity - sprite->opacity) > 0.01) /* People can't see the difference between */
+                    || sprite->refresh_me) {
+                        ply_rectangle_t size;
+                        ply_pixel_buffer_get_size (sprite->image, &size);
+                        region_add_area (region,
+                                         sprite->x,
+                                         sprite->y,
+                                         size.width,
+                                         size.height);
+                        region_add_area (region,
+                                         sprite->old_x,
+                                         sprite->old_y,
+                                         sprite->old_width,
+                                         sprite->old_height);
+
+                        sprite->old_x = sprite->x;
+                        sprite->old_y = sprite->y;
+                        sprite->old_z = sprite->z;
+                        sprite->old_width = size.width;
+                        sprite->old_height = size.height;
+                        sprite->old_opacity = sprite->opacity;
+                        sprite->refresh_me = false;
+                }
         }
-      node = next_node;
-    }
-
-  for (node = ply_list_get_first_node (data->sprite_list);
-       node;
-       node = ply_list_get_next_node (data->sprite_list, node))
-    {
-      sprite_t *sprite = ply_list_node_get_data (node);
-      if (!sprite->image) continue;
-      if ((sprite->x != sprite->old_x)
-          || (sprite->y != sprite->old_y)
-          || (sprite->z != sprite->old_z)
-          || (fabs (sprite->old_opacity - sprite->opacity) > 0.01)      /* People can't see the difference between */
-          || sprite->refresh_me)
-        {
-          ply_rectangle_t size;
-          ply_pixel_buffer_get_size (sprite->image, &size);
-          region_add_area (region,
-                           sprite->x,
-                           sprite->y,
-                           size.width,
-                           size.height);
-          region_add_area (region,
-                           sprite->old_x,
-                           sprite->old_y,
-                           sprite->old_width,
-                           sprite->old_height);
-
-          sprite->old_x = sprite->x;
-          sprite->old_y = sprite->y;
-          sprite->old_z = sprite->z;
-          sprite->old_width = size.width;
-          sprite->old_height = size.height;
-          sprite->old_opacity = sprite->opacity;
-          sprite->refresh_me = false;
+
+        rectable_list = ply_region_get_rectangle_list (region);
+
+        for (node = ply_list_get_first_node (rectable_list);
+             node;
+             node = ply_list_get_next_node (rectable_list, node)) {
+                ply_rectangle_t *rectangle = ply_list_node_get_data (node);
+                draw_area (data,
+                           rectangle->x,
+                           rectangle->y,
+                           rectangle->width,
+                           rectangle->height);
         }
-    }
-
-  rectable_list = ply_region_get_rectangle_list (region);
-
-  for (node = ply_list_get_first_node (rectable_list);
-       node;
-       node = ply_list_get_next_node (rectable_list, node))
-    {
-      ply_rectangle_t *rectangle = ply_list_node_get_data (node);
-      draw_area (data,
-                 rectangle->x,
-                 rectangle->y,
-                 rectangle->width,
-                 rectangle->height);
-    }
-
-  ply_region_free (region);
+
+        ply_region_free (region);
 }
 
 void script_lib_sprite_destroy (script_lib_sprite_data_t *data)
 {
-  ply_list_node_t *node;
-
-  for (node = ply_list_get_first_node (data->displays);
-       node;
-       node = ply_list_get_next_node (data->displays, node))
-    {
-      script_lib_display_t* display = ply_list_node_get_data (node);
-      ply_pixel_display_set_draw_handler (display->pixel_display, NULL, NULL);
-    }
-
-  node = ply_list_get_first_node (data->sprite_list);
-
-  while (node)
-    {
-      sprite_t *sprite = ply_list_node_get_data (node);
-      ply_list_node_t *next_node = ply_list_get_next_node (data->sprite_list,
-                                                           node);
-      ply_list_remove_node (data->sprite_list, node);
-      script_obj_unref (sprite->image_obj);
-      free (sprite);
-      node = next_node;
-    }
-
-  ply_list_free (data->sprite_list);
-  script_parse_op_free (data->script_main_op);
-  script_obj_native_class_destroy (data->class);
-  free (data);
-}
+        ply_list_node_t *node;
+
+        for (node = ply_list_get_first_node (data->displays);
+             node;
+             node = ply_list_get_next_node (data->displays, node)) {
+                script_lib_display_t *display = ply_list_node_get_data (node);
+                ply_pixel_display_set_draw_handler (display->pixel_display, NULL, NULL);
+        }
 
+        node = ply_list_get_first_node (data->sprite_list);
+
+        while (node) {
+                sprite_t *sprite = ply_list_node_get_data (node);
+                ply_list_node_t *next_node = ply_list_get_next_node (data->sprite_list,
+                                                                     node);
+                ply_list_remove_node (data->sprite_list, node);
+                script_obj_unref (sprite->image_obj);
+                free (sprite);
+                node = next_node;
+        }
+
+        ply_list_free (data->sprite_list);
+        script_parse_op_free (data->script_main_op);
+        script_obj_native_class_destroy (data->class);
+        free (data);
+}
diff --git a/src/plugins/splash/script/script-lib-sprite.h b/src/plugins/splash/script/script-lib-sprite.h
index 0cb0681..55105c3 100644
--- a/src/plugins/splash/script/script-lib-sprite.h
+++ b/src/plugins/splash/script/script-lib-sprite.h
@@ -28,39 +28,39 @@
 
 typedef struct
 {
-  ply_list_t                *displays;
-  ply_list_t                *sprite_list;
-  script_obj_native_class_t *class;
-  script_op_t               *script_main_op;
-  uint32_t                   background_color_start;
-  uint32_t                   background_color_end;
-  bool                       full_refresh;
+        ply_list_t                *displays;
+        ply_list_t                *sprite_list;
+        script_obj_native_class_t *class;
+        script_op_t               *script_main_op;
+        uint32_t                   background_color_start;
+        uint32_t                   background_color_end;
+        bool                       full_refresh;
 } script_lib_sprite_data_t;
 
 typedef struct
 {
-  ply_pixel_display_t      *pixel_display;
-  script_lib_sprite_data_t *data;
-  int                       x; 
-  int                       y; 
+        ply_pixel_display_t      *pixel_display;
+        script_lib_sprite_data_t *data;
+        int                       x;
+        int                       y;
 } script_lib_display_t;
 
 typedef struct
 {
-  int                 x;
-  int                 y;
-  int                 z;
-  double              opacity;
-  int                 old_x;
-  int                 old_y;
-  int                 old_z;
-  int                 old_width;
-  int                 old_height;
-  double              old_opacity;
-  bool                refresh_me;
-  bool                remove_me;
-  ply_pixel_buffer_t *image;
-  script_obj_t       *image_obj;
+        int                 x;
+        int                 y;
+        int                 z;
+        double              opacity;
+        int                 old_x;
+        int                 old_y;
+        int                 old_z;
+        int                 old_width;
+        int                 old_height;
+        double              old_opacity;
+        bool                refresh_me;
+        bool                remove_me;
+        ply_pixel_buffer_t *image;
+        script_obj_t       *image_obj;
 } sprite_t;
 
 script_lib_sprite_data_t *script_lib_sprite_setup (script_state_t *state,
diff --git a/src/plugins/splash/script/script-lib-string.c b/src/plugins/splash/script/script-lib-string.c
index 0b836eb..6fb5e7d 100644
--- a/src/plugins/splash/script/script-lib-string.c
+++ b/src/plugins/splash/script/script-lib-string.c
@@ -39,91 +39,85 @@
 static script_return_t script_lib_string_char_at (script_state_t *state,
                                                   void           *user_data)
 {
-  char *text = script_obj_as_string (state->this);
-  int index = script_obj_hash_get_number (state->local, "index");
-  int count;
-  char charstring [2];
-  
-  if (!text || index < 0)
-    {
-      free (text);
-      return script_return_obj_null ();
-    }
-  for (count = 0; count < index; count++)
-    {
-      if (text[count] == '\0')
-        {
-          free (text);
-          return script_return_obj(script_obj_new_string (""));
+        char *text = script_obj_as_string (state->this);
+        int index = script_obj_hash_get_number (state->local, "index");
+        int count;
+        char charstring [2];
+
+        if (!text || index < 0) {
+                free (text);
+                return script_return_obj_null ();
+        }
+        for (count = 0; count < index; count++) {
+                if (text[count] == '\0') {
+                        free (text);
+                        return script_return_obj (script_obj_new_string (""));
+                }
         }
-    }
-  charstring[0] = text[index];
-  charstring[1] = '\0';
-  free (text);
-  return script_return_obj(script_obj_new_string (charstring));
+        charstring[0] = text[index];
+        charstring[1] = '\0';
+        free (text);
+        return script_return_obj (script_obj_new_string (charstring));
 }
 
 static script_return_t script_lib_string_sub_string (script_state_t *state,
                                                      void           *user_data)
 {
-  char *text = script_obj_as_string (state->this);
-  int start = script_obj_hash_get_number (state->local, "start");
-  int end = script_obj_hash_get_number (state->local, "end");
-  int text_count;
-  char* substring;
-  script_obj_t *substring_obj;
+        char *text = script_obj_as_string (state->this);
+        int start = script_obj_hash_get_number (state->local, "start");
+        int end = script_obj_hash_get_number (state->local, "end");
+        int text_count;
+        char *substring;
+        script_obj_t *substring_obj;
 
-  if (!text || start < 0 || end < start)
-    {
-      free (text);
-      return script_return_obj_null ();
-    }
+        if (!text || start < 0 || end < start) {
+                free (text);
+                return script_return_obj_null ();
+        }
 
-  for (text_count = 0; text_count < start; text_count++)
-    {
-      if (text[text_count] == '\0')
-        {
-          free (text);
-          return script_return_obj(script_obj_new_string (""));
+        for (text_count = 0; text_count < start; text_count++) {
+                if (text[text_count] == '\0') {
+                        free (text);
+                        return script_return_obj (script_obj_new_string (""));
+                }
         }
-    }
 
-  substring = strndup(&text[text_count], end - start);
-  substring_obj = script_obj_new_string (substring);
-  free (substring);
-  free (text);
-  return script_return_obj(substring_obj);
+        substring = strndup (&text[text_count], end - start);
+        substring_obj = script_obj_new_string (substring);
+        free (substring);
+        free (text);
+        return script_return_obj (substring_obj);
 }
 
 script_lib_string_data_t *script_lib_string_setup (script_state_t *state)
 {
-  script_lib_string_data_t *data = malloc (sizeof (script_lib_string_data_t));
+        script_lib_string_data_t *data = malloc (sizeof(script_lib_string_data_t));
 
-  script_obj_t *string_hash = script_obj_hash_get_element (state->global, "String");
-  script_add_native_function (string_hash,
-                              "CharAt",
-                              script_lib_string_char_at,
-                              NULL,
-                              "index",
-                              NULL);
-  script_add_native_function (string_hash,
-                              "SubString",
-                              script_lib_string_sub_string,
-                              NULL,
-                              "start",
-                              "end",
-                              NULL);
-  script_obj_unref (string_hash);
-  data->script_main_op = script_parse_string (script_lib_string_string, "script-lib-string.script");
-  script_return_t ret = script_execute (state, data->script_main_op);
-  script_obj_unref (ret.object);
+        script_obj_t *string_hash = script_obj_hash_get_element (state->global, "String");
 
-  return data;
+        script_add_native_function (string_hash,
+                                    "CharAt",
+                                    script_lib_string_char_at,
+                                    NULL,
+                                    "index",
+                                    NULL);
+        script_add_native_function (string_hash,
+                                    "SubString",
+                                    script_lib_string_sub_string,
+                                    NULL,
+                                    "start",
+                                    "end",
+                                    NULL);
+        script_obj_unref (string_hash);
+        data->script_main_op = script_parse_string (script_lib_string_string, "script-lib-string.script");
+        script_return_t ret = script_execute (state, data->script_main_op);
+        script_obj_unref (ret.object);
+
+        return data;
 }
 
 void script_lib_string_destroy (script_lib_string_data_t *data)
 {
-  script_parse_op_free (data->script_main_op);
-  free (data);
+        script_parse_op_free (data->script_main_op);
+        free (data);
 }
-
diff --git a/src/plugins/splash/script/script-lib-string.h b/src/plugins/splash/script/script-lib-string.h
index 1ea6db8..642ac2e 100644
--- a/src/plugins/splash/script/script-lib-string.h
+++ b/src/plugins/splash/script/script-lib-string.h
@@ -26,7 +26,7 @@
 
 typedef struct
 {
-  script_op_t      *script_main_op;
+        script_op_t *script_main_op;
 } script_lib_string_data_t;
 
 script_lib_string_data_t *script_lib_string_setup (script_state_t *state);
diff --git a/src/plugins/splash/script/script-object.c b/src/plugins/splash/script/script-object.c
index 7c16c94..54b6d4c 100644
--- a/src/plugins/splash/script/script-object.c
+++ b/src/plugins/splash/script/script-object.c
@@ -44,583 +44,570 @@ void script_obj_reset (script_obj_t *obj);
 
 void script_obj_free (script_obj_t *obj)
 {
-  assert (!obj->refcount);
-  script_obj_reset (obj);
-  free (obj);
+        assert (!obj->refcount);
+        script_obj_reset (obj);
+        free (obj);
 }
 
 void script_obj_ref (script_obj_t *obj)
 {
-  obj->refcount++;
+        obj->refcount++;
 }
 
 void script_obj_unref (script_obj_t *obj)
 {
-  if (!obj) return;
-  assert (obj->refcount > 0);
-  obj->refcount--;
-  if (obj->refcount <= 0)
-    script_obj_free (obj);
+        if (!obj) return;
+        assert (obj->refcount > 0);
+        obj->refcount--;
+        if (obj->refcount <= 0)
+                script_obj_free (obj);
 }
 
 static void foreach_free_variable (void *key,
                                    void *data,
                                    void *user_data)
 {
-  script_variable_t *variable = data;
+        script_variable_t *variable = data;
 
-  script_obj_unref (variable->object);
-  free (variable->name);
-  free (variable);
+        script_obj_unref (variable->object);
+        free (variable->name);
+        free (variable);
 }
 
 void script_obj_reset (script_obj_t *obj)
 {
-  switch (obj->type)
-    {
-      case SCRIPT_OBJ_TYPE_REF:
-        script_obj_unref (obj->data.obj);
-        break;
+        switch (obj->type) {
+        case SCRIPT_OBJ_TYPE_REF:
+                script_obj_unref (obj->data.obj);
+                break;
 
-      case SCRIPT_OBJ_TYPE_EXTEND:
-        script_obj_unref (obj->data.dual_obj.obj_a);
-        script_obj_unref (obj->data.dual_obj.obj_b);
-        break;
+        case SCRIPT_OBJ_TYPE_EXTEND:
+                script_obj_unref (obj->data.dual_obj.obj_a);
+                script_obj_unref (obj->data.dual_obj.obj_b);
+                break;
 
-      case SCRIPT_OBJ_TYPE_NUMBER:
-        break;
+        case SCRIPT_OBJ_TYPE_NUMBER:
+                break;
 
-      case SCRIPT_OBJ_TYPE_STRING:
-        free (obj->data.string);
-        break;
+        case SCRIPT_OBJ_TYPE_STRING:
+                free (obj->data.string);
+                break;
 
-      case SCRIPT_OBJ_TYPE_HASH:                /* FIXME nightmare */
-        ply_hashtable_foreach (obj->data.hash, foreach_free_variable, NULL);
-        ply_hashtable_free (obj->data.hash);
-        break;
+        case SCRIPT_OBJ_TYPE_HASH:              /* FIXME nightmare */
+                ply_hashtable_foreach (obj->data.hash, foreach_free_variable, NULL);
+                ply_hashtable_free (obj->data.hash);
+                break;
 
-      case SCRIPT_OBJ_TYPE_FUNCTION:
+        case SCRIPT_OBJ_TYPE_FUNCTION:
         {
-          if (obj->data.function->freeable)
-            {
-              ply_list_node_t *node;
-              for (node =
-                     ply_list_get_first_node (obj->data.function->parameters);
-                   node;
-                   node =
-                     ply_list_get_next_node (obj->data.function->parameters,
-                                             node))
-                {
-                  char *operand = ply_list_node_get_data (node);
-                  free (operand);
+                if (obj->data.function->freeable) {
+                        ply_list_node_t *node;
+                        for (node =
+                                     ply_list_get_first_node (obj->data.function->parameters);
+                             node;
+                             node =
+                                     ply_list_get_next_node (obj->data.function->parameters,
+                                                             node)) {
+                                char *operand = ply_list_node_get_data (node);
+                                free (operand);
+                        }
+                        ply_list_free (obj->data.function->parameters);
+                        free (obj->data.function);
                 }
-              ply_list_free (obj->data.function->parameters);
-              free (obj->data.function);
-            }
         }
         break;
 
-      case SCRIPT_OBJ_TYPE_NATIVE:
-        if (obj->data.native.class->free_func)
-          obj->data.native.class->free_func (obj);
-        break;
+        case SCRIPT_OBJ_TYPE_NATIVE:
+                if (obj->data.native.class->free_func)
+                        obj->data.native.class->free_func (obj);
+                break;
 
-      case SCRIPT_OBJ_TYPE_NULL:
-        break;
-    }
-  obj->type = SCRIPT_OBJ_TYPE_NULL;
+        case SCRIPT_OBJ_TYPE_NULL:
+                break;
+        }
+        obj->type = SCRIPT_OBJ_TYPE_NULL;
 }
 
 script_obj_t *script_obj_deref_direct (script_obj_t *obj)
 {
-  while (obj->type == SCRIPT_OBJ_TYPE_REF)
-    obj = obj->data.obj;
-  return obj;
+        while (obj->type == SCRIPT_OBJ_TYPE_REF) {
+                obj = obj->data.obj;
+        }
+        return obj;
 }
 
 void script_obj_deref (script_obj_t **obj_ptr)
 {
-  script_obj_t *obj = *obj_ptr;
+        script_obj_t *obj = *obj_ptr;
 
-  obj = script_obj_deref_direct (obj);
-  script_obj_ref (obj);
-  script_obj_unref (*obj_ptr);
-  *obj_ptr = obj;
+        obj = script_obj_deref_direct (obj);
+        script_obj_ref (obj);
+        script_obj_unref (*obj_ptr);
+        *obj_ptr = obj;
 }
 
 script_obj_t *script_obj_new_null (void)
 {
-  script_obj_t *obj = malloc (sizeof (script_obj_t));
+        script_obj_t *obj = malloc (sizeof(script_obj_t));
 
-  obj->type = SCRIPT_OBJ_TYPE_NULL;
-  obj->refcount = 1;
-  return obj;
+        obj->type = SCRIPT_OBJ_TYPE_NULL;
+        obj->refcount = 1;
+        return obj;
 }
 
 script_obj_t *script_obj_new_number (script_number_t number)
 {
-  script_obj_t *obj = malloc (sizeof (script_obj_t));
-  obj->type = SCRIPT_OBJ_TYPE_NUMBER;
-  obj->refcount = 1;
-  obj->data.number = number;
-  return obj;
+        script_obj_t *obj = malloc (sizeof(script_obj_t));
+
+        obj->type = SCRIPT_OBJ_TYPE_NUMBER;
+        obj->refcount = 1;
+        obj->data.number = number;
+        return obj;
 }
 
 script_obj_t *script_obj_new_string (const char *string)
 {
-  if (!string) return script_obj_new_null ();
-  script_obj_t *obj = malloc (sizeof (script_obj_t));
-  obj->type = SCRIPT_OBJ_TYPE_STRING;
-  obj->refcount = 1;
-  obj->data.string = strdup (string);
-  return obj;
+        if (!string) return script_obj_new_null ();
+        script_obj_t *obj = malloc (sizeof(script_obj_t));
+        obj->type = SCRIPT_OBJ_TYPE_STRING;
+        obj->refcount = 1;
+        obj->data.string = strdup (string);
+        return obj;
 }
 
 script_obj_t *script_obj_new_hash (void)
 {
-  script_obj_t *obj = malloc (sizeof (script_obj_t));
+        script_obj_t *obj = malloc (sizeof(script_obj_t));
 
-  obj->type = SCRIPT_OBJ_TYPE_HASH;
-  obj->data.hash = ply_hashtable_new (ply_hashtable_string_hash,
-                                      ply_hashtable_string_compare);
-  obj->refcount = 1;
-  return obj;
+        obj->type = SCRIPT_OBJ_TYPE_HASH;
+        obj->data.hash = ply_hashtable_new (ply_hashtable_string_hash,
+                                            ply_hashtable_string_compare);
+        obj->refcount = 1;
+        return obj;
 }
 
 script_obj_t *script_obj_new_function (script_function_t *function)
 {
-  script_obj_t *obj = malloc (sizeof (script_obj_t));
+        script_obj_t *obj = malloc (sizeof(script_obj_t));
 
-  obj->type = SCRIPT_OBJ_TYPE_FUNCTION;
-  obj->data.function = function;
-  obj->refcount = 1;
-  return obj;
+        obj->type = SCRIPT_OBJ_TYPE_FUNCTION;
+        obj->data.function = function;
+        obj->refcount = 1;
+        return obj;
 }
 
 script_obj_t *script_obj_new_ref (script_obj_t *sub_obj)
 {
-  script_obj_t *obj = malloc (sizeof (script_obj_t));
-  sub_obj = script_obj_deref_direct (sub_obj);
-  script_obj_ref (sub_obj);
-  obj->type = SCRIPT_OBJ_TYPE_REF;
-  obj->data.obj = sub_obj;
-  obj->refcount = 1;
-  return obj;
+        script_obj_t *obj = malloc (sizeof(script_obj_t));
+
+        sub_obj = script_obj_deref_direct (sub_obj);
+        script_obj_ref (sub_obj);
+        obj->type = SCRIPT_OBJ_TYPE_REF;
+        obj->data.obj = sub_obj;
+        obj->refcount = 1;
+        return obj;
 }
 
 script_obj_t *script_obj_new_extend (script_obj_t *obj_a, script_obj_t *obj_b)
 {
-  script_obj_t *obj = malloc (sizeof (script_obj_t));
-  obj_a = script_obj_deref_direct (obj_a);
-  obj_b = script_obj_deref_direct (obj_b);
-  script_obj_ref (obj_a);
-  script_obj_ref (obj_b);
-  obj->type = SCRIPT_OBJ_TYPE_EXTEND;
-  obj->data.dual_obj.obj_a = obj_a;
-  obj->data.dual_obj.obj_b = obj_b;
-  obj->refcount = 1;
-  return obj;
+        script_obj_t *obj = malloc (sizeof(script_obj_t));
+
+        obj_a = script_obj_deref_direct (obj_a);
+        obj_b = script_obj_deref_direct (obj_b);
+        script_obj_ref (obj_a);
+        script_obj_ref (obj_b);
+        obj->type = SCRIPT_OBJ_TYPE_EXTEND;
+        obj->data.dual_obj.obj_a = obj_a;
+        obj->data.dual_obj.obj_b = obj_b;
+        obj->refcount = 1;
+        return obj;
 }
 
 script_obj_t *script_obj_new_native (void                      *object_data,
                                      script_obj_native_class_t *class)
 {
-  if (!object_data) return script_obj_new_null ();
-  script_obj_t *obj = malloc (sizeof (script_obj_t));
-  obj->type = SCRIPT_OBJ_TYPE_NATIVE;
-  obj->data.native.class = class;
-  obj->data.native.object_data = object_data;
-  obj->refcount = 1;
-  return obj;
-}
-
-void *script_obj_as_custom (script_obj_t             *obj,
-                            script_obj_direct_func_t  user_func,
-                            void                     *user_data)
-{
-  obj = script_obj_deref_direct (obj);
-  void *reply = user_func(obj, user_data);
-  if (reply) return reply;
-  if (obj->type == SCRIPT_OBJ_TYPE_EXTEND)
-    {
-      reply = script_obj_as_custom(obj->data.dual_obj.obj_a, user_func, user_data);
-      if (reply) return reply;
-      reply = script_obj_as_custom(obj->data.dual_obj.obj_b, user_func, user_data);
-      if (reply) return reply;
-    }
-  return NULL;
-}
-
-script_obj_t *script_obj_as_obj_type (script_obj_t      *obj,
-                                      script_obj_type_t  type)
-{
-  obj = script_obj_deref_direct (obj);
-  if (obj->type == type) return obj;
-  if (obj->type == SCRIPT_OBJ_TYPE_EXTEND)
-    {
-      script_obj_t *reply;
-      reply = script_obj_as_obj_type(obj->data.dual_obj.obj_a, type);
-      if (reply) return reply;
-      reply = script_obj_as_obj_type(obj->data.dual_obj.obj_b, type);
-      if (reply) return reply;
-    }
-  return NULL;
+        if (!object_data) return script_obj_new_null ();
+        script_obj_t *obj = malloc (sizeof(script_obj_t));
+        obj->type = SCRIPT_OBJ_TYPE_NATIVE;
+        obj->data.native.class = class;
+        obj->data.native.object_data = object_data;
+        obj->refcount = 1;
+        return obj;
+}
+
+void *script_obj_as_custom (script_obj_t            *obj,
+                            script_obj_direct_func_t user_func,
+                            void                    *user_data)
+{
+        obj = script_obj_deref_direct (obj);
+        void *reply = user_func (obj, user_data);
+        if (reply) return reply;
+        if (obj->type == SCRIPT_OBJ_TYPE_EXTEND) {
+                reply = script_obj_as_custom (obj->data.dual_obj.obj_a, user_func, user_data);
+                if (reply) return reply;
+                reply = script_obj_as_custom (obj->data.dual_obj.obj_b, user_func, user_data);
+                if (reply) return reply;
+        }
+        return NULL;
+}
+
+script_obj_t *script_obj_as_obj_type (script_obj_t     *obj,
+                                      script_obj_type_t type)
+{
+        obj = script_obj_deref_direct (obj);
+        if (obj->type == type) return obj;
+        if (obj->type == SCRIPT_OBJ_TYPE_EXTEND) {
+                script_obj_t *reply;
+                reply = script_obj_as_obj_type (obj->data.dual_obj.obj_a, type);
+                if (reply) return reply;
+                reply = script_obj_as_obj_type (obj->data.dual_obj.obj_b, type);
+                if (reply) return reply;
+        }
+        return NULL;
 }
 
 script_number_t script_obj_as_number (script_obj_t *obj)
 {                                                     /* If in then reply contents, otherwise reply NAN */
-  obj = script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_NUMBER);
-  if (obj) return obj->data.number;
-  return NAN;
+        obj = script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_NUMBER);
+        if (obj) return obj->data.number;
+        return NAN;
 }
 
 static void *script_obj_direct_as_bool (script_obj_t *obj,
                                         void         *user_data)
 {                                                 /* False objects are NULL, 0, NAN, "" */
-  switch (obj->type)
-    {
-      case SCRIPT_OBJ_TYPE_NUMBER:
+        switch (obj->type) {
+        case SCRIPT_OBJ_TYPE_NUMBER:
         {
-          int num_type = fpclassify(obj->data.number);
-          if (num_type == FP_ZERO || num_type == FP_NAN) return NULL;
-          return obj;
+                int num_type = fpclassify (obj->data.number);
+                if (num_type == FP_ZERO || num_type == FP_NAN) return NULL;
+                return obj;
+        }
+        case SCRIPT_OBJ_TYPE_NULL:
+        case SCRIPT_OBJ_TYPE_REF:
+        case SCRIPT_OBJ_TYPE_EXTEND:
+                return NULL;
+        case SCRIPT_OBJ_TYPE_HASH:
+        case SCRIPT_OBJ_TYPE_FUNCTION:
+        case SCRIPT_OBJ_TYPE_NATIVE:
+                return obj;
+        case SCRIPT_OBJ_TYPE_STRING:
+                if (*obj->data.string) return obj;
+                return NULL;
         }
-      case SCRIPT_OBJ_TYPE_NULL:
-      case SCRIPT_OBJ_TYPE_REF:
-      case SCRIPT_OBJ_TYPE_EXTEND:
-        return NULL;
-      case SCRIPT_OBJ_TYPE_HASH:
-      case SCRIPT_OBJ_TYPE_FUNCTION:
-      case SCRIPT_OBJ_TYPE_NATIVE:
-        return obj;
-      case SCRIPT_OBJ_TYPE_STRING:
-        if (*obj->data.string) return obj;
         return NULL;
-    }
-  return NULL;
 }
 
 bool script_obj_as_bool (script_obj_t *obj)
 {
-  return script_obj_as_custom(obj, script_obj_direct_as_bool, NULL);
+        return script_obj_as_custom (obj, script_obj_direct_as_bool, NULL);
 }
 
 char *script_obj_as_string (script_obj_t *obj)              /* reply is strdupped and may be NULL */
 {
-  char *reply;        
-  script_obj_t *string_obj = script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_STRING);
-  if (string_obj) return strdup (string_obj->data.string);
-  string_obj = script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_NUMBER);
-  if (string_obj)
-    {
-        asprintf (&reply, "%g", string_obj->data.number);
+        char *reply;
+        script_obj_t *string_obj = script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_STRING);
+
+        if (string_obj) return strdup (string_obj->data.string);
+        string_obj = script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_NUMBER);
+        if (string_obj) {
+                asprintf (&reply, "%g", string_obj->data.number);
+                return reply;
+        }
+        if (script_obj_is_null (obj))
+                return strdup ("#NULL");
+        asprintf (&reply, "#(0x%p)", obj);
         return reply;
-    }
-  if (script_obj_is_null (obj))
-    return strdup("#NULL");
-  asprintf (&reply, "#(0x%p)", obj);
-  return reply;
 }
 
 static void *script_obj_direct_as_native_of_class (script_obj_t *obj,
                                                    void         *user_data)
 {
-  script_obj_native_class_t *class = user_data;
-  if (obj->type == SCRIPT_OBJ_TYPE_NATIVE && obj->data.native.class == class)
-    return obj->data.native.object_data;
-  return NULL;
+        script_obj_native_class_t *class = user_data;
+
+        if (obj->type == SCRIPT_OBJ_TYPE_NATIVE && obj->data.native.class == class)
+                return obj->data.native.object_data;
+        return NULL;
 }
 
 void *script_obj_as_native_of_class (script_obj_t              *obj,
                                      script_obj_native_class_t *class)
 {
-  return script_obj_as_custom(obj, script_obj_direct_as_native_of_class, class);
+        return script_obj_as_custom (obj, script_obj_direct_as_native_of_class, class);
 }
 
 static void *script_obj_direct_as_native_of_class_name (script_obj_t *obj,
                                                         void         *user_data)
 {
-  const char *class_name = user_data;
-  if (obj->type == SCRIPT_OBJ_TYPE_NATIVE &&
-      !strcmp (obj->data.native.class->name, class_name))
-    return obj->data.native.object_data;
-  return NULL;
+        const char *class_name = user_data;
+
+        if (obj->type == SCRIPT_OBJ_TYPE_NATIVE &&
+            !strcmp (obj->data.native.class->name, class_name))
+                return obj->data.native.object_data;
+        return NULL;
 }
 
 void *script_obj_as_native_of_class_name (script_obj_t *obj,
                                           const char   *class_name)
 {
-  return script_obj_as_custom(obj, 
-                              script_obj_direct_as_native_of_class_name,
-                              (void*) class_name);
+        return script_obj_as_custom (obj,
+                                     script_obj_direct_as_native_of_class_name,
+                                     (void *) class_name);
 }
 
 bool script_obj_is_null (script_obj_t *obj)
 {
-  return script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_NULL);
+        return script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_NULL);
 }
 
 bool script_obj_is_number (script_obj_t *obj)
 {
-  return script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_NUMBER);
+        return script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_NUMBER);
 }
 
 bool script_obj_is_string (script_obj_t *obj)
 {
-  return script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_STRING);
+        return script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_STRING);
 }
 
 bool script_obj_is_hash (script_obj_t *obj)
 {
-  return script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_HASH);
+        return script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_HASH);
 }
 
 bool script_obj_is_native (script_obj_t *obj)
 {
-  return script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_NATIVE);
+        return script_obj_as_obj_type (obj, SCRIPT_OBJ_TYPE_NATIVE);
 }
 
 bool script_obj_is_native_of_class (script_obj_t              *obj,
                                     script_obj_native_class_t *class)
 {
-  return script_obj_as_custom(obj, 
-                              script_obj_direct_as_native_of_class,
-                              class);
+        return script_obj_as_custom (obj,
+                                     script_obj_direct_as_native_of_class,
+                                     class);
 }
 
 bool script_obj_is_native_of_class_name (script_obj_t *obj,
                                          const char   *class_name)
 {
-  return script_obj_as_custom(obj, 
-                              script_obj_direct_as_native_of_class_name,
-                              (void*)class_name);
+        return script_obj_as_custom (obj,
+                                     script_obj_direct_as_native_of_class_name,
+                                     (void *) class_name);
 }
 
 void script_obj_assign (script_obj_t *obj_a,
                         script_obj_t *obj_b)
 {
-  obj_b = script_obj_deref_direct (obj_b);
-  script_obj_ref (obj_b);
-  script_obj_reset (obj_a);
-  obj_a->type = SCRIPT_OBJ_TYPE_REF;
-  obj_a->data.obj = obj_b;
+        obj_b = script_obj_deref_direct (obj_b);
+        script_obj_ref (obj_b);
+        script_obj_reset (obj_a);
+        obj_a->type = SCRIPT_OBJ_TYPE_REF;
+        obj_a->data.obj = obj_b;
 }
 
 static void *script_obj_direct_as_hash_element (script_obj_t *obj,
                                                 void         *user_data)
 {
-  const char *name = user_data;
-  if (obj->type == SCRIPT_OBJ_TYPE_HASH)
-    {
-      script_variable_t *variable = ply_hashtable_lookup (obj->data.hash, (void *) name);
-      if (variable)
-        return variable->object;
-    }
-  return NULL;
+        const char *name = user_data;
+
+        if (obj->type == SCRIPT_OBJ_TYPE_HASH) {
+                script_variable_t *variable = ply_hashtable_lookup (obj->data.hash, (void *) name);
+                if (variable)
+                        return variable->object;
+        }
+        return NULL;
 }
 
 script_obj_t *script_obj_hash_peek_element (script_obj_t *hash,
                                             const char   *name)
 {
-  script_obj_t *object;
-  if (!name) return script_obj_new_null ();
-  object = script_obj_as_custom(hash,
-                                script_obj_direct_as_hash_element,
-                                (void*) name);
-  if (object) script_obj_ref (object);
-  return object;
+        script_obj_t *object;
+
+        if (!name) return script_obj_new_null ();
+        object = script_obj_as_custom (hash,
+                                       script_obj_direct_as_hash_element,
+                                       (void *) name);
+        if (object) script_obj_ref (object);
+        return object;
 }
 
 script_obj_t *script_obj_hash_get_element (script_obj_t *hash,
                                            const char   *name)
 {
-  script_obj_t *obj = script_obj_hash_peek_element (hash, name);
-  if (obj) return obj;
-  script_obj_t *realhash = script_obj_as_obj_type (hash, SCRIPT_OBJ_TYPE_HASH);
-  if (!realhash)
-    {
-      realhash = script_obj_new_hash();   /* If it wasn't a hash then make it into one */
-      script_obj_assign (hash, realhash);
-    }
-  script_variable_t *variable = malloc (sizeof (script_variable_t));
-  variable->name = strdup (name);
-  variable->object = script_obj_new_null ();
-  ply_hashtable_insert (realhash->data.hash, variable->name, variable);
-  script_obj_ref (variable->object);
-  return variable->object;
+        script_obj_t *obj = script_obj_hash_peek_element (hash, name);
+
+        if (obj) return obj;
+        script_obj_t *realhash = script_obj_as_obj_type (hash, SCRIPT_OBJ_TYPE_HASH);
+        if (!realhash) {
+                realhash = script_obj_new_hash (); /* If it wasn't a hash then make it into one */
+                script_obj_assign (hash, realhash);
+        }
+        script_variable_t *variable = malloc (sizeof(script_variable_t));
+        variable->name = strdup (name);
+        variable->object = script_obj_new_null ();
+        ply_hashtable_insert (realhash->data.hash, variable->name, variable);
+        script_obj_ref (variable->object);
+        return variable->object;
 }
 
 script_number_t script_obj_hash_get_number (script_obj_t *hash,
                                             const char   *name)
 {
-  script_obj_t *obj = script_obj_hash_get_element (hash, name);
-  script_number_t reply = script_obj_as_number (obj);
+        script_obj_t *obj = script_obj_hash_get_element (hash, name);
+        script_number_t reply = script_obj_as_number (obj);
 
-  script_obj_unref (obj);
-  return reply;
+        script_obj_unref (obj);
+        return reply;
 }
 
 bool script_obj_hash_get_bool (script_obj_t *hash,
                                const char   *name)
 {
-  script_obj_t *obj = script_obj_hash_get_element (hash, name);
-  bool reply = script_obj_as_bool (obj);
+        script_obj_t *obj = script_obj_hash_get_element (hash, name);
+        bool reply = script_obj_as_bool (obj);
 
-  script_obj_unref (obj);
-  return reply;
+        script_obj_unref (obj);
+        return reply;
 }
 
 char *script_obj_hash_get_string (script_obj_t *hash,
                                   const char   *name)
 {
-  script_obj_t *obj = script_obj_hash_get_element (hash, name);
-  char *reply = script_obj_as_string (obj);
+        script_obj_t *obj = script_obj_hash_get_element (hash, name);
+        char *reply = script_obj_as_string (obj);
 
-  script_obj_unref (obj);
-  return reply;
+        script_obj_unref (obj);
+        return reply;
 }
 
 void *script_obj_hash_get_native_of_class (script_obj_t              *hash,
                                            const char                *name,
                                            script_obj_native_class_t *class)
 {
-  script_obj_t *obj = script_obj_hash_get_element (hash, name);
-  void *reply = script_obj_as_native_of_class (obj, class);
+        script_obj_t *obj = script_obj_hash_get_element (hash, name);
+        void *reply = script_obj_as_native_of_class (obj, class);
 
-  script_obj_unref (obj);
-  return reply;
+        script_obj_unref (obj);
+        return reply;
 }
 
 void *script_obj_hash_get_native_of_class_name (script_obj_t *hash,
                                                 const char   *name,
                                                 const char   *class_name)
 {
-  script_obj_t *obj = script_obj_hash_get_element (hash, name);
-  void *reply = script_obj_as_native_of_class_name (obj, class_name);
+        script_obj_t *obj = script_obj_hash_get_element (hash, name);
+        void *reply = script_obj_as_native_of_class_name (obj, class_name);
 
-  script_obj_unref (obj);
-  return reply;
+        script_obj_unref (obj);
+        return reply;
 }
 
 void script_obj_hash_add_element (script_obj_t *hash,
                                   script_obj_t *element,
                                   const char   *name)
 {
-  script_obj_t *obj = script_obj_hash_get_element (hash, name);
-  script_obj_assign (obj, element);
-  script_obj_unref (obj);
+        script_obj_t *obj = script_obj_hash_get_element (hash, name);
+
+        script_obj_assign (obj, element);
+        script_obj_unref (obj);
 }
 
 script_obj_t *script_obj_plus (script_obj_t *script_obj_a,
                                script_obj_t *script_obj_b)
 {
-  if (script_obj_is_number (script_obj_a) && script_obj_is_number (script_obj_b))
-    {
-      script_number_t value = script_obj_as_number (script_obj_a) + script_obj_as_number (script_obj_b);
-      return script_obj_new_number (value);
-    }
-  if (script_obj_is_string (script_obj_a) || script_obj_is_string (script_obj_b))
-    {
-      script_obj_t *obj;
-      char *string_a = script_obj_as_string (script_obj_a);
-      char *string_b = script_obj_as_string (script_obj_b);
-      if (string_a && string_b)
-        {
-          char *newstring;
-          asprintf (&newstring, "%s%s", string_a, string_b);
-          obj = script_obj_new_string (newstring);
-          free (newstring);
+        if (script_obj_is_number (script_obj_a) && script_obj_is_number (script_obj_b)) {
+                script_number_t value = script_obj_as_number (script_obj_a) + script_obj_as_number (script_obj_b);
+                return script_obj_new_number (value);
         }
-      else
-        obj = script_obj_new_null ();
-      free (string_a);
-      free (string_b);
-      return obj;
-    }
-  return script_obj_new_null ();
+        if (script_obj_is_string (script_obj_a) || script_obj_is_string (script_obj_b)) {
+                script_obj_t *obj;
+                char *string_a = script_obj_as_string (script_obj_a);
+                char *string_b = script_obj_as_string (script_obj_b);
+                if (string_a && string_b) {
+                        char *newstring;
+                        asprintf (&newstring, "%s%s", string_a, string_b);
+                        obj = script_obj_new_string (newstring);
+                        free (newstring);
+                } else {
+                        obj = script_obj_new_null ();
+                }
+                free (string_a);
+                free (string_b);
+                return obj;
+        }
+        return script_obj_new_null ();
 }
 
 script_obj_t *script_obj_minus (script_obj_t *script_obj_a,
                                 script_obj_t *script_obj_b)
 {
-  if (script_obj_is_number (script_obj_a) && script_obj_is_number (script_obj_b))
-    {
-      script_number_t value = script_obj_as_number (script_obj_a) - script_obj_as_number (script_obj_b);
-      return script_obj_new_number (value);
-    }
-  return script_obj_new_null ();
+        if (script_obj_is_number (script_obj_a) && script_obj_is_number (script_obj_b)) {
+                script_number_t value = script_obj_as_number (script_obj_a) - script_obj_as_number (script_obj_b);
+                return script_obj_new_number (value);
+        }
+        return script_obj_new_null ();
 }
 
 script_obj_t *script_obj_mul (script_obj_t *script_obj_a,
                               script_obj_t *script_obj_b)
 {
-  if (script_obj_is_number (script_obj_a) && script_obj_is_number (script_obj_b))
-    {
-      script_number_t value = script_obj_as_number (script_obj_a) * script_obj_as_number (script_obj_b);
-      return script_obj_new_number (value);
-    }
-  return script_obj_new_null ();
+        if (script_obj_is_number (script_obj_a) && script_obj_is_number (script_obj_b)) {
+                script_number_t value = script_obj_as_number (script_obj_a) * script_obj_as_number (script_obj_b);
+                return script_obj_new_number (value);
+        }
+        return script_obj_new_null ();
 }
 
 script_obj_t *script_obj_div (script_obj_t *script_obj_a,
                               script_obj_t *script_obj_b)
 {
-  if (script_obj_is_number (script_obj_a) && script_obj_is_number (script_obj_b))
-    {
-      script_number_t value = script_obj_as_number (script_obj_a) / script_obj_as_number (script_obj_b);
-      return script_obj_new_number (value);
-    }
-  return script_obj_new_null ();
+        if (script_obj_is_number (script_obj_a) && script_obj_is_number (script_obj_b)) {
+                script_number_t value = script_obj_as_number (script_obj_a) / script_obj_as_number (script_obj_b);
+                return script_obj_new_number (value);
+        }
+        return script_obj_new_null ();
 }
 
 script_obj_t *script_obj_mod (script_obj_t *script_obj_a,
                               script_obj_t *script_obj_b)
 {
-  if (script_obj_is_number (script_obj_a) && script_obj_is_number (script_obj_b))
-    {
-      script_number_t value = fmodl (script_obj_as_number (script_obj_a), script_obj_as_number (script_obj_b));
-      return script_obj_new_number (value);
-    }
-  return script_obj_new_null ();
+        if (script_obj_is_number (script_obj_a) && script_obj_is_number (script_obj_b)) {
+                script_number_t value = fmodl (script_obj_as_number (script_obj_a), script_obj_as_number (script_obj_b));
+                return script_obj_new_number (value);
+        }
+        return script_obj_new_null ();
 }
 
 
 script_obj_cmp_result_t script_obj_cmp (script_obj_t *script_obj_a,
                                         script_obj_t *script_obj_b)
 {
-  if (script_obj_is_null (script_obj_a) && script_obj_is_null (script_obj_b))
-    {
-      return SCRIPT_OBJ_CMP_RESULT_EQ;
-    }
-  else if (script_obj_is_number (script_obj_a))
-    {
-      if (script_obj_is_number (script_obj_b))
-        {
-          script_number_t num_a = script_obj_as_number (script_obj_a);
-          script_number_t num_b = script_obj_as_number (script_obj_b);
-
-          if (num_a < num_b) return SCRIPT_OBJ_CMP_RESULT_LT;
-          if (num_a > num_b) return SCRIPT_OBJ_CMP_RESULT_GT;
-          if (num_a == num_b) return SCRIPT_OBJ_CMP_RESULT_EQ;
-          return SCRIPT_OBJ_CMP_RESULT_NE;
-        }
-    }
-  else if (script_obj_is_string (script_obj_a))
-    {
-      if (script_obj_is_string (script_obj_b))
-        {
-          char* string_a = script_obj_as_string (script_obj_a);
-          char* string_b = script_obj_as_string (script_obj_b);
-          int diff = strcmp (string_a, string_b);
-          free(string_a);
-          free(string_b);
-          if (diff < 0) return SCRIPT_OBJ_CMP_RESULT_LT;
-          if (diff > 0) return SCRIPT_OBJ_CMP_RESULT_GT;
-          return SCRIPT_OBJ_CMP_RESULT_EQ;
+        if (script_obj_is_null (script_obj_a) && script_obj_is_null (script_obj_b)) {
+                return SCRIPT_OBJ_CMP_RESULT_EQ;
+        } else if (script_obj_is_number (script_obj_a)) {
+                if (script_obj_is_number (script_obj_b)) {
+                        script_number_t num_a = script_obj_as_number (script_obj_a);
+                        script_number_t num_b = script_obj_as_number (script_obj_b);
+
+                        if (num_a < num_b) return SCRIPT_OBJ_CMP_RESULT_LT;
+                        if (num_a > num_b) return SCRIPT_OBJ_CMP_RESULT_GT;
+                        if (num_a == num_b) return SCRIPT_OBJ_CMP_RESULT_EQ;
+                        return SCRIPT_OBJ_CMP_RESULT_NE;
+                }
+        } else if (script_obj_is_string (script_obj_a)) {
+                if (script_obj_is_string (script_obj_b)) {
+                        char *string_a = script_obj_as_string (script_obj_a);
+                        char *string_b = script_obj_as_string (script_obj_b);
+                        int diff = strcmp (string_a, string_b);
+                        free (string_a);
+                        free (string_b);
+                        if (diff < 0) return SCRIPT_OBJ_CMP_RESULT_LT;
+                        if (diff > 0) return SCRIPT_OBJ_CMP_RESULT_GT;
+                        return SCRIPT_OBJ_CMP_RESULT_EQ;
+                }
+        } else if (script_obj_deref_direct (script_obj_a) == script_obj_deref_direct (script_obj_b)) {
+                return SCRIPT_OBJ_CMP_RESULT_EQ;
         }
-    }
-  else if (script_obj_deref_direct (script_obj_a) == script_obj_deref_direct (script_obj_b))
-        return SCRIPT_OBJ_CMP_RESULT_EQ;
-  return SCRIPT_OBJ_CMP_RESULT_NE;
+        return SCRIPT_OBJ_CMP_RESULT_NE;
 }
-
diff --git a/src/plugins/splash/script/script-object.h b/src/plugins/splash/script/script-object.h
index 8d5981b..9c9bf1c 100644
--- a/src/plugins/splash/script/script-object.h
+++ b/src/plugins/splash/script/script-object.h
@@ -28,14 +28,15 @@
 
 typedef enum
 {
-  SCRIPT_OBJ_CMP_RESULT_EQ = 1<<1,
-  SCRIPT_OBJ_CMP_RESULT_GT = 1<<2,
-  SCRIPT_OBJ_CMP_RESULT_LT = 1<<3,
-  SCRIPT_OBJ_CMP_RESULT_NE = 1<<4,
+        SCRIPT_OBJ_CMP_RESULT_EQ = 1 << 1,
+                SCRIPT_OBJ_CMP_RESULT_GT = 1 << 2,
+                SCRIPT_OBJ_CMP_RESULT_LT = 1 << 3,
+                SCRIPT_OBJ_CMP_RESULT_NE = 1 << 4,
 } script_obj_cmp_result_t;
 
 
-typedef void *(*script_obj_direct_func_t)(script_obj_t *, void *);
+typedef void *(*script_obj_direct_func_t)(script_obj_t *,
+                                          void         *);
 
 
 void script_obj_free (script_obj_t *obj);
@@ -50,20 +51,21 @@ script_obj_t *script_obj_new_null (void);
 script_obj_t *script_obj_new_hash (void);
 script_obj_t *script_obj_new_function (script_function_t *function);
 script_obj_t *script_obj_new_ref (script_obj_t *sub_obj);
-script_obj_t *script_obj_new_extend (script_obj_t *obj_a, script_obj_t *obj_b);
+script_obj_t *script_obj_new_extend (script_obj_t *obj_a,
+                                     script_obj_t *obj_b);
 
-script_obj_t *script_obj_new_native (void                       *object_data,
-                                     script_obj_native_class_t  *class );
-void *script_obj_as_custom (script_obj_t             *obj,
-                            script_obj_direct_func_t  user_func,
-                            void                     *user_data);
-script_obj_t *script_obj_as_obj_type (script_obj_t      *obj,
-                                      script_obj_type_t  type);
+script_obj_t *script_obj_new_native (void                      *object_data,
+                                     script_obj_native_class_t *class);
+void *script_obj_as_custom (script_obj_t            *obj,
+                            script_obj_direct_func_t user_func,
+                            void                    *user_data);
+script_obj_t *script_obj_as_obj_type (script_obj_t     *obj,
+                                      script_obj_type_t type);
 script_number_t script_obj_as_number (script_obj_t *obj);
 bool script_obj_as_bool (script_obj_t *obj);
 char *script_obj_as_string (script_obj_t *obj);
 void *script_obj_as_native_of_class (script_obj_t              *obj,
-                                     script_obj_native_class_t *class );
+                                     script_obj_native_class_t *class);
 void *script_obj_as_native_of_class_name (script_obj_t *obj,
                                           const char   *class_name);
 bool script_obj_is_null (script_obj_t *obj);
@@ -72,8 +74,8 @@ bool script_obj_is_string (script_obj_t *obj);
 bool script_obj_is_hash (script_obj_t *obj);
 bool script_obj_is_native (script_obj_t *obj);
 
-bool script_obj_is_native_of_class (script_obj_t * obj,
-                                    script_obj_native_class_t *class );
+bool script_obj_is_native_of_class (script_obj_t              *obj,
+                                    script_obj_native_class_t *class);
 bool script_obj_is_native_of_class_name (script_obj_t *obj,
                                          const char   *class_name);
 void script_obj_assign (script_obj_t *obj_a,
@@ -88,9 +90,9 @@ bool script_obj_hash_get_bool (script_obj_t *hash,
                                const char   *name);
 char *script_obj_hash_get_string (script_obj_t *hash,
                                   const char   *name);
-void *script_obj_hash_get_native_of_class (script_obj_t *hash,
-                                           const char   *name,
-                                           script_obj_native_class_t *class );
+void *script_obj_hash_get_native_of_class (script_obj_t              *hash,
+                                           const char                *name,
+                                           script_obj_native_class_t *class);
 void *script_obj_hash_get_native_of_class_name (script_obj_t *hash,
                                                 const char   *name,
                                                 const char   *class_name);
diff --git a/src/plugins/splash/script/script-parse.c b/src/plugins/splash/script/script-parse.c
index 4adf273..a4c7656 100644
--- a/src/plugins/splash/script/script-parse.c
+++ b/src/plugins/splash/script/script-parse.c
@@ -45,9 +45,9 @@
 
 typedef struct
 {
- const char        *symbol;
- script_exp_type_t  exp_type; 
- int                presedence;
+        const char       *symbol;
+        script_exp_type_t exp_type;
+        int               presedence;
 }script_parse_operator_table_entry_t;
 
 static script_op_t *script_parse_op (script_scan_t *scan);
@@ -58,19 +58,21 @@ static void script_parse_op_list_free (ply_list_t *op_list);
 static script_exp_t *script_parse_new_exp (script_exp_type_t        type,
                                            script_debug_location_t *location)
 {
-  script_exp_t *exp = malloc (sizeof (script_exp_t));
-  exp->type = type;
-  script_debug_add_element (exp, location);
-  return exp;
+        script_exp_t *exp = malloc (sizeof(script_exp_t));
+
+        exp->type = type;
+        script_debug_add_element (exp, location);
+        return exp;
 }
 
 static script_exp_t *script_parse_new_exp_single (script_exp_type_t        type,
                                                   script_exp_t            *sub,
                                                   script_debug_location_t *location)
 {
-  script_exp_t *exp = script_parse_new_exp(type, location);
-  exp->data.sub = sub;
-  return exp;
+        script_exp_t *exp = script_parse_new_exp (type, location);
+
+        exp->data.sub = sub;
+        return exp;
 }
 
 static script_exp_t *script_parse_new_exp_dual (script_exp_type_t        type,
@@ -78,85 +80,95 @@ static script_exp_t *script_parse_new_exp_dual (script_exp_type_t        type,
                                                 script_exp_t            *sub_b,
                                                 script_debug_location_t *location)
 {
-  script_exp_t *exp = script_parse_new_exp(type, location);
-  exp->data.dual.sub_a = sub_a;
-  exp->data.dual.sub_b = sub_b;
-  return exp;
+        script_exp_t *exp = script_parse_new_exp (type, location);
+
+        exp->data.dual.sub_a = sub_a;
+        exp->data.dual.sub_b = sub_b;
+        return exp;
 }
 
 static script_exp_t *script_parse_new_exp_number (script_number_t          number,
                                                   script_debug_location_t *location)
 {
-  script_exp_t *exp = script_parse_new_exp(SCRIPT_EXP_TYPE_TERM_NUMBER, location);
-  exp->data.number = number;
-  return exp;
+        script_exp_t *exp = script_parse_new_exp (SCRIPT_EXP_TYPE_TERM_NUMBER, location);
+
+        exp->data.number = number;
+        return exp;
 }
 
 static script_exp_t *script_parse_new_exp_string (char                    *string,
                                                   script_debug_location_t *location)
 {
-  script_exp_t *exp = script_parse_new_exp(SCRIPT_EXP_TYPE_TERM_STRING, location);
-  exp->data.string = strdup(string);
-  return exp;
+        script_exp_t *exp = script_parse_new_exp (SCRIPT_EXP_TYPE_TERM_STRING, location);
+
+        exp->data.string = strdup (string);
+        return exp;
 }
 
 static script_exp_t *script_parse_new_exp_var (char                    *string,
                                                script_debug_location_t *location)
 {
-  script_exp_t *exp = script_parse_new_exp(SCRIPT_EXP_TYPE_TERM_VAR, location);
-  exp->data.string = strdup(string);
-  return exp;
+        script_exp_t *exp = script_parse_new_exp (SCRIPT_EXP_TYPE_TERM_VAR, location);
+
+        exp->data.string = strdup (string);
+        return exp;
 }
 
 static script_exp_t *script_parse_new_exp_function_exe (script_exp_t            *name,
                                                         ply_list_t              *parameters,
                                                         script_debug_location_t *location)
 {
-  script_exp_t *exp = script_parse_new_exp(SCRIPT_EXP_TYPE_FUNCTION_EXE, location);
-  exp->data.function_exe.name = name;
-  exp->data.function_exe.parameters = parameters;
-  return exp;
+        script_exp_t *exp = script_parse_new_exp (SCRIPT_EXP_TYPE_FUNCTION_EXE, location);
+
+        exp->data.function_exe.name = name;
+        exp->data.function_exe.parameters = parameters;
+        return exp;
 }
 
 static script_exp_t *script_parse_new_exp_function_def (script_function_t       *function_def,
                                                         script_debug_location_t *location)
 {
-  script_exp_t *exp = script_parse_new_exp(SCRIPT_EXP_TYPE_FUNCTION_DEF, location);
-  exp->data.function_def = function_def;
-  return exp;
+        script_exp_t *exp = script_parse_new_exp (SCRIPT_EXP_TYPE_FUNCTION_DEF, location);
+
+        exp->data.function_def = function_def;
+        return exp;
 }
 
 static script_exp_t *script_parse_new_exp_set (ply_list_t              *parameters,
                                                script_debug_location_t *location)
 {
-  script_exp_t *exp = script_parse_new_exp(SCRIPT_EXP_TYPE_TERM_SET, location);
-  exp->data.parameters = parameters;
-  return exp;
+        script_exp_t *exp = script_parse_new_exp (SCRIPT_EXP_TYPE_TERM_SET, location);
+
+        exp->data.parameters = parameters;
+        return exp;
 }
 
 static script_op_t *script_parse_new_op (script_op_type_t         type,
                                          script_debug_location_t *location)
 {
-  script_op_t *op = malloc (sizeof (script_op_t));
-  op->type = type;
-  script_debug_add_element (op, location);
-  return op;
+        script_op_t *op = malloc (sizeof(script_op_t));
+
+        op->type = type;
+        script_debug_add_element (op, location);
+        return op;
 }
 
 static script_op_t *script_parse_new_op_exp (script_exp_t            *exp,
                                              script_debug_location_t *location)
 {
-  script_op_t *op = script_parse_new_op (SCRIPT_OP_TYPE_EXPRESSION, location);
-  op->data.exp = exp;
-  return op;
+        script_op_t *op = script_parse_new_op (SCRIPT_OP_TYPE_EXPRESSION, location);
+
+        op->data.exp = exp;
+        return op;
 }
 
 static script_op_t *script_parse_new_op_block (ply_list_t              *list,
                                                script_debug_location_t *location)
 {
-  script_op_t *op = script_parse_new_op (SCRIPT_OP_TYPE_OP_BLOCK, location);
-  op->data.list = list;
-  return op;
+        script_op_t *op = script_parse_new_op (SCRIPT_OP_TYPE_OP_BLOCK, location);
+
+        op->data.list = list;
+        return op;
 }
 
 static script_op_t *script_parse_new_op_cond (script_op_type_t         type,
@@ -165,911 +177,847 @@ static script_op_t *script_parse_new_op_cond (script_op_type_t         type,
                                               script_op_t             *op2,
                                               script_debug_location_t *location)
 {
-  script_op_t *op = script_parse_new_op (type, location);
-  op->data.cond_op.cond = cond;
-  op->data.cond_op.op1 = op1;
-  op->data.cond_op.op2 = op2;
-  return op;
+        script_op_t *op = script_parse_new_op (type, location);
+
+        op->data.cond_op.cond = cond;
+        op->data.cond_op.op1 = op1;
+        op->data.cond_op.op2 = op2;
+        return op;
 }
 
 static void script_parse_error (script_debug_location_t *location,
                                 const char              *message)
 {
-  ply_error ("Parser error \"%s\" L:%d C:%d : %s\n",
-             location->name,
-             location->line_index,
-             location->column_index,
-             message);
+        ply_error ("Parser error \"%s\" L:%d C:%d : %s\n",
+                   location->name,
+                   location->line_index,
+                   location->column_index,
+                   message);
 }
 
-static const script_parse_operator_table_entry_t*   /* Only allows 1 or 2 character symbols */
+static const script_parse_operator_table_entry_t *   /* Only allows 1 or 2 character symbols */
 script_parse_operator_table_entry_lookup (script_scan_t                             *scan,
                                           const script_parse_operator_table_entry_t *table)
 {
-  int entry_index;
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-  script_scan_token_t *peektoken = script_scan_peek_next_token (scan);
-  for (entry_index = 0; table[entry_index].symbol; entry_index++)
-    {
-      if (!script_scan_token_is_symbol (curtoken)) continue;
-      if (curtoken->data.symbol != table[entry_index].symbol[0]) continue;
-      if (table[entry_index].symbol[1])
-        {
-          if (!script_scan_token_is_symbol (peektoken)) continue;
-          if (peektoken->data.symbol != table[entry_index].symbol[1]) continue;
-          if (peektoken->whitespace) continue;
+        int entry_index;
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+        script_scan_token_t *peektoken = script_scan_peek_next_token (scan);
+
+        for (entry_index = 0; table[entry_index].symbol; entry_index++) {
+                if (!script_scan_token_is_symbol (curtoken)) continue;
+                if (curtoken->data.symbol != table[entry_index].symbol[0]) continue;
+                if (table[entry_index].symbol[1]) {
+                        if (!script_scan_token_is_symbol (peektoken)) continue;
+                        if (peektoken->data.symbol != table[entry_index].symbol[1]) continue;
+                        if (peektoken->whitespace) continue;
+                }
+                break;
         }
-      break;
-    }
-  return &table[entry_index];
+        return &table[entry_index];
 }
 
 static void script_parse_advance_scan_by_string (script_scan_t *scan,
-                                                 const char *string)
+                                                 const char    *string)
 {
-  while (*string)
-    {
-      script_scan_get_next_token(scan);
-      string++;
-    }
+        while (*string) {
+                script_scan_get_next_token (scan);
+                string++;
+        }
 }
 
 static script_function_t *script_parse_function_def (script_scan_t *scan)
 {
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-  ply_list_t *parameter_list;
-
-  if (!script_scan_token_is_symbol_of_value (curtoken, '('))
-    {
-      script_parse_error (&curtoken->location,
-        "Function declaration requires parameters to be declared within '(' brackets");
-      return NULL;
-    }
-  curtoken = script_scan_get_next_token (scan);
-  parameter_list = ply_list_new ();
-
-  while (true)
-    {
-      if (script_scan_token_is_symbol_of_value (curtoken, ')')) break;
-      if (!script_scan_token_is_identifier (curtoken))
-        {
-          script_parse_error (&curtoken->location,
-            "Function declaration parameters must be valid identifiers");
-          return NULL;
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+        ply_list_t *parameter_list;
+
+        if (!script_scan_token_is_symbol_of_value (curtoken, '(')) {
+                script_parse_error (&curtoken->location,
+                                    "Function declaration requires parameters to be declared within '(' brackets");
+                return NULL;
         }
-      char *parameter = strdup (curtoken->data.string);
-      ply_list_append_data (parameter_list, parameter);
+        curtoken = script_scan_get_next_token (scan);
+        parameter_list = ply_list_new ();
+
+        while (true) {
+                if (script_scan_token_is_symbol_of_value (curtoken, ')')) break;
+                if (!script_scan_token_is_identifier (curtoken)) {
+                        script_parse_error (&curtoken->location,
+                                            "Function declaration parameters must be valid identifiers");
+                        return NULL;
+                }
+                char *parameter = strdup (curtoken->data.string);
+                ply_list_append_data (parameter_list, parameter);
 
-      curtoken = script_scan_get_next_token (scan);
+                curtoken = script_scan_get_next_token (scan);
 
-      if (script_scan_token_is_symbol_of_value (curtoken, ')')) break;
-      if (!script_scan_token_is_symbol_of_value (curtoken, ','))
-        {
-          script_parse_error (&curtoken->location,
-            "Function declaration parameters must separated with ',' and terminated with a ')'");
-          return NULL;
+                if (script_scan_token_is_symbol_of_value (curtoken, ')')) break;
+                if (!script_scan_token_is_symbol_of_value (curtoken, ',')) {
+                        script_parse_error (&curtoken->location,
+                                            "Function declaration parameters must separated with ',' and terminated with a ')'");
+                        return NULL;
+                }
+                curtoken = script_scan_get_next_token (scan);
         }
-      curtoken = script_scan_get_next_token (scan);
-    }
 
-  curtoken = script_scan_get_next_token (scan);
+        curtoken = script_scan_get_next_token (scan);
 
-  script_op_t *func_op = script_parse_op (scan);
-  
-  script_function_t *function = script_function_script_new (func_op,
-                                                            NULL,
-                                                            parameter_list);
-  return function;
+        script_op_t *func_op = script_parse_op (scan);
+
+        script_function_t *function = script_function_script_new (func_op,
+                                                                  NULL,
+                                                                  parameter_list);
+        return function;
 }
 
 static script_exp_t *script_parse_exp_tm (script_scan_t *scan)
 {
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-  script_exp_t *exp = NULL;
-
-  if (script_scan_token_is_integer (curtoken))
-    {
-      exp = script_parse_new_exp_number (curtoken->data.integer, &curtoken->location);
-      script_scan_get_next_token (scan);
-      return exp;
-    }
-  if (script_scan_token_is_float (curtoken))
-    {
-      exp = script_parse_new_exp_number (curtoken->data.floatpoint, &curtoken->location);
-      script_scan_get_next_token (scan);
-      return exp;
-    }
-  if (script_scan_token_is_identifier (curtoken))
-    {
-      if (script_scan_token_is_identifier_of_value (curtoken, "NULL"))
-        exp = script_parse_new_exp(SCRIPT_EXP_TYPE_TERM_NULL, &curtoken->location);
-      else if (script_scan_token_is_identifier_of_value (curtoken, "INFINITY"))
-        exp = script_parse_new_exp_number (INFINITY, &curtoken->location);
-      else if (script_scan_token_is_identifier_of_value (curtoken, "NAN"))
-        exp = script_parse_new_exp_number (NAN, &curtoken->location);
-      else if (script_scan_token_is_identifier_of_value (curtoken, "global"))
-        exp = script_parse_new_exp(SCRIPT_EXP_TYPE_TERM_GLOBAL, &curtoken->location);
-      else if (script_scan_token_is_identifier_of_value (curtoken, "local"))
-        exp = script_parse_new_exp(SCRIPT_EXP_TYPE_TERM_LOCAL, &curtoken->location);
-      else if (script_scan_token_is_identifier_of_value (curtoken, "this"))
-        exp = script_parse_new_exp(SCRIPT_EXP_TYPE_TERM_THIS, &curtoken->location);
-      else if (script_scan_token_is_identifier_of_value (curtoken, "fun"))
-        {
-          script_debug_location_t location = curtoken->location;
-          script_scan_get_next_token (scan);
-          exp = script_parse_new_exp_function_def (script_parse_function_def (scan), &location);
-          return exp;
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+        script_exp_t *exp = NULL;
+
+        if (script_scan_token_is_integer (curtoken)) {
+                exp = script_parse_new_exp_number (curtoken->data.integer, &curtoken->location);
+                script_scan_get_next_token (scan);
+                return exp;
         }
-      else
-        {
-          exp = script_parse_new_exp_var (curtoken->data.string, &curtoken->location);
+        if (script_scan_token_is_float (curtoken)) {
+                exp = script_parse_new_exp_number (curtoken->data.floatpoint, &curtoken->location);
+                script_scan_get_next_token (scan);
+                return exp;
         }
-      curtoken = script_scan_get_next_token (scan);
-      return exp;
-    }
-  if (script_scan_token_is_string (curtoken))
-    {
-      exp = script_parse_new_exp_string (curtoken->data.string, &curtoken->location);
-      script_scan_get_next_token (scan);
-      return exp;
-    }
-  
-  if (script_scan_token_is_symbol_of_value (curtoken, '['))
-    {
-      ply_list_t *parameters = ply_list_new ();
-      script_debug_location_t location = curtoken->location;
-      script_scan_get_next_token (scan);
-      while (true)
-        {
-          if (script_scan_token_is_symbol_of_value (curtoken, ']')) break;
-          script_exp_t *parameter = script_parse_exp (scan);
-
-          ply_list_append_data (parameters, parameter);
-
-          curtoken = script_scan_get_current_token (scan);
-          if (script_scan_token_is_symbol_of_value (curtoken, ']')) break;
-          if (!script_scan_token_is_symbol_of_value (curtoken, ','))
-            {
-              script_parse_error (&curtoken->location,
-                "Set parameters should be separated with a ',' and terminated with a ']'");
-              return NULL;
-            }
-          curtoken = script_scan_get_next_token (scan);
+        if (script_scan_token_is_identifier (curtoken)) {
+                if (script_scan_token_is_identifier_of_value (curtoken, "NULL")) {
+                        exp = script_parse_new_exp (SCRIPT_EXP_TYPE_TERM_NULL, &curtoken->location);
+                } else if (script_scan_token_is_identifier_of_value (curtoken, "INFINITY")) {
+                        exp = script_parse_new_exp_number (INFINITY, &curtoken->location);
+                } else if (script_scan_token_is_identifier_of_value (curtoken, "NAN")) {
+                        exp = script_parse_new_exp_number (NAN, &curtoken->location);
+                } else if (script_scan_token_is_identifier_of_value (curtoken, "global")) {
+                        exp = script_parse_new_exp (SCRIPT_EXP_TYPE_TERM_GLOBAL, &curtoken->location);
+                } else if (script_scan_token_is_identifier_of_value (curtoken, "local")) {
+                        exp = script_parse_new_exp (SCRIPT_EXP_TYPE_TERM_LOCAL, &curtoken->location);
+                } else if (script_scan_token_is_identifier_of_value (curtoken, "this")) {
+                        exp = script_parse_new_exp (SCRIPT_EXP_TYPE_TERM_THIS, &curtoken->location);
+                } else if (script_scan_token_is_identifier_of_value (curtoken, "fun")) {
+                        script_debug_location_t location = curtoken->location;
+                        script_scan_get_next_token (scan);
+                        exp = script_parse_new_exp_function_def (script_parse_function_def (scan), &location);
+                        return exp;
+                } else {
+                        exp = script_parse_new_exp_var (curtoken->data.string, &curtoken->location);
+                }
+                curtoken = script_scan_get_next_token (scan);
+                return exp;
         }
-      script_scan_get_next_token (scan);
-      exp = script_parse_new_exp_set (parameters, &location);
-      return exp;
-    }
-  if (script_scan_token_is_symbol_of_value (curtoken, '('))
-    {
-      script_scan_get_next_token (scan);
-      exp = script_parse_exp (scan);
-      curtoken = script_scan_get_current_token (scan);
-      if (!exp)
-        {
-          script_parse_error (&curtoken->location,
-            "Expected valid contents of bracketed expression");
-          return NULL;
+        if (script_scan_token_is_string (curtoken)) {
+                exp = script_parse_new_exp_string (curtoken->data.string, &curtoken->location);
+                script_scan_get_next_token (scan);
+                return exp;
         }
-      if (!script_scan_token_is_symbol_of_value (curtoken, ')'))
-        {
-          script_parse_error (&curtoken->location,
-            "Expected bracketed block to be terminated with a ')'");
-          return NULL;
+
+        if (script_scan_token_is_symbol_of_value (curtoken, '[')) {
+                ply_list_t *parameters = ply_list_new ();
+                script_debug_location_t location = curtoken->location;
+                script_scan_get_next_token (scan);
+                while (true) {
+                        if (script_scan_token_is_symbol_of_value (curtoken, ']')) break;
+                        script_exp_t *parameter = script_parse_exp (scan);
+
+                        ply_list_append_data (parameters, parameter);
+
+                        curtoken = script_scan_get_current_token (scan);
+                        if (script_scan_token_is_symbol_of_value (curtoken, ']')) break;
+                        if (!script_scan_token_is_symbol_of_value (curtoken, ',')) {
+                                script_parse_error (&curtoken->location,
+                                                    "Set parameters should be separated with a ',' and terminated with a ']'");
+                                return NULL;
+                        }
+                        curtoken = script_scan_get_next_token (scan);
+                }
+                script_scan_get_next_token (scan);
+                exp = script_parse_new_exp_set (parameters, &location);
+                return exp;
+        }
+        if (script_scan_token_is_symbol_of_value (curtoken, '(')) {
+                script_scan_get_next_token (scan);
+                exp = script_parse_exp (scan);
+                curtoken = script_scan_get_current_token (scan);
+                if (!exp) {
+                        script_parse_error (&curtoken->location,
+                                            "Expected valid contents of bracketed expression");
+                        return NULL;
+                }
+                if (!script_scan_token_is_symbol_of_value (curtoken, ')')) {
+                        script_parse_error (&curtoken->location,
+                                            "Expected bracketed block to be terminated with a ')'");
+                        return NULL;
+                }
+                script_scan_get_next_token (scan);
+                return exp;
         }
-      script_scan_get_next_token (scan);
-      return exp;
-    }
-  return NULL;
+        return NULL;
 }
 
 static script_exp_t *script_parse_exp_pi (script_scan_t *scan)
 {
-  script_exp_t *exp = script_parse_exp_tm (scan);
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-
-  while (true)
-    {
-      script_debug_location_t location = curtoken->location;
-      if (!script_scan_token_is_symbol (curtoken)) break;
-      if (script_scan_token_is_symbol_of_value (curtoken, '('))
-        {
-          ply_list_t *parameters = ply_list_new ();
-          script_scan_get_next_token (scan);
-          while (true)
-            {
-              if (script_scan_token_is_symbol_of_value (curtoken, ')')) break;
-              script_exp_t *parameter = script_parse_exp (scan);
-
-              ply_list_append_data (parameters, parameter);
-
-              curtoken = script_scan_get_current_token (scan);
-              if (script_scan_token_is_symbol_of_value (curtoken, ')')) break;
-              if (!script_scan_token_is_symbol_of_value (curtoken, ','))
-                {
-                  script_parse_error (&curtoken->location,
-                    "Function parameters should be separated with a ',' and terminated with a ')'");
-                  return NULL;
+        script_exp_t *exp = script_parse_exp_tm (scan);
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+
+        while (true) {
+                script_debug_location_t location = curtoken->location;
+                if (!script_scan_token_is_symbol (curtoken)) break;
+                if (script_scan_token_is_symbol_of_value (curtoken, '(')) {
+                        ply_list_t *parameters = ply_list_new ();
+                        script_scan_get_next_token (scan);
+                        while (true) {
+                                if (script_scan_token_is_symbol_of_value (curtoken, ')')) break;
+                                script_exp_t *parameter = script_parse_exp (scan);
+
+                                ply_list_append_data (parameters, parameter);
+
+                                curtoken = script_scan_get_current_token (scan);
+                                if (script_scan_token_is_symbol_of_value (curtoken, ')')) break;
+                                if (!script_scan_token_is_symbol_of_value (curtoken, ',')) {
+                                        script_parse_error (&curtoken->location,
+                                                            "Function parameters should be separated with a ',' and terminated with a ')'");
+                                        return NULL;
+                                }
+                                curtoken = script_scan_get_next_token (scan);
+                        }
+                        script_scan_get_next_token (scan);
+                        exp = script_parse_new_exp_function_exe (exp, parameters, &location);
+                        continue;
                 }
-              curtoken = script_scan_get_next_token (scan);
-            }
-          script_scan_get_next_token (scan);
-          exp = script_parse_new_exp_function_exe (exp, parameters, &location);
-          continue;
-        }
-      script_exp_t *key;
-
-      if (script_scan_token_is_symbol_of_value (curtoken, '.'))
-        {
-          script_scan_get_next_token (scan);
-          if (script_scan_token_is_identifier (curtoken))
-            {
-              key = script_parse_new_exp_string (curtoken->data.string, &curtoken->location);
-            }
-          else
-            {
-              script_parse_error (&curtoken->location,
-                "A dot based hash index must be an identifier");
-              return NULL;
-            }
-          curtoken = script_scan_get_next_token (scan);
-        }
-      else if (script_scan_token_is_symbol_of_value (curtoken, '['))
-        {
-          script_scan_get_next_token (scan);
-          key = script_parse_exp (scan);
-          if (!key)
-            {
-              script_parse_error (&curtoken->location,
-                "Expected a valid index expression");
-              return NULL;
-            }
-          curtoken = script_scan_get_current_token (scan);
-          if (!script_scan_token_is_symbol_of_value (curtoken, ']'))
-            {
-              script_parse_error (&curtoken->location,
-                "Expected a ']' to terminate the index expression");
-              return NULL;
-            }
-          curtoken = script_scan_get_next_token (scan);
+                script_exp_t *key;
+
+                if (script_scan_token_is_symbol_of_value (curtoken, '.')) {
+                        script_scan_get_next_token (scan);
+                        if (script_scan_token_is_identifier (curtoken)) {
+                                key = script_parse_new_exp_string (curtoken->data.string, &curtoken->location);
+                        } else {
+                                script_parse_error (&curtoken->location,
+                                                    "A dot based hash index must be an identifier");
+                                return NULL;
+                        }
+                        curtoken = script_scan_get_next_token (scan);
+                } else if (script_scan_token_is_symbol_of_value (curtoken, '[')) {
+                        script_scan_get_next_token (scan);
+                        key = script_parse_exp (scan);
+                        if (!key) {
+                                script_parse_error (&curtoken->location,
+                                                    "Expected a valid index expression");
+                                return NULL;
+                        }
+                        curtoken = script_scan_get_current_token (scan);
+                        if (!script_scan_token_is_symbol_of_value (curtoken, ']')) {
+                                script_parse_error (&curtoken->location,
+                                                    "Expected a ']' to terminate the index expression");
+                                return NULL;
+                        }
+                        curtoken = script_scan_get_next_token (scan);
+                } else { break; }
+                exp = script_parse_new_exp_dual (SCRIPT_EXP_TYPE_HASH, exp, key, &location);
         }
-      else break;
-      exp = script_parse_new_exp_dual (SCRIPT_EXP_TYPE_HASH, exp, key, &location);
-    }
-  return exp;
+        return exp;
 }
 
 static script_exp_t *script_parse_exp_pr (script_scan_t *scan)
 {
-  static const script_parse_operator_table_entry_t operator_table[] =
-    {
-      {"++", SCRIPT_EXP_TYPE_PRE_INC,    0},
-      {"+",  SCRIPT_EXP_TYPE_POS,        0},
-      {"--", SCRIPT_EXP_TYPE_PRE_DEC,    0},
-      {"-",  SCRIPT_EXP_TYPE_NEG,        0},
-      {"!",  SCRIPT_EXP_TYPE_NOT,        0},
-      {NULL, SCRIPT_EXP_TYPE_TERM_NULL, -1},
-    };
-  const script_parse_operator_table_entry_t* entry;
-  entry =  script_parse_operator_table_entry_lookup(scan, operator_table);
-  if (entry->presedence < 0) return script_parse_exp_pi (scan);
-  script_debug_location_t location = script_scan_get_current_token (scan)->location;
-  script_parse_advance_scan_by_string(scan, entry->symbol);
-  return script_parse_new_exp_single(entry->exp_type, script_parse_exp_pr (scan), &location);
+        static const script_parse_operator_table_entry_t operator_table[] =
+        {
+                { "++", SCRIPT_EXP_TYPE_PRE_INC,   0  },
+                { "+",  SCRIPT_EXP_TYPE_POS,       0  },
+                { "--", SCRIPT_EXP_TYPE_PRE_DEC,   0  },
+                { "-",  SCRIPT_EXP_TYPE_NEG,       0  },
+                { "!",  SCRIPT_EXP_TYPE_NOT,       0  },
+                { NULL, SCRIPT_EXP_TYPE_TERM_NULL, -1 },
+        };
+        const script_parse_operator_table_entry_t *entry;
+
+        entry = script_parse_operator_table_entry_lookup (scan, operator_table);
+        if (entry->presedence < 0) return script_parse_exp_pi (scan);
+        script_debug_location_t location = script_scan_get_current_token (scan)->location;
+        script_parse_advance_scan_by_string (scan, entry->symbol);
+        return script_parse_new_exp_single (entry->exp_type, script_parse_exp_pr (scan), &location);
 }
 
 static script_exp_t *script_parse_exp_po (script_scan_t *scan)
 {
-  static const script_parse_operator_table_entry_t operator_table[] =
-    {
-      {"++", SCRIPT_EXP_TYPE_POST_INC,   0},
-      {"--", SCRIPT_EXP_TYPE_POST_DEC,   0},
-      {NULL, SCRIPT_EXP_TYPE_TERM_NULL, -1},
-    };
-  script_exp_t *exp = script_parse_exp_pr (scan);
-
-  while (true)
-    {
-      const script_parse_operator_table_entry_t* entry;
-      entry =  script_parse_operator_table_entry_lookup(scan, operator_table);
-      if (entry->presedence < 0) break;
-      exp = script_parse_new_exp_single(entry->exp_type, exp, &script_scan_get_current_token (scan)->location);
-      script_parse_advance_scan_by_string(scan, entry->symbol);
-    }
-  return exp;
+        static const script_parse_operator_table_entry_t operator_table[] =
+        {
+                { "++", SCRIPT_EXP_TYPE_POST_INC,  0  },
+                { "--", SCRIPT_EXP_TYPE_POST_DEC,  0  },
+                { NULL, SCRIPT_EXP_TYPE_TERM_NULL, -1 },
+        };
+        script_exp_t *exp = script_parse_exp_pr (scan);
+
+        while (true) {
+                const script_parse_operator_table_entry_t *entry;
+                entry = script_parse_operator_table_entry_lookup (scan, operator_table);
+                if (entry->presedence < 0) break;
+                exp = script_parse_new_exp_single (entry->exp_type, exp, &script_scan_get_current_token (scan)->location);
+                script_parse_advance_scan_by_string (scan, entry->symbol);
+        }
+        return exp;
 }
 
 static script_exp_t *script_parse_exp_ltr (script_scan_t *scan, int presedence)
 {
-  static const script_parse_operator_table_entry_t operator_table[] =
-    {
-      {"||", SCRIPT_EXP_TYPE_OR,         1},    /* FIXME Does const imply static? */
-      {"&&", SCRIPT_EXP_TYPE_AND,        2},
-      {"==", SCRIPT_EXP_TYPE_EQ,         3},
-      {"!=", SCRIPT_EXP_TYPE_NE,         3},
-      {">=", SCRIPT_EXP_TYPE_GE,         4},
-      {"<=", SCRIPT_EXP_TYPE_LE,         4},
-      {"+=", SCRIPT_EXP_TYPE_TERM_NULL, -1},    /* A few things it shouldn't consume */
-      {"-=", SCRIPT_EXP_TYPE_TERM_NULL, -1},
-      {"*=", SCRIPT_EXP_TYPE_TERM_NULL, -1},
-      {"/=", SCRIPT_EXP_TYPE_TERM_NULL, -1},
-      {"%=", SCRIPT_EXP_TYPE_TERM_NULL, -1},
-      {"|=", SCRIPT_EXP_TYPE_TERM_NULL, -1},
-      {"|",  SCRIPT_EXP_TYPE_EXTEND,     0},
-      {">",  SCRIPT_EXP_TYPE_GT,         4},
-      {"<",  SCRIPT_EXP_TYPE_LT,         4},
-      {"+",  SCRIPT_EXP_TYPE_PLUS,       5},
-      {"-",  SCRIPT_EXP_TYPE_MINUS,      5},
-      {"*",  SCRIPT_EXP_TYPE_MUL,        6},
-      {"/",  SCRIPT_EXP_TYPE_DIV,        6},
-      {"%",  SCRIPT_EXP_TYPE_MOD,        6},    /* Put this number into the "presedence > ?" line below*/
-      {NULL, SCRIPT_EXP_TYPE_TERM_NULL, -1},
-    };
-    
-  if (presedence > 6) return script_parse_exp_po (scan);
-  script_exp_t *exp = script_parse_exp_ltr (scan, presedence + 1);
-  if (!exp) return NULL;
-  
-  while (true)
-    {
-      const script_parse_operator_table_entry_t* entry;
-      entry =  script_parse_operator_table_entry_lookup(scan, operator_table);
-      if (entry->presedence != presedence) break;
-      script_debug_location_t location = script_scan_get_current_token (scan)->location;
-      script_parse_advance_scan_by_string(scan, entry->symbol);
-      exp = script_parse_new_exp_dual(entry->exp_type, exp, script_parse_exp_ltr (scan, presedence + 1), &location);
-      if (!exp->data.dual.sub_b)
+        static const script_parse_operator_table_entry_t operator_table[] =
         {
-          script_parse_error (&script_scan_get_current_token (scan)->location,
-                              "An invalid RHS of an operation");
-          return NULL;
+                { "||", SCRIPT_EXP_TYPE_OR,        1  }, /* FIXME Does const imply static? */
+                { "&&", SCRIPT_EXP_TYPE_AND,       2  },
+                { "==", SCRIPT_EXP_TYPE_EQ,        3  },
+                { "!=", SCRIPT_EXP_TYPE_NE,        3  },
+                { ">=", SCRIPT_EXP_TYPE_GE,        4  },
+                { "<=", SCRIPT_EXP_TYPE_LE,        4  },
+                { "+=", SCRIPT_EXP_TYPE_TERM_NULL, -1 }, /* A few things it shouldn't consume */
+                { "-=", SCRIPT_EXP_TYPE_TERM_NULL, -1 },
+                { "*=", SCRIPT_EXP_TYPE_TERM_NULL, -1 },
+                { "/=", SCRIPT_EXP_TYPE_TERM_NULL, -1 },
+                { "%=", SCRIPT_EXP_TYPE_TERM_NULL, -1 },
+                { "|=", SCRIPT_EXP_TYPE_TERM_NULL, -1 },
+                { "|",  SCRIPT_EXP_TYPE_EXTEND,    0  },
+                { ">",  SCRIPT_EXP_TYPE_GT,        4  },
+                { "<",  SCRIPT_EXP_TYPE_LT,        4  },
+                { "+",  SCRIPT_EXP_TYPE_PLUS,      5  },
+                { "-",  SCRIPT_EXP_TYPE_MINUS,     5  },
+                { "*",  SCRIPT_EXP_TYPE_MUL,       6  },
+                { "/",  SCRIPT_EXP_TYPE_DIV,       6  },
+                { "%",  SCRIPT_EXP_TYPE_MOD,       6  }, /* Put this number into the "presedence > ?" line below*/
+                { NULL, SCRIPT_EXP_TYPE_TERM_NULL, -1 },
+        };
+
+        if (presedence > 6) return script_parse_exp_po (scan);
+        script_exp_t *exp = script_parse_exp_ltr (scan, presedence + 1);
+        if (!exp) return NULL;
+
+        while (true) {
+                const script_parse_operator_table_entry_t *entry;
+                entry = script_parse_operator_table_entry_lookup (scan, operator_table);
+                if (entry->presedence != presedence) break;
+                script_debug_location_t location = script_scan_get_current_token (scan)->location;
+                script_parse_advance_scan_by_string (scan, entry->symbol);
+                exp = script_parse_new_exp_dual (entry->exp_type, exp, script_parse_exp_ltr (scan, presedence + 1), &location);
+                if (!exp->data.dual.sub_b) {
+                        script_parse_error (&script_scan_get_current_token (scan)->location,
+                                            "An invalid RHS of an operation");
+                        return NULL;
+                }
         }
-    }
-  return exp;
+        return exp;
 }
 
 static script_exp_t *script_parse_exp_as (script_scan_t *scan)
 {
-  static const script_parse_operator_table_entry_t operator_table[] =
-    {
-      {"+=", SCRIPT_EXP_TYPE_ASSIGN_PLUS,  0},
-      {"-=", SCRIPT_EXP_TYPE_ASSIGN_MINUS, 0}, 
-      {"*=", SCRIPT_EXP_TYPE_ASSIGN_MUL,   0}, 
-      {"/=", SCRIPT_EXP_TYPE_ASSIGN_DIV,   0}, 
-      {"%=", SCRIPT_EXP_TYPE_ASSIGN_MOD,   0}, 
-      {"|=", SCRIPT_EXP_TYPE_ASSIGN_EXTEND,0},
-      {"=",  SCRIPT_EXP_TYPE_ASSIGN,       0}, 
-      {NULL, SCRIPT_EXP_TYPE_TERM_NULL,   -1}, 
-    };
-  script_exp_t *lhs = script_parse_exp_ltr (scan, 0);
-  if (!lhs) return NULL;
-
-  const script_parse_operator_table_entry_t* entry;
-  entry =  script_parse_operator_table_entry_lookup(scan, operator_table);
-  if (entry->presedence < 0) return lhs;
-  script_debug_location_t location = script_scan_get_current_token (scan)->location;
-  script_parse_advance_scan_by_string(scan, entry->symbol);
-  script_exp_t *rhs = script_parse_exp_as (scan);
-  if (!rhs)
-    {
-      script_parse_error (&script_scan_get_current_token (scan)->location,
-                          "An invalid RHS of an assign");
-      return NULL;
-    }
-  return script_parse_new_exp_dual (entry->exp_type, lhs, rhs, &location);
+        static const script_parse_operator_table_entry_t operator_table[] =
+        {
+                { "+=", SCRIPT_EXP_TYPE_ASSIGN_PLUS,   0  },
+                { "-=", SCRIPT_EXP_TYPE_ASSIGN_MINUS,  0  },
+                { "*=", SCRIPT_EXP_TYPE_ASSIGN_MUL,    0  },
+                { "/=", SCRIPT_EXP_TYPE_ASSIGN_DIV,    0  },
+                { "%=", SCRIPT_EXP_TYPE_ASSIGN_MOD,    0  },
+                { "|=", SCRIPT_EXP_TYPE_ASSIGN_EXTEND, 0  },
+                { "=",  SCRIPT_EXP_TYPE_ASSIGN,        0  },
+                { NULL, SCRIPT_EXP_TYPE_TERM_NULL,     -1 },
+        };
+        script_exp_t *lhs = script_parse_exp_ltr (scan, 0);
+
+        if (!lhs) return NULL;
+
+        const script_parse_operator_table_entry_t *entry;
+        entry = script_parse_operator_table_entry_lookup (scan, operator_table);
+        if (entry->presedence < 0) return lhs;
+        script_debug_location_t location = script_scan_get_current_token (scan)->location;
+        script_parse_advance_scan_by_string (scan, entry->symbol);
+        script_exp_t *rhs = script_parse_exp_as (scan);
+        if (!rhs) {
+                script_parse_error (&script_scan_get_current_token (scan)->location,
+                                    "An invalid RHS of an assign");
+                return NULL;
+        }
+        return script_parse_new_exp_dual (entry->exp_type, lhs, rhs, &location);
 }
 
 static script_exp_t *script_parse_exp (script_scan_t *scan)
 {
-  return script_parse_exp_as (scan);
+        return script_parse_exp_as (scan);
 }
 
 static script_op_t *script_parse_op_block (script_scan_t *scan)
 {
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-
-  if (!script_scan_token_is_symbol_of_value (curtoken, '{'))
-    return NULL;
-  script_debug_location_t location = curtoken->location;
-
-  script_scan_get_next_token (scan);
-  ply_list_t *sublist = script_parse_op_list (scan);
-
-  curtoken = script_scan_get_current_token (scan);
-  if (!script_scan_token_is_symbol_of_value (curtoken, '}'))
-    {
-      script_parse_error (&curtoken->location,
-                          "Expected a '}' to terminate the operation block");
-      return NULL;
-    }
-  curtoken = script_scan_get_next_token (scan);
-
-  script_op_t *op = script_parse_new_op_block (sublist, &location);
-  return op;
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+
+        if (!script_scan_token_is_symbol_of_value (curtoken, '{'))
+                return NULL;
+        script_debug_location_t location = curtoken->location;
+
+        script_scan_get_next_token (scan);
+        ply_list_t *sublist = script_parse_op_list (scan);
+
+        curtoken = script_scan_get_current_token (scan);
+        if (!script_scan_token_is_symbol_of_value (curtoken, '}')) {
+                script_parse_error (&curtoken->location,
+                                    "Expected a '}' to terminate the operation block");
+                return NULL;
+        }
+        curtoken = script_scan_get_next_token (scan);
+
+        script_op_t *op = script_parse_new_op_block (sublist, &location);
+        return op;
 }
 
 static script_op_t *script_parse_if_while (script_scan_t *scan)
 {
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-  script_op_type_t type;
-
-  if       (script_scan_token_is_identifier_of_value (curtoken, "if"))
-    type = SCRIPT_OP_TYPE_IF;
-  else if  (script_scan_token_is_identifier_of_value (curtoken, "while"))
-    type = SCRIPT_OP_TYPE_WHILE;
-  else return NULL;
-
-  script_debug_location_t location = curtoken->location;
-  curtoken = script_scan_get_next_token (scan);
-  if (!script_scan_token_is_symbol_of_value (curtoken, '('))
-    {
-      script_parse_error (&curtoken->location,
-                          "Expected a '(' at the start of a condition block");
-      return NULL;
-    }
-  curtoken = script_scan_get_next_token (scan);
-
-  script_exp_t *cond = script_parse_exp (scan);
-  curtoken = script_scan_get_current_token (scan);
-  if (!cond)
-    {
-      script_parse_error (&curtoken->location, "Expected a valid condition expression");
-      return NULL;
-    }
-  if (!script_scan_token_is_symbol_of_value (curtoken, ')'))
-    {
-      script_parse_error (&curtoken->location,
-                          "Expected a ')' at the end of a condition block");
-      return NULL;
-    }
-  script_scan_get_next_token (scan);
-  script_op_t *cond_op = script_parse_op (scan);
-  script_op_t *else_op = NULL;
-
-  curtoken = script_scan_get_current_token (scan);
-  if ((type == SCRIPT_OP_TYPE_IF)
-      && (script_scan_token_is_identifier_of_value (curtoken, "else")))
-    {
-      script_scan_get_next_token (scan);
-      else_op = script_parse_op (scan);
-    }
-  script_op_t *op = script_parse_new_op_cond (type, cond, cond_op, else_op, &location);
-  return op;
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+        script_op_type_t type;
+
+        if (script_scan_token_is_identifier_of_value (curtoken, "if"))
+                type = SCRIPT_OP_TYPE_IF;
+        else if (script_scan_token_is_identifier_of_value (curtoken, "while"))
+                type = SCRIPT_OP_TYPE_WHILE;
+        else return NULL;
+
+        script_debug_location_t location = curtoken->location;
+        curtoken = script_scan_get_next_token (scan);
+        if (!script_scan_token_is_symbol_of_value (curtoken, '(')) {
+                script_parse_error (&curtoken->location,
+                                    "Expected a '(' at the start of a condition block");
+                return NULL;
+        }
+        curtoken = script_scan_get_next_token (scan);
+
+        script_exp_t *cond = script_parse_exp (scan);
+        curtoken = script_scan_get_current_token (scan);
+        if (!cond) {
+                script_parse_error (&curtoken->location, "Expected a valid condition expression");
+                return NULL;
+        }
+        if (!script_scan_token_is_symbol_of_value (curtoken, ')')) {
+                script_parse_error (&curtoken->location,
+                                    "Expected a ')' at the end of a condition block");
+                return NULL;
+        }
+        script_scan_get_next_token (scan);
+        script_op_t *cond_op = script_parse_op (scan);
+        script_op_t *else_op = NULL;
+
+        curtoken = script_scan_get_current_token (scan);
+        if ((type == SCRIPT_OP_TYPE_IF)
+            && (script_scan_token_is_identifier_of_value (curtoken, "else"))) {
+                script_scan_get_next_token (scan);
+                else_op = script_parse_op (scan);
+        }
+        script_op_t *op = script_parse_new_op_cond (type, cond, cond_op, else_op, &location);
+        return op;
 }
 
 static script_op_t *script_parse_do_while (script_scan_t *scan)
 {
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-
-  if (!script_scan_token_is_identifier_of_value (curtoken, "do"))
-    return NULL;
-  script_debug_location_t location = curtoken->location;
-  curtoken = script_scan_get_next_token (scan);
-  script_op_t *cond_op = script_parse_op (scan);
-  curtoken = script_scan_get_current_token (scan);
-
-  if (!script_scan_token_is_identifier_of_value (curtoken, "while"))
-    {
-      script_parse_error (&curtoken->location,
-                          "Expected a 'while' after a 'do' block");
-      return NULL;
-    }
-  curtoken = script_scan_get_next_token (scan);
-
-  if (!script_scan_token_is_symbol_of_value (curtoken, '('))
-    {
-      script_parse_error (&curtoken->location,
-                          "Expected a '(' at the start of a do-while condition block");
-      return NULL;
-    }
-  curtoken = script_scan_get_next_token (scan);
-  script_exp_t *cond = script_parse_exp (scan);
-  curtoken = script_scan_get_current_token (scan);
-  if (!cond)
-    {
-      script_parse_error (&curtoken->location, "Expected a valid condition expression");
-      return NULL;
-    }
-  if (!script_scan_token_is_symbol_of_value (curtoken, ')'))
-    {
-      script_parse_error (&curtoken->location,
-                          "Expected a ')' at the end of a condition block");
-      return NULL;
-    }
-  curtoken = script_scan_get_next_token (scan);
-  if (!script_scan_token_is_symbol_of_value (curtoken, ';'))
-    {
-      script_parse_error (&curtoken->location,
-                          "Expected a ';' after a do-while expression");
-      return NULL;
-    }
-  script_scan_get_next_token (scan);
-  script_op_t *op = script_parse_new_op_cond (SCRIPT_OP_TYPE_DO_WHILE, cond, cond_op, NULL, &location);
-  return op;
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+
+        if (!script_scan_token_is_identifier_of_value (curtoken, "do"))
+                return NULL;
+        script_debug_location_t location = curtoken->location;
+        curtoken = script_scan_get_next_token (scan);
+        script_op_t *cond_op = script_parse_op (scan);
+        curtoken = script_scan_get_current_token (scan);
+
+        if (!script_scan_token_is_identifier_of_value (curtoken, "while")) {
+                script_parse_error (&curtoken->location,
+                                    "Expected a 'while' after a 'do' block");
+                return NULL;
+        }
+        curtoken = script_scan_get_next_token (scan);
+
+        if (!script_scan_token_is_symbol_of_value (curtoken, '(')) {
+                script_parse_error (&curtoken->location,
+                                    "Expected a '(' at the start of a do-while condition block");
+                return NULL;
+        }
+        curtoken = script_scan_get_next_token (scan);
+        script_exp_t *cond = script_parse_exp (scan);
+        curtoken = script_scan_get_current_token (scan);
+        if (!cond) {
+                script_parse_error (&curtoken->location, "Expected a valid condition expression");
+                return NULL;
+        }
+        if (!script_scan_token_is_symbol_of_value (curtoken, ')')) {
+                script_parse_error (&curtoken->location,
+                                    "Expected a ')' at the end of a condition block");
+                return NULL;
+        }
+        curtoken = script_scan_get_next_token (scan);
+        if (!script_scan_token_is_symbol_of_value (curtoken, ';')) {
+                script_parse_error (&curtoken->location,
+                                    "Expected a ';' after a do-while expression");
+                return NULL;
+        }
+        script_scan_get_next_token (scan);
+        script_op_t *op = script_parse_new_op_cond (SCRIPT_OP_TYPE_DO_WHILE, cond, cond_op, NULL, &location);
+        return op;
 }
 
 static script_op_t *script_parse_for (script_scan_t *scan)
 {
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-
-  if (!script_scan_token_is_identifier_of_value (curtoken, "for")) return NULL;
-  script_debug_location_t location_for = curtoken->location;
-  curtoken = script_scan_get_next_token (scan);
-  if (!script_scan_token_is_symbol_of_value (curtoken, '('))
-    {
-      script_parse_error (&curtoken->location,
-                          "Expected a '(' at the start of a condition block");
-      return NULL;
-    }
-  curtoken = script_scan_get_next_token (scan);
-  script_debug_location_t location_first = curtoken->location;
-
-  script_exp_t *first = script_parse_exp (scan);
-  if (!first)
-    {
-      script_parse_error (&curtoken->location, "Expected a valid first expression");
-      return NULL;
-    }
-  curtoken = script_scan_get_current_token (scan);
-  if (!script_scan_token_is_symbol_of_value (curtoken, ';'))
-    {
-      script_parse_error (&curtoken->location,
-                          "Expected a ';' after the first 'for' expression");
-      return NULL;
-    }
-  script_scan_get_next_token (scan);
-
-  script_exp_t *cond = script_parse_exp (scan);
-  if (!cond)
-    {
-      script_parse_error (&curtoken->location, "Expected a valid condition expression");
-      return NULL;
-    }
-  curtoken = script_scan_get_current_token (scan);
-  if (!script_scan_token_is_symbol_of_value (curtoken, ';'))
-    {
-      script_parse_error (&curtoken->location, "Expected a ';' after the 'for' condition");
-      return NULL;
-    }
-  script_scan_get_next_token (scan);
-  script_debug_location_t location_last = curtoken->location;
-
-  script_exp_t *last = script_parse_exp (scan);
-  if (!last)
-    {
-      script_parse_error (&curtoken->location, "Expected a valid last expression");
-      return NULL;
-    }
-  curtoken = script_scan_get_current_token (scan);
-  if (!script_scan_token_is_symbol_of_value (curtoken, ')'))
-    {
-      script_parse_error (&curtoken->location, "Expected a ')' at the end of a for block");
-      return NULL;
-    }
-  script_scan_get_next_token (scan);
-  script_op_t *op_body = script_parse_op (scan);
-
-  script_op_t *op_first = script_parse_new_op_exp (first, &location_first);
-  script_op_t *op_last = script_parse_new_op_exp (last, &location_last);
-  script_op_t *op_for = script_parse_new_op_cond (SCRIPT_OP_TYPE_FOR, cond, op_body, op_last, &location_for);
-
-  ply_list_t *op_list = ply_list_new ();
-  ply_list_append_data (op_list, op_first);
-  ply_list_append_data (op_list, op_for);
-
-  script_op_t *op_block = script_parse_new_op_block (op_list, &location_for);
-
-  return op_block;
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+
+        if (!script_scan_token_is_identifier_of_value (curtoken, "for")) return NULL;
+        script_debug_location_t location_for = curtoken->location;
+        curtoken = script_scan_get_next_token (scan);
+        if (!script_scan_token_is_symbol_of_value (curtoken, '(')) {
+                script_parse_error (&curtoken->location,
+                                    "Expected a '(' at the start of a condition block");
+                return NULL;
+        }
+        curtoken = script_scan_get_next_token (scan);
+        script_debug_location_t location_first = curtoken->location;
+
+        script_exp_t *first = script_parse_exp (scan);
+        if (!first) {
+                script_parse_error (&curtoken->location, "Expected a valid first expression");
+                return NULL;
+        }
+        curtoken = script_scan_get_current_token (scan);
+        if (!script_scan_token_is_symbol_of_value (curtoken, ';')) {
+                script_parse_error (&curtoken->location,
+                                    "Expected a ';' after the first 'for' expression");
+                return NULL;
+        }
+        script_scan_get_next_token (scan);
+
+        script_exp_t *cond = script_parse_exp (scan);
+        if (!cond) {
+                script_parse_error (&curtoken->location, "Expected a valid condition expression");
+                return NULL;
+        }
+        curtoken = script_scan_get_current_token (scan);
+        if (!script_scan_token_is_symbol_of_value (curtoken, ';')) {
+                script_parse_error (&curtoken->location, "Expected a ';' after the 'for' condition");
+                return NULL;
+        }
+        script_scan_get_next_token (scan);
+        script_debug_location_t location_last = curtoken->location;
+
+        script_exp_t *last = script_parse_exp (scan);
+        if (!last) {
+                script_parse_error (&curtoken->location, "Expected a valid last expression");
+                return NULL;
+        }
+        curtoken = script_scan_get_current_token (scan);
+        if (!script_scan_token_is_symbol_of_value (curtoken, ')')) {
+                script_parse_error (&curtoken->location, "Expected a ')' at the end of a for block");
+                return NULL;
+        }
+        script_scan_get_next_token (scan);
+        script_op_t *op_body = script_parse_op (scan);
+
+        script_op_t *op_first = script_parse_new_op_exp (first, &location_first);
+        script_op_t *op_last = script_parse_new_op_exp (last, &location_last);
+        script_op_t *op_for = script_parse_new_op_cond (SCRIPT_OP_TYPE_FOR, cond, op_body, op_last, &location_for);
+
+        ply_list_t *op_list = ply_list_new ();
+        ply_list_append_data (op_list, op_first);
+        ply_list_append_data (op_list, op_for);
+
+        script_op_t *op_block = script_parse_new_op_block (op_list, &location_for);
+
+        return op_block;
 }
 
 static script_op_t *script_parse_function (script_scan_t *scan)
 {
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-
-  if (!script_scan_token_is_identifier_of_value (curtoken, "fun")) return NULL;
-  script_debug_location_t location = curtoken->location;
-  curtoken = script_scan_get_next_token (scan);
-  if (!script_scan_token_is_identifier (curtoken))
-    {
-      script_parse_error (&curtoken->location,
-                          "A function declaration requires a valid name");
-      return NULL;
-    }
-  script_exp_t *name = script_parse_new_exp_var (curtoken->data.string, &curtoken->location);
-  
-  curtoken = script_scan_get_next_token (scan);     /* FIXME parse any type of exp as target and do an assign*/
-
-  script_function_t *function = script_parse_function_def (scan);
-  if (!function) return NULL;
-  script_exp_t *func_exp = script_parse_new_exp_function_def (function, &location);
-  script_exp_t *func_def = script_parse_new_exp_dual (SCRIPT_EXP_TYPE_ASSIGN, name, func_exp, &location);
-    
-  script_op_t *op = script_parse_new_op_exp (func_def, &location);
-  return op;
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+
+        if (!script_scan_token_is_identifier_of_value (curtoken, "fun")) return NULL;
+        script_debug_location_t location = curtoken->location;
+        curtoken = script_scan_get_next_token (scan);
+        if (!script_scan_token_is_identifier (curtoken)) {
+                script_parse_error (&curtoken->location,
+                                    "A function declaration requires a valid name");
+                return NULL;
+        }
+        script_exp_t *name = script_parse_new_exp_var (curtoken->data.string, &curtoken->location);
+
+        curtoken = script_scan_get_next_token (scan); /* FIXME parse any type of exp as target and do an assign*/
+
+        script_function_t *function = script_parse_function_def (scan);
+        if (!function) return NULL;
+        script_exp_t *func_exp = script_parse_new_exp_function_def (function, &location);
+        script_exp_t *func_def = script_parse_new_exp_dual (SCRIPT_EXP_TYPE_ASSIGN, name, func_exp, &location);
+
+        script_op_t *op = script_parse_new_op_exp (func_def, &location);
+        return op;
 }
 
 static script_op_t *script_parse_return (script_scan_t *scan)
 {
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-  script_op_type_t type;
-  if      (script_scan_token_is_identifier_of_value (curtoken, "return"))
-    type = SCRIPT_OP_TYPE_RETURN;
-  else if (script_scan_token_is_identifier_of_value (curtoken, "fail"))
-    type = SCRIPT_OP_TYPE_FAIL;
-  else if (script_scan_token_is_identifier_of_value (curtoken, "break"))
-    type = SCRIPT_OP_TYPE_BREAK;
-  else if (script_scan_token_is_identifier_of_value (curtoken, "continue"))
-    type = SCRIPT_OP_TYPE_CONTINUE;
-  else return NULL;
-  curtoken = script_scan_get_next_token (scan);
-
-  script_op_t *op = script_parse_new_op (type, &curtoken->location);
-  if (type == SCRIPT_OP_TYPE_RETURN)
-    {
-      op->data.exp = script_parse_exp (scan);                  /* May be NULL */
-      curtoken = script_scan_get_current_token (scan);
-    }
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+        script_op_type_t type;
+
+        if (script_scan_token_is_identifier_of_value (curtoken, "return"))
+                type = SCRIPT_OP_TYPE_RETURN;
+        else if (script_scan_token_is_identifier_of_value (curtoken, "fail"))
+                type = SCRIPT_OP_TYPE_FAIL;
+        else if (script_scan_token_is_identifier_of_value (curtoken, "break"))
+                type = SCRIPT_OP_TYPE_BREAK;
+        else if (script_scan_token_is_identifier_of_value (curtoken, "continue"))
+                type = SCRIPT_OP_TYPE_CONTINUE;
+        else return NULL;
+        curtoken = script_scan_get_next_token (scan);
+
+        script_op_t *op = script_parse_new_op (type, &curtoken->location);
+        if (type == SCRIPT_OP_TYPE_RETURN) {
+                op->data.exp = script_parse_exp (scan);        /* May be NULL */
+                curtoken = script_scan_get_current_token (scan);
+        }
 #ifdef WITH_SEMIES
-  if (!script_scan_token_is_symbol_of_value (curtoken, ';'))
-    {
-      script_parse_error (&curtoken->location, "Expected ';' after an expression");
-      return NULL;
-    }
-  curtoken = script_scan_get_next_token (scan);
+        if (!script_scan_token_is_symbol_of_value (curtoken, ';')) {
+                script_parse_error (&curtoken->location, "Expected ';' after an expression");
+                return NULL;
+        }
+        curtoken = script_scan_get_next_token (scan);
 #endif
 
-  return op;
+        return op;
 }
 
 static script_op_t *script_parse_op (script_scan_t *scan)
 {
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-  script_op_t *reply = NULL;
-
-  reply = script_parse_op_block (scan);
-  if (reply) return reply;
-  reply = script_parse_if_while (scan);
-  if (reply) return reply;
-  reply = script_parse_do_while (scan);
-  if (reply) return reply;
-  reply = script_parse_for (scan);
-  if (reply) return reply;
-  reply = script_parse_return (scan);
-  if (reply) return reply;
-  reply = script_parse_function (scan);
-  if (reply) return reply;
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+        script_op_t *reply = NULL;
+
+        reply = script_parse_op_block (scan);
+        if (reply) return reply;
+        reply = script_parse_if_while (scan);
+        if (reply) return reply;
+        reply = script_parse_do_while (scan);
+        if (reply) return reply;
+        reply = script_parse_for (scan);
+        if (reply) return reply;
+        reply = script_parse_return (scan);
+        if (reply) return reply;
+        reply = script_parse_function (scan);
+        if (reply) return reply;
 /* if curtoken->data.string == "if/for/while... */
 
 /* default is expression */
-  {
-    script_debug_location_t location = curtoken->location;
-    script_exp_t *exp = script_parse_exp (scan);
-    if (!exp) return NULL;
-    curtoken = script_scan_get_current_token (scan);
+        {
+                script_debug_location_t location = curtoken->location;
+                script_exp_t *exp = script_parse_exp (scan);
+                if (!exp) return NULL;
+                curtoken = script_scan_get_current_token (scan);
 #ifdef WITH_SEMIES
-    if (!script_scan_token_is_symbol_of_value (curtoken, ';'))
-      {
-        script_parse_error (&curtoken->location, "Expected ';' after an expression");
-        return NULL;
-      }
-    curtoken = script_scan_get_next_token (scan);
+                if (!script_scan_token_is_symbol_of_value (curtoken, ';')) {
+                        script_parse_error (&curtoken->location, "Expected ';' after an expression");
+                        return NULL;
+                }
+                curtoken = script_scan_get_next_token (scan);
 #endif
 
-    script_op_t *op = script_parse_new_op_exp (exp, &location);
-    return op;
-  }
-  return NULL;
+                script_op_t *op = script_parse_new_op_exp (exp, &location);
+                return op;
+        }
+        return NULL;
 }
 
 static ply_list_t *script_parse_op_list (script_scan_t *scan)
 {
-  ply_list_t *op_list = ply_list_new ();
+        ply_list_t *op_list = ply_list_new ();
 
-  while (true)
-    {
-      script_op_t *op = script_parse_op (scan);
-      if (!op) break;
-      ply_list_append_data (op_list, op);
-    }
+        while (true) {
+                script_op_t *op = script_parse_op (scan);
+                if (!op) break;
+                ply_list_append_data (op_list, op);
+        }
 
-  return op_list;
+        return op_list;
 }
 
 static void script_parse_exp_free (script_exp_t *exp)
 {
-  if (!exp) return;
-  switch (exp->type)
-    {
-      case SCRIPT_EXP_TYPE_PLUS:
-      case SCRIPT_EXP_TYPE_MINUS:
-      case SCRIPT_EXP_TYPE_MUL:
-      case SCRIPT_EXP_TYPE_DIV:
-      case SCRIPT_EXP_TYPE_MOD:
-      case SCRIPT_EXP_TYPE_EQ:
-      case SCRIPT_EXP_TYPE_NE:
-      case SCRIPT_EXP_TYPE_GT:
-      case SCRIPT_EXP_TYPE_GE:
-      case SCRIPT_EXP_TYPE_LT:
-      case SCRIPT_EXP_TYPE_LE:
-      case SCRIPT_EXP_TYPE_AND:
-      case SCRIPT_EXP_TYPE_OR:
-      case SCRIPT_EXP_TYPE_EXTEND:
-      case SCRIPT_EXP_TYPE_ASSIGN:
-      case SCRIPT_EXP_TYPE_ASSIGN_PLUS:
-      case SCRIPT_EXP_TYPE_ASSIGN_MINUS:
-      case SCRIPT_EXP_TYPE_ASSIGN_MUL:
-      case SCRIPT_EXP_TYPE_ASSIGN_DIV:
-      case SCRIPT_EXP_TYPE_ASSIGN_MOD:
-      case SCRIPT_EXP_TYPE_ASSIGN_EXTEND:
-      case SCRIPT_EXP_TYPE_HASH:
-        script_parse_exp_free (exp->data.dual.sub_a);
-        script_parse_exp_free (exp->data.dual.sub_b);
-        break;
-
-      case SCRIPT_EXP_TYPE_NOT:
-      case SCRIPT_EXP_TYPE_POS:
-      case SCRIPT_EXP_TYPE_NEG:
-      case SCRIPT_EXP_TYPE_PRE_INC:
-      case SCRIPT_EXP_TYPE_PRE_DEC:
-      case SCRIPT_EXP_TYPE_POST_INC:
-      case SCRIPT_EXP_TYPE_POST_DEC:
-        script_parse_exp_free (exp->data.sub);
-        break;
-
-      case SCRIPT_EXP_TYPE_TERM_NUMBER:
-      case SCRIPT_EXP_TYPE_TERM_NULL:
-      case SCRIPT_EXP_TYPE_TERM_LOCAL:
-      case SCRIPT_EXP_TYPE_TERM_GLOBAL:
-      case SCRIPT_EXP_TYPE_TERM_THIS:
-        break;
-      case SCRIPT_EXP_TYPE_TERM_SET:
+        if (!exp) return;
+        switch (exp->type) {
+        case SCRIPT_EXP_TYPE_PLUS:
+        case SCRIPT_EXP_TYPE_MINUS:
+        case SCRIPT_EXP_TYPE_MUL:
+        case SCRIPT_EXP_TYPE_DIV:
+        case SCRIPT_EXP_TYPE_MOD:
+        case SCRIPT_EXP_TYPE_EQ:
+        case SCRIPT_EXP_TYPE_NE:
+        case SCRIPT_EXP_TYPE_GT:
+        case SCRIPT_EXP_TYPE_GE:
+        case SCRIPT_EXP_TYPE_LT:
+        case SCRIPT_EXP_TYPE_LE:
+        case SCRIPT_EXP_TYPE_AND:
+        case SCRIPT_EXP_TYPE_OR:
+        case SCRIPT_EXP_TYPE_EXTEND:
+        case SCRIPT_EXP_TYPE_ASSIGN:
+        case SCRIPT_EXP_TYPE_ASSIGN_PLUS:
+        case SCRIPT_EXP_TYPE_ASSIGN_MINUS:
+        case SCRIPT_EXP_TYPE_ASSIGN_MUL:
+        case SCRIPT_EXP_TYPE_ASSIGN_DIV:
+        case SCRIPT_EXP_TYPE_ASSIGN_MOD:
+        case SCRIPT_EXP_TYPE_ASSIGN_EXTEND:
+        case SCRIPT_EXP_TYPE_HASH:
+                script_parse_exp_free (exp->data.dual.sub_a);
+                script_parse_exp_free (exp->data.dual.sub_b);
+                break;
+
+        case SCRIPT_EXP_TYPE_NOT:
+        case SCRIPT_EXP_TYPE_POS:
+        case SCRIPT_EXP_TYPE_NEG:
+        case SCRIPT_EXP_TYPE_PRE_INC:
+        case SCRIPT_EXP_TYPE_PRE_DEC:
+        case SCRIPT_EXP_TYPE_POST_INC:
+        case SCRIPT_EXP_TYPE_POST_DEC:
+                script_parse_exp_free (exp->data.sub);
+                break;
+
+        case SCRIPT_EXP_TYPE_TERM_NUMBER:
+        case SCRIPT_EXP_TYPE_TERM_NULL:
+        case SCRIPT_EXP_TYPE_TERM_LOCAL:
+        case SCRIPT_EXP_TYPE_TERM_GLOBAL:
+        case SCRIPT_EXP_TYPE_TERM_THIS:
+                break;
+        case SCRIPT_EXP_TYPE_TERM_SET:
         {
-          ply_list_node_t *node;
-          for (node = ply_list_get_first_node (exp->data.parameters);
-               node;
-               node = ply_list_get_next_node (exp->data.parameters, node))
-            {
-              script_exp_t *sub = ply_list_node_get_data (node);
-              script_parse_exp_free (sub);
-            }
-          ply_list_free (exp->data.parameters);
-          break;
+                ply_list_node_t *node;
+                for (node = ply_list_get_first_node (exp->data.parameters);
+                     node;
+                     node = ply_list_get_next_node (exp->data.parameters, node)) {
+                        script_exp_t *sub = ply_list_node_get_data (node);
+                        script_parse_exp_free (sub);
+                }
+                ply_list_free (exp->data.parameters);
+                break;
         }
-      case SCRIPT_EXP_TYPE_FUNCTION_EXE:
+        case SCRIPT_EXP_TYPE_FUNCTION_EXE:
         {
-          ply_list_node_t *node;
-          for (node = ply_list_get_first_node (exp->data.function_exe.parameters);
-               node;
-               node = ply_list_get_next_node (exp->data.function_exe.parameters, node))
-            {
-              script_exp_t *sub = ply_list_node_get_data (node);
-              script_parse_exp_free (sub);
-            }
-          ply_list_free (exp->data.function_exe.parameters);
-          script_parse_exp_free (exp->data.function_exe.name);
-          break;
+                ply_list_node_t *node;
+                for (node = ply_list_get_first_node (exp->data.function_exe.parameters);
+                     node;
+                     node = ply_list_get_next_node (exp->data.function_exe.parameters, node)) {
+                        script_exp_t *sub = ply_list_node_get_data (node);
+                        script_parse_exp_free (sub);
+                }
+                ply_list_free (exp->data.function_exe.parameters);
+                script_parse_exp_free (exp->data.function_exe.name);
+                break;
         }
-      case SCRIPT_EXP_TYPE_FUNCTION_DEF:   /* FIXME merge the frees with one from op_free */
+        case SCRIPT_EXP_TYPE_FUNCTION_DEF: /* FIXME merge the frees with one from op_free */
         {
-          if (exp->data.function_def->type == SCRIPT_FUNCTION_TYPE_SCRIPT) 
-            script_parse_op_free (exp->data.function_def->data.script);
-          ply_list_node_t *node;
-          for (node = ply_list_get_first_node (exp->data.function_def->parameters);
-               node;
-               node = ply_list_get_next_node (exp->data.function_def->parameters, node))
-            {
-              char *arg = ply_list_node_get_data (node);
-              free (arg);
-            }
-          ply_list_free (exp->data.function_def->parameters);
-          free (exp->data.function_def);
-          break;
+                if (exp->data.function_def->type == SCRIPT_FUNCTION_TYPE_SCRIPT)
+                        script_parse_op_free (exp->data.function_def->data.script);
+                ply_list_node_t *node;
+                for (node = ply_list_get_first_node (exp->data.function_def->parameters);
+                     node;
+                     node = ply_list_get_next_node (exp->data.function_def->parameters, node)) {
+                        char *arg = ply_list_node_get_data (node);
+                        free (arg);
+                }
+                ply_list_free (exp->data.function_def->parameters);
+                free (exp->data.function_def);
+                break;
         }
 
-      case SCRIPT_EXP_TYPE_TERM_STRING:
-      case SCRIPT_EXP_TYPE_TERM_VAR:
-        free (exp->data.string);
-        break;
-    }
-  script_debug_remove_element (exp);
-  free (exp);
+        case SCRIPT_EXP_TYPE_TERM_STRING:
+        case SCRIPT_EXP_TYPE_TERM_VAR:
+                free (exp->data.string);
+                break;
+        }
+        script_debug_remove_element (exp);
+        free (exp);
 }
 
 void script_parse_op_free (script_op_t *op)
 {
-  if (!op) return;
-  switch (op->type)
-    {
-      case SCRIPT_OP_TYPE_EXPRESSION:
-        script_parse_exp_free (op->data.exp);
-        break;
-
-      case SCRIPT_OP_TYPE_OP_BLOCK:
-        script_parse_op_list_free (op->data.list);
-        break;
-
-      case SCRIPT_OP_TYPE_IF:
-      case SCRIPT_OP_TYPE_WHILE:
-      case SCRIPT_OP_TYPE_DO_WHILE:
-      case SCRIPT_OP_TYPE_FOR:
-        script_parse_exp_free (op->data.cond_op.cond);
-        script_parse_op_free  (op->data.cond_op.op1);
-        script_parse_op_free  (op->data.cond_op.op2);
-        break;
-
-      case SCRIPT_OP_TYPE_RETURN:
-        if (op->data.exp) script_parse_exp_free (op->data.exp);
-        break;
-
-      case SCRIPT_OP_TYPE_FAIL:
-      case SCRIPT_OP_TYPE_BREAK:
-      case SCRIPT_OP_TYPE_CONTINUE:
-        break;
-    }
-  script_debug_remove_element (op);
-  free (op);
+        if (!op) return;
+        switch (op->type) {
+        case SCRIPT_OP_TYPE_EXPRESSION:
+                script_parse_exp_free (op->data.exp);
+                break;
+
+        case SCRIPT_OP_TYPE_OP_BLOCK:
+                script_parse_op_list_free (op->data.list);
+                break;
+
+        case SCRIPT_OP_TYPE_IF:
+        case SCRIPT_OP_TYPE_WHILE:
+        case SCRIPT_OP_TYPE_DO_WHILE:
+        case SCRIPT_OP_TYPE_FOR:
+                script_parse_exp_free (op->data.cond_op.cond);
+                script_parse_op_free (op->data.cond_op.op1);
+                script_parse_op_free (op->data.cond_op.op2);
+                break;
+
+        case SCRIPT_OP_TYPE_RETURN:
+                if (op->data.exp) script_parse_exp_free (op->data.exp);
+                break;
+
+        case SCRIPT_OP_TYPE_FAIL:
+        case SCRIPT_OP_TYPE_BREAK:
+        case SCRIPT_OP_TYPE_CONTINUE:
+                break;
+        }
+        script_debug_remove_element (op);
+        free (op);
 }
 
 static void script_parse_op_list_free (ply_list_t *op_list)
 {
-  ply_list_node_t *node;
-
-  for (node = ply_list_get_first_node (op_list);
-       node;
-       node = ply_list_get_next_node (op_list, node))
-    {
-      script_op_t *op = ply_list_node_get_data (node);
-      script_parse_op_free (op);
-    }
-  ply_list_free (op_list);
-  return;
+        ply_list_node_t *node;
+
+        for (node = ply_list_get_first_node (op_list);
+             node;
+             node = ply_list_get_next_node (op_list, node)) {
+                script_op_t *op = ply_list_node_get_data (node);
+                script_parse_op_free (op);
+        }
+        ply_list_free (op_list);
+        return;
 }
 
 script_op_t *script_parse_file (const char *filename)
 {
-  script_scan_t *scan = script_scan_file (filename);
-
-  if (!scan)
-    {
-      ply_error ("Parser error : Error opening file %s\n", filename);
-      return NULL;
-    }
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-  script_debug_location_t location = curtoken->location;
-  ply_list_t *list = script_parse_op_list (scan);
-
-  curtoken = script_scan_get_current_token (scan);
-  if (curtoken->type != SCRIPT_SCAN_TOKEN_TYPE_EOF)
-    {
-      script_parse_error (&curtoken->location, "Unparsed characters at end of file");
-      return NULL;
-    }
-  script_op_t *op = script_parse_new_op_block (list, &location);
-  script_scan_free (scan);
-  return op;
+        script_scan_t *scan = script_scan_file (filename);
+
+        if (!scan) {
+                ply_error ("Parser error : Error opening file %s\n", filename);
+                return NULL;
+        }
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+        script_debug_location_t location = curtoken->location;
+        ply_list_t *list = script_parse_op_list (scan);
+
+        curtoken = script_scan_get_current_token (scan);
+        if (curtoken->type != SCRIPT_SCAN_TOKEN_TYPE_EOF) {
+                script_parse_error (&curtoken->location, "Unparsed characters at end of file");
+                return NULL;
+        }
+        script_op_t *op = script_parse_new_op_block (list, &location);
+        script_scan_free (scan);
+        return op;
 }
 
 script_op_t *script_parse_string (const char *string,
                                   const char *name)
 {
-  script_scan_t *scan = script_scan_string (string, name);
-
-  if (!scan)
-    {
-      ply_error ("Parser error : Error creating a parser with a string");
-      return NULL;
-    }
-  script_scan_token_t *curtoken = script_scan_get_current_token (scan);
-  script_debug_location_t location = curtoken->location;
-  ply_list_t *list = script_parse_op_list (scan);
-  
-  curtoken = script_scan_get_current_token (scan);
-  if (curtoken->type != SCRIPT_SCAN_TOKEN_TYPE_EOF)
-    {
-      script_parse_error (&curtoken->location, "Unparsed characters at end of file");
-      return NULL;
-    }
-  script_op_t *op = script_parse_new_op_block (list, &location);
-  script_scan_free (scan);
-  return op;
+        script_scan_t *scan = script_scan_string (string, name);
+
+        if (!scan) {
+                ply_error ("Parser error : Error creating a parser with a string");
+                return NULL;
+        }
+        script_scan_token_t *curtoken = script_scan_get_current_token (scan);
+        script_debug_location_t location = curtoken->location;
+        ply_list_t *list = script_parse_op_list (scan);
+
+        curtoken = script_scan_get_current_token (scan);
+        if (curtoken->type != SCRIPT_SCAN_TOKEN_TYPE_EOF) {
+                script_parse_error (&curtoken->location, "Unparsed characters at end of file");
+                return NULL;
+        }
+        script_op_t *op = script_parse_new_op_block (list, &location);
+        script_scan_free (scan);
+        return op;
 }
diff --git a/src/plugins/splash/script/script-scan.c b/src/plugins/splash/script/script-scan.c
index 5d1aa64..c27ffcf 100644
--- a/src/plugins/splash/script/script-scan.c
+++ b/src/plugins/splash/script/script-scan.c
@@ -39,383 +39,352 @@
 
 static script_scan_t *script_scan_new (void)
 {
-  unsigned char *chars;
-  script_scan_t *scan = calloc (1, sizeof (script_scan_t));
-
-  scan->tokens = NULL;
-  scan->tokencount = 0;
-  scan->cur_char = '\0';
-  scan->line_index = 1;                 /* According to Nedit the first line is 1 but first column is 0 */
-  scan->column_index = COLUMN_START_INDEX;
-
-  scan->identifier_1st_char = ply_bitarray_new (256);
-  scan->identifier_nth_char = ply_bitarray_new (256);
-
-  for (chars =
-        (unsigned char *) "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_";
-       *chars;
-       chars++)
-    ply_bitarray_set (scan->identifier_1st_char, *chars);
-  for (chars =
-         (unsigned char *) "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789";
-       *chars;
-       chars++)
-    ply_bitarray_set (scan->identifier_nth_char, *chars);
-  return scan;
+        unsigned char *chars;
+        script_scan_t *scan = calloc (1, sizeof(script_scan_t));
+
+        scan->tokens = NULL;
+        scan->tokencount = 0;
+        scan->cur_char = '\0';
+        scan->line_index = 1;           /* According to Nedit the first line is 1 but first column is 0 */
+        scan->column_index = COLUMN_START_INDEX;
+
+        scan->identifier_1st_char = ply_bitarray_new (256);
+        scan->identifier_nth_char = ply_bitarray_new (256);
+
+        for (chars =
+                     (unsigned char *) "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_";
+             *chars;
+             chars++) {
+                ply_bitarray_set (scan->identifier_1st_char, *chars);
+        }
+        for (chars =
+                     (unsigned char *) "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789";
+             *chars;
+             chars++) {
+                ply_bitarray_set (scan->identifier_nth_char, *chars);
+        }
+        return scan;
 }
 
 script_scan_t *script_scan_file (const char *filename)
 {
-  int fd = open (filename, O_RDONLY|O_CLOEXEC);
-  if (fd < 0) return NULL;
-  script_scan_t *scan = script_scan_new ();
-  scan->name = strdup (filename);
-  scan->source.fd = fd;
-  scan->source_is_file = true;
-  script_scan_get_next_char (scan);
-  return scan;
+        int fd = open (filename, O_RDONLY | O_CLOEXEC);
+
+        if (fd < 0) return NULL;
+        script_scan_t *scan = script_scan_new ();
+        scan->name = strdup (filename);
+        scan->source.fd = fd;
+        scan->source_is_file = true;
+        script_scan_get_next_char (scan);
+        return scan;
 }
 
 script_scan_t *script_scan_string (const char *string,
                                    const char *name)
 {
-  script_scan_t *scan = script_scan_new ();
-  scan->name = strdup (name);
-  scan->source.string = string;
-  scan->source_is_file = false;
-  script_scan_get_next_char (scan);
-  return scan;
+        script_scan_t *scan = script_scan_new ();
+
+        scan->name = strdup (name);
+        scan->source.string = string;
+        scan->source_is_file = false;
+        script_scan_get_next_char (scan);
+        return scan;
 }
 
 void script_scan_token_clean (script_scan_token_t *token)
 {
-  switch (token->type)
-    {
-      case SCRIPT_SCAN_TOKEN_TYPE_EMPTY:
-      case SCRIPT_SCAN_TOKEN_TYPE_EOF:
-      case SCRIPT_SCAN_TOKEN_TYPE_INTEGER:
-      case SCRIPT_SCAN_TOKEN_TYPE_FLOAT:
-      case SCRIPT_SCAN_TOKEN_TYPE_SYMBOL:
-        break;
-      case SCRIPT_SCAN_TOKEN_TYPE_IDENTIFIER:
-      case SCRIPT_SCAN_TOKEN_TYPE_STRING:
-      case SCRIPT_SCAN_TOKEN_TYPE_COMMENT:
-      case SCRIPT_SCAN_TOKEN_TYPE_ERROR:
-        free (token->data.string);
-        break;
-    }
-  token->type = SCRIPT_SCAN_TOKEN_TYPE_EMPTY;
-  token->whitespace = 0;
+        switch (token->type) {
+        case SCRIPT_SCAN_TOKEN_TYPE_EMPTY:
+        case SCRIPT_SCAN_TOKEN_TYPE_EOF:
+        case SCRIPT_SCAN_TOKEN_TYPE_INTEGER:
+        case SCRIPT_SCAN_TOKEN_TYPE_FLOAT:
+        case SCRIPT_SCAN_TOKEN_TYPE_SYMBOL:
+                break;
+        case SCRIPT_SCAN_TOKEN_TYPE_IDENTIFIER:
+        case SCRIPT_SCAN_TOKEN_TYPE_STRING:
+        case SCRIPT_SCAN_TOKEN_TYPE_COMMENT:
+        case SCRIPT_SCAN_TOKEN_TYPE_ERROR:
+                free (token->data.string);
+                break;
+        }
+        token->type = SCRIPT_SCAN_TOKEN_TYPE_EMPTY;
+        token->whitespace = 0;
 }
 
 void script_scan_free (script_scan_t *scan)
 {
-  int i;
-  if (scan->source_is_file) close (scan->source.fd);
-  for (i = 0; i < scan->tokencount; i++)
-    {
-      script_scan_token_clean (scan->tokens[i]);
-      free (scan->tokens[i]);
-    }
-  ply_bitarray_free (scan->identifier_1st_char);
-  ply_bitarray_free (scan->identifier_nth_char);
-  free (scan->name);
-  free (scan->tokens);
-  free (scan);
+        int i;
+
+        if (scan->source_is_file) close (scan->source.fd);
+        for (i = 0; i < scan->tokencount; i++) {
+                script_scan_token_clean (scan->tokens[i]);
+                free (scan->tokens[i]);
+        }
+        ply_bitarray_free (scan->identifier_1st_char);
+        ply_bitarray_free (scan->identifier_nth_char);
+        free (scan->name);
+        free (scan->tokens);
+        free (scan);
 }
 
 unsigned char script_scan_get_current_char (script_scan_t *scan)
 {
-  return scan->cur_char;
+        return scan->cur_char;
 }
 
 unsigned char script_scan_get_next_char (script_scan_t *scan)
 {
-  if (scan->cur_char == '\n')
-    {
-      scan->line_index++;
-      scan->column_index = COLUMN_START_INDEX;
-    }
-  else if (scan->cur_char != '\0')
-    scan->column_index++;
-  if (scan->source_is_file)
-    {
-      int got = read (scan->source.fd, &scan->cur_char, 1);
-      if (!got) scan->cur_char = 0;                    /* FIXME a better way of doing EOF etc */
-    }
-  else
-    {
-      scan->cur_char = *scan->source.string;
-      if (scan->cur_char) scan->source.string++;
-    }
-  return scan->cur_char;
+        if (scan->cur_char == '\n') {
+                scan->line_index++;
+                scan->column_index = COLUMN_START_INDEX;
+        } else if (scan->cur_char != '\0') {
+                scan->column_index++;
+        }
+        if (scan->source_is_file) {
+                int got = read (scan->source.fd, &scan->cur_char, 1);
+                if (!got) scan->cur_char = 0;          /* FIXME a better way of doing EOF etc */
+        } else {
+                scan->cur_char = *scan->source.string;
+                if (scan->cur_char) scan->source.string++;
+        }
+        return scan->cur_char;
 }
 
 void script_scan_read_next_token (script_scan_t       *scan,
-                               script_scan_token_t *token)
+                                  script_scan_token_t *token)
 {
-  unsigned char curchar = script_scan_get_current_char (scan);     /* FIXME Double check these unsigned chars are ok */
-  unsigned char nextchar;
+        unsigned char curchar = script_scan_get_current_char (scan);  /* FIXME Double check these unsigned chars are ok */
+        unsigned char nextchar;
 
-  token->whitespace = 0;
-  while (true)
-    {
-      if (curchar == ' ')
-        {
-          curchar = script_scan_get_next_char (scan);
-          token->whitespace++;
-          continue;
-        }                                                                                           /* FIXME restrcuture */
-      if (curchar == '\n')
-        {
-          curchar = script_scan_get_next_char (scan);
-          token->whitespace++;
-          continue;
+        token->whitespace = 0;
+        while (true) {
+                if (curchar == ' ') {
+                        curchar = script_scan_get_next_char (scan);
+                        token->whitespace++;
+                        continue;
+                }                                                                                   /* FIXME restrcuture */
+                if (curchar == '\n') {
+                        curchar = script_scan_get_next_char (scan);
+                        token->whitespace++;
+                        continue;
+                }
+                if (curchar == '\t') {
+                        curchar = script_scan_get_next_char (scan);
+                        token->whitespace++;
+                        continue;
+                }
+                break;
         }
-      if (curchar == '\t')
-        {
-          curchar = script_scan_get_next_char (scan);
-          token->whitespace++;
-          continue;
+        token->location.line_index = scan->line_index;
+        token->location.column_index = scan->column_index;
+        token->location.name = scan->name;
+        nextchar = script_scan_get_next_char (scan);
+
+        if (ply_bitarray_lookup (scan->identifier_1st_char, curchar)) {
+                int index = 1;
+                token->type = SCRIPT_SCAN_TOKEN_TYPE_IDENTIFIER;
+                token->data.string = malloc (2 * sizeof(char));
+                token->data.string[0] = curchar;
+                token->data.string[1] = '\0';
+                curchar = nextchar;
+                while (ply_bitarray_lookup (scan->identifier_nth_char, curchar)) {
+                        token->data.string = realloc (token->data.string,
+                                                      (index + 2) * sizeof(char));
+                        token->data.string[index] = curchar;
+                        token->data.string[index + 1] = '\0';
+                        index++;
+                        curchar = script_scan_get_next_char (scan);
+                }
+                return;
         }
-      break;
-    }
-  token->location.line_index = scan->line_index;
-  token->location.column_index = scan->column_index;
-  token->location.name = scan->name;
-  nextchar = script_scan_get_next_char (scan);
-
-  if (ply_bitarray_lookup (scan->identifier_1st_char, curchar))
-    {
-      int index = 1;
-      token->type = SCRIPT_SCAN_TOKEN_TYPE_IDENTIFIER;
-      token->data.string =  malloc (2 * sizeof (char));
-      token->data.string[0] = curchar;
-      token->data.string[1] = '\0';
-      curchar = nextchar;
-      while (ply_bitarray_lookup (scan->identifier_nth_char, curchar))
-        {
-          token->data.string = realloc (token->data.string,
-                                        (index + 2) * sizeof (char));
-          token->data.string[index] = curchar;
-          token->data.string[index + 1] = '\0';
-          index++;
-          curchar = script_scan_get_next_char (scan);
+        if ((curchar >= '0') && (curchar <= '9')) {
+                long long int int_value = curchar - '0';
+                curchar = nextchar;
+                while (curchar >= '0' && curchar <= '9') {
+                        int_value *= 10;
+                        int_value += curchar - '0';
+                        curchar = script_scan_get_next_char (scan);
+                }
+
+                if (curchar == '.') {
+                        double floatpoint = int_value;
+                        double scalar = 1;
+
+                        curchar = script_scan_get_next_char (scan);
+                        while (curchar >= '0' && curchar <= '9') {
+                                scalar /= 10;
+                                floatpoint += scalar * (curchar - '0');
+                                curchar = script_scan_get_next_char (scan);
+                        }
+                        token->type = SCRIPT_SCAN_TOKEN_TYPE_FLOAT;
+                        token->data.floatpoint = floatpoint;
+                } else {
+                        token->type = SCRIPT_SCAN_TOKEN_TYPE_INTEGER;
+                        token->data.integer = int_value;
+                }
+                return;
         }
-      return;
-    }
-  if ((curchar >= '0') && (curchar <= '9'))
-    {
-      long long int int_value = curchar - '0';
-      curchar = nextchar;
-      while (curchar >= '0' && curchar <= '9')
-        {
-          int_value *= 10;
-          int_value += curchar - '0';
-          curchar = script_scan_get_next_char (scan);
+        if (!curchar) {
+                token->type = SCRIPT_SCAN_TOKEN_TYPE_EOF;
+                return;
         }
+        if (curchar == '\"') {
+                token->type = SCRIPT_SCAN_TOKEN_TYPE_STRING;
+                int index = 0;
+                token->data.string = malloc (sizeof(char));
+                token->data.string[0] = '\0';
+                curchar = nextchar;
 
-      if (curchar == '.')
-        {
-          double floatpoint = int_value;
-          double scalar = 1;
-
-          curchar = script_scan_get_next_char (scan);
-          while (curchar >= '0' && curchar <= '9')
-            {
-              scalar /= 10;
-              floatpoint += scalar * (curchar - '0');
-              curchar = script_scan_get_next_char (scan);
-            }
-          token->type = SCRIPT_SCAN_TOKEN_TYPE_FLOAT;
-          token->data.floatpoint = floatpoint;
+                while (curchar != '\"') {
+                        if (curchar == '\0') {
+                                token->data.string = strdup ("End of file before end of string");
+                                token->type = SCRIPT_SCAN_TOKEN_TYPE_ERROR;
+                                return;
+                        }
+                        if (curchar == '\n') {
+                                token->data.string = strdup ("Line terminator before end of string");
+                                token->type = SCRIPT_SCAN_TOKEN_TYPE_ERROR;
+                                return;
+                        }
+                        if (curchar == '\\') {
+                                curchar = script_scan_get_next_char (scan);
+                                switch (curchar) {
+                                case 'n':
+                                        curchar = '\n';
+                                        break;
+
+                                case '0':
+                                        curchar = '\0';
+                                        break;
+
+                                case '"':
+                                        curchar = '\"';
+                                        break;
+
+                                default:
+                                        break;
+                                }
+                        }
+                        token->data.string = realloc (token->data.string,
+                                                      (index + 2) * sizeof(char));
+                        token->data.string[index] = curchar;
+                        token->data.string[index + 1] = '\0';
+                        index++;
+                        curchar = script_scan_get_next_char (scan);
+                }
+                script_scan_get_next_char (scan);
+                return;
         }
-      else
         {
-          token->type = SCRIPT_SCAN_TOKEN_TYPE_INTEGER;
-          token->data.integer = int_value;
+                bool linecomment = false;
+                if (curchar == '#') linecomment = true;
+                if ((curchar == '/') && (nextchar == '/')) {
+                        linecomment = true;
+                        nextchar = script_scan_get_next_char (scan);
+                }
+                if (linecomment) {
+                        int index = 0;
+                        token->data.string = malloc (sizeof(char));
+                        token->data.string[0] = '\0';
+                        curchar = nextchar;
+                        for (curchar = nextchar;
+                             curchar != '\n' && curchar != '\0';
+                             curchar = script_scan_get_next_char (scan)) {
+                                token->data.string = realloc (token->data.string,
+                                                              (index + 2) * sizeof(char));
+                                token->data.string[index] = curchar;
+                                token->data.string[index + 1] = '\0';
+                                index++;
+                        }
+                        token->type = SCRIPT_SCAN_TOKEN_TYPE_COMMENT;
+                        return;
+                }
         }
-      return;
-    }
-  if (!curchar)
-    {
-      token->type = SCRIPT_SCAN_TOKEN_TYPE_EOF;
-      return;
-    }
-  if (curchar == '\"')
-    {
-      token->type = SCRIPT_SCAN_TOKEN_TYPE_STRING;
-      int index = 0;
-      token->data.string = malloc (sizeof (char));
-      token->data.string[0] = '\0';
-      curchar = nextchar;
-
-      while (curchar != '\"')
-        {
-          if (curchar == '\0')
-            {
-              token->data.string = strdup("End of file before end of string");
-              token->type = SCRIPT_SCAN_TOKEN_TYPE_ERROR;
-              return;
-            }
-          if (curchar == '\n')
-            {
-              token->data.string = strdup("Line terminator before end of string");
-              token->type = SCRIPT_SCAN_TOKEN_TYPE_ERROR;
-              return;
-            }
-          if (curchar == '\\')
-            {
-              curchar = script_scan_get_next_char (scan);
-              switch (curchar)
-                {
-                  case 'n':
-                    curchar = '\n';
-                    break;
-
-                  case '0':
-                    curchar = '\0';
-                    break;
-
-                  case '"':
-                    curchar = '\"';
-                    break;
-
-                  default:
-                    break;
+
+        if ((curchar == '/') && (nextchar == '*')) {
+                int index = 0;
+                int depth = 1;
+                token->data.string = malloc (sizeof(char));
+                token->data.string[0] = '\0';
+                curchar = script_scan_get_next_char (scan);
+                nextchar = script_scan_get_next_char (scan);
+
+                while (true) {
+                        if (nextchar == '\0') {
+                                free (token->data.string);
+                                token->data.string = strdup ("End of file before end of comment");
+                                token->type = SCRIPT_SCAN_TOKEN_TYPE_ERROR;
+                                return;
+                        }
+                        if ((curchar == '/') && (nextchar == '*'))
+                                depth++;
+                        if ((curchar == '*') && (nextchar == '/')) {
+                                depth--;
+                                if (!depth) break;
+                        }
+                        token->data.string = realloc (token->data.string,
+                                                      (index + 2) * sizeof(char));
+                        token->data.string[index] = curchar;
+                        token->data.string[index + 1] = '\0';
+                        index++;
+                        curchar = nextchar;
+                        nextchar = script_scan_get_next_char (scan);
                 }
-            }
-          token->data.string = realloc (token->data.string,
-                                        (index + 2) * sizeof (char));
-          token->data.string[index] = curchar;
-          token->data.string[index + 1] = '\0';
-          index++;
-          curchar = script_scan_get_next_char (scan);
+                script_scan_get_next_char (scan);
+                token->type = SCRIPT_SCAN_TOKEN_TYPE_COMMENT;
+                return;
         }
-      script_scan_get_next_char (scan);
-      return;
-    }
-  {
-    bool linecomment = false;
-    if (curchar == '#') linecomment = true;
-    if ((curchar == '/') && (nextchar == '/'))
-      {
-        linecomment = true;
-        nextchar = script_scan_get_next_char (scan);
-      }
-    if (linecomment)
-      {
-        int index = 0;
-        token->data.string = malloc (sizeof (char));
-        token->data.string[0] = '\0';
-        curchar = nextchar;
-        for (curchar = nextchar;
-             curchar != '\n' && curchar != '\0';
-             curchar = script_scan_get_next_char (scan))
-          {
-            token->data.string = realloc (token->data.string,
-                                          (index + 2) * sizeof (char));
-            token->data.string[index] = curchar;
-            token->data.string[index + 1] = '\0';
-            index++;
-          }
-        token->type = SCRIPT_SCAN_TOKEN_TYPE_COMMENT;
+        /* all other */
+        token->type = SCRIPT_SCAN_TOKEN_TYPE_SYMBOL;
+        token->data.symbol = curchar;
         return;
-      }
-  }
-
-  if ((curchar == '/') && (nextchar == '*'))
-    {
-      int index = 0;
-      int depth = 1;
-      token->data.string = malloc (sizeof (char));
-      token->data.string[0] = '\0';
-      curchar = script_scan_get_next_char (scan);
-      nextchar = script_scan_get_next_char (scan);
-
-      while (true)
-        {
-          if (nextchar == '\0')
-            {
-              free (token->data.string);
-              token->data.string = strdup("End of file before end of comment");
-              token->type = SCRIPT_SCAN_TOKEN_TYPE_ERROR;
-              return;
-            }
-          if ((curchar == '/') && (nextchar == '*'))
-            depth++;
-          if ((curchar == '*') && (nextchar == '/'))
-            {
-              depth--;
-              if (!depth) break;
-            }
-          token->data.string = realloc (token->data.string,
-                                        (index + 2) * sizeof (char));
-          token->data.string[index] = curchar;
-          token->data.string[index + 1] = '\0';
-          index++;
-          curchar = nextchar;
-          nextchar = script_scan_get_next_char (scan);
-        }
-      script_scan_get_next_char (scan);
-      token->type = SCRIPT_SCAN_TOKEN_TYPE_COMMENT;
-      return;
-    }
-  /* all other */
-  token->type = SCRIPT_SCAN_TOKEN_TYPE_SYMBOL;
-  token->data.symbol = curchar;
-  return;
 }
 
 static script_scan_token_t *script_scan_peek_token (script_scan_t *scan,
-                                              int         n)
+                                                    int            n)
 {
-  int i;
-
-  /* we're screwed long before we ever actually hit INT_MAX; but at least
-   * we shouldn't get ourselves stuck in an infinite loop. */
-  if (scan->tokencount <= n && n < INT_MAX)
-    {
-      scan->tokens =
-        realloc (scan->tokens, (n + 1) * sizeof (script_scan_token_t *));
-      for (i = scan->tokencount; i <= n; i++)
-        {
-          scan->tokens[i] = malloc (sizeof (script_scan_token_t));
-          scan->tokens[i]->type = SCRIPT_SCAN_TOKEN_TYPE_EMPTY;
+        int i;
+
+        /* we're screwed long before we ever actually hit INT_MAX; but at least
+         * we shouldn't get ourselves stuck in an infinite loop. */
+        if (scan->tokencount <= n && n < INT_MAX) {
+                scan->tokens =
+                        realloc (scan->tokens, (n + 1) * sizeof(script_scan_token_t *));
+                for (i = scan->tokencount; i <= n; i++) {
+                        scan->tokens[i] = malloc (sizeof(script_scan_token_t));
+                        scan->tokens[i]->type = SCRIPT_SCAN_TOKEN_TYPE_EMPTY;
+                }
+                scan->tokencount = n + 1;
         }
-      scan->tokencount = n + 1;
-    }
-  if (scan->tokens[n]->type == SCRIPT_SCAN_TOKEN_TYPE_EMPTY)
-    {
-      if ((n > 0) && (scan->tokens[n - 1]->type == SCRIPT_SCAN_TOKEN_TYPE_EMPTY))
-        script_scan_peek_token (scan, n - 1);
-      do
-        {
-          script_scan_token_clean (scan->tokens[n]);
-          script_scan_read_next_token (scan, scan->tokens[n]);                     /* FIXME if skipping comments, add whitespace to next token */
+        if (scan->tokens[n]->type == SCRIPT_SCAN_TOKEN_TYPE_EMPTY) {
+                if ((n > 0) && (scan->tokens[n - 1]->type == SCRIPT_SCAN_TOKEN_TYPE_EMPTY))
+                        script_scan_peek_token (scan, n - 1);
+                do {
+                        script_scan_token_clean (scan->tokens[n]);
+                        script_scan_read_next_token (scan, scan->tokens[n]);       /* FIXME if skipping comments, add whitespace to next token */
+                } while (scan->tokens[n]->type == SCRIPT_SCAN_TOKEN_TYPE_COMMENT); /* FIXME optionally pass comments back */
         }
-      while (scan->tokens[n]->type == SCRIPT_SCAN_TOKEN_TYPE_COMMENT);             /* FIXME optionally pass comments back */
-    }
-  return scan->tokens[n];
+        return scan->tokens[n];
 }
 
 script_scan_token_t *script_scan_get_next_token (script_scan_t *scan)
 {
-  int i;
-  script_scan_token_clean (scan->tokens[0]);
-  for (i = 0; i < (scan->tokencount - 1); i++)
-    *scan->tokens[i] = *scan->tokens[i + 1];
-  scan->tokens[(scan->tokencount - 1)]->type = SCRIPT_SCAN_TOKEN_TYPE_EMPTY;
-  return script_scan_peek_token (scan, 0);
+        int i;
+
+        script_scan_token_clean (scan->tokens[0]);
+        for (i = 0; i < (scan->tokencount - 1); i++) {
+                *scan->tokens[i] = *scan->tokens[i + 1];
+        }
+        scan->tokens[(scan->tokencount - 1)]->type = SCRIPT_SCAN_TOKEN_TYPE_EMPTY;
+        return script_scan_peek_token (scan, 0);
 }
 
 script_scan_token_t *script_scan_get_current_token (script_scan_t *scan)
 {
-  return script_scan_peek_token (scan, 0);
+        return script_scan_peek_token (scan, 0);
 }
 
 script_scan_token_t *script_scan_peek_next_token (script_scan_t *scan)
 {
-  return script_scan_peek_token (scan, 1);
+        return script_scan_peek_token (scan, 1);
 }
-
diff --git a/src/plugins/splash/script/script-scan.h b/src/plugins/splash/script/script-scan.h
index 132451d..0da83a7 100644
--- a/src/plugins/splash/script/script-scan.h
+++ b/src/plugins/splash/script/script-scan.h
@@ -28,66 +28,66 @@
 
 typedef enum
 {
-  SCRIPT_SCAN_TOKEN_TYPE_EMPTY,
-  SCRIPT_SCAN_TOKEN_TYPE_EOF,
-  SCRIPT_SCAN_TOKEN_TYPE_INTEGER,
-  SCRIPT_SCAN_TOKEN_TYPE_FLOAT,
-  SCRIPT_SCAN_TOKEN_TYPE_IDENTIFIER,
-  SCRIPT_SCAN_TOKEN_TYPE_STRING,
-  SCRIPT_SCAN_TOKEN_TYPE_SYMBOL,
-  SCRIPT_SCAN_TOKEN_TYPE_COMMENT,
-  SCRIPT_SCAN_TOKEN_TYPE_ERROR,
+        SCRIPT_SCAN_TOKEN_TYPE_EMPTY,
+        SCRIPT_SCAN_TOKEN_TYPE_EOF,
+        SCRIPT_SCAN_TOKEN_TYPE_INTEGER,
+        SCRIPT_SCAN_TOKEN_TYPE_FLOAT,
+        SCRIPT_SCAN_TOKEN_TYPE_IDENTIFIER,
+        SCRIPT_SCAN_TOKEN_TYPE_STRING,
+        SCRIPT_SCAN_TOKEN_TYPE_SYMBOL,
+        SCRIPT_SCAN_TOKEN_TYPE_COMMENT,
+        SCRIPT_SCAN_TOKEN_TYPE_ERROR,
 } script_scan_token_type_t;
 
 typedef struct
 {
-  script_scan_token_type_t type;
-  union
-  {
-    char *string;
-    char symbol;
-    long long int integer;
-    double floatpoint;
-  } data;
-  int whitespace;
-  script_debug_location_t location;
+        script_scan_token_type_t type;
+        union
+        {
+                char         *string;
+                char          symbol;
+                long long int integer;
+                double        floatpoint;
+        } data;
+        int                     whitespace;
+        script_debug_location_t location;
 } script_scan_token_t;
 
 typedef struct
 {
-  union
-  {
-    int fd;
-    const char *string;
-  } source;
-  char* name;
-  unsigned char cur_char;
-  ply_bitarray_t *identifier_1st_char;
-  ply_bitarray_t *identifier_nth_char;
-  int tokencount;
-  script_scan_token_t **tokens;
-  int line_index;
-  int column_index;
-  bool source_is_file;
+        union
+        {
+                int         fd;
+                const char *string;
+        } source;
+        char                 *name;
+        unsigned char         cur_char;
+        ply_bitarray_t       *identifier_1st_char;
+        ply_bitarray_t       *identifier_nth_char;
+        int                   tokencount;
+        script_scan_token_t **tokens;
+        int                   line_index;
+        int                   column_index;
+        bool                  source_is_file;
 } script_scan_t;
 
 
 #define script_scan_token_is_symbol(__token) \
-      (__token->type == SCRIPT_SCAN_TOKEN_TYPE_SYMBOL)
-#define script_scan_token_is_symbol_of_value(__token,__value) \
-      (__token->type == SCRIPT_SCAN_TOKEN_TYPE_SYMBOL \
-      && __token->data.symbol == __value)
+        (__token->type == SCRIPT_SCAN_TOKEN_TYPE_SYMBOL)
+#define script_scan_token_is_symbol_of_value(__token, __value) \
+        (__token->type == SCRIPT_SCAN_TOKEN_TYPE_SYMBOL \
+         && __token->data.symbol == __value)
 #define script_scan_token_is_identifier(__token) \
-      (__token->type == SCRIPT_SCAN_TOKEN_TYPE_IDENTIFIER)
-#define script_scan_token_is_identifier_of_value(__token,__value) \
-      (__token->type == SCRIPT_SCAN_TOKEN_TYPE_IDENTIFIER \
-      && !strcmp(__token->data.string, __value))
+        (__token->type == SCRIPT_SCAN_TOKEN_TYPE_IDENTIFIER)
+#define script_scan_token_is_identifier_of_value(__token, __value) \
+        (__token->type == SCRIPT_SCAN_TOKEN_TYPE_IDENTIFIER \
+         && !strcmp (__token->data.string, __value))
 #define script_scan_token_is_integer(__token) \
-      (__token->type == SCRIPT_SCAN_TOKEN_TYPE_INTEGER)
+        (__token->type == SCRIPT_SCAN_TOKEN_TYPE_INTEGER)
 #define script_scan_token_is_string(__token) \
-      (__token->type == SCRIPT_SCAN_TOKEN_TYPE_STRING)
+        (__token->type == SCRIPT_SCAN_TOKEN_TYPE_STRING)
 #define script_scan_token_is_float(__token) \
-      (__token->type == SCRIPT_SCAN_TOKEN_TYPE_FLOAT)
+        (__token->type == SCRIPT_SCAN_TOKEN_TYPE_FLOAT)
 
 
 
diff --git a/src/plugins/splash/script/script.c b/src/plugins/splash/script/script.c
index 3290825..cd41d58 100644
--- a/src/plugins/splash/script/script.c
+++ b/src/plugins/splash/script/script.c
@@ -44,28 +44,28 @@ script_function_t *script_function_script_new (script_op_t *script,
                                                void        *user_data,
                                                ply_list_t  *parameter_list)
 {
-  script_function_t *function = malloc (sizeof (script_function_t));
-
-  function->type = SCRIPT_FUNCTION_TYPE_SCRIPT;
-  function->parameters = parameter_list;
-  function->data.script = script;
-  function->freeable = false;
-  function->user_data = user_data;
-  return function;
+        script_function_t *function = malloc (sizeof(script_function_t));
+
+        function->type = SCRIPT_FUNCTION_TYPE_SCRIPT;
+        function->parameters = parameter_list;
+        function->data.script = script;
+        function->freeable = false;
+        function->user_data = user_data;
+        return function;
 }
 
-script_function_t *script_function_native_new (script_native_function_t  native_function,
-                                               void                     *user_data,
-                                               ply_list_t               *parameter_list)
+script_function_t *script_function_native_new (script_native_function_t native_function,
+                                               void                    *user_data,
+                                               ply_list_t              *parameter_list)
 {
-  script_function_t *function = malloc (sizeof (script_function_t));
-
-  function->type = SCRIPT_FUNCTION_TYPE_NATIVE;
-  function->parameters = parameter_list;
-  function->data.native = native_function;
-  function->freeable = true;
-  function->user_data = user_data;
-  return function;
+        script_function_t *function = malloc (sizeof(script_function_t));
+
+        function->type = SCRIPT_FUNCTION_TYPE_NATIVE;
+        function->parameters = parameter_list;
+        function->data.native = native_function;
+        function->freeable = true;
+        function->user_data = user_data;
+        return function;
 }
 
 void script_add_native_function (script_obj_t            *hash,
@@ -75,76 +75,76 @@ void script_add_native_function (script_obj_t            *hash,
                                  const char              *first_arg,
                                  ...)
 {
-  va_list args;
-  const char *arg;
-  ply_list_t *parameter_list = ply_list_new ();
-
-  arg = first_arg;
-  va_start (args, first_arg);
-  while (arg)
-    {
-      ply_list_append_data (parameter_list, strdup (arg));
-      arg = va_arg (args, const char *);
-    }
-  va_end (args);
-
-  script_function_t *function = script_function_native_new (native_function,
-                                                            user_data,
-                                                            parameter_list);
-  script_obj_t *obj = script_obj_new_function (function);
-  script_obj_hash_add_element (hash, obj, name);
-  script_obj_unref (obj);
+        va_list args;
+        const char *arg;
+        ply_list_t *parameter_list = ply_list_new ();
+
+        arg = first_arg;
+        va_start (args, first_arg);
+        while (arg) {
+                ply_list_append_data (parameter_list, strdup (arg));
+                arg = va_arg (args, const char *);
+        }
+        va_end (args);
+
+        script_function_t *function = script_function_native_new (native_function,
+                                                                  user_data,
+                                                                  parameter_list);
+        script_obj_t *obj = script_obj_new_function (function);
+        script_obj_hash_add_element (hash, obj, name);
+        script_obj_unref (obj);
 }
 
 script_obj_native_class_t *script_obj_native_class_new (script_obj_function_t free_func,
                                                         const char           *name,
                                                         void                 *user_data)
 {
-  script_obj_native_class_t *class = malloc (sizeof (script_obj_native_class_t));
+        script_obj_native_class_t *class = malloc (sizeof(script_obj_native_class_t));
 
-  class->free_func = free_func;
-  class->name = strdup (name);
-  class->user_data = user_data;
-  return class;
+        class->free_func = free_func;
+        class->name = strdup (name);
+        class->user_data = user_data;
+        return class;
 }
 
 void script_obj_native_class_destroy (script_obj_native_class_t *class)
 {
-  free (class->name);
-  free (class);
-  return;
+        free (class->name);
+        free (class);
+        return;
 }
 
 script_state_t *script_state_new (void *user_data)
 {
-  script_state_t *state = malloc (sizeof (script_state_t));
-  script_obj_t *global_hash = script_obj_new_hash ();
-  state->global = script_obj_new_ref (global_hash);
-  script_obj_unref(global_hash);
-  state->local = script_obj_new_ref (global_hash);
-  state->this = script_obj_new_null();
-  state->user_data = user_data;
-  return state;
+        script_state_t *state = malloc (sizeof(script_state_t));
+        script_obj_t *global_hash = script_obj_new_hash ();
+
+        state->global = script_obj_new_ref (global_hash);
+        script_obj_unref (global_hash);
+        state->local = script_obj_new_ref (global_hash);
+        state->this = script_obj_new_null ();
+        state->user_data = user_data;
+        return state;
 }
 
 script_state_t *script_state_init_sub (script_state_t *oldstate, script_obj_t *this)
 {
-  script_state_t *newstate = malloc (sizeof (script_state_t));
-  script_obj_t *local_hash = script_obj_new_hash ();
-  newstate->local = script_obj_new_ref (local_hash);
-  script_obj_unref(local_hash);
-  newstate->global = script_obj_new_ref (oldstate->global);
-  if (this) newstate->this = script_obj_new_ref (this);
-  else newstate->this = script_obj_new_ref (oldstate->this);
-  newstate->user_data = oldstate->user_data;
-  return newstate;
+        script_state_t *newstate = malloc (sizeof(script_state_t));
+        script_obj_t *local_hash = script_obj_new_hash ();
+
+        newstate->local = script_obj_new_ref (local_hash);
+        script_obj_unref (local_hash);
+        newstate->global = script_obj_new_ref (oldstate->global);
+        if (this) newstate->this = script_obj_new_ref (this);
+        else newstate->this = script_obj_new_ref (oldstate->this);
+        newstate->user_data = oldstate->user_data;
+        return newstate;
 }
 
 void script_state_destroy (script_state_t *state)
 {
-  script_obj_unref (state->global);
-  script_obj_unref (state->local);
-  script_obj_unref (state->this);
-  free (state);
+        script_obj_unref (state->global);
+        script_obj_unref (state->local);
+        script_obj_unref (state->this);
+        free (state);
 }
-
diff --git a/src/plugins/splash/script/script.h b/src/plugins/splash/script/script.h
index 391deca..2932c5f 100644
--- a/src/plugins/splash/script/script.h
+++ b/src/plugins/splash/script/script.h
@@ -28,216 +28,217 @@
 
 typedef enum                        /* FIXME add _t to all types */
 {
-  SCRIPT_RETURN_TYPE_NORMAL,
-  SCRIPT_RETURN_TYPE_RETURN,
-  SCRIPT_RETURN_TYPE_FAIL,
-  SCRIPT_RETURN_TYPE_BREAK,
-  SCRIPT_RETURN_TYPE_CONTINUE,
+        SCRIPT_RETURN_TYPE_NORMAL,
+        SCRIPT_RETURN_TYPE_RETURN,
+        SCRIPT_RETURN_TYPE_FAIL,
+        SCRIPT_RETURN_TYPE_BREAK,
+        SCRIPT_RETURN_TYPE_CONTINUE,
 } script_return_type_t;
 
 struct script_obj_t;
 
 typedef struct
 {
-  script_return_type_t type;
-  struct script_obj_t *object;
+        script_return_type_t type;
+        struct script_obj_t *object;
 } script_return_t;
 
 typedef struct
 {
-  void *user_data;
-  struct script_obj_t *global;
-  struct script_obj_t *local;
-  struct script_obj_t *this;
+        void                *user_data;
+        struct script_obj_t *global;
+        struct script_obj_t *local;
+        struct script_obj_t *this;
 } script_state_t;
 
 typedef enum
 {
-  SCRIPT_FUNCTION_TYPE_SCRIPT,
-  SCRIPT_FUNCTION_TYPE_NATIVE,
+        SCRIPT_FUNCTION_TYPE_SCRIPT,
+        SCRIPT_FUNCTION_TYPE_NATIVE,
 } script_function_type_t;
 
-typedef script_return_t (*script_native_function_t)(script_state_t *, void *);
+typedef script_return_t (*script_native_function_t)(script_state_t *,
+                                                    void           *);
 
 typedef struct script_function_t
 {
-  script_function_type_t type;
-  ply_list_t *parameters;           /*  list of char* typedef names */
-  void *user_data;
-  union
-  {
-    script_native_function_t native;
-    struct script_op_t *script;
-  } data;
-  bool freeable;
+        script_function_type_t type;
+        ply_list_t            *parameters; /*  list of char* typedef names */
+        void                  *user_data;
+        union
+        {
+                script_native_function_t native;
+                struct script_op_t      *script;
+        } data;
+        bool                   freeable;
 } script_function_t;
 
 typedef void (*script_obj_function_t)(struct script_obj_t *);
 
 typedef struct
 {
-  script_obj_function_t free_func;
-  char *name;
-  void *user_data;
+        script_obj_function_t free_func;
+        char                 *name;
+        void                 *user_data;
 } script_obj_native_class_t;
 
 typedef double script_number_t;
 
 typedef struct
 {
-  void *object_data;
-  script_obj_native_class_t *class;
+        void                      *object_data;
+        script_obj_native_class_t *class;
 } script_obj_native_t;
 
 typedef enum
 {
-  SCRIPT_OBJ_TYPE_NULL,
-  SCRIPT_OBJ_TYPE_REF,
-  SCRIPT_OBJ_TYPE_EXTEND,
-  SCRIPT_OBJ_TYPE_NUMBER,
-  SCRIPT_OBJ_TYPE_STRING,
-  SCRIPT_OBJ_TYPE_HASH,
-  SCRIPT_OBJ_TYPE_FUNCTION,
-  SCRIPT_OBJ_TYPE_NATIVE,
+        SCRIPT_OBJ_TYPE_NULL,
+        SCRIPT_OBJ_TYPE_REF,
+        SCRIPT_OBJ_TYPE_EXTEND,
+        SCRIPT_OBJ_TYPE_NUMBER,
+        SCRIPT_OBJ_TYPE_STRING,
+        SCRIPT_OBJ_TYPE_HASH,
+        SCRIPT_OBJ_TYPE_FUNCTION,
+        SCRIPT_OBJ_TYPE_NATIVE,
 } script_obj_type_t;
 
 typedef struct script_obj_t
 {
-  script_obj_type_t type;
-  int refcount;
-  union
-  {
-    script_number_t number;
-    char *string;
-    struct script_obj_t *obj;
-    struct
-      {
-        struct script_obj_t *obj_a;
-        struct script_obj_t *obj_b;
-      } dual_obj;
-    script_function_t *function;
-    ply_hashtable_t *hash;
-    script_obj_native_t native;
-  } data;
+        script_obj_type_t type;
+        int               refcount;
+        union
+        {
+                script_number_t      number;
+                char                *string;
+                struct script_obj_t *obj;
+                struct
+                {
+                        struct script_obj_t *obj_a;
+                        struct script_obj_t *obj_b;
+                } dual_obj;
+                script_function_t   *function;
+                ply_hashtable_t     *hash;
+                script_obj_native_t  native;
+        } data;
 } script_obj_t;
 
 typedef enum
 {
-  SCRIPT_EXP_TYPE_TERM_NULL,
-  SCRIPT_EXP_TYPE_TERM_NUMBER,
-  SCRIPT_EXP_TYPE_TERM_STRING,
-  SCRIPT_EXP_TYPE_TERM_VAR,
-  SCRIPT_EXP_TYPE_TERM_LOCAL,
-  SCRIPT_EXP_TYPE_TERM_GLOBAL,
-  SCRIPT_EXP_TYPE_TERM_THIS,
-  SCRIPT_EXP_TYPE_TERM_SET,
-  SCRIPT_EXP_TYPE_PLUS,
-  SCRIPT_EXP_TYPE_MINUS,
-  SCRIPT_EXP_TYPE_MUL,
-  SCRIPT_EXP_TYPE_DIV,
-  SCRIPT_EXP_TYPE_MOD,
-  SCRIPT_EXP_TYPE_GT,
-  SCRIPT_EXP_TYPE_GE,
-  SCRIPT_EXP_TYPE_LT,
-  SCRIPT_EXP_TYPE_LE,
-  SCRIPT_EXP_TYPE_EQ,
-  SCRIPT_EXP_TYPE_NE,
-  SCRIPT_EXP_TYPE_AND,
-  SCRIPT_EXP_TYPE_OR,
-  SCRIPT_EXP_TYPE_EXTEND,
-  SCRIPT_EXP_TYPE_NOT,
-  SCRIPT_EXP_TYPE_POS,
-  SCRIPT_EXP_TYPE_NEG,
-  SCRIPT_EXP_TYPE_PRE_INC,
-  SCRIPT_EXP_TYPE_PRE_DEC,
-  SCRIPT_EXP_TYPE_POST_INC,
-  SCRIPT_EXP_TYPE_POST_DEC,
-  SCRIPT_EXP_TYPE_HASH,
-  SCRIPT_EXP_TYPE_FUNCTION_EXE,
-  SCRIPT_EXP_TYPE_FUNCTION_DEF,
-  SCRIPT_EXP_TYPE_ASSIGN,
-  SCRIPT_EXP_TYPE_ASSIGN_PLUS,
-  SCRIPT_EXP_TYPE_ASSIGN_MINUS,
-  SCRIPT_EXP_TYPE_ASSIGN_MUL,
-  SCRIPT_EXP_TYPE_ASSIGN_DIV,
-  SCRIPT_EXP_TYPE_ASSIGN_MOD,
-  SCRIPT_EXP_TYPE_ASSIGN_EXTEND,
+        SCRIPT_EXP_TYPE_TERM_NULL,
+        SCRIPT_EXP_TYPE_TERM_NUMBER,
+        SCRIPT_EXP_TYPE_TERM_STRING,
+        SCRIPT_EXP_TYPE_TERM_VAR,
+        SCRIPT_EXP_TYPE_TERM_LOCAL,
+        SCRIPT_EXP_TYPE_TERM_GLOBAL,
+        SCRIPT_EXP_TYPE_TERM_THIS,
+        SCRIPT_EXP_TYPE_TERM_SET,
+        SCRIPT_EXP_TYPE_PLUS,
+        SCRIPT_EXP_TYPE_MINUS,
+        SCRIPT_EXP_TYPE_MUL,
+        SCRIPT_EXP_TYPE_DIV,
+        SCRIPT_EXP_TYPE_MOD,
+        SCRIPT_EXP_TYPE_GT,
+        SCRIPT_EXP_TYPE_GE,
+        SCRIPT_EXP_TYPE_LT,
+        SCRIPT_EXP_TYPE_LE,
+        SCRIPT_EXP_TYPE_EQ,
+        SCRIPT_EXP_TYPE_NE,
+        SCRIPT_EXP_TYPE_AND,
+        SCRIPT_EXP_TYPE_OR,
+        SCRIPT_EXP_TYPE_EXTEND,
+        SCRIPT_EXP_TYPE_NOT,
+        SCRIPT_EXP_TYPE_POS,
+        SCRIPT_EXP_TYPE_NEG,
+        SCRIPT_EXP_TYPE_PRE_INC,
+        SCRIPT_EXP_TYPE_PRE_DEC,
+        SCRIPT_EXP_TYPE_POST_INC,
+        SCRIPT_EXP_TYPE_POST_DEC,
+        SCRIPT_EXP_TYPE_HASH,
+        SCRIPT_EXP_TYPE_FUNCTION_EXE,
+        SCRIPT_EXP_TYPE_FUNCTION_DEF,
+        SCRIPT_EXP_TYPE_ASSIGN,
+        SCRIPT_EXP_TYPE_ASSIGN_PLUS,
+        SCRIPT_EXP_TYPE_ASSIGN_MINUS,
+        SCRIPT_EXP_TYPE_ASSIGN_MUL,
+        SCRIPT_EXP_TYPE_ASSIGN_DIV,
+        SCRIPT_EXP_TYPE_ASSIGN_MOD,
+        SCRIPT_EXP_TYPE_ASSIGN_EXTEND,
 } script_exp_type_t;
 
 typedef struct script_exp_t
 {
-  script_exp_type_t type;
-  union
-  {
-    struct
-    {
-      struct script_exp_t *sub_a;
-      struct script_exp_t *sub_b;
-    } dual;
-    struct script_exp_t *sub;
-    char *string;
-    script_number_t number;
-    struct
-    {
-      struct script_exp_t *name;
-      ply_list_t *parameters;
-    } function_exe;
-    ply_list_t *parameters;
-    script_function_t *function_def;
-  } data;
+        script_exp_type_t type;
+        union
+        {
+                struct
+                {
+                        struct script_exp_t *sub_a;
+                        struct script_exp_t *sub_b;
+                } dual;
+                struct script_exp_t *sub;
+                char                *string;
+                script_number_t      number;
+                struct
+                {
+                        struct script_exp_t *name;
+                        ply_list_t          *parameters;
+                } function_exe;
+                ply_list_t          *parameters;
+                script_function_t   *function_def;
+        } data;
 } script_exp_t;
 
 typedef enum
 {
-  SCRIPT_OP_TYPE_EXPRESSION,
-  SCRIPT_OP_TYPE_OP_BLOCK,
-  SCRIPT_OP_TYPE_IF,
-  SCRIPT_OP_TYPE_WHILE,
-  SCRIPT_OP_TYPE_DO_WHILE,
-  SCRIPT_OP_TYPE_FOR,
-  SCRIPT_OP_TYPE_RETURN,
-  SCRIPT_OP_TYPE_FAIL,
-  SCRIPT_OP_TYPE_BREAK,
-  SCRIPT_OP_TYPE_CONTINUE,
+        SCRIPT_OP_TYPE_EXPRESSION,
+        SCRIPT_OP_TYPE_OP_BLOCK,
+        SCRIPT_OP_TYPE_IF,
+        SCRIPT_OP_TYPE_WHILE,
+        SCRIPT_OP_TYPE_DO_WHILE,
+        SCRIPT_OP_TYPE_FOR,
+        SCRIPT_OP_TYPE_RETURN,
+        SCRIPT_OP_TYPE_FAIL,
+        SCRIPT_OP_TYPE_BREAK,
+        SCRIPT_OP_TYPE_CONTINUE,
 } script_op_type_t;
 
 typedef struct script_op_t
 {
-  script_op_type_t type;
-  union
-  {
-    script_exp_t *exp;
-    ply_list_t *list;
-    struct
-    {
-      script_exp_t *cond;
-      struct script_op_t *op1;
-      struct script_op_t *op2;
-    } cond_op;
-  } data;
+        script_op_type_t type;
+        union
+        {
+                script_exp_t *exp;
+                ply_list_t   *list;
+                struct
+                {
+                        script_exp_t       *cond;
+                        struct script_op_t *op1;
+                        struct script_op_t *op2;
+                } cond_op;
+        } data;
 } script_op_t;
 
 typedef struct
 {
-  char *name;
-  script_obj_t *object;
+        char         *name;
+        script_obj_t *object;
 } script_variable_t;
 
 
-#define script_return_obj(_return_object) ((script_return_t) {SCRIPT_RETURN_TYPE_RETURN, _return_object})
-#define script_return_obj_null() ((script_return_t) {SCRIPT_RETURN_TYPE_RETURN, script_obj_new_null ()})
-#define script_return_fail() ((script_return_t) {SCRIPT_RETURN_TYPE_FAIL, NULL})
-#define script_return_normal() ((script_return_t) {SCRIPT_RETURN_TYPE_NORMAL, NULL})
-#define script_return_normal_obj(_return_object) ((script_return_t) {SCRIPT_RETURN_TYPE_NORMAL, _return_object})
-#define script_return_break() ((script_return_t) {SCRIPT_RETURN_TYPE_BREAK, NULL})
-#define script_return_continue() ((script_return_t) {SCRIPT_RETURN_TYPE_CONTINUE, NULL})
+#define script_return_obj(_return_object) ((script_return_t) { SCRIPT_RETURN_TYPE_RETURN, _return_object })
+#define script_return_obj_null() ((script_return_t) { SCRIPT_RETURN_TYPE_RETURN, script_obj_new_null () })
+#define script_return_fail() ((script_return_t) { SCRIPT_RETURN_TYPE_FAIL, NULL })
+#define script_return_normal() ((script_return_t) { SCRIPT_RETURN_TYPE_NORMAL, NULL })
+#define script_return_normal_obj(_return_object) ((script_return_t) { SCRIPT_RETURN_TYPE_NORMAL, _return_object })
+#define script_return_break() ((script_return_t) { SCRIPT_RETURN_TYPE_BREAK, NULL })
+#define script_return_continue() ((script_return_t) { SCRIPT_RETURN_TYPE_CONTINUE, NULL })
 
-script_function_t *script_function_script_new (script_op_t  *script,
-                                               void         *user_data,
-                                               ply_list_t   *parameter_list);
-script_function_t *script_function_native_new (script_native_function_t  native_function,
-                                               void                     *user_data,
-                                               ply_list_t               *parameter_list);
+script_function_t *script_function_script_new (script_op_t *script,
+                                               void        *user_data,
+                                               ply_list_t  *parameter_list);
+script_function_t *script_function_native_new (script_native_function_t native_function,
+                                               void                    *user_data,
+                                               ply_list_t              *parameter_list);
 void script_add_native_function (script_obj_t            *hash,
                                  const char              *name,
                                  script_native_function_t native_function,
@@ -248,9 +249,9 @@ script_obj_native_class_t *script_obj_native_class_new (script_obj_function_t fr
                                                         const char           *name,
                                                         void                 *user_data);
 
-void script_obj_native_class_destroy (script_obj_native_class_t * class);
+void script_obj_native_class_destroy (script_obj_native_class_t *class);
 script_state_t *script_state_new (void *user_data);
-script_state_t *script_state_init_sub (script_state_t *oldstate, script_obj_t *this);
+script_state_t *script_state_init_sub (script_state_t * oldstate, script_obj_t * this);
 void script_state_destroy (script_state_t *state);
 
 #endif /* SCRIPT_H */
diff --git a/src/plugins/splash/space-flares/plugin.c b/src/plugins/splash/space-flares/plugin.c
index e31dce8..5212c38 100644
--- a/src/plugins/splash/space-flares/plugin.c
+++ b/src/plugins/splash/space-flares/plugin.c
@@ -72,135 +72,136 @@
 #define SHOW_PROGRESS_BAR
 /*#define SHOW_LOGO_HALO */
 
-typedef enum {
-  PLY_BOOT_SPLASH_DISPLAY_NORMAL,
-  PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
-  PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
+typedef enum
+{
+        PLY_BOOT_SPLASH_DISPLAY_NORMAL,
+        PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
+        PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
 } ply_boot_splash_display_type_t;
 
 typedef enum
 {
-  SPRITE_TYPE_STATIC,
-  SPRITE_TYPE_FLARE,
-  SPRITE_TYPE_SATELLITE,
-  SPRITE_TYPE_PROGRESS,
-  SPRITE_TYPE_STAR_BG,
+        SPRITE_TYPE_STATIC,
+        SPRITE_TYPE_FLARE,
+        SPRITE_TYPE_SATELLITE,
+        SPRITE_TYPE_PROGRESS,
+        SPRITE_TYPE_STAR_BG,
 } sprite_type_t;
 
 typedef struct
 {
-  int x; 
-  int y;
-  int z;
-  int oldx; 
-  int oldy;
-  int oldz;
-  int refresh_me;
-  float opacity;
-  ply_image_t *image;
-  sprite_type_t type;
-  void* data;
+        int           x;
+        int           y;
+        int           z;
+        int           oldx;
+        int           oldy;
+        int           oldz;
+        int           refresh_me;
+        float         opacity;
+        ply_image_t  *image;
+        sprite_type_t type;
+        void         *data;
 } sprite_t;
 
 
 typedef struct
 {
-  float stretch[FLARE_COUNT];
-  float rotate_yz[FLARE_COUNT];
-  float rotate_xy[FLARE_COUNT];
-  float rotate_xz[FLARE_COUNT];
-  float increase_speed[FLARE_COUNT];
-  float z_offset_strength[FLARE_COUNT];
-  float y_size[FLARE_COUNT];
-  ply_image_t *image_a;
-  ply_image_t *image_b;
-  int frame_count;
+        float        stretch[FLARE_COUNT];
+        float        rotate_yz[FLARE_COUNT];
+        float        rotate_xy[FLARE_COUNT];
+        float        rotate_xz[FLARE_COUNT];
+        float        increase_speed[FLARE_COUNT];
+        float        z_offset_strength[FLARE_COUNT];
+        float        y_size[FLARE_COUNT];
+        ply_image_t *image_a;
+        ply_image_t *image_b;
+        int          frame_count;
 } flare_t;
 
 typedef enum
 {
-  SATELLITE_TYPE_PLANET,
-  SATELLITE_TYPE_COMET,
+        SATELLITE_TYPE_PLANET,
+        SATELLITE_TYPE_COMET,
 } satellite_type_t;
 
 typedef struct
 {
-  satellite_type_t type;
-  int start_x;
-  int start_y;
-  int end_x;
-  int end_y;
-  int distance;
-  double theta;
-  ply_image_t *image;
-  ply_image_t *image_altered;
+        satellite_type_t type;
+        int              start_x;
+        int              start_y;
+        int              end_x;
+        int              end_y;
+        int              distance;
+        double           theta;
+        ply_image_t     *image;
+        ply_image_t     *image_altered;
 } satellite_t;
 
 
 
 typedef struct
 {
-  int start_width;
-  int end_width;
-  int current_width;
-  ply_image_t *image;
-  ply_image_t *image_altered;
+        int          start_width;
+        int          end_width;
+        int          current_width;
+        ply_image_t *image;
+        ply_image_t *image_altered;
 } progress_t;
 
 
 typedef struct
 {
-  int star_count;
-  int *star_x;
-  int *star_y;
-  int *star_refresh;
-  int frame_count;
+        int  star_count;
+        int *star_x;
+        int *star_y;
+        int *star_refresh;
+        int  frame_count;
 } star_bg_t;
 
 typedef struct
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_pixel_display_t *display;
-  ply_entry_t *entry;
-  ply_label_t *label;
-  ply_label_t *message_label;
-  ply_list_t *sprites;
-  ply_rectangle_t box_area, lock_area, logo_area;
-  ply_image_t *scaled_background_image;
+        ply_boot_splash_plugin_t *plugin;
+        ply_pixel_display_t      *display;
+        ply_entry_t              *entry;
+        ply_label_t              *label;
+        ply_label_t              *message_label;
+        ply_list_t               *sprites;
+        ply_rectangle_t           box_area, lock_area, logo_area;
+        ply_image_t              *scaled_background_image;
 } view_t;
 
 struct _ply_boot_splash_plugin
 {
-  ply_event_loop_t *loop;
-  ply_boot_splash_mode_t mode;
-  ply_image_t *logo_image;
-  ply_image_t *lock_image;
-  ply_image_t *box_image;
-  ply_image_t *star_image;
-  
+        ply_event_loop_t              *loop;
+        ply_boot_splash_mode_t         mode;
+        ply_image_t                   *logo_image;
+        ply_image_t                   *lock_image;
+        ply_image_t                   *box_image;
+        ply_image_t                   *star_image;
+
 #ifdef  SHOW_PLANETS
-  ply_image_t *planet_image[5];
+        ply_image_t                   *planet_image[5];
 #endif
 #ifdef  SHOW_PROGRESS_BAR
-  ply_image_t *progress_barimage;
+        ply_image_t                   *progress_barimage;
 #endif
 
 #ifdef SHOW_LOGO_HALO
-  ply_image_t *highlight_logo_image;
+        ply_image_t                   *highlight_logo_image;
 #endif
 
-  char *image_dir;
-  ply_boot_splash_display_type_t state;
-  ply_list_t *views;
+        char                          *image_dir;
+        ply_boot_splash_display_type_t state;
+        ply_list_t                    *views;
 
-  double now;
-  
-  double progress;
-  double progress_target;
+        double                         now;
 
-  uint32_t root_is_mounted : 1;
-  uint32_t is_visible : 1;
-  uint32_t is_animating : 1;
+        double                         progress;
+        double                         progress_target;
+
+        uint32_t                       root_is_mounted : 1;
+        uint32_t                       is_visible : 1;
+        uint32_t                       is_animating : 1;
 };
 
 ply_boot_splash_plugin_interface_t *ply_boot_splash_plugin_get_interface (void);
@@ -210,19 +211,19 @@ static view_t *
 view_new (ply_boot_splash_plugin_t *plugin,
           ply_pixel_display_t      *display)
 {
-  view_t *view;
+        view_t *view;
 
-  view = calloc (1, sizeof (view_t));
-  view->plugin = plugin;
-  view->display = display;
+        view = calloc (1, sizeof(view_t));
+        view->plugin = plugin;
+        view->display = display;
 
-  view->entry = ply_entry_new (plugin->image_dir);
-  view->label = ply_label_new ();
-  view->message_label = ply_label_new ();
+        view->entry = ply_entry_new (plugin->image_dir);
+        view->label = ply_label_new ();
+        view->message_label = ply_label_new ();
 
-  view->sprites = ply_list_new ();
+        view->sprites = ply_list_new ();
 
-  return view;
+        return view;
 }
 
 static void view_free_sprites (view_t *view);
@@ -230,172 +231,166 @@ static void view_free_sprites (view_t *view);
 static void
 view_free (view_t *view)
 {
+        ply_entry_free (view->entry);
+        ply_label_free (view->label);
+        ply_label_free (view->message_label);
+        view_free_sprites (view);
+        ply_list_free (view->sprites);
 
-  ply_entry_free (view->entry);
-  ply_label_free (view->label);
-  ply_label_free (view->message_label);
-  view_free_sprites (view);
-  ply_list_free (view->sprites);
-
-  ply_image_free (view->scaled_background_image);
+        ply_image_free (view->scaled_background_image);
 
-  free (view);
+        free (view);
 }
 
 static void
 free_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_free (view);
+                view_free (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  ply_list_free (plugin->views);
-  plugin->views = NULL;
+        ply_list_free (plugin->views);
+        plugin->views = NULL;
 }
 
 static bool
 view_load (view_t *view)
 {
-  ply_trace ("loading entry");
-  if (!ply_entry_load (view->entry))
-    return false;
+        ply_trace ("loading entry");
+        if (!ply_entry_load (view->entry))
+                return false;
 
-  return true;
+        return true;
 }
 
 static bool
 load_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
-  bool view_loaded;
+        ply_list_node_t *node;
+        bool view_loaded;
 
-  view_loaded = false;
-  node = ply_list_get_first_node (plugin->views);
+        view_loaded = false;
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view_load (view))
-        view_loaded = true;
+                if (view_load (view))
+                        view_loaded = true;
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  return view_loaded;
+        return view_loaded;
 }
 
 static void
 view_redraw (view_t *view)
 {
-  unsigned long screen_width, screen_height;
+        unsigned long screen_width, screen_height;
 
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
 
-  ply_pixel_display_draw_area (view->display, 0, 0,
-                               screen_width, screen_height);
+        ply_pixel_display_draw_area (view->display, 0, 0,
+                                     screen_width, screen_height);
 }
 
 static void
 redraw_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_redraw (view);
+                view_redraw (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 pause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_pixel_display_pause_updates (view->display);
+                ply_pixel_display_pause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 unpause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_pixel_display_unpause_updates (view->display);
+                ply_pixel_display_unpause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
-static sprite_t*
+static sprite_t *
 add_sprite (view_t      *view,
             ply_image_t *image,
             int          type,
             void        *data)
 {
- sprite_t *new_sprite = calloc (1, sizeof (sprite_t));
-
- new_sprite->x = 0;
- new_sprite->y = 0;
- new_sprite->z = 0;
- new_sprite->oldx = 0;
- new_sprite->oldy = 0;
- new_sprite->oldz = 0;
- new_sprite->opacity = 1;
- new_sprite->refresh_me = 0;
- new_sprite->image = image;
- new_sprite->type = type;
- new_sprite->data = data;
-
- ply_list_append_data (view->sprites, new_sprite);
-
- return new_sprite;
+        sprite_t *new_sprite = calloc (1, sizeof(sprite_t));
+
+        new_sprite->x = 0;
+        new_sprite->y = 0;
+        new_sprite->z = 0;
+        new_sprite->oldx = 0;
+        new_sprite->oldy = 0;
+        new_sprite->oldz = 0;
+        new_sprite->opacity = 1;
+        new_sprite->refresh_me = 0;
+        new_sprite->image = image;
+        new_sprite->type = type;
+        new_sprite->data = data;
+
+        ply_list_append_data (view->sprites, new_sprite);
+
+        return new_sprite;
 }
 
 static void view_setup_scene (view_t *view);
@@ -403,784 +398,752 @@ static void view_setup_scene (view_t *view);
 static void
 view_start_animation (view_t *view)
 {
-  unsigned long screen_width, screen_height;
+        unsigned long screen_width, screen_height;
 
-  assert (view != NULL);
+        assert (view != NULL);
 
-  view_setup_scene (view);
+        view_setup_scene (view);
 
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
 
-  ply_pixel_display_draw_area (view->display, 0, 0,
-                               screen_width, screen_height);
+        ply_pixel_display_draw_area (view->display, 0, 0,
+                                     screen_width, screen_height);
 }
 
 static void
 view_show_prompt (view_t     *view,
                   const char *prompt)
 {
-  ply_boot_splash_plugin_t *plugin;
-  int x, y;
-  int entry_width, entry_height;
+        ply_boot_splash_plugin_t *plugin;
+        int x, y;
+        int entry_width, entry_height;
 
-  assert (view != NULL);
+        assert (view != NULL);
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  if (ply_entry_is_hidden (view->entry))
-    {
-      unsigned long screen_width, screen_height;
+        if (ply_entry_is_hidden (view->entry)) {
+                unsigned long screen_width, screen_height;
 
-      screen_width = ply_pixel_display_get_width (view->display);
-      screen_height = ply_pixel_display_get_height (view->display);
+                screen_width = ply_pixel_display_get_width (view->display);
+                screen_height = ply_pixel_display_get_height (view->display);
 
-      view->box_area.width = ply_image_get_width (plugin->box_image);
-      view->box_area.height = ply_image_get_height (plugin->box_image);
-      view->box_area.x = screen_width / 2.0 - view->box_area.width / 2.0;
-      view->box_area.y = screen_height / 2.0 - view->box_area.height / 2.0;
+                view->box_area.width = ply_image_get_width (plugin->box_image);
+                view->box_area.height = ply_image_get_height (plugin->box_image);
+                view->box_area.x = screen_width / 2.0 - view->box_area.width / 2.0;
+                view->box_area.y = screen_height / 2.0 - view->box_area.height / 2.0;
 
-      view->lock_area.width = ply_image_get_width (plugin->lock_image);
-      view->lock_area.height = ply_image_get_height (plugin->lock_image);
+                view->lock_area.width = ply_image_get_width (plugin->lock_image);
+                view->lock_area.height = ply_image_get_height (plugin->lock_image);
 
-      entry_width = ply_entry_get_width (view->entry);
-      entry_height = ply_entry_get_height (view->entry);
+                entry_width = ply_entry_get_width (view->entry);
+                entry_height = ply_entry_get_height (view->entry);
 
-      x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0 + view->lock_area.width;
-      y = screen_height / 2.0 - entry_height / 2.0;
+                x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0 + view->lock_area.width;
+                y = screen_height / 2.0 - entry_height / 2.0;
 
-      view->lock_area.x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0;
-      view->lock_area.y = screen_height / 2.0 - view->lock_area.height / 2.0;
+                view->lock_area.x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0;
+                view->lock_area.y = screen_height / 2.0 - view->lock_area.height / 2.0;
 
-      ply_entry_show (view->entry, plugin->loop, view->display, x, y);
-    }
+                ply_entry_show (view->entry, plugin->loop, view->display, x, y);
+        }
 
-  if (prompt != NULL)
-    {
-      ply_label_set_text (view->label, prompt);
+        if (prompt != NULL) {
+                ply_label_set_text (view->label, prompt);
 
-      x = view->box_area.x + view->lock_area.width / 2;
-      y = view->box_area.y + view->box_area.height;
+                x = view->box_area.x + view->lock_area.width / 2;
+                y = view->box_area.y + view->box_area.height;
 
-      ply_label_show (view->label, view->display, x, y);
-    }
+                ply_label_show (view->label, view->display, x, y);
+        }
 }
 
 static void
 view_hide_prompt (view_t *view)
 {
-  assert (view != NULL);
+        assert (view != NULL);
 
-  ply_entry_hide (view->entry);
-  ply_label_hide (view->label);
+        ply_entry_hide (view->entry);
+        ply_label_hide (view->label);
 }
 
 static void
 hide_prompt (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_hide_prompt (view);
+                view_hide_prompt (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static ply_boot_splash_plugin_t *
 create_plugin (ply_key_file_t *key_file)
 {
-  ply_boot_splash_plugin_t *plugin;
-  char *image_dir, *image_path;
+        ply_boot_splash_plugin_t *plugin;
+        char *image_dir, *image_path;
 
-  srand ((int) ply_get_timestamp ());
-  plugin = calloc (1, sizeof (ply_boot_splash_plugin_t));
+        srand ((int) ply_get_timestamp ());
+        plugin = calloc (1, sizeof(ply_boot_splash_plugin_t));
 
-  plugin->logo_image = ply_image_new (PLYMOUTH_LOGO_FILE);
+        plugin->logo_image = ply_image_new (PLYMOUTH_LOGO_FILE);
 
-  image_dir = ply_key_file_get_value (key_file, "space-flares", "ImageDir");
+        image_dir = ply_key_file_get_value (key_file, "space-flares", "ImageDir");
 
-  asprintf (&image_path, "%s/lock.png", image_dir);
-  plugin->lock_image = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/lock.png", image_dir);
+        plugin->lock_image = ply_image_new (image_path);
+        free (image_path);
 
-  asprintf (&image_path, "%s/box.png", image_dir);
-  plugin->box_image = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/box.png", image_dir);
+        plugin->box_image = ply_image_new (image_path);
+        free (image_path);
 
-  asprintf (&image_path, "%s/star.png", image_dir);
-  plugin->star_image = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/star.png", image_dir);
+        plugin->star_image = ply_image_new (image_path);
+        free (image_path);
 
 #ifdef  SHOW_PLANETS
 
-  asprintf (&image_path, "%s/plant1.png", image_dir);
-  plugin->planet_image[0] = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/plant1.png", image_dir);
+        plugin->planet_image[0] = ply_image_new (image_path);
+        free (image_path);
 
-  asprintf (&image_path, "%s/plant2.png", image_dir);
-  plugin->planet_image[1] = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/plant2.png", image_dir);
+        plugin->planet_image[1] = ply_image_new (image_path);
+        free (image_path);
 
-  asprintf (&image_path, "%s/plant3.png", image_dir);
-  plugin->planet_image[2] = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/plant3.png", image_dir);
+        plugin->planet_image[2] = ply_image_new (image_path);
+        free (image_path);
 
-  asprintf (&image_path, "%s/plant4.png", image_dir);
-  plugin->planet_image[3] = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/plant4.png", image_dir);
+        plugin->planet_image[3] = ply_image_new (image_path);
+        free (image_path);
 
-  asprintf (&image_path, "%s/plant5.png", image_dir);
-  plugin->planet_image[4] = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/plant5.png", image_dir);
+        plugin->planet_image[4] = ply_image_new (image_path);
+        free (image_path);
 
 #endif
 #ifdef  SHOW_PROGRESS_BAR
 
-  asprintf (&image_path, "%s/progress_bar.png", image_dir);
-  plugin->progress_barimage = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/progress_bar.png", image_dir);
+        plugin->progress_barimage = ply_image_new (image_path);
+        free (image_path);
 #endif
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
-  plugin->progress = 0;
-  plugin->progress_target = -1;
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
+        plugin->progress = 0;
+        plugin->progress_target = -1;
 
-  plugin->image_dir = image_dir;
+        plugin->image_dir = image_dir;
 
-  plugin->views = ply_list_new ();
+        plugin->views = ply_list_new ();
 
-  return plugin;
+        return plugin;
 }
 
 static void
 destroy_plugin (ply_boot_splash_plugin_t *plugin)
 {
-  if (plugin == NULL)
-    return;
+        if (plugin == NULL)
+                return;
 
-  free (plugin->image_dir);
+        free (plugin->image_dir);
 
-  if (plugin->loop != NULL)
-    {
-      ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
+        if (plugin->loop != NULL) {
+                ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
 
-  ply_image_free (plugin->logo_image);
-  ply_image_free (plugin->lock_image);
-  ply_image_free (plugin->box_image);
+        ply_image_free (plugin->logo_image);
+        ply_image_free (plugin->lock_image);
+        ply_image_free (plugin->box_image);
 
-  ply_image_free (plugin->star_image);
+        ply_image_free (plugin->star_image);
 #ifdef  SHOW_PLANETS
-  ply_image_free (plugin->planet_image[0]);
-  ply_image_free (plugin->planet_image[1]);
-  ply_image_free (plugin->planet_image[2]);
-  ply_image_free (plugin->planet_image[3]);
-  ply_image_free (plugin->planet_image[4]);
+        ply_image_free (plugin->planet_image[0]);
+        ply_image_free (plugin->planet_image[1]);
+        ply_image_free (plugin->planet_image[2]);
+        ply_image_free (plugin->planet_image[3]);
+        ply_image_free (plugin->planet_image[4]);
 #endif
 #ifdef  SHOW_PROGRESS_BAR
-  ply_image_free (plugin->progress_barimage);
+        ply_image_free (plugin->progress_barimage);
 #endif
 
-  free_views (plugin);
+        free_views (plugin);
 
-  free (plugin);
+        free (plugin);
 }
 
 static void
-free_sprite (sprite_t* sprite)
+free_sprite (sprite_t *sprite)
 {
-  if (sprite)
-    {
-      switch (sprite->type){
-          case SPRITE_TYPE_STATIC:
-              break;
-          case SPRITE_TYPE_SATELLITE:
-            {
-              satellite_t *satellite = sprite->data;
-              ply_image_free (satellite->image_altered);
-              break;
-            }
-              break;
-          case SPRITE_TYPE_PROGRESS:
-            {
-              progress_t *progress = sprite->data;
-              ply_image_free (progress->image_altered);
-              break;
-            }
-              break;
-          case SPRITE_TYPE_FLARE:
-            {
-              flare_t *flare = sprite->data;
-              ply_image_free (flare->image_a);
-              ply_image_free (flare->image_b);
-              break;
-            }
-          case SPRITE_TYPE_STAR_BG:
-            {
-              star_bg_t *star_bg = sprite->data;
-              free (star_bg->star_x);
-              free (star_bg->star_y);
-              free (star_bg->star_refresh);
-              break;
-            }
+        if (sprite) {
+                switch (sprite->type) {
+                case SPRITE_TYPE_STATIC:
+                        break;
+                case SPRITE_TYPE_SATELLITE:
+                {
+                        satellite_t *satellite = sprite->data;
+                        ply_image_free (satellite->image_altered);
+                        break;
+                }
+                break;
+                case SPRITE_TYPE_PROGRESS:
+                {
+                        progress_t *progress = sprite->data;
+                        ply_image_free (progress->image_altered);
+                        break;
+                }
+                break;
+                case SPRITE_TYPE_FLARE:
+                {
+                        flare_t *flare = sprite->data;
+                        ply_image_free (flare->image_a);
+                        ply_image_free (flare->image_b);
+                        break;
+                }
+                case SPRITE_TYPE_STAR_BG:
+                {
+                        star_bg_t *star_bg = sprite->data;
+                        free (star_bg->star_x);
+                        free (star_bg->star_y);
+                        free (star_bg->star_refresh);
+                        break;
+                }
+                }
+
+                if (sprite->data) free (sprite->data);
+                free (sprite);
         }
-
-      if (sprite->data) free(sprite->data);
-      free(sprite);
-    }
- return;
+        return;
 }
 
 static int
 sprite_compare_z (void *data_a, void *data_b)
 {
- sprite_t *sprite_a = data_a;
- sprite_t *sprite_b = data_b;
- return sprite_a->z - sprite_b->z;
+        sprite_t *sprite_a = data_a;
+        sprite_t *sprite_b = data_b;
+
+        return sprite_a->z - sprite_b->z;
 }
 
-static void 
-stretch_image(ply_image_t *scaled_image, ply_image_t *orig_image, int width)
+static void
+stretch_image (ply_image_t *scaled_image, ply_image_t *orig_image, int width)
 {
-  int x, y;
-  int stretched_width = ply_image_get_width (scaled_image);
-  int stretched_height = ply_image_get_height (scaled_image);
-  int orig_width = ply_image_get_width (orig_image);
-  uint32_t * scaled_image_data = ply_image_get_data (scaled_image);
-  uint32_t * orig_image_data = ply_image_get_data (orig_image);
-  
-  
-  for (y=0; y<stretched_height; y++)
-    {
-      float my_width = y+0.5;
-      my_width /= (stretched_height);
-      my_width *= 2;
-      my_width -= 1;
-      my_width *= my_width;
-      my_width = sqrt(1-my_width)-1;
-      my_width *= stretched_height;
-      my_width /= 2;
-      my_width = width+my_width;
-      for (x=0; x<stretched_width;  x++)
-        {
-          if(x<my_width)
-            {
-              uint32_t value = 0x0;
-              int new_x = (x * orig_width) / width;
-              value = orig_image_data[new_x + y * orig_width];
-              scaled_image_data[x + y * stretched_width] = value;
-            }
-          else
-            {
-              scaled_image_data[x + y * stretched_width] = 0;
-            }
+        int x, y;
+        int stretched_width = ply_image_get_width (scaled_image);
+        int stretched_height = ply_image_get_height (scaled_image);
+        int orig_width = ply_image_get_width (orig_image);
+        uint32_t *scaled_image_data = ply_image_get_data (scaled_image);
+        uint32_t *orig_image_data = ply_image_get_data (orig_image);
+
+
+        for (y = 0; y < stretched_height; y++) {
+                float my_width = y + 0.5;
+                my_width /= (stretched_height);
+                my_width *= 2;
+                my_width -= 1;
+                my_width *= my_width;
+                my_width = sqrt (1 - my_width) - 1;
+                my_width *= stretched_height;
+                my_width /= 2;
+                my_width = width + my_width;
+                for (x = 0; x < stretched_width; x++) {
+                        if (x < my_width) {
+                                uint32_t value = 0x0;
+                                int new_x = (x * orig_width) / width;
+                                value = orig_image_data[new_x + y * orig_width];
+                                scaled_image_data[x + y * stretched_width] = value;
+                        } else {
+                                scaled_image_data[x + y * stretched_width] = 0;
+                        }
+                }
         }
-    }
 }
 
 static void
-progress_update (view_t *view, sprite_t* sprite, double time)
+progress_update (view_t *view, sprite_t *sprite, double time)
 {
-  progress_t *progress = sprite->data;
-  ply_boot_splash_plugin_t *plugin = view->plugin;
-  int newwidth = plugin->progress * (progress->end_width - progress->start_width) + progress->start_width;
-
-  if (progress->current_width >newwidth) return;
-  progress->current_width = newwidth;
-  stretch_image(progress->image_altered, progress->image, newwidth);
-  sprite->opacity = plugin->progress;
-  sprite->refresh_me=1;
+        progress_t *progress = sprite->data;
+        ply_boot_splash_plugin_t *plugin = view->plugin;
+        int newwidth = plugin->progress * (progress->end_width - progress->start_width) + progress->start_width;
+
+        if (progress->current_width > newwidth) return;
+        progress->current_width = newwidth;
+        stretch_image (progress->image_altered, progress->image, newwidth);
+        sprite->opacity = plugin->progress;
+        sprite->refresh_me = 1;
 }
 
 
-static inline uint32_t 
+static inline uint32_t
 star_bg_gradient_colour (int x, int y, int width, int height, bool star, float time)
 {
-  int full_dist =  sqrt(width*width+height*height);
-  int my_dist = sqrt(x*x+y*y);
-  float val;
-  
-  uint16_t r0 = 0x0000;  /* start colour:033c73 */
-  uint16_t g0 = 0x3c00;
-  uint16_t b0 = 0x7300;
-  
-  uint16_t r1 = 0x0000;  /* end colour:00193a */
-  uint16_t g1 = 0x1900;
-  uint16_t b1 = 0x3a00;
-  
-  uint16_t r = r0+((r1-r0)*my_dist)/full_dist;
-  uint16_t g = g0+((g1-g0)*my_dist)/full_dist;
-  uint16_t b = b0+((b1-b0)*my_dist)/full_dist;
-
-  static uint16_t r_err = 0; 
-  static uint16_t g_err = 0; 
-  static uint16_t b_err = 0; 
-  
-  r += r_err;
-  g += g_err;
-  b += b_err;
-  r_err = ((r>>8) | ((r>>8)<<8)) - r;
-  g_err = ((g>>8) | ((g>>8)<<8)) - g;
-  b_err = ((b>>8) | ((b>>8)<<8)) - b;
-  r >>= 8;
-  g >>= 8;
-  b >>= 8;
-  
-  if (!star) {
-    
-    return 0xff000000 | r<<16 | g<<8 | b;
-    }
-  
-  x -= width+720-800;
-  y -= height+300-480;
-  val = sqrt(x*x+y*y)/100;
-  val = (sin(val-time*(2*M_PI)*STAR_HZ+atan2(y, x)*2)+1)/2;
-  
-  val= val*0.3;
-  
-  r = r*(1-val) + val*0xff;
-  g = g*(1-val) + val*0xff;
-  b = b*(1-val) + val*0xff;
-  
-  return 0xff000000 | r<<16 | g<<8 | b;
+        int full_dist = sqrt (width * width + height * height);
+        int my_dist = sqrt (x * x + y * y);
+        float val;
+
+        uint16_t r0 = 0x0000;  /* start colour:033c73 */
+        uint16_t g0 = 0x3c00;
+        uint16_t b0 = 0x7300;
+
+        uint16_t r1 = 0x0000;  /* end colour:00193a */
+        uint16_t g1 = 0x1900;
+        uint16_t b1 = 0x3a00;
+
+        uint16_t r = r0 + ((r1 - r0) * my_dist) / full_dist;
+        uint16_t g = g0 + ((g1 - g0) * my_dist) / full_dist;
+        uint16_t b = b0 + ((b1 - b0) * my_dist) / full_dist;
+
+        static uint16_t r_err = 0;
+        static uint16_t g_err = 0;
+        static uint16_t b_err = 0;
+
+        r += r_err;
+        g += g_err;
+        b += b_err;
+        r_err = ((r >> 8) | ((r >> 8) << 8)) - r;
+        g_err = ((g >> 8) | ((g >> 8) << 8)) - g;
+        b_err = ((b >> 8) | ((b >> 8) << 8)) - b;
+        r >>= 8;
+        g >>= 8;
+        b >>= 8;
+
+        if (!star)
+
+                return 0xff000000 | r << 16 | g << 8 | b;
+
+        x -= width + 720 - 800;
+        y -= height + 300 - 480;
+        val = sqrt (x * x + y * y) / 100;
+        val = (sin (val - time * (2 * M_PI) * STAR_HZ + atan2 (y, x) * 2) + 1) / 2;
+
+        val = val * 0.3;
+
+        r = r * (1 - val) + val * 0xff;
+        g = g * (1 - val) + val * 0xff;
+        b = b * (1 - val) + val * 0xff;
+
+        return 0xff000000 | r << 16 | g << 8 | b;
 }
 
 
 
 static void
-star_bg_update (view_t *view, sprite_t* sprite, double time)
+star_bg_update (view_t *view, sprite_t *sprite, double time)
 {
-  star_bg_t *star_bg = sprite->data;
-  int width = ply_image_get_width (sprite->image);
-  int height = ply_image_get_height (sprite->image);
-  uint32_t* image_data = ply_image_get_data (sprite->image);
-  int i, x, y;
-  star_bg->frame_count++;
-  star_bg->frame_count%=FRAMES_PER_SECOND/BG_STARS_FRAMES_PER_SECOND;
-
-  for (i = star_bg->frame_count; i < star_bg->star_count; i+=FRAMES_PER_SECOND/BG_STARS_FRAMES_PER_SECOND){
-    x = star_bg->star_x[i];
-    y = star_bg->star_y[i];
-    uint32_t pixel_colour = star_bg_gradient_colour (x, y, width, height, true, time);
-    if (abs(((image_data[x + y * width]>>16)&0xff) - ((pixel_colour>>16)&0xff))>8){
-        image_data[x + y * width] = pixel_colour;
-        star_bg->star_refresh[i]=1;
+        star_bg_t *star_bg = sprite->data;
+        int width = ply_image_get_width (sprite->image);
+        int height = ply_image_get_height (sprite->image);
+        uint32_t *image_data = ply_image_get_data (sprite->image);
+        int i, x, y;
+
+        star_bg->frame_count++;
+        star_bg->frame_count %= FRAMES_PER_SECOND / BG_STARS_FRAMES_PER_SECOND;
+
+        for (i = star_bg->frame_count; i < star_bg->star_count; i += FRAMES_PER_SECOND / BG_STARS_FRAMES_PER_SECOND) {
+                x = star_bg->star_x[i];
+                y = star_bg->star_y[i];
+                uint32_t pixel_colour = star_bg_gradient_colour (x, y, width, height, true, time);
+                if (abs (((image_data[x + y * width] >> 16) & 0xff) - ((pixel_colour >> 16) & 0xff)) > 8) {
+                        image_data[x + y * width] = pixel_colour;
+                        star_bg->star_refresh[i] = 1;
+                }
         }
-    }
-  
-  
-  sprite->refresh_me=1;
+
+
+        sprite->refresh_me = 1;
 }
 
 static void
-satellite_move (view_t *view, sprite_t* sprite, double time)
+satellite_move (view_t *view, sprite_t *sprite, double time)
 {
-  ply_boot_splash_plugin_t *plugin = view->plugin;
-  satellite_t *satellite = sprite->data;
-
-  int width = ply_image_get_width (sprite->image);
-  int height = ply_image_get_height (sprite->image);
-  unsigned long screen_width, screen_height;
-
-  sprite->x=cos(satellite->theta+(1-plugin->progress)*2000/(satellite->distance))*satellite->distance;
-  sprite->y=sin(satellite->theta+(1-plugin->progress)*2000/(satellite->distance))*satellite->distance;
-  sprite->z=0;
-
-  float distance = sqrt(sprite->z*sprite->z+sprite->y*sprite->y);
-  float angle_zy = atan2 (sprite->y, sprite->z)-M_PI*0.4;
-  sprite->z = distance* cos(angle_zy);
-  sprite->y = distance* sin(angle_zy);
-
-  float angle_offset = atan2 (sprite->x, sprite->y);
-  float cresent_angle = atan2 (sqrt(sprite->x*sprite->x+sprite->y*sprite->y), sprite->z);
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
-
-  sprite->x+=(float)satellite->end_x*plugin->progress+(float)satellite->start_x*(1-plugin->progress)-width/2;
-  sprite->y+=(float)satellite->end_y*plugin->progress+(float)satellite->start_y*(1-plugin->progress)-height/2;
-  
-  if (sprite->x > (signed int) screen_width) return;
-  if (sprite->y > (signed int) screen_height) return;
-  
-  if (satellite->type == SATELLITE_TYPE_PLANET)
-    {
-      int x, y;
-
-      uint32_t *image_data = ply_image_get_data (satellite->image);
-      uint32_t *cresent_data = ply_image_get_data (satellite->image_altered);
-
-      for (y=0; y<height; y++) for (x=0; x<width; x++)
-        {
-      
-          float fx = x-(float)width/2;
-          float fy = y-(float)height/2;
-          float angle = atan2 (fy, fx)+angle_offset;
-          float distance = sqrt(fy*fy+fx*fx);
-          fx = cos(angle)*(distance/(width/2));
-          fy = sin(angle)*(distance/(height/2));
-          float want_y = sqrt(1-fx*fx);
-          want_y *= -cos(cresent_angle);
-          if (fy<want_y)
-            {
-              cresent_data[x+y*width] = image_data[x+y*width];
-            }
-          else
-            {
-              int strength =(fy-want_y)*16+2;
-              uint32_t val =0;
-              int alpha = ((image_data[x+y*width]>>24) & 0xFF);
-              if (strength<=0)strength=1;
-              if (strength>=8)strength=8;
-              val |= (((image_data[x+y*width]>>24) & 0xFF)/1)<<24;
-              val |= (((image_data[x+y*width]>>16) & 0xFF)/strength)<<16;
-              val |= (((image_data[x+y*width]>>8 ) & 0xFF)/strength)<<8;
-              val |= (((image_data[x+y*width]>>0 ) & 0xFF)/strength+(alpha-alpha/(strength))/8)<<0;
-              cresent_data[x+y*width] =val;
-            }
-        }
-    }
-  
-  if (satellite->type == SATELLITE_TYPE_COMET)
-    {
-      int x, y;
-
-      uint32_t *image_data = ply_image_get_data (satellite->image);
-      uint32_t *comet_data = ply_image_get_data (satellite->image_altered);
-      x = width/2;
-      image_data[x] = 0xFFFFFFFF;
-      x = 2*sin(plugin->progress*62)+width/2;
-      image_data[x] = 0xFFFFFFFF;
-      x = 2*sin(plugin->progress*163)+width/2;
-      image_data[x] = 0xFFFFFFFF;
-      x = 2*sin(plugin->progress*275)+width/2;
-      image_data[x] = 0xFFFFFFFF;
-      for (y=height-1; y>0; y--)
-        {
-          for (x=1; x<width-1; x++)
-            {
-               uint32_t pixel;
-               pixel = 2 * (image_data[x + (y - 1) * width] >> 24)
-                       + (image_data[(x - 1) + (y - 1) * width] >> 24)
-                       + (image_data[(x + 1) + (y - 1) * width] >> 24);
-               pixel /= 4.05;
-               pixel |= pixel<<8;
-               pixel |= pixel<<16;
-               image_data[x+y*width] = pixel;
-            }
+        ply_boot_splash_plugin_t *plugin = view->plugin;
+        satellite_t *satellite = sprite->data;
+
+        int width = ply_image_get_width (sprite->image);
+        int height = ply_image_get_height (sprite->image);
+        unsigned long screen_width, screen_height;
+
+        sprite->x = cos (satellite->theta + (1 - plugin->progress) * 2000 / (satellite->distance)) * satellite->distance;
+        sprite->y = sin (satellite->theta + (1 - plugin->progress) * 2000 / (satellite->distance)) * satellite->distance;
+        sprite->z = 0;
+
+        float distance = sqrt (sprite->z * sprite->z + sprite->y * sprite->y);
+        float angle_zy = atan2 (sprite->y, sprite->z) - M_PI * 0.4;
+        sprite->z = distance * cos (angle_zy);
+        sprite->y = distance * sin (angle_zy);
+
+        float angle_offset = atan2 (sprite->x, sprite->y);
+        float cresent_angle = atan2 (sqrt (sprite->x * sprite->x + sprite->y * sprite->y), sprite->z);
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
+
+        sprite->x += (float) satellite->end_x * plugin->progress + (float) satellite->start_x * (1 - plugin->progress) - width / 2;
+        sprite->y += (float) satellite->end_y * plugin->progress + (float) satellite->start_y * (1 - plugin->progress) - height / 2;
+
+        if (sprite->x > (signed int) screen_width) return;
+        if (sprite->y > (signed int) screen_height) return;
+
+        if (satellite->type == SATELLITE_TYPE_PLANET) {
+                int x, y;
+
+                uint32_t *image_data = ply_image_get_data (satellite->image);
+                uint32_t *cresent_data = ply_image_get_data (satellite->image_altered);
+
+                for (y = 0; y < height; y++) {
+                        for (x = 0; x < width; x++) {
+                                float fx = x - (float) width / 2;
+                                float fy = y - (float) height / 2;
+                                float angle = atan2 (fy, fx) + angle_offset;
+                                float distance = sqrt (fy * fy + fx * fx);
+                                fx = cos (angle) * (distance / (width / 2));
+                                fy = sin (angle) * (distance / (height / 2));
+                                float want_y = sqrt (1 - fx * fx);
+                                want_y *= -cos (cresent_angle);
+                                if (fy < want_y) {
+                                        cresent_data[x + y * width] = image_data[x + y * width];
+                                } else {
+                                        int strength = (fy - want_y) * 16 + 2;
+                                        uint32_t val = 0;
+                                        int alpha = ((image_data[x + y * width] >> 24) & 0xFF);
+                                        if (strength <= 0) strength = 1;
+                                        if (strength >= 8) strength = 8;
+                                        val |= (((image_data[x + y * width] >> 24) & 0xFF) / 1) << 24;
+                                        val |= (((image_data[x + y * width] >> 16) & 0xFF) / strength) << 16;
+                                        val |= (((image_data[x + y * width] >> 8) & 0xFF) / strength) << 8;
+                                        val |= (((image_data[x + y * width] >> 0) & 0xFF) / strength + (alpha - alpha / (strength)) / 8) << 0;
+                                        cresent_data[x + y * width] = val;
+                                }
+                        }
+                }
         }
-      for (x=1; x<width-1; x++) image_data[x] = 0x0;
-      for (y=0; y<height; y++) for (x=0; x<width; x++)
-        {
-          float scale= cos(M_PI*0.4);
-          float fx=x;
-          float fy=y;
-          fx -= (float) width/2;
-          fy -= (float) height/2;
-          fy /= scale;
-          float angle = atan2 (fy, fx)-(satellite->theta+(1-plugin->progress)*2000/(satellite->distance))+M_PI/2*0.0;
-          float distance = sqrt(fy*fy+fx*fx);
-          fx = cos(angle)*distance;
-          fy = sin(angle)*distance;
-          fx += (fy*fy*2)/(satellite->distance);
-          fx += (float) width/2;
-          fy += (float) height/2;
-          int ix=fx;
-          int iy=fy;
-          if (ix<0 || iy<0 || ix>=width || iy>=height){
-          comet_data[x+y*width] = 0;
-            }
-          else
-            {
-              comet_data[x+y*width] = image_data[ix+iy*width];
-            }
+
+        if (satellite->type == SATELLITE_TYPE_COMET) {
+                int x, y;
+
+                uint32_t *image_data = ply_image_get_data (satellite->image);
+                uint32_t *comet_data = ply_image_get_data (satellite->image_altered);
+                x = width / 2;
+                image_data[x] = 0xFFFFFFFF;
+                x = 2 * sin (plugin->progress * 62) + width / 2;
+                image_data[x] = 0xFFFFFFFF;
+                x = 2 * sin (plugin->progress * 163) + width / 2;
+                image_data[x] = 0xFFFFFFFF;
+                x = 2 * sin (plugin->progress * 275) + width / 2;
+                image_data[x] = 0xFFFFFFFF;
+                for (y = height - 1; y > 0; y--) {
+                        for (x = 1; x < width - 1; x++) {
+                                uint32_t pixel;
+                                pixel = 2 * (image_data[x + (y - 1) * width] >> 24)
+                                        + (image_data[(x - 1) + (y - 1) * width] >> 24)
+                                        + (image_data[(x + 1) + (y - 1) * width] >> 24);
+                                pixel /= 4.05;
+                                pixel |= pixel << 8;
+                                pixel |= pixel << 16;
+                                image_data[x + y * width] = pixel;
+                        }
+                }
+                for (x = 1; x < width - 1; x++) {
+                        image_data[x] = 0x0;
+                }
+                for (y = 0; y < height; y++) {
+                        for (x = 0; x < width; x++) {
+                                float scale = cos (M_PI * 0.4);
+                                float fx = x;
+                                float fy = y;
+                                fx -= (float) width / 2;
+                                fy -= (float) height / 2;
+                                fy /= scale;
+                                float angle = atan2 (fy, fx) - (satellite->theta + (1 - plugin->progress) * 2000 / (satellite->distance)) + M_PI / 2 * 0.0;
+                                float distance = sqrt (fy * fy + fx * fx);
+                                fx = cos (angle) * distance;
+                                fy = sin (angle) * distance;
+                                fx += (fy * fy * 2) / (satellite->distance);
+                                fx += (float) width / 2;
+                                fy += (float) height / 2;
+                                int ix = fx;
+                                int iy = fy;
+                                if (ix < 0 || iy < 0 || ix >= width || iy >= height)
+                                        comet_data[x + y * width] = 0;
+                                else
+                                        comet_data[x + y * width] = image_data[ix + iy * width];
+                        }
+                }
         }
-    }
-  return;
+        return;
 }
 
 
 static void
 sprite_list_sort (view_t *view)
 {
-  ply_list_sort_stable (view->sprites, &sprite_compare_z);
+        ply_list_sort_stable (view->sprites, &sprite_compare_z);
 }
 
 static void
 flare_reset (flare_t *flare, int index)
 {
-  flare->rotate_yz[index]=((float)(rand()%1000)/1000)*2*M_PI;
-  flare->rotate_xy[index]=((float)(rand()%1000)/1000)*2*M_PI;
-  flare->rotate_xz[index]=((float)(rand()%1000)/1000)*2*M_PI;
-  flare->y_size[index]=((float)(rand()%1000)/1000)*0.8+0.2;
-  flare->increase_speed[index] = ((float)(rand()%1000)/1000)*0.08+0.08;
-  flare->stretch[index]=(((float)(rand()%1000)/1000)*0.1+0.3)*flare->y_size[index];
-  flare->z_offset_strength[index]=0.1;
+        flare->rotate_yz[index] = ((float) (rand () % 1000) / 1000) * 2 * M_PI;
+        flare->rotate_xy[index] = ((float) (rand () % 1000) / 1000) * 2 * M_PI;
+        flare->rotate_xz[index] = ((float) (rand () % 1000) / 1000) * 2 * M_PI;
+        flare->y_size[index] = ((float) (rand () % 1000) / 1000) * 0.8 + 0.2;
+        flare->increase_speed[index] = ((float) (rand () % 1000) / 1000) * 0.08 + 0.08;
+        flare->stretch[index] = (((float) (rand () % 1000) / 1000) * 0.1 + 0.3) * flare->y_size[index];
+        flare->z_offset_strength[index] = 0.1;
 }
 
 static void
-flare_update (sprite_t* sprite, double time)
+flare_update (sprite_t *sprite, double time)
 {
-  int width;
-  int height;
-  flare_t *flare = sprite->data;
-  ply_image_t *old_image;
-  ply_image_t *new_image;
-  uint32_t * old_image_data;
-  uint32_t * new_image_data;
-
-  flare->frame_count++;
-  if (flare->frame_count%(FRAMES_PER_SECOND/FLARE_FRAMES_PER_SECOND)){
-    return;
-    }
-
-  old_image = flare->image_a;
-  new_image = flare->image_b;
-
-  old_image_data = ply_image_get_data (old_image);
-  new_image_data = ply_image_get_data (new_image);
-
-  width = ply_image_get_width (new_image);
-  height = ply_image_get_height (new_image);
-
-
-  int b;
-  for (b=0; b<FLARE_COUNT; b++)
-    {
-      int flare_line;
-      flare->stretch[b] += (flare->stretch[b] * flare->increase_speed[b]) * (1-(1/(3.01-flare->stretch[b])));
-      flare->increase_speed[b]-=0.003;
-      flare->z_offset_strength[b]+=0.01;
-
-      if (flare->stretch[b]>2 || flare->stretch[b]<0.2)
-        {
-          flare_reset (flare, b);
+        int width;
+        int height;
+        flare_t *flare = sprite->data;
+        ply_image_t *old_image;
+        ply_image_t *new_image;
+        uint32_t *old_image_data;
+        uint32_t *new_image_data;
+
+        flare->frame_count++;
+        if (flare->frame_count % (FRAMES_PER_SECOND / FLARE_FRAMES_PER_SECOND))
+                return;
+
+        old_image = flare->image_a;
+        new_image = flare->image_b;
+
+        old_image_data = ply_image_get_data (old_image);
+        new_image_data = ply_image_get_data (new_image);
+
+        width = ply_image_get_width (new_image);
+        height = ply_image_get_height (new_image);
+
+
+        int b;
+        for (b = 0; b < FLARE_COUNT; b++) {
+                int flare_line;
+                flare->stretch[b] += (flare->stretch[b] * flare->increase_speed[b]) * (1 - (1 / (3.01 - flare->stretch[b])));
+                flare->increase_speed[b] -= 0.003;
+                flare->z_offset_strength[b] += 0.01;
+
+                if (flare->stretch[b] > 2 || flare->stretch[b] < 0.2)
+                        flare_reset (flare, b);
+                for (flare_line = 0; flare_line < FLARE_LINE_COUNT; flare_line++) {
+                        double x, y, z;
+                        double angle, distance;
+                        float theta;
+                        for (theta = -M_PI + (0.05 * cos (flare->increase_speed[b] * 1000 + flare_line)); theta < M_PI; theta += 0.05) {
+                                int ix;
+                                int iy;
+
+                                x = (cos (theta) + 0.5) * flare->stretch[b] * 0.8;
+                                y = (sin (theta)) * flare->y_size[b];
+                                z = x * (sin (b + flare_line * flare_line)) * flare->z_offset_strength[b];
+
+                                float strength = 1.1 - (x / 2) + flare->increase_speed[b] * 3;
+                                x += 4.5;
+                                if ((x * x + y * y + z * z) < 25) continue;
+
+                                strength = CLAMP (strength, 0, 1);
+                                strength *= 32;
+
+                                x += 0.05 * sin (4 * theta * (sin (b + flare_line * 5)));
+                                y += 0.05 * cos (4 * theta * (sin (b + flare_line * 5)));
+                                z += 0.05 * sin (4 * theta * (sin (b + flare_line * 5)));
+
+                                distance = sqrt (x * x + y * y);
+                                angle = atan2 (y, x) + flare->rotate_xy[b] + 0.02 * sin (b * flare_line);
+                                x = distance * cos (angle);
+                                y = distance * sin (angle);
+
+                                distance = sqrt (z * z + y * y);
+                                angle = atan2 (y, z) + flare->rotate_yz[b] + 0.02 * sin (3 * b * flare_line);
+                                z = distance * cos (angle);
+                                y = distance * sin (angle);
+
+                                distance = sqrt (x * x + z * z);
+                                angle = atan2 (z, x) + flare->rotate_xz[b] + 0.02 * sin (8 * b * flare_line);
+                                x = distance * cos (angle);
+                                z = distance * sin (angle);
+
+
+                                x *= 41;
+                                y *= 41;
+
+                                x += 720 - 800 + width;
+                                y += 300 - 480 + height;
+
+                                ix = x;
+                                iy = y;
+                                if (ix >= (width - 1) || iy >= (height - 1) || ix <= 0 || iy <= 0) continue;
+
+                                uint32_t colour = MIN (strength + (old_image_data[ix + iy * width] >> 24), 255);
+                                colour <<= 24;
+                                old_image_data[ix + iy * width] = colour;
+                        }
+                }
         }
-      for (flare_line=0; flare_line<FLARE_LINE_COUNT; flare_line++)
-        {
-          double x, y, z;
-          double angle, distance;
-          float theta;
-          for (theta = -M_PI+(0.05*cos(flare->increase_speed[b]*1000+flare_line)); theta < M_PI; theta+=0.05)
-            {
-              int ix;
-              int iy;
-
-              x=(cos(theta)+0.5)*flare->stretch[b]*0.8;
-              y=(sin(theta))*flare->y_size[b];
-              z=x*(sin(b+flare_line*flare_line))*flare->z_offset_strength[b];
-              
-              float strength = 1.1-(x/2)+flare->increase_speed[b]*3;
-              x+=4.5;
-              if ((x*x+y*y+z*z)<25) continue;
-
-              strength = CLAMP(strength, 0, 1);
-              strength*=32;
-
-              x+=0.05*sin(4*theta*(sin(b+flare_line*5)));
-              y+=0.05*cos(4*theta*(sin(b+flare_line*5)));
-              z+=0.05*sin(4*theta*(sin(b+flare_line*5)));
-
-              distance = sqrt(x*x+y*y);
-              angle = atan2 (y, x) + flare->rotate_xy[b]+0.02*sin(b*flare_line) ;
-              x = distance* cos(angle);
-              y = distance* sin(angle);
-
-              distance = sqrt(z*z+y*y);
-              angle = atan2 (y, z) + flare->rotate_yz[b]+0.02*sin(3*b*flare_line);
-              z = distance* cos(angle);
-              y = distance* sin(angle);
-
-              distance = sqrt(x*x+z*z);
-              angle = atan2 (z, x) + flare->rotate_xz[b]+0.02*sin(8*b*flare_line);
-              x = distance* cos(angle);
-              z = distance* sin(angle);
-
-
-              x*=41;
-              y*=41;
-
-              x+=720-800+width;
-              y+=300-480+height;
-
-              ix=x;
-              iy=y;
-              if (ix>=(width-1) || iy>=(height-1) || ix<=0 || iy<=0) continue;
-
-              uint32_t colour = MIN (strength + (old_image_data[ix + iy * width]>>24), 255);
-              colour <<= 24;
-              old_image_data[ix + iy * width] = colour;
-
-            }
-        }
-    }
 
-  {
-  int  x, y;
-  for (y = 1; y < (height-1); y++)
-    {
-      for (x = 1; x < (width-1); x++)
         {
-          uint32_t value = 0;
-          value += (old_image_data[(x-1) + (y-1) * width]>>24)*1;
-          value += (old_image_data[ x +    (y-1) * width]>>24)*2;
-          value += (old_image_data[(x+1) + (y-1) * width]>>24)*1;
-          value += (old_image_data[(x-1) +  y    * width]>>24)*2;
-          value += (old_image_data[ x +     y    * width]>>24)*8;
-          value += (old_image_data[(x+1) +  y    * width]>>24)*2;
-          value += (old_image_data[(x-1) + (y+1) * width]>>24)*1;
-          value += (old_image_data[ x +    (y+1) * width]>>24)*2;
-          value += (old_image_data[(x+1) + (y+1) * width]>>24)*1;
-          value /=21;
-          value = (value<<24) | ((int)(value*0.7)<<16) | (value<<8) | (value<<0);
-          new_image_data[x +y * width] = value;
+                int x, y;
+                for (y = 1; y < (height - 1); y++) {
+                        for (x = 1; x < (width - 1); x++) {
+                                uint32_t value = 0;
+                                value += (old_image_data[(x - 1) + (y - 1) * width] >> 24) * 1;
+                                value += (old_image_data[x + (y - 1) * width] >> 24) * 2;
+                                value += (old_image_data[(x + 1) + (y - 1) * width] >> 24) * 1;
+                                value += (old_image_data[(x - 1) + y * width] >> 24) * 2;
+                                value += (old_image_data[x + y * width] >> 24) * 8;
+                                value += (old_image_data[(x + 1) + y * width] >> 24) * 2;
+                                value += (old_image_data[(x - 1) + (y + 1) * width] >> 24) * 1;
+                                value += (old_image_data[x + (y + 1) * width] >> 24) * 2;
+                                value += (old_image_data[(x + 1) + (y + 1) * width] >> 24) * 1;
+                                value /= 21;
+                                value = (value << 24) | ((int) (value * 0.7) << 16) | (value << 8) | (value << 0);
+                                new_image_data[x + y * width] = value;
+                        }
+                }
         }
-    }
-  }
-  flare->image_a = new_image;
-  flare->image_b = old_image;
-  sprite->image = new_image;
-  sprite->refresh_me = 1;
-  return;
+        flare->image_a = new_image;
+        flare->image_b = old_image;
+        sprite->image = new_image;
+        sprite->refresh_me = 1;
+        return;
 }
 
 static void
-sprite_move (view_t *view, sprite_t* sprite, double time)
+sprite_move (view_t *view, sprite_t *sprite, double time)
 {
-  sprite->oldx = sprite->x;
-  sprite->oldy = sprite->y;
-  sprite->oldz = sprite->z;
-  switch (sprite->type){
-      case SPRITE_TYPE_STATIC:
-          break;
-      case SPRITE_TYPE_PROGRESS:
-          progress_update (view, sprite, time);
-          break;
-      case SPRITE_TYPE_FLARE:
-          flare_update (sprite, time);
-          break;
-      case SPRITE_TYPE_SATELLITE:
-          satellite_move (view, sprite, time);
-          break;
-      case SPRITE_TYPE_STAR_BG:
-          star_bg_update (view, sprite, time);
-          break;
-    }
+        sprite->oldx = sprite->x;
+        sprite->oldy = sprite->y;
+        sprite->oldz = sprite->z;
+        switch (sprite->type) {
+        case SPRITE_TYPE_STATIC:
+                break;
+        case SPRITE_TYPE_PROGRESS:
+                progress_update (view, sprite, time);
+                break;
+        case SPRITE_TYPE_FLARE:
+                flare_update (sprite, time);
+                break;
+        case SPRITE_TYPE_SATELLITE:
+                satellite_move (view, sprite, time);
+                break;
+        case SPRITE_TYPE_STAR_BG:
+                star_bg_update (view, sprite, time);
+                break;
+        }
 }
 
 static void
 view_animate_attime (view_t *view, double time)
 {
-  ply_list_node_t *node;
-  ply_boot_splash_plugin_t *plugin;
-
-  plugin = view->plugin;
-
-  if (plugin->progress_target>=0)
-      plugin->progress = (plugin->progress*10 + plugin->progress_target) /11;
-    
-  node = ply_list_get_first_node (view->sprites);
-  while(node)
-    {
-      sprite_t* sprite = ply_list_node_get_data (node);
-      sprite_move (view, sprite, time);
-      node = ply_list_get_next_node (view->sprites, node);
-    }
-
-  sprite_list_sort (view);
-
-  for(node = ply_list_get_first_node (view->sprites); node; node = ply_list_get_next_node (view->sprites, node))
-    {
-      sprite_t* sprite = ply_list_node_get_data (node);
-      if (sprite->x != sprite->oldx ||
-          sprite->y != sprite->oldy ||
-          sprite->z != sprite->oldz ||
-          sprite->refresh_me)
-        {
-          sprite->refresh_me=0;
-
-          int width = ply_image_get_width (sprite->image);
-          int height= ply_image_get_height (sprite->image);
-          
-          if (sprite->type == SPRITE_TYPE_STAR_BG){
-            star_bg_t *star_bg = sprite->data;
-            int i;
-            for (i=0; i<star_bg->star_count; i++){
-                if (star_bg->star_refresh[i]){
-                    ply_pixel_display_draw_area (view->display,
-                                                 sprite->x+star_bg->star_x[i], sprite->y+star_bg->star_y[i], 1, 1);
-                    star_bg->star_refresh[i]=0;
-                    }
-              }
-            continue;
-            }
-          
-          
-          
-          int x = sprite->x - sprite->oldx;
-          int y = sprite->y - sprite->oldy;
-
-          if (x < width && x > -width && y < height && y > -height)
-            {
-              x=MIN(sprite->x, sprite->oldx);
-              y=MIN(sprite->y, sprite->oldy);
-              width =(MAX(sprite->x, sprite->oldx)-x)+ply_image_get_width (sprite->image);
-              height=(MAX(sprite->y, sprite->oldy)-y)+ply_image_get_height (sprite->image);
-              ply_pixel_display_draw_area (view->display,
-                                           x, y, width, height);
-            }
-          else
-            {
-              ply_pixel_display_draw_area (view->display,
-                                           sprite->x, sprite->y, width, height);
-              ply_pixel_display_draw_area (view->display,
-                                           sprite->oldx, sprite->oldy, width, height);
-            }
+        ply_list_node_t *node;
+        ply_boot_splash_plugin_t *plugin;
+
+        plugin = view->plugin;
+
+        if (plugin->progress_target >= 0)
+                plugin->progress = (plugin->progress * 10 + plugin->progress_target) / 11;
+
+        node = ply_list_get_first_node (view->sprites);
+        while (node) {
+                sprite_t *sprite = ply_list_node_get_data (node);
+                sprite_move (view, sprite, time);
+                node = ply_list_get_next_node (view->sprites, node);
+        }
+
+        sprite_list_sort (view);
+
+        for (node = ply_list_get_first_node (view->sprites); node; node = ply_list_get_next_node (view->sprites, node)) {
+                sprite_t *sprite = ply_list_node_get_data (node);
+                if (sprite->x != sprite->oldx ||
+                    sprite->y != sprite->oldy ||
+                    sprite->z != sprite->oldz ||
+                    sprite->refresh_me) {
+                        sprite->refresh_me = 0;
+
+                        int width = ply_image_get_width (sprite->image);
+                        int height = ply_image_get_height (sprite->image);
+
+                        if (sprite->type == SPRITE_TYPE_STAR_BG) {
+                                star_bg_t *star_bg = sprite->data;
+                                int i;
+                                for (i = 0; i < star_bg->star_count; i++) {
+                                        if (star_bg->star_refresh[i]) {
+                                                ply_pixel_display_draw_area (view->display,
+                                                                             sprite->x + star_bg->star_x[i], sprite->y + star_bg->star_y[i], 1, 1);
+                                                star_bg->star_refresh[i] = 0;
+                                        }
+                                }
+                                continue;
+                        }
+
+
+
+                        int x = sprite->x - sprite->oldx;
+                        int y = sprite->y - sprite->oldy;
+
+                        if (x < width && x > -width && y < height && y > -height) {
+                                x = MIN (sprite->x, sprite->oldx);
+                                y = MIN (sprite->y, sprite->oldy);
+                                width = (MAX (sprite->x, sprite->oldx) - x) + ply_image_get_width (sprite->image);
+                                height = (MAX (sprite->y, sprite->oldy) - y) + ply_image_get_height (sprite->image);
+                                ply_pixel_display_draw_area (view->display,
+                                                             x, y, width, height);
+                        } else {
+                                ply_pixel_display_draw_area (view->display,
+                                                             sprite->x, sprite->y, width, height);
+                                ply_pixel_display_draw_area (view->display,
+                                                             sprite->oldx, sprite->oldy, width, height);
+                        }
+                }
         }
-    }
 }
 
 static void
 on_timeout (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
-  double sleep_time;
-  double now;
+        ply_list_node_t *node;
+        double sleep_time;
+        double now;
 
-  now = ply_get_timestamp ();
+        now = ply_get_timestamp ();
 
-  node = ply_list_get_first_node (plugin->views);
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_animate_attime (view, now);
+                view_animate_attime (view, now);
 
-      node = next_node;
-    }
-  plugin->now = now;
+                node = next_node;
+        }
+        plugin->now = now;
 
-  sleep_time = 1.0 / FRAMES_PER_SECOND;
+        sleep_time = 1.0 / FRAMES_PER_SECOND;
 
-  ply_event_loop_watch_for_timeout (plugin->loop, 
-                                    sleep_time,
-                                    (ply_event_loop_timeout_handler_t)
-                                    on_timeout, plugin);
+        ply_event_loop_watch_for_timeout (plugin->loop,
+                                          sleep_time,
+                                          (ply_event_loop_timeout_handler_t)
+                                          on_timeout, plugin);
 }
 
 static void
@@ -1188,88 +1151,84 @@ on_boot_progress (ply_boot_splash_plugin_t *plugin,
                   double                    duration,
                   double                    percent_done)
 {
-  if (plugin->progress_target<0)
-    plugin->progress = percent_done;
-  plugin->progress_target = percent_done;
+        if (plugin->progress_target < 0)
+                plugin->progress = percent_done;
+        plugin->progress_target = percent_done;
 }
 
 static void
 start_animation (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (plugin->is_animating)
-     return;
+        if (plugin->is_animating)
+                return;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_start_animation (view);
+                view_start_animation (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  on_timeout (plugin);
+        on_timeout (plugin);
 
-  plugin->is_animating = true;
+        plugin->is_animating = true;
 }
 
 static void
 view_free_sprites (view_t *view)
 {
-  ply_list_node_t *node;
-
-  for (node = ply_list_get_first_node (view->sprites);
-       node != NULL;
-       node = ply_list_get_next_node (view->sprites, node))
-    {
-      sprite_t* sprite = ply_list_node_get_data (node);
-      free_sprite (sprite);
-    }
-  ply_list_remove_all_nodes (view->sprites);
+        ply_list_node_t *node;
+
+        for (node = ply_list_get_first_node (view->sprites);
+             node != NULL;
+             node = ply_list_get_next_node (view->sprites, node)) {
+                sprite_t *sprite = ply_list_node_get_data (node);
+                free_sprite (sprite);
+        }
+        ply_list_remove_all_nodes (view->sprites);
 }
 
 static void
 stop_animation (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (plugin != NULL);
-  assert (plugin->loop != NULL);
+        assert (plugin != NULL);
+        assert (plugin->loop != NULL);
 
-  if (!plugin->is_animating)
-     return;
+        if (!plugin->is_animating)
+                return;
 
-  plugin->is_animating = false;
+        plugin->is_animating = false;
 
-  if (plugin->loop != NULL)
-    {
-      ply_event_loop_stop_watching_for_timeout (plugin->loop,
-                                                (ply_event_loop_timeout_handler_t)
-                                                on_timeout, plugin);
-    }
+        if (plugin->loop != NULL) {
+                ply_event_loop_stop_watching_for_timeout (plugin->loop,
+                                                          (ply_event_loop_timeout_handler_t)
+                                                          on_timeout, plugin);
+        }
 
 #ifdef  SHOW_LOGO_HALO
-  ply_image_free(plugin->highlight_logo_image);
+        ply_image_free (plugin->highlight_logo_image);
 #endif
 
-  for(node = ply_list_get_first_node (plugin->views); node; node = ply_list_get_next_node (plugin->views, node))
-    {
-      view_t *view = ply_list_node_get_data (node);
-      view_free_sprites (view);
-    }
+        for (node = ply_list_get_first_node (plugin->views); node; node = ply_list_get_next_node (plugin->views, node)) {
+                view_t *view = ply_list_node_get_data (node);
+                view_free_sprites (view);
+        }
 }
 
 static void
 detach_from_event_loop (ply_boot_splash_plugin_t *plugin)
 {
-  plugin->loop = NULL;
+        plugin->loop = NULL;
 }
 
 static void
@@ -1280,98 +1239,91 @@ draw_background (view_t             *view,
                  int                 width,
                  int                 height);
 static void
-on_draw (view_t                   *view,
-         ply_pixel_buffer_t       *pixel_buffer,
-         int                       x,
-         int                       y,
-         int                       width,
-         int                       height)
+on_draw (view_t             *view,
+         ply_pixel_buffer_t *pixel_buffer,
+         int                 x,
+         int                 y,
+         int                 width,
+         int                 height)
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_rectangle_t clip_area;
-  clip_area.x = x;
-  clip_area.y = y;
-  clip_area.width = width;
-  clip_area.height = height;
-
-  bool single_pixel = 0;
-  float pixel_r=0;
-  float pixel_g=0;
-  float pixel_b=0;
-
-  plugin = view->plugin;
-
-  if (width==1 && height==1)
-      single_pixel = true;
-
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY || 
-      plugin->state == PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY  )
-    {
-      uint32_t *box_data, *lock_data;
-
-      draw_background (view, pixel_buffer, x, y, width, height);
-
-      box_data = ply_image_get_data (plugin->box_image);
-      ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
-                                              &view->box_area,
-                                              box_data);
-      ply_entry_draw_area (view->entry, pixel_buffer, x, y, width, height);
-      ply_label_draw_area (view->label, pixel_buffer, x, y, width, height);
-      lock_data = ply_image_get_data (plugin->lock_image);
-      ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
-                                              &view->lock_area,
-                                              lock_data);
-    }
-  else
-    {
-      ply_list_node_t *node;
-
-      draw_background (view, pixel_buffer, x, y, width, height);
-
-      for(node = ply_list_get_first_node (view->sprites); node; node = ply_list_get_next_node (view->sprites, node))
-        {
-          sprite_t* sprite = ply_list_node_get_data (node);
-          ply_rectangle_t sprite_area;
-
-
-          sprite_area.x = sprite->x;
-          sprite_area.y = sprite->y;
-
-          if (sprite_area.x>=(x+width)) continue;
-          if (sprite_area.y>=(y+height)) continue;
-
-          sprite_area.width =  ply_image_get_width (sprite->image);
-          sprite_area.height = ply_image_get_height (sprite->image);
-
-          if ((int) (sprite_area.x+sprite_area.width)<=x) continue;
-          if ((int) (sprite_area.y+sprite_area.height)<=y) continue;
-
-          if (single_pixel)
-            {
-              uint32_t* image_data = ply_image_get_data (sprite->image);
-              uint32_t overlay_pixel = image_data[(x-sprite_area.x)+(y-sprite_area.y)*sprite_area.width];
-              float  alpha = (float)((overlay_pixel>>24)&0xff)/255 * sprite->opacity;
-              float  red =   (float)((overlay_pixel>>16)&0xff)/255 * sprite->opacity;
-              float  green = (float)((overlay_pixel>>8) &0xff)/255 * sprite->opacity;
-              float  blue =  (float)((overlay_pixel>>0) &0xff)/255 * sprite->opacity;
-              pixel_r = pixel_r*(1-alpha) + red;
-              pixel_g = pixel_g*(1-alpha) + green;
-              pixel_b = pixel_b*(1-alpha) + blue;
-            }
-          else
-            {
-              ply_pixel_buffer_fill_with_argb32_data_at_opacity_with_clip (pixel_buffer,
-                                                                           &sprite_area, &clip_area,
-                                                                           ply_image_get_data (sprite->image), sprite->opacity);
-            }
+        ply_boot_splash_plugin_t *plugin;
+        ply_rectangle_t clip_area;
+
+        clip_area.x = x;
+        clip_area.y = y;
+        clip_area.width = width;
+        clip_area.height = height;
+
+        bool single_pixel = 0;
+        float pixel_r = 0;
+        float pixel_g = 0;
+        float pixel_b = 0;
+
+        plugin = view->plugin;
+
+        if (width == 1 && height == 1)
+                single_pixel = true;
+
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY ||
+            plugin->state == PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY) {
+                uint32_t *box_data, *lock_data;
+
+                draw_background (view, pixel_buffer, x, y, width, height);
+
+                box_data = ply_image_get_data (plugin->box_image);
+                ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
+                                                        &view->box_area,
+                                                        box_data);
+                ply_entry_draw_area (view->entry, pixel_buffer, x, y, width, height);
+                ply_label_draw_area (view->label, pixel_buffer, x, y, width, height);
+                lock_data = ply_image_get_data (plugin->lock_image);
+                ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
+                                                        &view->lock_area,
+                                                        lock_data);
+        } else {
+                ply_list_node_t *node;
+
+                draw_background (view, pixel_buffer, x, y, width, height);
+
+                for (node = ply_list_get_first_node (view->sprites); node; node = ply_list_get_next_node (view->sprites, node)) {
+                        sprite_t *sprite = ply_list_node_get_data (node);
+                        ply_rectangle_t sprite_area;
+
+
+                        sprite_area.x = sprite->x;
+                        sprite_area.y = sprite->y;
+
+                        if (sprite_area.x >= (x + width)) continue;
+                        if (sprite_area.y >= (y + height)) continue;
+
+                        sprite_area.width = ply_image_get_width (sprite->image);
+                        sprite_area.height = ply_image_get_height (sprite->image);
+
+                        if ((int) (sprite_area.x + sprite_area.width) <= x) continue;
+                        if ((int) (sprite_area.y + sprite_area.height) <= y) continue;
+
+                        if (single_pixel) {
+                                uint32_t *image_data = ply_image_get_data (sprite->image);
+                                uint32_t overlay_pixel = image_data[(x - sprite_area.x) + (y - sprite_area.y) * sprite_area.width];
+                                float alpha = (float) ((overlay_pixel >> 24) & 0xff) / 255 * sprite->opacity;
+                                float red = (float) ((overlay_pixel >> 16) & 0xff) / 255 * sprite->opacity;
+                                float green = (float) ((overlay_pixel >> 8) & 0xff) / 255 * sprite->opacity;
+                                float blue = (float) ((overlay_pixel >> 0) & 0xff) / 255 * sprite->opacity;
+                                pixel_r = pixel_r * (1 - alpha) + red;
+                                pixel_g = pixel_g * (1 - alpha) + green;
+                                pixel_b = pixel_b * (1 - alpha) + blue;
+                        } else {
+                                ply_pixel_buffer_fill_with_argb32_data_at_opacity_with_clip (pixel_buffer,
+                                                                                             &sprite_area, &clip_area,
+                                                                                             ply_image_get_data (sprite->image), sprite->opacity);
+                        }
+                }
         }
-    }
-  if (single_pixel){
-      ply_pixel_buffer_fill_with_color (pixel_buffer, &clip_area, pixel_r, pixel_g, pixel_b, 1.0);
-      }
-  ply_label_draw_area (view->message_label,
-                       pixel_buffer,
-                       x, y, width, height);
+        if (single_pixel)
+                ply_pixel_buffer_fill_with_color (pixel_buffer, &clip_area, pixel_r, pixel_g, pixel_b, 1.0);
+        ply_label_draw_area (view->message_label,
+                             pixel_buffer,
+                             x, y, width, height);
 }
 
 static void
@@ -1382,263 +1334,258 @@ draw_background (view_t             *view,
                  int                 width,
                  int                 height)
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_rectangle_t area;
-  ply_rectangle_t image_area;
-
-  plugin = view->plugin;
-
-  area.x = x;
-  area.y = y;
-  area.width = width;
-  area.height = height;
-
-  image_area.x = 0;
-  image_area.y = 0;
-  image_area.width = ply_image_get_width (view->scaled_background_image);
-  image_area.height = ply_image_get_height (view->scaled_background_image);
-
-  ply_pixel_buffer_fill_with_argb32_data_with_clip (pixel_buffer,
-                                                    &image_area, &area,
-                                                    ply_image_get_data (view->scaled_background_image));
-  
-  image_area.x = image_area.width-ply_image_get_width(plugin->star_image);
-  image_area.y = image_area.height-ply_image_get_height(plugin->star_image);
-  image_area.width = ply_image_get_width(plugin->star_image);
-  image_area.height = ply_image_get_height(plugin->star_image);
-  
-  
-  ply_pixel_buffer_fill_with_argb32_data_with_clip (pixel_buffer,
-                                                     &image_area, &area,
-                                                     ply_image_get_data (plugin->star_image));
-                                                     
-  image_area.x = 20;
-  image_area.y = 20;
-  image_area.width = ply_image_get_width(plugin->logo_image);
-  image_area.height = ply_image_get_height(plugin->logo_image);
-  
-  
-  ply_pixel_buffer_fill_with_argb32_data_with_clip (pixel_buffer,
-                                                     &image_area, &area,
-                                                     ply_image_get_data (plugin->logo_image));
+        ply_boot_splash_plugin_t *plugin;
+        ply_rectangle_t area;
+        ply_rectangle_t image_area;
+
+        plugin = view->plugin;
+
+        area.x = x;
+        area.y = y;
+        area.width = width;
+        area.height = height;
+
+        image_area.x = 0;
+        image_area.y = 0;
+        image_area.width = ply_image_get_width (view->scaled_background_image);
+        image_area.height = ply_image_get_height (view->scaled_background_image);
+
+        ply_pixel_buffer_fill_with_argb32_data_with_clip (pixel_buffer,
+                                                          &image_area, &area,
+                                                          ply_image_get_data (view->scaled_background_image));
+
+        image_area.x = image_area.width - ply_image_get_width (plugin->star_image);
+        image_area.y = image_area.height - ply_image_get_height (plugin->star_image);
+        image_area.width = ply_image_get_width (plugin->star_image);
+        image_area.height = ply_image_get_height (plugin->star_image);
+
+
+        ply_pixel_buffer_fill_with_argb32_data_with_clip (pixel_buffer,
+                                                          &image_area, &area,
+                                                          ply_image_get_data (plugin->star_image));
+
+        image_area.x = 20;
+        image_area.y = 20;
+        image_area.width = ply_image_get_width (plugin->logo_image);
+        image_area.height = ply_image_get_height (plugin->logo_image);
+
+
+        ply_pixel_buffer_fill_with_argb32_data_with_clip (pixel_buffer,
+                                                          &image_area, &area,
+                                                          ply_image_get_data (plugin->logo_image));
 }
 
 static void
 add_pixel_display (ply_boot_splash_plugin_t *plugin,
                    ply_pixel_display_t      *display)
 {
-  view_t *view;
+        view_t *view;
 
-  view = view_new (plugin, display);
+        view = view_new (plugin, display);
 
-  ply_pixel_display_set_draw_handler (view->display,
-                                      (ply_pixel_display_draw_handler_t)
-                                      on_draw, view);
+        ply_pixel_display_set_draw_handler (view->display,
+                                            (ply_pixel_display_draw_handler_t)
+                                            on_draw, view);
 
-  ply_list_append_data (plugin->views, view);
+        ply_list_append_data (plugin->views, view);
 }
 
 static void
 remove_pixel_display (ply_boot_splash_plugin_t *plugin,
                       ply_pixel_display_t      *display)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      view_t *view;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                view_t *view;
+                ply_list_node_t *next_node;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view->display == display)
-        {
+                if (view->display == display) {
+                        ply_pixel_display_set_draw_handler (view->display, NULL, NULL);
+                        view_free (view);
+                        ply_list_remove_node (plugin->views, node);
+                        return;
+                }
 
-          ply_pixel_display_set_draw_handler (view->display, NULL, NULL);
-          view_free (view);
-          ply_list_remove_node (plugin->views, node);
-          return;
+                node = next_node;
         }
-
-      node = next_node;
-    }
 }
 
 static void
 view_setup_scene (view_t *view)
 {
-  ply_boot_splash_plugin_t *plugin;
-  sprite_t *sprite;
-  int i;
-  int x, y;
-  int width = 360;
-  int height = 460;
-  unsigned long screen_width, screen_height;
-
-  plugin = view->plugin;
-
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
-
-    {
-      star_bg_t* star_bg;
-      if (view->scaled_background_image)
-        ply_image_free (view->scaled_background_image);
-      view->scaled_background_image = ply_image_resize (plugin->logo_image, screen_width, screen_height);
-      star_bg = malloc(sizeof(star_bg_t));
-      star_bg->star_count = (screen_width * screen_height)/400;
-      star_bg->star_x = malloc(sizeof(int)*star_bg->star_count);
-      star_bg->star_y = malloc(sizeof(int)*star_bg->star_count);
-      star_bg->star_refresh = malloc(sizeof(int)*star_bg->star_count);
-      star_bg->frame_count=0;
-      sprite = add_sprite (view, view->scaled_background_image, SPRITE_TYPE_STAR_BG, star_bg);
-      sprite->z = -10000;
-      
-      uint32_t* image_data = ply_image_get_data (view->scaled_background_image);
-      for (y=0; y< (int) screen_height; y++) for (x=0; x< (int) screen_width; x++){
-          image_data[x + y * screen_width] = star_bg_gradient_colour(x, y, screen_width, screen_height, false, 0);
-        }
-      
-      for (i=0; i<star_bg->star_count; i++){
-          do
-            {
-              x = rand()%screen_width;
-              y = rand()%screen_height;
-            }
-          while (image_data[x + y * screen_width] == 0xFFFFFFFF);
-          star_bg->star_refresh[i] = 0;
-          star_bg->star_x[i] = x;
-          star_bg->star_y[i] = y;
-          image_data[x + y * screen_width] = 0xFFFFFFFF;
-        }
-      for (i=0; i<(int) (screen_width * screen_height)/400; i++){
-        x = rand()%screen_width;
-        y = rand()%screen_height;
-        image_data[x + y * screen_width] = star_bg_gradient_colour(x, y, screen_width, screen_height, true, ((float)x*y*13/10000));
-        }
-      
-      for (i=0; i<star_bg->star_count; i++){
-        image_data[star_bg->star_x[i]  + star_bg->star_y[i] * screen_width] = 
-            star_bg_gradient_colour(star_bg->star_x[i], star_bg->star_y[i], screen_width, screen_height, true, 0.0);
+        ply_boot_splash_plugin_t *plugin;
+        sprite_t *sprite;
+        int i;
+        int x, y;
+        int width = 360;
+        int height = 460;
+        unsigned long screen_width, screen_height;
+
+        plugin = view->plugin;
+
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
+
+        {
+                star_bg_t *star_bg;
+                if (view->scaled_background_image)
+                        ply_image_free (view->scaled_background_image);
+                view->scaled_background_image = ply_image_resize (plugin->logo_image, screen_width, screen_height);
+                star_bg = malloc (sizeof(star_bg_t));
+                star_bg->star_count = (screen_width * screen_height) / 400;
+                star_bg->star_x = malloc (sizeof(int) * star_bg->star_count);
+                star_bg->star_y = malloc (sizeof(int) * star_bg->star_count);
+                star_bg->star_refresh = malloc (sizeof(int) * star_bg->star_count);
+                star_bg->frame_count = 0;
+                sprite = add_sprite (view, view->scaled_background_image, SPRITE_TYPE_STAR_BG, star_bg);
+                sprite->z = -10000;
+
+                uint32_t *image_data = ply_image_get_data (view->scaled_background_image);
+                for (y = 0; y < (int) screen_height; y++) {
+                        for (x = 0; x < (int) screen_width; x++) {
+                                image_data[x + y * screen_width] = star_bg_gradient_colour (x, y, screen_width, screen_height, false, 0);
+                        }
+                }
+
+                for (i = 0; i < star_bg->star_count; i++) {
+                        do {
+                                x = rand () % screen_width;
+                                y = rand () % screen_height;
+                        } while (image_data[x + y * screen_width] == 0xFFFFFFFF);
+                        star_bg->star_refresh[i] = 0;
+                        star_bg->star_x[i] = x;
+                        star_bg->star_y[i] = y;
+                        image_data[x + y * screen_width] = 0xFFFFFFFF;
+                }
+                for (i = 0; i < (int) (screen_width * screen_height) / 400; i++) {
+                        x = rand () % screen_width;
+                        y = rand () % screen_height;
+                        image_data[x + y * screen_width] = star_bg_gradient_colour (x, y, screen_width, screen_height, true, ((float) x * y * 13 / 10000));
+                }
+
+                for (i = 0; i < star_bg->star_count; i++) {
+                        image_data[star_bg->star_x[i] + star_bg->star_y[i] * screen_width] =
+                                star_bg_gradient_colour (star_bg->star_x[i], star_bg->star_y[i], screen_width, screen_height, true, 0.0);
+                }
         }
-    }
 
-  sprite = add_sprite (view, plugin->logo_image, SPRITE_TYPE_STATIC, NULL);
-  sprite->x=screen_width/2-ply_image_get_width(plugin->logo_image)/2;
-  sprite->y=screen_height/2-ply_image_get_height(plugin->logo_image)/2;
-  sprite->z=1000;
+        sprite = add_sprite (view, plugin->logo_image, SPRITE_TYPE_STATIC, NULL);
+        sprite->x = screen_width / 2 - ply_image_get_width (plugin->logo_image) / 2;
+        sprite->y = screen_height / 2 - ply_image_get_height (plugin->logo_image) / 2;
+        sprite->z = 1000;
 
 #ifdef SHOW_LOGO_HALO
-  plugin->highlight_logo_image = ply_image_resize (plugin->logo_image, ply_image_get_width(plugin->logo_image)+HALO_BLUR*2, ply_image_get_height(plugin->logo_image)+HALO_BLUR*2);
-  highlight_image (plugin->highlight_logo_image, plugin->logo_image, HALO_BLUR);
-  sprite = add_sprite (view, plugin->highlight_logo_image, SPRITE_TYPE_STATIC, NULL);
-  sprite->x=10-HALO_BLUR;
-  sprite->y=10-HALO_BLUR;
-  sprite->z=-910;
+        plugin->highlight_logo_image = ply_image_resize (plugin->logo_image, ply_image_get_width (plugin->logo_image) + HALO_BLUR * 2, ply_image_get_height (plugin->logo_image) + HALO_BLUR * 2);
+        highlight_image (plugin->highlight_logo_image, plugin->logo_image, HALO_BLUR);
+        sprite = add_sprite (view, plugin->highlight_logo_image, SPRITE_TYPE_STATIC, NULL);
+        sprite->x = 10 - HALO_BLUR;
+        sprite->y = 10 - HALO_BLUR;
+        sprite->z = -910;
 #endif
 
-  sprite = add_sprite (view, plugin->star_image, SPRITE_TYPE_STATIC, NULL);
-  sprite->x=screen_width-ply_image_get_width(plugin->star_image);
-  sprite->y=screen_height-ply_image_get_height(plugin->star_image);
-  sprite->z=0;
+        sprite = add_sprite (view, plugin->star_image, SPRITE_TYPE_STATIC, NULL);
+        sprite->x = screen_width - ply_image_get_width (plugin->star_image);
+        sprite->y = screen_height - ply_image_get_height (plugin->star_image);
+        sprite->z = 0;
 #ifdef  SHOW_PLANETS
-  for (i=0; i<5; i++)
-    {
-       satellite_t* satellite = malloc(sizeof(satellite_t));
-       satellite->type=SATELLITE_TYPE_PLANET;
-       satellite->end_x=satellite->start_x=720-800+screen_width;
-       satellite->end_y=satellite->start_y=300-480+screen_height;
-
-       satellite->distance=i*100+280;
-       satellite->theta=M_PI*0.8;
-       satellite->image=plugin->planet_image[i];
-       satellite->image_altered=ply_image_resize (satellite->image, ply_image_get_width(satellite->image), ply_image_get_height(satellite->image));
-       sprite = add_sprite (view, satellite->image_altered, SPRITE_TYPE_SATELLITE, satellite);
-       satellite_move (plugin, sprite, 0);
-
-    }
+        for (i = 0; i < 5; i++) {
+                satellite_t *satellite = malloc (sizeof(satellite_t));
+                satellite->type = SATELLITE_TYPE_PLANET;
+                satellite->end_x = satellite->start_x = 720 - 800 + screen_width;
+                satellite->end_y = satellite->start_y = 300 - 480 + screen_height;
+
+                satellite->distance = i * 100 + 280;
+                satellite->theta = M_PI * 0.8;
+                satellite->image = plugin->planet_image[i];
+                satellite->image_altered = ply_image_resize (satellite->image, ply_image_get_width (satellite->image), ply_image_get_height (satellite->image));
+                sprite = add_sprite (view, satellite->image_altered, SPRITE_TYPE_SATELLITE, satellite);
+                satellite_move (plugin, sprite, 0);
+        }
 #endif
 #ifdef  SHOW_COMETS
-  for (i=0; i<1; i++)
-    {
-      satellite_t* satellite = malloc(sizeof(satellite_t));
-      satellite->type=SATELLITE_TYPE_COMET;
-      satellite->end_x=satellite->start_x=720-800+screen_width;
-      satellite->end_y=satellite->start_y=300-480+screen_height;
-      satellite->distance=550+i*50;
-      satellite->theta=M_PI*0.8;
+        for (i = 0; i < 1; i++) {
+                satellite_t *satellite = malloc (sizeof(satellite_t));
+                satellite->type = SATELLITE_TYPE_COMET;
+                satellite->end_x = satellite->start_x = 720 - 800 + screen_width;
+                satellite->end_y = satellite->start_y = 300 - 480 + screen_height;
+                satellite->distance = 550 + i * 50;
+                satellite->theta = M_PI * 0.8;
 #define COMET_SIZE 64
-      satellite->image=ply_image_resize (plugin->progress_barimage, COMET_SIZE, COMET_SIZE);
-      satellite->image_altered=ply_image_resize (satellite->image, COMET_SIZE, COMET_SIZE);
-      uint32_t * image_data = ply_image_get_data (satellite->image);
-      uint32_t * image_altered_data = ply_image_get_data (satellite->image_altered);
-
-
-      for (y=0; y<COMET_SIZE; y++)for (x=0; x<COMET_SIZE; x++){
-          image_data[x + y * COMET_SIZE] = 0x0;
-          image_altered_data[x + y * COMET_SIZE] = 0x0;
+                satellite->image = ply_image_resize (plugin->progress_barimage, COMET_SIZE, COMET_SIZE);
+                satellite->image_altered = ply_image_resize (satellite->image, COMET_SIZE, COMET_SIZE);
+                uint32_t *image_data = ply_image_get_data (satellite->image);
+                uint32_t *image_altered_data = ply_image_get_data (satellite->image_altered);
+
+
+                for (y = 0; y < COMET_SIZE; y++) {
+                        for (x = 0; x < COMET_SIZE; x++) {
+                                image_data[x + y * COMET_SIZE] = 0x0;
+                                image_altered_data[x + y * COMET_SIZE] = 0x0;
+                        }
+                }
+
+                sprite = add_sprite (view, satellite->image_altered, SPRITE_TYPE_SATELLITE, satellite);
+                for (x = 0; x < COMET_SIZE; x++) {
+                        satellite_move (plugin, sprite, 0);
+                }
         }
-            
-      sprite = add_sprite (view, satellite->image_altered, SPRITE_TYPE_SATELLITE, satellite);
-      for (x=0; x<COMET_SIZE; x++) satellite_move (plugin, sprite, 0);
-     }
 #endif
 
 #ifdef  SHOW_PROGRESS_BAR
-  progress_t* progress = malloc(sizeof(progress_t));
-  
-  progress->image = plugin->progress_barimage;
-  
-  x = screen_width/2-ply_image_get_width(plugin->logo_image)/2;;
-  y = screen_height/2+ply_image_get_height(plugin->logo_image)/2+20;
-  progress->image_altered = ply_image_resize (plugin->progress_barimage, ply_image_get_width(plugin->logo_image), ply_image_get_height(plugin->progress_barimage));
-  progress->start_width = 1;
-  progress->end_width = ply_image_get_width(plugin->logo_image);
-  progress->current_width = 0;
-  
-  sprite = add_sprite (view, progress->image_altered, SPRITE_TYPE_PROGRESS, progress);
-  sprite->x=x;
-  sprite->y=y;
-  sprite->z=10011;
-  progress_update (view, sprite, 0);
-  
-  
-  
+        progress_t *progress = malloc (sizeof(progress_t));
+
+        progress->image = plugin->progress_barimage;
+
+        x = screen_width / 2 - ply_image_get_width (plugin->logo_image) / 2;
+        y = screen_height / 2 + ply_image_get_height (plugin->logo_image) / 2 + 20;
+        progress->image_altered = ply_image_resize (plugin->progress_barimage, ply_image_get_width (plugin->logo_image), ply_image_get_height (plugin->progress_barimage));
+        progress->start_width = 1;
+        progress->end_width = ply_image_get_width (plugin->logo_image);
+        progress->current_width = 0;
+
+        sprite = add_sprite (view, progress->image_altered, SPRITE_TYPE_PROGRESS, progress);
+        sprite->x = x;
+        sprite->y = y;
+        sprite->z = 10011;
+        progress_update (view, sprite, 0);
+
+
+
 #endif
 
-  flare_t *flare = malloc(sizeof(flare_t));
+        flare_t *flare = malloc (sizeof(flare_t));
 
-  flare->image_a = ply_image_resize (plugin->star_image, width, height);
-  flare->image_b = ply_image_resize (plugin->star_image, width, height);
+        flare->image_a = ply_image_resize (plugin->star_image, width, height);
+        flare->image_b = ply_image_resize (plugin->star_image, width, height);
 
-  sprite = add_sprite (view, flare->image_a, SPRITE_TYPE_FLARE, flare);
-  sprite->x=screen_width-width;
-  sprite->y=screen_height-height;
-  sprite->z=1;
+        sprite = add_sprite (view, flare->image_a, SPRITE_TYPE_FLARE, flare);
+        sprite->x = screen_width - width;
+        sprite->y = screen_height - height;
+        sprite->z = 1;
 
-  sprite_list_sort (view);
+        sprite_list_sort (view);
 
-  uint32_t * old_image_data = ply_image_get_data (flare->image_a);
-  uint32_t * new_image_data = ply_image_get_data (flare->image_b);
+        uint32_t *old_image_data = ply_image_get_data (flare->image_a);
+        uint32_t *new_image_data = ply_image_get_data (flare->image_b);
 
 
-  for (y = 0; y < height; y++)
-    {
-      for (x = 0; x < width; x++)
-        {
-          new_image_data[x + y * width] = 0x0;
-          old_image_data[x + y * width] = 0x0;
+        for (y = 0; y < height; y++) {
+                for (x = 0; x < width; x++) {
+                        new_image_data[x + y * width] = 0x0;
+                        old_image_data[x + y * width] = 0x0;
+                }
         }
-    }
-
-  for (i=0; i<FLARE_COUNT; i++)
-    {
-      flare_reset (flare, i);
-    }
-  flare->frame_count=0;
-  flare_update(sprite, i);
+
+        for (i = 0; i < FLARE_COUNT; i++) {
+                flare_reset (flare, i);
+        }
+        flare->frame_count = 0;
+        flare_update (sprite, i);
 }
 
 static bool
@@ -1647,89 +1594,87 @@ show_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_buffer_t             *boot_buffer,
                     ply_boot_splash_mode_t    mode)
 {
-  assert (plugin != NULL);
-  assert (plugin->logo_image != NULL);
+        assert (plugin != NULL);
+        assert (plugin->logo_image != NULL);
 
-  plugin->loop = loop;
-  plugin->mode = mode;
+        plugin->loop = loop;
+        plugin->mode = mode;
 
-  ply_trace ("loading logo image");
-  if (!ply_image_load (plugin->logo_image))
-    return false;
+        ply_trace ("loading logo image");
+        if (!ply_image_load (plugin->logo_image))
+                return false;
 
-  ply_trace ("loading star image");
-  if (!ply_image_load (plugin->star_image))
-    return false;
+        ply_trace ("loading star image");
+        if (!ply_image_load (plugin->star_image))
+                return false;
 
-  ply_trace ("loading planet images");
+        ply_trace ("loading planet images");
 #ifdef  SHOW_PLANETS
-  if (!ply_image_load (plugin->planet_image[0]))
-    return false;
-  if (!ply_image_load (plugin->planet_image[1]))
-    return false;
-  if (!ply_image_load (plugin->planet_image[2]))
-    return false;
-  if (!ply_image_load (plugin->planet_image[3]))
-    return false;
-  if (!ply_image_load (plugin->planet_image[4]))
-    return false;
+        if (!ply_image_load (plugin->planet_image[0]))
+                return false;
+        if (!ply_image_load (plugin->planet_image[1]))
+                return false;
+        if (!ply_image_load (plugin->planet_image[2]))
+                return false;
+        if (!ply_image_load (plugin->planet_image[3]))
+                return false;
+        if (!ply_image_load (plugin->planet_image[4]))
+                return false;
 #endif
 #ifdef  SHOW_PROGRESS_BAR
-  if (!ply_image_load (plugin->progress_barimage))
-    return false;
+        if (!ply_image_load (plugin->progress_barimage))
+                return false;
 #endif
 
-  ply_trace ("loading lock image");
-  if (!ply_image_load (plugin->lock_image))
-    return false;
+        ply_trace ("loading lock image");
+        if (!ply_image_load (plugin->lock_image))
+                return false;
 
-  ply_trace ("loading box image");
-  if (!ply_image_load (plugin->box_image))
-    return false;
+        ply_trace ("loading box image");
+        if (!ply_image_load (plugin->box_image))
+                return false;
 
-  if (!load_views (plugin))
-    {
-      ply_trace ("couldn't load views");
-      return false;
-    }
+        if (!load_views (plugin)) {
+                ply_trace ("couldn't load views");
+                return false;
+        }
 
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
-                                 detach_from_event_loop,
-                                 plugin);
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       detach_from_event_loop,
+                                       plugin);
 
-  ply_trace ("starting boot animation");
+        ply_trace ("starting boot animation");
 
-  start_animation (plugin);
+        start_animation (plugin);
 
-  plugin->is_visible = true;
+        plugin->is_visible = true;
 
-  return true;
+        return true;
 }
 
 static void
 update_status (ply_boot_splash_plugin_t *plugin,
                const char               *status)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 }
 
 static void
 hide_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_event_loop_t         *loop)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  if (plugin->loop != NULL)
-    {
-      stop_animation (plugin);
+        if (plugin->loop != NULL) {
+                stop_animation (plugin);
 
-      ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
+                ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
 
-  plugin->is_visible = false;
+        plugin->is_visible = false;
 }
 
 static void
@@ -1737,22 +1682,21 @@ show_password_prompt (ply_boot_splash_plugin_t *plugin,
                       const char               *text,
                       int                       number_of_bullets)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, text);
-      ply_entry_set_bullet_count (view->entry, number_of_bullets);
+                view_show_prompt (view, text);
+                ply_entry_set_bullet_count (view->entry, number_of_bullets);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
@@ -1760,73 +1704,71 @@ show_prompt (ply_boot_splash_plugin_t *plugin,
              const char               *prompt,
              const char               *entry_text)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, prompt);
-      ply_entry_set_text (view->entry, entry_text);
+                view_show_prompt (view, prompt);
+                ply_entry_set_text (view->entry, entry_text);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 on_root_mounted (ply_boot_splash_plugin_t *plugin)
 {
-  plugin->root_is_mounted = true;
+        plugin->root_is_mounted = true;
 }
 
 static void
 become_idle (ply_boot_splash_plugin_t *plugin,
              ply_trigger_t            *idle_trigger)
 {
-  stop_animation (plugin);
-  ply_trigger_pull (idle_trigger, NULL);
+        stop_animation (plugin);
+        ply_trigger_pull (idle_trigger, NULL);
 }
 
 static void
 show_message (ply_boot_splash_plugin_t *plugin,
               const char               *message)
 {
-  ply_trace ("Showing message '%s'", message);
-  ply_list_node_t *node;
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
-
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
-      ply_label_set_text (view->message_label, message);
-      ply_label_show (view->message_label, view->display, 10, 10);
-
-      ply_pixel_display_draw_area (view->display, 10, 10,
-                                   ply_label_get_width (view->message_label),
-                                   ply_label_get_height(view->message_label));
-      node = next_node;
-    }
+        ply_trace ("Showing message '%s'", message);
+        ply_list_node_t *node;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
+
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
+                ply_label_set_text (view->message_label, message);
+                ply_label_show (view->message_label, view->display, 10, 10);
+
+                ply_pixel_display_draw_area (view->display, 10, 10,
+                                             ply_label_get_width (view->message_label),
+                                             ply_label_get_height (view->message_label));
+                node = next_node;
+        }
 }
 
 static void
 display_normal (ply_boot_splash_plugin_t *plugin)
 {
-  pause_views (plugin);
-  if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    hide_prompt (plugin);
-
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
-  start_animation (plugin);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        pause_views (plugin);
+        if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                hide_prompt (plugin);
+
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
+        start_animation (plugin);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
@@ -1834,14 +1776,14 @@ display_password (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   int                       bullets)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin);
-
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
-  show_password_prompt (plugin, prompt, bullets);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin);
+
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
+        show_password_prompt (plugin, prompt, bullets);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
@@ -1849,45 +1791,45 @@ display_question (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   const char               *entry_text)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin);
-
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY;
-  show_prompt (plugin, prompt, entry_text);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin);
+
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY;
+        show_prompt (plugin, prompt, entry_text);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
 display_message (ply_boot_splash_plugin_t *plugin,
                  const char               *message)
 {
-  show_message (plugin, message);
+        show_message (plugin, message);
 }
 
 ply_boot_splash_plugin_interface_t *
 ply_boot_splash_plugin_get_interface (void)
 {
-  static ply_boot_splash_plugin_interface_t plugin_interface =
-    {
-      .create_plugin = create_plugin,
-      .destroy_plugin = destroy_plugin,
-      .add_pixel_display = add_pixel_display,
-      .remove_pixel_display = remove_pixel_display,
-      .show_splash_screen = show_splash_screen,
-      .update_status = update_status,
-      .on_boot_progress = on_boot_progress,
-      .hide_splash_screen = hide_splash_screen,
-      .on_root_mounted = on_root_mounted,
-      .become_idle = become_idle,
-      .display_normal = display_normal,
-      .display_password = display_password,
-      .display_question = display_question,      
-      .display_message = display_message,
-    };
-
-  return &plugin_interface;
+        static ply_boot_splash_plugin_interface_t plugin_interface =
+        {
+                .create_plugin        = create_plugin,
+                .destroy_plugin       = destroy_plugin,
+                .add_pixel_display    = add_pixel_display,
+                .remove_pixel_display = remove_pixel_display,
+                .show_splash_screen   = show_splash_screen,
+                .update_status        = update_status,
+                .on_boot_progress     = on_boot_progress,
+                .hide_splash_screen   = hide_splash_screen,
+                .on_root_mounted      = on_root_mounted,
+                .become_idle          = become_idle,
+                .display_normal       = display_normal,
+                .display_password     = display_password,
+                .display_question     = display_question,
+                .display_message      = display_message,
+        };
+
+        return &plugin_interface;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/plugins/splash/text/plugin.c b/src/plugins/splash/text/plugin.c
index fb97c14..85cfda2 100644
--- a/src/plugins/splash/text/plugin.c
+++ b/src/plugins/splash/text/plugin.c
@@ -51,32 +51,32 @@
 
 #include <linux/kd.h>
 
-typedef enum {
-   PLY_BOOT_SPLASH_DISPLAY_NORMAL,
-   PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
-   PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
+typedef enum
+{
+        PLY_BOOT_SPLASH_DISPLAY_NORMAL,
+        PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
+        PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
 } ply_boot_splash_display_type_t;
 
 struct _ply_boot_splash_plugin
 {
-  ply_event_loop_t *loop;
-  ply_boot_splash_mode_t mode;
+        ply_event_loop_t              *loop;
+        ply_boot_splash_mode_t         mode;
 
-  ply_list_t *views;
+        ply_list_t                    *views;
 
-  ply_boot_splash_display_type_t state;
+        ply_boot_splash_display_type_t state;
 
-  char *message;
+        char                          *message;
 
-  uint32_t is_animating : 1;
+        uint32_t                       is_animating : 1;
 };
 
 typedef struct
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_text_display_t *display;
-  ply_text_step_bar_t *step_bar;
-
+        ply_boot_splash_plugin_t *plugin;
+        ply_text_display_t       *display;
+        ply_text_step_bar_t      *step_bar;
 } view_t;
 
 ply_boot_splash_plugin_interface_t *ply_boot_splash_plugin_get_interface (void);
@@ -88,45 +88,45 @@ static view_t *
 view_new (ply_boot_splash_plugin_t *plugin,
           ply_text_display_t       *display)
 {
-  view_t *view;
+        view_t *view;
 
-  view = calloc (1, sizeof (view_t));
-  view->plugin = plugin;
-  view->display = display;
+        view = calloc (1, sizeof(view_t));
+        view->plugin = plugin;
+        view->display = display;
 
-  view->step_bar = ply_text_step_bar_new ();
+        view->step_bar = ply_text_step_bar_new ();
 
-  return view;
+        return view;
 }
 
 static void
 view_free (view_t *view)
 {
-  ply_text_step_bar_free (view->step_bar);
+        ply_text_step_bar_free (view->step_bar);
 
-  free (view);
+        free (view);
 }
 
 static void
 view_show_message (view_t *view)
 {
-  ply_boot_splash_plugin_t *plugin;
-  int display_width, display_height;
+        ply_boot_splash_plugin_t *plugin;
+        int display_width, display_height;
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  display_width = ply_text_display_get_number_of_columns (view->display);
-  display_height = ply_text_display_get_number_of_rows (view->display);
+        display_width = ply_text_display_get_number_of_columns (view->display);
+        display_height = ply_text_display_get_number_of_rows (view->display);
 
-  ply_text_display_set_cursor_position (view->display, 0,
-                                        display_height / 2);
-  ply_text_display_clear_line (view->display);
-  ply_text_display_set_cursor_position (view->display,
-                                        (display_width -
-                                        strlen (plugin->message)) / 2,
-                                        display_height / 2);
+        ply_text_display_set_cursor_position (view->display, 0,
+                                              display_height / 2);
+        ply_text_display_clear_line (view->display);
+        ply_text_display_set_cursor_position (view->display,
+                                              (display_width -
+                                               strlen (plugin->message)) / 2,
+                                              display_height / 2);
 
-  ply_text_display_write (view->display, "%s", plugin->message);
+        ply_text_display_write (view->display, "%s", plugin->message);
 }
 
 static void
@@ -134,385 +134,373 @@ view_show_prompt (view_t     *view,
                   const char *prompt,
                   const char *entered_text)
 {
+        int display_width, display_height;
+        int i;
 
-  int display_width, display_height;
-  int i;
-
-  display_width = ply_text_display_get_number_of_columns (view->display);
-  display_height = ply_text_display_get_number_of_rows (view->display);
-  ply_text_display_set_background_color (view->display, PLY_TERMINAL_COLOR_DEFAULT);
-  ply_text_display_clear_screen (view->display);
+        display_width = ply_text_display_get_number_of_columns (view->display);
+        display_height = ply_text_display_get_number_of_rows (view->display);
+        ply_text_display_set_background_color (view->display, PLY_TERMINAL_COLOR_DEFAULT);
+        ply_text_display_clear_screen (view->display);
 
-  ply_text_display_set_cursor_position (view->display, 0, display_height / 2);
+        ply_text_display_set_cursor_position (view->display, 0, display_height / 2);
 
-  for (i=0; i < display_width; i++)
-    ply_text_display_write (view->display, "%c", ' ');
+        for (i = 0; i < display_width; i++) {
+                ply_text_display_write (view->display, "%c", ' ');
+        }
 
-  ply_text_display_set_cursor_position (view->display,
-                                        display_width / 2 - (strlen (prompt)),
-                                        display_height / 2);
+        ply_text_display_set_cursor_position (view->display,
+                                              display_width / 2 - (strlen (prompt)),
+                                              display_height / 2);
 
-  ply_text_display_write (view->display, "%s:%s", prompt, entered_text);
+        ply_text_display_write (view->display, "%s:%s", prompt, entered_text);
 
-  ply_text_display_show_cursor (view->display);
+        ply_text_display_show_cursor (view->display);
 }
 
 static void
 view_start_animation (view_t *view)
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_terminal_t *terminal;
+        ply_boot_splash_plugin_t *plugin;
+        ply_terminal_t *terminal;
 
-  assert (view != NULL);
+        assert (view != NULL);
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  terminal = ply_text_display_get_terminal (view->display);
+        terminal = ply_text_display_get_terminal (view->display);
 
-  ply_terminal_set_color_hex_value (terminal,
-                                    PLY_TERMINAL_COLOR_BLACK,
-                                    0x000000);
-  ply_terminal_set_color_hex_value (terminal,
-                                    PLY_TERMINAL_COLOR_WHITE,
-                                    0xffffff);
-  ply_terminal_set_color_hex_value (terminal,
-                                    PLY_TERMINAL_COLOR_BLUE,
-                                    0x3465a4);
-  ply_terminal_set_color_hex_value (terminal,
-                                    PLY_TERMINAL_COLOR_BROWN,
-                                    0x979a9b);
+        ply_terminal_set_color_hex_value (terminal,
+                                          PLY_TERMINAL_COLOR_BLACK,
+                                          0x000000);
+        ply_terminal_set_color_hex_value (terminal,
+                                          PLY_TERMINAL_COLOR_WHITE,
+                                          0xffffff);
+        ply_terminal_set_color_hex_value (terminal,
+                                          PLY_TERMINAL_COLOR_BLUE,
+                                          0x3465a4);
+        ply_terminal_set_color_hex_value (terminal,
+                                          PLY_TERMINAL_COLOR_BROWN,
+                                          0x979a9b);
 
-  ply_text_display_set_background_color (view->display,
-                                         PLY_TERMINAL_COLOR_BLACK);
-  ply_text_display_clear_screen (view->display);
-  ply_text_display_hide_cursor (view->display);
+        ply_text_display_set_background_color (view->display,
+                                               PLY_TERMINAL_COLOR_BLACK);
+        ply_text_display_clear_screen (view->display);
+        ply_text_display_hide_cursor (view->display);
 
-  if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
-    {
-      ply_text_step_bar_hide (view->step_bar);
-      return;
-    }
+        if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN) {
+                ply_text_step_bar_hide (view->step_bar);
+                return;
+        }
 
-  ply_text_step_bar_show (view->step_bar,
-                              view->display);
+        ply_text_step_bar_show (view->step_bar,
+                                view->display);
 }
 
 static void
 view_redraw (view_t *view)
 {
-  unsigned long screen_width, screen_height;
+        unsigned long screen_width, screen_height;
 
-  screen_width = ply_text_display_get_number_of_columns (view->display);
-  screen_height = ply_text_display_get_number_of_rows (view->display);
+        screen_width = ply_text_display_get_number_of_columns (view->display);
+        screen_height = ply_text_display_get_number_of_rows (view->display);
 
-  ply_text_display_draw_area (view->display, 0, 0,
-                              screen_width, screen_height);
+        ply_text_display_draw_area (view->display, 0, 0,
+                                    screen_width, screen_height);
 }
 
 static void
 redraw_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_redraw (view);
+                view_redraw (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 view_hide (view_t *view)
 {
-  if (view->display != NULL)
-    {
-      ply_terminal_t *terminal;
+        if (view->display != NULL) {
+                ply_terminal_t *terminal;
 
-      terminal = ply_text_display_get_terminal (view->display);
+                terminal = ply_text_display_get_terminal (view->display);
 
-      ply_text_display_set_background_color (view->display, PLY_TERMINAL_COLOR_DEFAULT);
-      ply_text_display_clear_screen (view->display);
-      ply_text_display_show_cursor (view->display);
+                ply_text_display_set_background_color (view->display, PLY_TERMINAL_COLOR_DEFAULT);
+                ply_text_display_clear_screen (view->display);
+                ply_text_display_show_cursor (view->display);
 
-      ply_terminal_reset_colors (terminal);
-    }
+                ply_terminal_reset_colors (terminal);
+        }
 }
 
 static void
 hide_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_hide (view);
+                view_hide (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 pause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_text_display_pause_updates (view->display);
+                ply_text_display_pause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 unpause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_text_display_unpause_updates (view->display);
+                ply_text_display_unpause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static ply_boot_splash_plugin_t *
 create_plugin (ply_key_file_t *key_file)
 {
-  ply_boot_splash_plugin_t *plugin;
+        ply_boot_splash_plugin_t *plugin;
 
-  ply_trace ("creating plugin");
+        ply_trace ("creating plugin");
 
-  plugin = calloc (1, sizeof (ply_boot_splash_plugin_t));
-  plugin->message = NULL;
+        plugin = calloc (1, sizeof(ply_boot_splash_plugin_t));
+        plugin->message = NULL;
 
-  plugin->views = ply_list_new ();
+        plugin->views = ply_list_new ();
 
-  return plugin;
+        return plugin;
 }
 
 static void
 detach_from_event_loop (ply_boot_splash_plugin_t *plugin)
 {
-  plugin->loop = NULL;
+        plugin->loop = NULL;
 
-  ply_trace ("detaching from event loop");
+        ply_trace ("detaching from event loop");
 }
 
 static void
 free_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_free (view);
-      ply_list_remove_node (plugin->views, node);
+                view_free (view);
+                ply_list_remove_node (plugin->views, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  ply_list_free (plugin->views);
-  plugin->views = NULL;
+        ply_list_free (plugin->views);
+        plugin->views = NULL;
 }
 
 static void
 destroy_plugin (ply_boot_splash_plugin_t *plugin)
 {
-  ply_trace ("destroying plugin");
+        ply_trace ("destroying plugin");
 
-  if (plugin == NULL)
-    return;
+        if (plugin == NULL)
+                return;
 
-  /* It doesn't ever make sense to keep this plugin on screen
-   * after exit
-   */
-  hide_splash_screen (plugin, plugin->loop);
+        /* It doesn't ever make sense to keep this plugin on screen
+         * after exit
+         */
+        hide_splash_screen (plugin, plugin->loop);
 
-  free_views (plugin);
-  if (plugin->message != NULL)
-    free (plugin->message);
+        free_views (plugin);
+        if (plugin->message != NULL)
+                free (plugin->message);
 
-  free (plugin);
+        free (plugin);
 }
 
 static void
 show_message (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_message (view);
+                view_show_message (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 start_animation (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (plugin != NULL);
-  assert (plugin->loop != NULL);
+        assert (plugin != NULL);
+        assert (plugin->loop != NULL);
 
-  redraw_views (plugin);
+        redraw_views (plugin);
 
-  if (plugin->message != NULL)
-    show_message (plugin);
+        if (plugin->message != NULL)
+                show_message (plugin);
 
-  if (plugin->is_animating)
-     return;
+        if (plugin->is_animating)
+                return;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_start_animation (view);
+                view_start_animation (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  plugin->is_animating = true;
+        plugin->is_animating = true;
 }
 
 static void
 stop_animation (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (plugin != NULL);
-  assert (plugin->loop != NULL);
+        assert (plugin != NULL);
+        assert (plugin->loop != NULL);
 
-  if (!plugin->is_animating)
-     return;
+        if (!plugin->is_animating)
+                return;
 
-  plugin->is_animating = false;
+        plugin->is_animating = false;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_text_step_bar_hide (view->step_bar);
+                ply_text_step_bar_hide (view->step_bar);
 
-      node = next_node;
-    }
-  redraw_views (plugin);
+                node = next_node;
+        }
+        redraw_views (plugin);
 }
 
 static void
-on_draw (view_t                   *view,
-         ply_terminal_t           *terminal,
-         int                       x,
-         int                       y,
-         int                       width,
-         int                       height)
+on_draw (view_t         *view,
+         ply_terminal_t *terminal,
+         int             x,
+         int             y,
+         int             width,
+         int             height)
 {
-  ply_text_display_clear_screen (view->display);
+        ply_text_display_clear_screen (view->display);
 }
 
 static void
 add_text_display (ply_boot_splash_plugin_t *plugin,
                   ply_text_display_t       *display)
 {
-  view_t *view;
-  ply_terminal_t *terminal;
+        view_t *view;
+        ply_terminal_t *terminal;
 
-  view = view_new (plugin, display);
+        view = view_new (plugin, display);
 
-  terminal = ply_text_display_get_terminal (view->display);
-  if (ply_terminal_open (terminal))
-    ply_terminal_activate_vt (terminal);
+        terminal = ply_text_display_get_terminal (view->display);
+        if (ply_terminal_open (terminal))
+                ply_terminal_activate_vt (terminal);
 
-  ply_text_display_set_draw_handler (view->display,
-                                     (ply_text_display_draw_handler_t)
-                                     on_draw, view);
+        ply_text_display_set_draw_handler (view->display,
+                                           (ply_text_display_draw_handler_t)
+                                           on_draw, view);
 
-  ply_list_append_data (plugin->views, view);
+        ply_list_append_data (plugin->views, view);
 }
 
 static void
 remove_text_display (ply_boot_splash_plugin_t *plugin,
                      ply_text_display_t       *display)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      view_t *view;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                view_t *view;
+                ply_list_node_t *next_node;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view->display == display)
-        {
-          ply_text_display_set_draw_handler (view->display,
-                                             NULL, NULL);
-          view_free (view);
-          ply_list_remove_node (plugin->views, node);
-          return;
-        }
+                if (view->display == display) {
+                        ply_text_display_set_draw_handler (view->display,
+                                                           NULL, NULL);
+                        view_free (view);
+                        ply_list_remove_node (plugin->views, node);
+                        return;
+                }
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static bool
@@ -521,27 +509,27 @@ show_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_buffer_t             *boot_buffer,
                     ply_boot_splash_mode_t    mode)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  plugin->loop = loop;
-  plugin->mode = mode;
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
-                                 detach_from_event_loop,
-                                 plugin);
+        plugin->loop = loop;
+        plugin->mode = mode;
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       detach_from_event_loop,
+                                       plugin);
 
-  ply_show_new_kernel_messages (false);
-  start_animation (plugin);
+        ply_show_new_kernel_messages (false);
+        start_animation (plugin);
 
-  return true;
+        return true;
 }
 
 static void
 update_status (ply_boot_splash_plugin_t *plugin,
                const char               *status)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  ply_trace ("status update");
+        ply_trace ("status update");
 }
 
 static void
@@ -549,77 +537,74 @@ on_boot_progress (ply_boot_splash_plugin_t *plugin,
                   double                    duration,
                   double                    percent_done)
 {
-  ply_list_node_t *node;
-  double total_duration;
+        ply_list_node_t *node;
+        double total_duration;
 
-  total_duration = duration / percent_done;
+        total_duration = duration / percent_done;
 
-  /* Fun made-up smoothing function to make the growth asymptotic:
-   * fraction(time,estimate)=1-2^(-(time^1.45)/estimate) */
-  percent_done = 1.0 - pow (2.0, -pow (duration, 1.45) / total_duration) * (1.0 - percent_done);
+        /* Fun made-up smoothing function to make the growth asymptotic:
+         * fraction(time,estimate)=1-2^(-(time^1.45)/estimate) */
+        percent_done = 1.0 - pow (2.0, -pow (duration, 1.45) / total_duration) * (1.0 - percent_done);
 
-  node = ply_list_get_first_node (plugin->views);
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_text_step_bar_set_percent_done (view->step_bar, percent_done);
-      ply_text_step_bar_draw (view->step_bar);
+                ply_text_step_bar_set_percent_done (view->step_bar, percent_done);
+                ply_text_step_bar_draw (view->step_bar);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 hide_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_event_loop_t         *loop)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  ply_trace ("hiding splash screen");
+        ply_trace ("hiding splash screen");
 
-  if (plugin->loop != NULL)
-    {
-      stop_animation (plugin);
+        if (plugin->loop != NULL) {
+                stop_animation (plugin);
 
-      ply_event_loop_stop_watching_for_exit (plugin->loop,
-                                             (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
+                ply_event_loop_stop_watching_for_exit (plugin->loop,
+                                                       (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
 
-  hide_views (plugin);
-  ply_show_new_kernel_messages (true);
+        hide_views (plugin);
+        ply_show_new_kernel_messages (true);
 }
 
 static void
 display_normal (ply_boot_splash_plugin_t *plugin)
 {
-  pause_views (plugin);
-  if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    {
-      plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
-      start_animation (plugin);
-      redraw_views (plugin);
-    }
-  unpause_views (plugin);
+        pause_views (plugin);
+        if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL) {
+                plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
+                start_animation (plugin);
+                redraw_views (plugin);
+        }
+        unpause_views (plugin);
 }
 
 static void
 display_message (ply_boot_splash_plugin_t *plugin,
                  const char               *message)
 {
-  if (plugin->message != NULL)
-    free (plugin->message);
+        if (plugin->message != NULL)
+                free (plugin->message);
 
-  plugin->message = strdup (message);
-  start_animation (plugin);
+        plugin->message = strdup (message);
+        start_animation (plugin);
 }
 
 static void
@@ -627,29 +612,29 @@ show_password_prompt (ply_boot_splash_plugin_t *plugin,
                       const char               *prompt,
                       int                       bullets)
 {
-  ply_list_node_t *node;
-  int i;
-  char *entered_text;
+        ply_list_node_t *node;
+        int i;
+        char *entered_text;
 
-  entered_text = calloc (bullets + 1, sizeof (char));
+        entered_text = calloc (bullets + 1, sizeof(char));
 
-  for (i = 0; i < bullets; i++)
-    entered_text[i] = '*';
+        for (i = 0; i < bullets; i++) {
+                entered_text[i] = '*';
+        }
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, prompt, entered_text);
+                view_show_prompt (view, prompt, entered_text);
 
-      node = next_node;
-    }
-  free (entered_text);
+                node = next_node;
+        }
+        free (entered_text);
 }
 
 static void
@@ -657,21 +642,20 @@ show_prompt (ply_boot_splash_plugin_t *plugin,
              const char               *prompt,
              const char               *text)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, prompt, text);
+                view_show_prompt (view, prompt, text);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
@@ -679,18 +663,18 @@ display_password (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   int                       bullets)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin);
 
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
 
-  if (!prompt)
-    prompt = "Password";
+        if (!prompt)
+                prompt = "Password";
 
-  show_password_prompt (plugin, prompt, bullets);
+        show_password_prompt (plugin, prompt, bullets);
 
-  unpause_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
@@ -698,40 +682,40 @@ display_question (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   const char               *entry_text)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin);
 
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
 
-  if (!prompt)
-    prompt = "Password";
+        if (!prompt)
+                prompt = "Password";
 
-  show_prompt (plugin, prompt, entry_text);
+        show_prompt (plugin, prompt, entry_text);
 
-  unpause_views (plugin);
+        unpause_views (plugin);
 }
 
 ply_boot_splash_plugin_interface_t *
 ply_boot_splash_plugin_get_interface (void)
 {
-  static ply_boot_splash_plugin_interface_t plugin_interface =
-    {
-      .create_plugin = create_plugin,
-      .destroy_plugin = destroy_plugin,
-      .add_text_display = add_text_display,
-      .remove_text_display = remove_text_display,
-      .show_splash_screen = show_splash_screen,
-      .update_status = update_status,
-      .on_boot_progress = on_boot_progress,
-      .hide_splash_screen = hide_splash_screen,
-      .display_normal = display_normal,
-      .display_message = display_message,
-      .display_password = display_password,
-      .display_question = display_question,      
-    };
-
-  return &plugin_interface;
+        static ply_boot_splash_plugin_interface_t plugin_interface =
+        {
+                .create_plugin       = create_plugin,
+                .destroy_plugin      = destroy_plugin,
+                .add_text_display    = add_text_display,
+                .remove_text_display = remove_text_display,
+                .show_splash_screen  = show_splash_screen,
+                .update_status       = update_status,
+                .on_boot_progress    = on_boot_progress,
+                .hide_splash_screen  = hide_splash_screen,
+                .display_normal      = display_normal,
+                .display_message     = display_message,
+                .display_password    = display_password,
+                .display_question    = display_question,
+        };
+
+        return &plugin_interface;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/plugins/splash/throbgress/plugin.c b/src/plugins/splash/throbgress/plugin.c
index fba809b..c105e02 100644
--- a/src/plugins/splash/throbgress/plugin.c
+++ b/src/plugins/splash/throbgress/plugin.c
@@ -65,48 +65,49 @@
 #define BAR_HEIGHT 16
 #endif
 
-typedef enum {
-   PLY_BOOT_SPLASH_DISPLAY_NORMAL,
-   PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
-   PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
+typedef enum
+{
+        PLY_BOOT_SPLASH_DISPLAY_NORMAL,
+        PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
+        PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
 } ply_boot_splash_display_type_t;
 
 typedef struct
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_pixel_display_t *display;
-  ply_entry_t *entry;
-  ply_throbber_t *throbber;
-  ply_progress_bar_t *progress_bar;
-  ply_label_t *label;
-  ply_label_t *message_label;
-  ply_rectangle_t box_area, lock_area, logo_area, bar_area;
+        ply_boot_splash_plugin_t *plugin;
+        ply_pixel_display_t      *display;
+        ply_entry_t              *entry;
+        ply_throbber_t           *throbber;
+        ply_progress_bar_t       *progress_bar;
+        ply_label_t              *label;
+        ply_label_t              *message_label;
+        ply_rectangle_t           box_area, lock_area, logo_area, bar_area;
 } view_t;
 
 struct _ply_boot_splash_plugin
 {
-  ply_event_loop_t *loop;
-  ply_boot_splash_mode_t mode;
-  ply_image_t *logo_image;
-  ply_image_t *lock_image;
-  ply_image_t *box_image;
-  ply_list_t *views;
+        ply_event_loop_t              *loop;
+        ply_boot_splash_mode_t         mode;
+        ply_image_t                   *logo_image;
+        ply_image_t                   *lock_image;
+        ply_image_t                   *box_image;
+        ply_list_t                    *views;
 
-  char *image_dir;
-  ply_boot_splash_display_type_t state;
+        char                          *image_dir;
+        ply_boot_splash_display_type_t state;
 
-  uint32_t background_start_color;
-  uint32_t background_end_color;
+        uint32_t                       background_start_color;
+        uint32_t                       background_end_color;
 
-  ply_trigger_t *idle_trigger;
+        ply_trigger_t                 *idle_trigger;
 
-  uint32_t root_is_mounted : 1;
-  uint32_t is_visible : 1;
-  uint32_t is_animating : 1;
-  uint32_t is_idle : 1;
+        uint32_t                       root_is_mounted : 1;
+        uint32_t                       is_visible : 1;
+        uint32_t                       is_animating : 1;
+        uint32_t                       is_idle : 1;
 };
 
-ply_boot_splash_plugin_interface_t * ply_boot_splash_plugin_get_interface (void);
+ply_boot_splash_plugin_interface_t *ply_boot_splash_plugin_get_interface (void);
 static void detach_from_event_loop (ply_boot_splash_plugin_t *plugin);
 
 static void become_idle (ply_boot_splash_plugin_t *plugin,
@@ -116,342 +117,333 @@ static view_t *
 view_new (ply_boot_splash_plugin_t *plugin,
           ply_pixel_display_t      *display)
 {
-  view_t *view;
+        view_t *view;
 
-  view = calloc (1, sizeof (view_t));
-  view->plugin = plugin;
-  view->display = display;
+        view = calloc (1, sizeof(view_t));
+        view->plugin = plugin;
+        view->display = display;
 
-  view->entry = ply_entry_new (plugin->image_dir);
-  view->throbber = ply_throbber_new (plugin->image_dir,
-                                     "throbber-");
-  view->progress_bar = ply_progress_bar_new ();
-  view->label = ply_label_new ();
-  view->message_label = ply_label_new ();
+        view->entry = ply_entry_new (plugin->image_dir);
+        view->throbber = ply_throbber_new (plugin->image_dir,
+                                           "throbber-");
+        view->progress_bar = ply_progress_bar_new ();
+        view->label = ply_label_new ();
+        view->message_label = ply_label_new ();
 
-  return view;
+        return view;
 }
 
 static void
 view_free (view_t *view)
 {
+        ply_entry_free (view->entry);
+        ply_throbber_free (view->throbber);
+        ply_progress_bar_free (view->progress_bar);
+        ply_label_free (view->label);
+        ply_label_free (view->message_label);
 
-  ply_entry_free (view->entry);
-  ply_throbber_free (view->throbber);
-  ply_progress_bar_free (view->progress_bar);
-  ply_label_free (view->label);
-  ply_label_free (view->message_label);
-
-  free (view);
+        free (view);
 }
 
 static void
 free_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_free (view);
-      ply_list_remove_node (plugin->views, node);
+                view_free (view);
+                ply_list_remove_node (plugin->views, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  ply_list_free (plugin->views);
-  plugin->views = NULL;
+        ply_list_free (plugin->views);
+        plugin->views = NULL;
 }
 
 static bool
 view_load (view_t *view)
 {
-  ply_trace ("loading entry");
-  if (!ply_entry_load (view->entry))
-    return false;
+        ply_trace ("loading entry");
+        if (!ply_entry_load (view->entry))
+                return false;
 
-  ply_trace ("loading throbber");
-  if (!ply_throbber_load (view->throbber))
-    return false;
+        ply_trace ("loading throbber");
+        if (!ply_throbber_load (view->throbber))
+                return false;
 
-  return true;
+        return true;
 }
 
 static bool
 load_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
-  bool view_loaded;
+        ply_list_node_t *node;
+        bool view_loaded;
 
-  view_loaded = false;
-  node = ply_list_get_first_node (plugin->views);
+        view_loaded = false;
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view_load (view))
-        view_loaded = true;
+                if (view_load (view))
+                        view_loaded = true;
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  return view_loaded;
+        return view_loaded;
 }
 
 static void
 view_redraw (view_t *view)
 {
-  unsigned long screen_width, screen_height;
+        unsigned long screen_width, screen_height;
 
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
 
-  ply_pixel_display_draw_area (view->display, 0, 0,
-                               screen_width, screen_height);
+        ply_pixel_display_draw_area (view->display, 0, 0,
+                                     screen_width, screen_height);
 }
 
 static void
 redraw_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_redraw (view);
+                view_redraw (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 pause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("pausing views");
+        ply_trace ("pausing views");
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_pixel_display_pause_updates (view->display);
+                ply_pixel_display_pause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 unpause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("unpausing views");
+        ply_trace ("unpausing views");
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_pixel_display_unpause_updates (view->display);
+                ply_pixel_display_unpause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 view_start_animation (view_t *view)
 {
-  ply_boot_splash_plugin_t *plugin;
+        ply_boot_splash_plugin_t *plugin;
 
-  unsigned long screen_width, screen_height;
-  long width, height;
+        unsigned long screen_width, screen_height;
+        long width, height;
 
-  assert (view != NULL);
+        assert (view != NULL);
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  assert (plugin != NULL);
-  assert (plugin->loop != NULL);
+        assert (plugin != NULL);
+        assert (plugin->loop != NULL);
 
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
 
-  ply_pixel_display_draw_area (view->display, 0, 0,
-                               screen_width, screen_height);
+        ply_pixel_display_draw_area (view->display, 0, 0,
+                                     screen_width, screen_height);
 
-  if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
-    return;
+        if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
+                return;
 
-  plugin->is_idle = false;
+        plugin->is_idle = false;
 
-  width = ply_throbber_get_width (view->throbber);
-  height = ply_throbber_get_height (view->throbber);
-  ply_throbber_start (view->throbber,
-                      plugin->loop,
-                      view->display,
-                      screen_width / 2.0 - width / 2.0,
-                      view->logo_area.y + view->logo_area.height + height / 2);
-  ply_progress_bar_show (view->progress_bar,
-                         view->display,
-                         0, screen_height - ply_progress_bar_get_height (view->progress_bar));
-  view_redraw (view);
+        width = ply_throbber_get_width (view->throbber);
+        height = ply_throbber_get_height (view->throbber);
+        ply_throbber_start (view->throbber,
+                            plugin->loop,
+                            view->display,
+                            screen_width / 2.0 - width / 2.0,
+                            view->logo_area.y + view->logo_area.height + height / 2);
+        ply_progress_bar_show (view->progress_bar,
+                               view->display,
+                               0, screen_height - ply_progress_bar_get_height (view->progress_bar));
+        view_redraw (view);
 }
 
 static void
 view_show_prompt (view_t     *view,
                   const char *prompt)
 {
-  ply_boot_splash_plugin_t *plugin;
-  int x, y;
-  int entry_width, entry_height;
+        ply_boot_splash_plugin_t *plugin;
+        int x, y;
+        int entry_width, entry_height;
 
-  assert (view != NULL);
+        assert (view != NULL);
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  if (ply_entry_is_hidden (view->entry))
-    {
-      unsigned long screen_width, screen_height;
+        if (ply_entry_is_hidden (view->entry)) {
+                unsigned long screen_width, screen_height;
 
-      screen_width = ply_pixel_display_get_width (view->display);
-      screen_height = ply_pixel_display_get_height (view->display);
+                screen_width = ply_pixel_display_get_width (view->display);
+                screen_height = ply_pixel_display_get_height (view->display);
 
-      view->box_area.width = ply_image_get_width (plugin->box_image);
-      view->box_area.height = ply_image_get_height (plugin->box_image);
-      view->box_area.x = screen_width / 2.0 - view->box_area.width / 2.0;
-      view->box_area.y = screen_height / 2.0 - view->box_area.height / 2.0;
+                view->box_area.width = ply_image_get_width (plugin->box_image);
+                view->box_area.height = ply_image_get_height (plugin->box_image);
+                view->box_area.x = screen_width / 2.0 - view->box_area.width / 2.0;
+                view->box_area.y = screen_height / 2.0 - view->box_area.height / 2.0;
 
-      view->lock_area.width = ply_image_get_width (plugin->lock_image);
-      view->lock_area.height = ply_image_get_height (plugin->lock_image);
+                view->lock_area.width = ply_image_get_width (plugin->lock_image);
+                view->lock_area.height = ply_image_get_height (plugin->lock_image);
 
-      entry_width = ply_entry_get_width (view->entry);
-      entry_height = ply_entry_get_height (view->entry);
+                entry_width = ply_entry_get_width (view->entry);
+                entry_height = ply_entry_get_height (view->entry);
 
-      x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0 + view->lock_area.width;
-      y = screen_height / 2.0 - entry_height / 2.0;
+                x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0 + view->lock_area.width;
+                y = screen_height / 2.0 - entry_height / 2.0;
 
-      view->lock_area.x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0;
-      view->lock_area.y = screen_height / 2.0 - view->lock_area.height / 2.0;
+                view->lock_area.x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0;
+                view->lock_area.y = screen_height / 2.0 - view->lock_area.height / 2.0;
 
-      ply_entry_show (view->entry, plugin->loop, view->display, x, y);
-    }
+                ply_entry_show (view->entry, plugin->loop, view->display, x, y);
+        }
 
-  if (prompt != NULL)
-    {
-      ply_label_set_text (view->label, prompt);
+        if (prompt != NULL) {
+                ply_label_set_text (view->label, prompt);
 
-      x = view->box_area.x + view->lock_area.width / 2;
-      y = view->box_area.y + view->box_area.height;
+                x = view->box_area.x + view->lock_area.width / 2;
+                y = view->box_area.y + view->box_area.height;
 
-      ply_label_show (view->label, view->display, x, y);
-    }
+                ply_label_show (view->label, view->display, x, y);
+        }
 }
 
 static void
 view_hide_prompt (view_t *view)
 {
-  assert (view != NULL);
+        assert (view != NULL);
 
-  ply_entry_hide (view->entry);
-  ply_label_hide (view->label);
+        ply_entry_hide (view->entry);
+        ply_label_hide (view->label);
 }
 
 static ply_boot_splash_plugin_t *
 create_plugin (ply_key_file_t *key_file)
 {
-  ply_boot_splash_plugin_t *plugin;
-  char *image_dir, *image_path;
-  char *color;
+        ply_boot_splash_plugin_t *plugin;
+        char *image_dir, *image_path;
+        char *color;
 
-  srand ((int) ply_get_timestamp ());
-  plugin = calloc (1, sizeof (ply_boot_splash_plugin_t));
+        srand ((int) ply_get_timestamp ());
+        plugin = calloc (1, sizeof(ply_boot_splash_plugin_t));
 
-  plugin->logo_image = ply_image_new (PLYMOUTH_LOGO_FILE);
-  image_dir = ply_key_file_get_value (key_file, "throbgress", "ImageDir");
+        plugin->logo_image = ply_image_new (PLYMOUTH_LOGO_FILE);
+        image_dir = ply_key_file_get_value (key_file, "throbgress", "ImageDir");
 
-  asprintf (&image_path, "%s/lock.png", image_dir);
-  plugin->lock_image = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/lock.png", image_dir);
+        plugin->lock_image = ply_image_new (image_path);
+        free (image_path);
 
-  asprintf (&image_path, "%s/box.png", image_dir);
-  plugin->box_image = ply_image_new (image_path);
-  free (image_path);
+        asprintf (&image_path, "%s/box.png", image_dir);
+        plugin->box_image = ply_image_new (image_path);
+        free (image_path);
 
-  plugin->image_dir = image_dir;
-  plugin->views = ply_list_new ();
+        plugin->image_dir = image_dir;
+        plugin->views = ply_list_new ();
 
-  color = ply_key_file_get_value (key_file, "throbgress", "BackgroundStartColor");
+        color = ply_key_file_get_value (key_file, "throbgress", "BackgroundStartColor");
 
-  if (color != NULL)
-    plugin->background_start_color = strtol (color, NULL, 0);
-  else
-    plugin->background_start_color = PLYMOUTH_BACKGROUND_START_COLOR;
+        if (color != NULL)
+                plugin->background_start_color = strtol (color, NULL, 0);
+        else
+                plugin->background_start_color = PLYMOUTH_BACKGROUND_START_COLOR;
 
-  free (color);
+        free (color);
 
-  color = ply_key_file_get_value (key_file, "throbgress", "BackgroundEndColor");
+        color = ply_key_file_get_value (key_file, "throbgress", "BackgroundEndColor");
 
-  if (color != NULL)
-    plugin->background_end_color = strtol (color, NULL, 0);
-  else
-    plugin->background_end_color = PLYMOUTH_BACKGROUND_END_COLOR;
+        if (color != NULL)
+                plugin->background_end_color = strtol (color, NULL, 0);
+        else
+                plugin->background_end_color = PLYMOUTH_BACKGROUND_END_COLOR;
 
-  free (color);
+        free (color);
 
-  return plugin;
+        return plugin;
 }
 
 static void
 destroy_plugin (ply_boot_splash_plugin_t *plugin)
 {
-  if (plugin == NULL)
-    return;
+        if (plugin == NULL)
+                return;
 
-  ply_trace ("destroying plugin");
+        ply_trace ("destroying plugin");
 
-  if (plugin->loop != NULL)
-    {
-      ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
+        if (plugin->loop != NULL) {
+                ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
 
-  ply_image_free (plugin->logo_image);
-  ply_image_free (plugin->box_image);
-  ply_image_free (plugin->lock_image);
+        ply_image_free (plugin->logo_image);
+        ply_image_free (plugin->box_image);
+        ply_image_free (plugin->lock_image);
 
-  free_views (plugin);
+        free_views (plugin);
 
-  free (plugin);
+        free (plugin);
 }
 
 static void
@@ -462,211 +454,204 @@ draw_background (view_t             *view,
                  int                 width,
                  int                 height)
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_rectangle_t area;
+        ply_boot_splash_plugin_t *plugin;
+        ply_rectangle_t area;
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  area.x = x;
-  area.y = y;
-  area.width = width;
-  area.height = height;
+        area.x = x;
+        area.y = y;
+        area.width = width;
+        area.height = height;
 
-  if (plugin->background_start_color != plugin->background_end_color)
-    ply_pixel_buffer_fill_with_gradient (pixel_buffer, &area,
-                                         plugin->background_start_color,
-                                         plugin->background_end_color);
-  else
-    ply_pixel_buffer_fill_with_hex_color (pixel_buffer, &area,
-                                          plugin->background_start_color);
+        if (plugin->background_start_color != plugin->background_end_color)
+                ply_pixel_buffer_fill_with_gradient (pixel_buffer, &area,
+                                                     plugin->background_start_color,
+                                                     plugin->background_end_color);
+        else
+                ply_pixel_buffer_fill_with_hex_color (pixel_buffer, &area,
+                                                      plugin->background_start_color);
 }
 
 static void
-draw_logo (view_t                   *view,
-           ply_pixel_buffer_t       *pixel_buffer)
+draw_logo (view_t             *view,
+           ply_pixel_buffer_t *pixel_buffer)
 {
-  ply_boot_splash_plugin_t *plugin;
-  uint32_t *logo_data;
-  unsigned long screen_width, screen_height;
-  long width, height;
+        ply_boot_splash_plugin_t *plugin;
+        uint32_t *logo_data;
+        unsigned long screen_width, screen_height;
+        long width, height;
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
 
-  width = ply_image_get_width (plugin->logo_image);
-  height = ply_image_get_height (plugin->logo_image);
-  logo_data = ply_image_get_data (plugin->logo_image);
-  view->logo_area.x = (screen_width / 2) - (width / 2);
-  view->logo_area.y = (screen_height / 2) - (height / 2);
-  view->logo_area.width = width;
-  view->logo_area.height = height;
+        width = ply_image_get_width (plugin->logo_image);
+        height = ply_image_get_height (plugin->logo_image);
+        logo_data = ply_image_get_data (plugin->logo_image);
+        view->logo_area.x = (screen_width / 2) - (width / 2);
+        view->logo_area.y = (screen_height / 2) - (height / 2);
+        view->logo_area.width = width;
+        view->logo_area.height = height;
 
-  ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
-                                          &view->logo_area,
-                                          logo_data);
+        ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
+                                                &view->logo_area,
+                                                logo_data);
 }
 
 static void
 start_animation (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (plugin->is_animating)
-     return;
+        if (plugin->is_animating)
+                return;
 
-  ply_trace ("starting animation");
+        ply_trace ("starting animation");
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_start_animation (view);
+                view_start_animation (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  plugin->is_animating = true;
+        plugin->is_animating = true;
 
-  if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
-    plugin->is_idle = true;
+        if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
+                plugin->is_idle = true;
 }
 
 static void
 stop_animation (ply_boot_splash_plugin_t *plugin,
                 ply_trigger_t            *trigger)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (plugin != NULL);
-  assert (plugin->loop != NULL);
+        assert (plugin != NULL);
+        assert (plugin->loop != NULL);
 
-  if (!plugin->is_animating)
-     return;
+        if (!plugin->is_animating)
+                return;
 
-  ply_trace ("stopping animation%s",
-             trigger != NULL? " with trigger" : "");
+        ply_trace ("stopping animation%s",
+                   trigger != NULL ? " with trigger" : "");
 
-  plugin->is_animating = false;
+        plugin->is_animating = false;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_progress_bar_hide (view->progress_bar);
-      if (trigger != NULL)
-        ply_trigger_ignore_next_pull (trigger);
-      ply_throbber_stop (view->throbber, trigger);
+                ply_progress_bar_hide (view->progress_bar);
+                if (trigger != NULL)
+                        ply_trigger_ignore_next_pull (trigger);
+                ply_throbber_stop (view->throbber, trigger);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  if (trigger != NULL)
-    ply_trigger_pull (trigger, NULL);
+        if (trigger != NULL)
+                ply_trigger_pull (trigger, NULL);
 }
 
 static void
 detach_from_event_loop (ply_boot_splash_plugin_t *plugin)
 {
-  plugin->loop = NULL;
+        plugin->loop = NULL;
 }
 
 static void
-on_draw (view_t                   *view,
-         ply_pixel_buffer_t       *pixel_buffer,
-         int                       x,
-         int                       y,
-         int                       width,
-         int                       height)
+on_draw (view_t             *view,
+         ply_pixel_buffer_t *pixel_buffer,
+         int                 x,
+         int                 y,
+         int                 width,
+         int                 height)
 {
-  ply_boot_splash_plugin_t *plugin;
-  plugin = view->plugin;
+        ply_boot_splash_plugin_t *plugin;
+
+        plugin = view->plugin;
 
-  draw_background (view, pixel_buffer, x, y, width, height);
+        draw_background (view, pixel_buffer, x, y, width, height);
 
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY ||
-      plugin->state == PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY  )
-    {
-      uint32_t *box_data, *lock_data;
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY ||
+            plugin->state == PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY) {
+                uint32_t *box_data, *lock_data;
 
-      box_data = ply_image_get_data (plugin->box_image);
-      ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
-                                              &view->box_area,
-                                              box_data);
-      ply_entry_draw_area (view->entry, pixel_buffer, x, y, width, height);
-      ply_label_draw_area (view->label, pixel_buffer, x, y, width, height);
-      lock_data = ply_image_get_data (plugin->lock_image);
-      ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
-                                              &view->lock_area,
-                                              lock_data);
-    }
-  else
-    {
-      draw_logo (view, pixel_buffer);
-      ply_throbber_draw_area (view->throbber,
-                              pixel_buffer, x, y, width, height);
-      ply_progress_bar_draw_area (view->progress_bar,
-                                  pixel_buffer, x, y, width, height);
-    }
-  ply_label_draw_area (view->message_label,
-                       pixel_buffer,
-                       x, y, width, height);
+                box_data = ply_image_get_data (plugin->box_image);
+                ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
+                                                        &view->box_area,
+                                                        box_data);
+                ply_entry_draw_area (view->entry, pixel_buffer, x, y, width, height);
+                ply_label_draw_area (view->label, pixel_buffer, x, y, width, height);
+                lock_data = ply_image_get_data (plugin->lock_image);
+                ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
+                                                        &view->lock_area,
+                                                        lock_data);
+        } else {
+                draw_logo (view, pixel_buffer);
+                ply_throbber_draw_area (view->throbber,
+                                        pixel_buffer, x, y, width, height);
+                ply_progress_bar_draw_area (view->progress_bar,
+                                            pixel_buffer, x, y, width, height);
+        }
+        ply_label_draw_area (view->message_label,
+                             pixel_buffer,
+                             x, y, width, height);
 }
 
 static void
 add_pixel_display (ply_boot_splash_plugin_t *plugin,
                    ply_pixel_display_t      *display)
 {
-  view_t *view;
+        view_t *view;
 
-  ply_trace ("adding pixel display to plugin");
-  view = view_new (plugin, display);
+        ply_trace ("adding pixel display to plugin");
+        view = view_new (plugin, display);
 
-  ply_pixel_display_set_draw_handler (view->display,
-                                      (ply_pixel_display_draw_handler_t)
-                                      on_draw, view);
+        ply_pixel_display_set_draw_handler (view->display,
+                                            (ply_pixel_display_draw_handler_t)
+                                            on_draw, view);
 
-  ply_list_append_data (plugin->views, view);
+        ply_list_append_data (plugin->views, view);
 }
 
 static void
 remove_pixel_display (ply_boot_splash_plugin_t *plugin,
                       ply_pixel_display_t      *display)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("removing pixel display from plugin");
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      view_t *view;
-      ply_list_node_t *next_node;
+        ply_trace ("removing pixel display from plugin");
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                view_t *view;
+                ply_list_node_t *next_node;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view->display == display)
-        {
+                if (view->display == display) {
+                        ply_pixel_display_set_draw_handler (view->display, NULL, NULL);
+                        view_free (view);
+                        ply_list_remove_node (plugin->views, node);
+                        return;
+                }
 
-          ply_pixel_display_set_draw_handler (view->display, NULL, NULL);
-          view_free (view);
-          ply_list_remove_node (plugin->views, node);
-          return;
+                node = next_node;
         }
-
-      node = next_node;
-    }
 }
 
 static bool
@@ -675,47 +660,46 @@ show_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_buffer_t             *boot_buffer,
                     ply_boot_splash_mode_t    mode)
 {
-  assert (plugin != NULL);
-  assert (plugin->logo_image != NULL);
+        assert (plugin != NULL);
+        assert (plugin->logo_image != NULL);
 
-  plugin->loop = loop;
-  plugin->mode = mode;
+        plugin->loop = loop;
+        plugin->mode = mode;
 
-  ply_trace ("loading logo image");
-  if (!ply_image_load (plugin->logo_image))
-    return false;
+        ply_trace ("loading logo image");
+        if (!ply_image_load (plugin->logo_image))
+                return false;
 
-  ply_trace ("loading lock image");
-  if (!ply_image_load (plugin->lock_image))
-    return false;
+        ply_trace ("loading lock image");
+        if (!ply_image_load (plugin->lock_image))
+                return false;
 
-  ply_trace ("loading box image");
-  if (!ply_image_load (plugin->box_image))
-    return false;
+        ply_trace ("loading box image");
+        if (!ply_image_load (plugin->box_image))
+                return false;
 
-  if (!load_views (plugin))
-    {
-      ply_trace ("couldn't load views");
-      return false;
-    }
+        if (!load_views (plugin)) {
+                ply_trace ("couldn't load views");
+                return false;
+        }
 
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
-                                 detach_from_event_loop,
-                                 plugin);
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       detach_from_event_loop,
+                                       plugin);
 
-  ply_trace ("starting boot animation");
-  start_animation (plugin);
+        ply_trace ("starting boot animation");
+        start_animation (plugin);
 
-  plugin->is_visible = true;
+        plugin->is_visible = true;
 
-  return true;
+        return true;
 }
 
 static void
 update_status (ply_boot_splash_plugin_t *plugin,
                const char               *status)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 }
 
 static void
@@ -723,53 +707,51 @@ on_boot_progress (ply_boot_splash_plugin_t *plugin,
                   double                    duration,
                   double                    percent_done)
 {
-  ply_list_node_t *node;
-  double total_duration;
+        ply_list_node_t *node;
+        double total_duration;
 
-  if (plugin->mode == PLY_BOOT_SPLASH_MODE_UPDATES)
-    return;
+        if (plugin->mode == PLY_BOOT_SPLASH_MODE_UPDATES)
+                return;
 
-  total_duration = duration / percent_done;
+        total_duration = duration / percent_done;
 
-  /* Fun made-up smoothing function to make the growth asymptotic:
-   * fraction(time,estimate)=1-2^(-(time^1.45)/estimate) */
-  percent_done = 1.0 - pow (2.0, -pow (duration, 1.45) / total_duration) * (1.0 - percent_done);
+        /* Fun made-up smoothing function to make the growth asymptotic:
+         * fraction(time,estimate)=1-2^(-(time^1.45)/estimate) */
+        percent_done = 1.0 - pow (2.0, -pow (duration, 1.45) / total_duration) * (1.0 - percent_done);
 
-  node = ply_list_get_first_node (plugin->views);
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_progress_bar_set_percent_done (view->progress_bar, percent_done);
-      ply_progress_bar_draw (view->progress_bar);
+                ply_progress_bar_set_percent_done (view->progress_bar, percent_done);
+                ply_progress_bar_draw (view->progress_bar);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 hide_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_event_loop_t         *loop)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  ply_trace ("hiding splash");
-  if (plugin->loop != NULL)
-    {
-      stop_animation (plugin, NULL);
+        ply_trace ("hiding splash");
+        if (plugin->loop != NULL) {
+                stop_animation (plugin, NULL);
 
-      ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
+                ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
 
-  plugin->is_visible = false;
+        plugin->is_visible = false;
 }
 
 static void
@@ -777,23 +759,22 @@ show_password_prompt (ply_boot_splash_plugin_t *plugin,
                       const char               *text,
                       int                       number_of_bullets)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("showing password prompt");
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        ply_trace ("showing password prompt");
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, text);
-      ply_entry_set_bullet_count (view->entry, number_of_bullets);
+                view_show_prompt (view, text);
+                ply_entry_set_bullet_count (view->entry, number_of_bullets);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
@@ -801,67 +782,64 @@ show_prompt (ply_boot_splash_plugin_t *plugin,
              const char               *prompt,
              const char               *entry_text)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("showing prompt");
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        ply_trace ("showing prompt");
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, prompt);
-      ply_entry_set_text (view->entry, entry_text);
+                view_show_prompt (view, prompt);
+                ply_entry_set_text (view->entry, entry_text);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 on_root_mounted (ply_boot_splash_plugin_t *plugin)
 {
-  ply_trace ("root filesystem mounted");
-  plugin->root_is_mounted = true;
+        ply_trace ("root filesystem mounted");
+        plugin->root_is_mounted = true;
 }
 
 static void
 become_idle (ply_boot_splash_plugin_t *plugin,
              ply_trigger_t            *idle_trigger)
 {
-  ply_trace ("deactivation requested");
-  if (plugin->is_idle)
-    {
-      ply_trace ("plugin is already idle");
-      ply_trigger_pull (idle_trigger, NULL);
-      return;
-    }
+        ply_trace ("deactivation requested");
+        if (plugin->is_idle) {
+                ply_trace ("plugin is already idle");
+                ply_trigger_pull (idle_trigger, NULL);
+                return;
+        }
 
-  stop_animation (plugin, idle_trigger);
-  plugin->is_idle = true;
+        stop_animation (plugin, idle_trigger);
+        plugin->is_idle = true;
 }
 
 static void
 hide_prompt (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("hiding prompt");
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        ply_trace ("hiding prompt");
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_hide_prompt (view);
+                view_hide_prompt (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 
@@ -869,37 +847,36 @@ static void
 show_message (ply_boot_splash_plugin_t *plugin,
               const char               *message)
 {
-  ply_trace ("Showing message '%s'", message);
-  ply_list_node_t *node;
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
-
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
-      ply_label_set_text (view->message_label, message);
-      ply_label_show (view->message_label, view->display, 10, 10);
-
-      ply_pixel_display_draw_area (view->display, 10, 10,
-                                   ply_label_get_width (view->message_label),
-                                   ply_label_get_height(view->message_label));
-      node = next_node;
-    }
+        ply_trace ("Showing message '%s'", message);
+        ply_list_node_t *node;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
+
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
+                ply_label_set_text (view->message_label, message);
+                ply_label_show (view->message_label, view->display, 10, 10);
+
+                ply_pixel_display_draw_area (view->display, 10, 10,
+                                             ply_label_get_width (view->message_label),
+                                             ply_label_get_height (view->message_label));
+                node = next_node;
+        }
 }
 
 static void
 display_normal (ply_boot_splash_plugin_t *plugin)
 {
-  pause_views (plugin);
-  if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    hide_prompt (plugin);
+        pause_views (plugin);
+        if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                hide_prompt (plugin);
 
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
-  start_animation (plugin);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
+        start_animation (plugin);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
@@ -907,14 +884,14 @@ display_password (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   int                       bullets)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin, NULL);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin, NULL);
 
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
-  show_password_prompt (plugin, prompt, bullets);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
+        show_password_prompt (plugin, prompt, bullets);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
@@ -922,69 +899,68 @@ display_question (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   const char               *entry_text)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin, NULL);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin, NULL);
 
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY;
-  show_prompt (plugin, prompt, entry_text);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY;
+        show_prompt (plugin, prompt, entry_text);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
 display_message (ply_boot_splash_plugin_t *plugin,
                  const char               *message)
 {
-  show_message (plugin, message);
+        show_message (plugin, message);
 }
 
 static void
 system_update (ply_boot_splash_plugin_t *plugin,
                int                       progress)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (plugin->mode != PLY_BOOT_SPLASH_MODE_UPDATES)
-    return;
+        if (plugin->mode != PLY_BOOT_SPLASH_MODE_UPDATES)
+                return;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
-      ply_progress_bar_set_percent_done (view->progress_bar, (double) progress / 100.f);
-      ply_progress_bar_draw (view->progress_bar);
-      node = next_node;
-    }
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
+                ply_progress_bar_set_percent_done (view->progress_bar, (double) progress / 100.f);
+                ply_progress_bar_draw (view->progress_bar);
+                node = next_node;
+        }
 }
 
 ply_boot_splash_plugin_interface_t *
 ply_boot_splash_plugin_get_interface (void)
 {
-  static ply_boot_splash_plugin_interface_t plugin_interface =
-    {
-      .create_plugin = create_plugin,
-      .destroy_plugin = destroy_plugin,
-      .add_pixel_display = add_pixel_display,
-      .remove_pixel_display = remove_pixel_display,
-      .show_splash_screen = show_splash_screen,
-      .update_status = update_status,
-      .on_boot_progress = on_boot_progress,
-      .hide_splash_screen = hide_splash_screen,
-      .on_root_mounted = on_root_mounted,
-      .become_idle = become_idle,
-      .display_normal = display_normal,
-      .display_password = display_password,
-      .display_question = display_question,      
-      .display_message = display_message,
-      .system_update = system_update,
-    };
-
-  return &plugin_interface;
+        static ply_boot_splash_plugin_interface_t plugin_interface =
+        {
+                .create_plugin        = create_plugin,
+                .destroy_plugin       = destroy_plugin,
+                .add_pixel_display    = add_pixel_display,
+                .remove_pixel_display = remove_pixel_display,
+                .show_splash_screen   = show_splash_screen,
+                .update_status        = update_status,
+                .on_boot_progress     = on_boot_progress,
+                .hide_splash_screen   = hide_splash_screen,
+                .on_root_mounted      = on_root_mounted,
+                .become_idle          = become_idle,
+                .display_normal       = display_normal,
+                .display_password     = display_password,
+                .display_question     = display_question,
+                .display_message      = display_message,
+                .system_update        = system_update,
+        };
+
+        return &plugin_interface;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/plugins/splash/tribar/plugin.c b/src/plugins/splash/tribar/plugin.c
index 4458bad..0dcd7f8 100644
--- a/src/plugins/splash/tribar/plugin.c
+++ b/src/plugins/splash/tribar/plugin.c
@@ -54,32 +54,32 @@
 
 #include <linux/kd.h>
 
-typedef enum {
-   PLY_BOOT_SPLASH_DISPLAY_NORMAL,
-   PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
-   PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
+typedef enum
+{
+        PLY_BOOT_SPLASH_DISPLAY_NORMAL,
+        PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
+        PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
 } ply_boot_splash_display_type_t;
 
 struct _ply_boot_splash_plugin
 {
-  ply_event_loop_t *loop;
-  ply_boot_splash_mode_t mode;
+        ply_event_loop_t              *loop;
+        ply_boot_splash_mode_t         mode;
 
-  ply_list_t *views;
+        ply_list_t                    *views;
 
-  ply_boot_splash_display_type_t state;
+        ply_boot_splash_display_type_t state;
 
-  char *message;
+        char                          *message;
 
-  uint32_t is_animating : 1;
+        uint32_t                       is_animating : 1;
 };
 
 typedef struct
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_text_display_t *display;
-  ply_text_progress_bar_t *progress_bar;
-
+        ply_boot_splash_plugin_t *plugin;
+        ply_text_display_t       *display;
+        ply_text_progress_bar_t  *progress_bar;
 } view_t;
 
 ply_boot_splash_plugin_interface_t *ply_boot_splash_plugin_get_interface (void);
@@ -91,45 +91,45 @@ static view_t *
 view_new (ply_boot_splash_plugin_t *plugin,
           ply_text_display_t       *display)
 {
-  view_t *view;
+        view_t *view;
 
-  view = calloc (1, sizeof (view_t));
-  view->plugin = plugin;
-  view->display = display;
+        view = calloc (1, sizeof(view_t));
+        view->plugin = plugin;
+        view->display = display;
 
-  view->progress_bar = ply_text_progress_bar_new ();
+        view->progress_bar = ply_text_progress_bar_new ();
 
-  return view;
+        return view;
 }
 
 static void
 view_free (view_t *view)
 {
-  ply_text_progress_bar_free (view->progress_bar);
+        ply_text_progress_bar_free (view->progress_bar);
 
-  free (view);
+        free (view);
 }
 
 static void
 view_show_message (view_t *view)
 {
-  ply_boot_splash_plugin_t *plugin;
-  int display_width, display_height;
+        ply_boot_splash_plugin_t *plugin;
+        int display_width, display_height;
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  display_width = ply_text_display_get_number_of_columns (view->display);
-  display_height = ply_text_display_get_number_of_rows (view->display);
+        display_width = ply_text_display_get_number_of_columns (view->display);
+        display_height = ply_text_display_get_number_of_rows (view->display);
 
-  ply_text_display_set_cursor_position (view->display, 0,
-                                        display_height / 2);
-  ply_text_display_clear_line (view->display);
-  ply_text_display_set_cursor_position (view->display,
-                                        (display_width -
-                                        strlen (plugin->message)) / 2,
-                                        display_height / 2);
+        ply_text_display_set_cursor_position (view->display, 0,
+                                              display_height / 2);
+        ply_text_display_clear_line (view->display);
+        ply_text_display_set_cursor_position (view->display,
+                                              (display_width -
+                                               strlen (plugin->message)) / 2,
+                                              display_height / 2);
 
-  ply_text_display_write (view->display, "%s", plugin->message);
+        ply_text_display_write (view->display, "%s", plugin->message);
 }
 
 static void
@@ -137,385 +137,373 @@ view_show_prompt (view_t     *view,
                   const char *prompt,
                   const char *entered_text)
 {
+        int display_width, display_height;
+        int i;
 
-  int display_width, display_height;
-  int i;
-
-  display_width = ply_text_display_get_number_of_columns (view->display);
-  display_height = ply_text_display_get_number_of_rows (view->display);
-  ply_text_display_set_background_color (view->display, PLY_TERMINAL_COLOR_DEFAULT);
-  ply_text_display_clear_screen (view->display);
+        display_width = ply_text_display_get_number_of_columns (view->display);
+        display_height = ply_text_display_get_number_of_rows (view->display);
+        ply_text_display_set_background_color (view->display, PLY_TERMINAL_COLOR_DEFAULT);
+        ply_text_display_clear_screen (view->display);
 
-  ply_text_display_set_cursor_position (view->display, 0, display_height / 2);
+        ply_text_display_set_cursor_position (view->display, 0, display_height / 2);
 
-  for (i=0; i < display_width; i++)
-    ply_text_display_write (view->display, "%c", ' ');
+        for (i = 0; i < display_width; i++) {
+                ply_text_display_write (view->display, "%c", ' ');
+        }
 
-  ply_text_display_set_cursor_position (view->display,
-                                        display_width / 2 - (strlen (prompt)),
-                                        display_height / 2);
+        ply_text_display_set_cursor_position (view->display,
+                                              display_width / 2 - (strlen (prompt)),
+                                              display_height / 2);
 
-  ply_text_display_write (view->display, "%s:%s", prompt, entered_text);
+        ply_text_display_write (view->display, "%s:%s", prompt, entered_text);
 
-  ply_text_display_show_cursor (view->display);
+        ply_text_display_show_cursor (view->display);
 }
 
 static void
 view_start_animation (view_t *view)
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_terminal_t *terminal;
+        ply_boot_splash_plugin_t *plugin;
+        ply_terminal_t *terminal;
 
-  assert (view != NULL);
+        assert (view != NULL);
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  terminal = ply_text_display_get_terminal (view->display);
+        terminal = ply_text_display_get_terminal (view->display);
 
-  ply_terminal_set_color_hex_value (terminal,
-                                    PLY_TERMINAL_COLOR_BLACK,
-                                    0x000000);
-  ply_terminal_set_color_hex_value (terminal,
-                                    PLY_TERMINAL_COLOR_WHITE,
-                                    0xffffff);
-  ply_terminal_set_color_hex_value (terminal,
-                                    PLY_TERMINAL_COLOR_BLUE,
-                                    0x0073B3);
-  ply_terminal_set_color_hex_value (terminal,
-                                    PLY_TERMINAL_COLOR_BROWN,
-                                    0x00457E);
+        ply_terminal_set_color_hex_value (terminal,
+                                          PLY_TERMINAL_COLOR_BLACK,
+                                          0x000000);
+        ply_terminal_set_color_hex_value (terminal,
+                                          PLY_TERMINAL_COLOR_WHITE,
+                                          0xffffff);
+        ply_terminal_set_color_hex_value (terminal,
+                                          PLY_TERMINAL_COLOR_BLUE,
+                                          0x0073B3);
+        ply_terminal_set_color_hex_value (terminal,
+                                          PLY_TERMINAL_COLOR_BROWN,
+                                          0x00457E);
 
-  ply_text_display_set_background_color (view->display,
-                                         PLY_TERMINAL_COLOR_BLACK);
-  ply_text_display_clear_screen (view->display);
-  ply_text_display_hide_cursor (view->display);
+        ply_text_display_set_background_color (view->display,
+                                               PLY_TERMINAL_COLOR_BLACK);
+        ply_text_display_clear_screen (view->display);
+        ply_text_display_hide_cursor (view->display);
 
-  if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
-    {
-      ply_text_progress_bar_hide (view->progress_bar);
-      return;
-    }
+        if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN) {
+                ply_text_progress_bar_hide (view->progress_bar);
+                return;
+        }
 
-  ply_text_progress_bar_show (view->progress_bar,
-                              view->display);
+        ply_text_progress_bar_show (view->progress_bar,
+                                    view->display);
 }
 
 static void
 view_redraw (view_t *view)
 {
-  unsigned long screen_width, screen_height;
+        unsigned long screen_width, screen_height;
 
-  screen_width = ply_text_display_get_number_of_columns (view->display);
-  screen_height = ply_text_display_get_number_of_rows (view->display);
+        screen_width = ply_text_display_get_number_of_columns (view->display);
+        screen_height = ply_text_display_get_number_of_rows (view->display);
 
-  ply_text_display_draw_area (view->display, 0, 0,
-                              screen_width, screen_height);
+        ply_text_display_draw_area (view->display, 0, 0,
+                                    screen_width, screen_height);
 }
 
 static void
 redraw_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_redraw (view);
+                view_redraw (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 view_hide (view_t *view)
 {
-  if (view->display != NULL)
-    {
-      ply_terminal_t *terminal;
+        if (view->display != NULL) {
+                ply_terminal_t *terminal;
 
-      terminal = ply_text_display_get_terminal (view->display);
+                terminal = ply_text_display_get_terminal (view->display);
 
-      ply_text_display_set_background_color (view->display, PLY_TERMINAL_COLOR_DEFAULT);
-      ply_text_display_clear_screen (view->display);
-      ply_text_display_show_cursor (view->display);
+                ply_text_display_set_background_color (view->display, PLY_TERMINAL_COLOR_DEFAULT);
+                ply_text_display_clear_screen (view->display);
+                ply_text_display_show_cursor (view->display);
 
-      ply_terminal_reset_colors (terminal);
-    }
+                ply_terminal_reset_colors (terminal);
+        }
 }
 
 static void
 hide_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_hide (view);
+                view_hide (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 pause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_text_display_pause_updates (view->display);
+                ply_text_display_pause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 unpause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_text_display_unpause_updates (view->display);
+                ply_text_display_unpause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static ply_boot_splash_plugin_t *
 create_plugin (ply_key_file_t *key_file)
 {
-  ply_boot_splash_plugin_t *plugin;
+        ply_boot_splash_plugin_t *plugin;
 
-  ply_trace ("creating plugin");
+        ply_trace ("creating plugin");
 
-  plugin = calloc (1, sizeof (ply_boot_splash_plugin_t));
-  plugin->message = NULL;
+        plugin = calloc (1, sizeof(ply_boot_splash_plugin_t));
+        plugin->message = NULL;
 
-  plugin->views = ply_list_new ();
+        plugin->views = ply_list_new ();
 
-  return plugin;
+        return plugin;
 }
 
 static void
 detach_from_event_loop (ply_boot_splash_plugin_t *plugin)
 {
-  plugin->loop = NULL;
+        plugin->loop = NULL;
 
-  ply_trace ("detaching from event loop");
+        ply_trace ("detaching from event loop");
 }
 
 static void
 free_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_free (view);
-      ply_list_remove_node (plugin->views, node);
+                view_free (view);
+                ply_list_remove_node (plugin->views, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  ply_list_free (plugin->views);
-  plugin->views = NULL;
+        ply_list_free (plugin->views);
+        plugin->views = NULL;
 }
 
 static void
 destroy_plugin (ply_boot_splash_plugin_t *plugin)
 {
-  ply_trace ("destroying plugin");
+        ply_trace ("destroying plugin");
 
-  if (plugin == NULL)
-    return;
+        if (plugin == NULL)
+                return;
 
-  /* It doesn't ever make sense to keep this plugin on screen
-   * after exit
-   */
-  hide_splash_screen (plugin, plugin->loop);
+        /* It doesn't ever make sense to keep this plugin on screen
+         * after exit
+         */
+        hide_splash_screen (plugin, plugin->loop);
 
-  free_views (plugin);
-  if (plugin->message != NULL)
-    free (plugin->message);
+        free_views (plugin);
+        if (plugin->message != NULL)
+                free (plugin->message);
 
-  free (plugin);
+        free (plugin);
 }
 
 static void
 show_message (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_message (view);
+                view_show_message (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 start_animation (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (plugin != NULL);
-  assert (plugin->loop != NULL);
+        assert (plugin != NULL);
+        assert (plugin->loop != NULL);
 
-  redraw_views (plugin);
+        redraw_views (plugin);
 
-  if (plugin->message != NULL)
-    show_message (plugin);
+        if (plugin->message != NULL)
+                show_message (plugin);
 
-  if (plugin->is_animating)
-     return;
+        if (plugin->is_animating)
+                return;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_start_animation (view);
+                view_start_animation (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  plugin->is_animating = true;
+        plugin->is_animating = true;
 }
 
 static void
 stop_animation (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (plugin != NULL);
-  assert (plugin->loop != NULL);
+        assert (plugin != NULL);
+        assert (plugin->loop != NULL);
 
-  if (!plugin->is_animating)
-     return;
+        if (!plugin->is_animating)
+                return;
 
-  plugin->is_animating = false;
+        plugin->is_animating = false;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_text_progress_bar_hide (view->progress_bar);
+                ply_text_progress_bar_hide (view->progress_bar);
 
-      node = next_node;
-    }
-  redraw_views (plugin);
+                node = next_node;
+        }
+        redraw_views (plugin);
 }
 
 static void
-on_draw (view_t                   *view,
-         ply_terminal_t           *terminal,
-         int                       x,
-         int                       y,
-         int                       width,
-         int                       height)
+on_draw (view_t         *view,
+         ply_terminal_t *terminal,
+         int             x,
+         int             y,
+         int             width,
+         int             height)
 {
-  ply_text_display_clear_screen (view->display);
+        ply_text_display_clear_screen (view->display);
 }
 
 static void
 add_text_display (ply_boot_splash_plugin_t *plugin,
                   ply_text_display_t       *display)
 {
-  view_t *view;
-  ply_terminal_t *terminal;
+        view_t *view;
+        ply_terminal_t *terminal;
 
-  view = view_new (plugin, display);
+        view = view_new (plugin, display);
 
-  terminal = ply_text_display_get_terminal (view->display);
-  if (ply_terminal_open (terminal))
-    ply_terminal_activate_vt (terminal);
+        terminal = ply_text_display_get_terminal (view->display);
+        if (ply_terminal_open (terminal))
+                ply_terminal_activate_vt (terminal);
 
-  ply_text_display_set_draw_handler (view->display,
-                                     (ply_text_display_draw_handler_t)
-                                     on_draw, view);
+        ply_text_display_set_draw_handler (view->display,
+                                           (ply_text_display_draw_handler_t)
+                                           on_draw, view);
 
-  ply_list_append_data (plugin->views, view);
+        ply_list_append_data (plugin->views, view);
 }
 
 static void
 remove_text_display (ply_boot_splash_plugin_t *plugin,
                      ply_text_display_t       *display)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      view_t *view;
-      ply_list_node_t *next_node;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                view_t *view;
+                ply_list_node_t *next_node;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view->display == display)
-        {
-          ply_text_display_set_draw_handler (view->display,
-                                             NULL, NULL);
-          view_free (view);
-          ply_list_remove_node (plugin->views, node);
-          return;
-        }
+                if (view->display == display) {
+                        ply_text_display_set_draw_handler (view->display,
+                                                           NULL, NULL);
+                        view_free (view);
+                        ply_list_remove_node (plugin->views, node);
+                        return;
+                }
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static bool
@@ -524,27 +512,27 @@ show_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_buffer_t             *boot_buffer,
                     ply_boot_splash_mode_t    mode)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  plugin->loop = loop;
-  plugin->mode = mode;
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
-                                 detach_from_event_loop,
-                                 plugin);
+        plugin->loop = loop;
+        plugin->mode = mode;
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       detach_from_event_loop,
+                                       plugin);
 
-  ply_show_new_kernel_messages (false);
-  start_animation (plugin);
+        ply_show_new_kernel_messages (false);
+        start_animation (plugin);
 
-  return true;
+        return true;
 }
 
 static void
 update_status (ply_boot_splash_plugin_t *plugin,
                const char               *status)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  ply_trace ("status update");
+        ply_trace ("status update");
 }
 
 static void
@@ -552,77 +540,74 @@ on_boot_progress (ply_boot_splash_plugin_t *plugin,
                   double                    duration,
                   double                    percent_done)
 {
-  ply_list_node_t *node;
-  double total_duration;
+        ply_list_node_t *node;
+        double total_duration;
 
-  total_duration = duration / percent_done;
+        total_duration = duration / percent_done;
 
-  /* Fun made-up smoothing function to make the growth asymptotic:
-   * fraction(time,estimate)=1-2^(-(time^1.45)/estimate) */
-  percent_done = 1.0 - pow (2.0, -pow (duration, 1.45) / total_duration) * (1.0 - percent_done);
+        /* Fun made-up smoothing function to make the growth asymptotic:
+         * fraction(time,estimate)=1-2^(-(time^1.45)/estimate) */
+        percent_done = 1.0 - pow (2.0, -pow (duration, 1.45) / total_duration) * (1.0 - percent_done);
 
-  node = ply_list_get_first_node (plugin->views);
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_text_progress_bar_set_percent_done (view->progress_bar, percent_done);
-      ply_text_progress_bar_draw (view->progress_bar);
+                ply_text_progress_bar_set_percent_done (view->progress_bar, percent_done);
+                ply_text_progress_bar_draw (view->progress_bar);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 hide_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_event_loop_t         *loop)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  ply_trace ("hiding splash screen");
+        ply_trace ("hiding splash screen");
 
-  if (plugin->loop != NULL)
-    {
-      stop_animation (plugin);
+        if (plugin->loop != NULL) {
+                stop_animation (plugin);
 
-      ply_event_loop_stop_watching_for_exit (plugin->loop,
-                                             (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
+                ply_event_loop_stop_watching_for_exit (plugin->loop,
+                                                       (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
 
-  hide_views (plugin);
-  ply_show_new_kernel_messages (true);
+        hide_views (plugin);
+        ply_show_new_kernel_messages (true);
 }
 
 static void
 display_normal (ply_boot_splash_plugin_t *plugin)
 {
-  pause_views (plugin);
-  if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    {
-      plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
-      start_animation (plugin);
-      redraw_views (plugin);
-    }
-  unpause_views (plugin);
+        pause_views (plugin);
+        if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL) {
+                plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
+                start_animation (plugin);
+                redraw_views (plugin);
+        }
+        unpause_views (plugin);
 }
 
 static void
 display_message (ply_boot_splash_plugin_t *plugin,
                  const char               *message)
 {
-  if (plugin->message != NULL)
-    free (plugin->message);
+        if (plugin->message != NULL)
+                free (plugin->message);
 
-  plugin->message = strdup (message);
-  start_animation (plugin);
+        plugin->message = strdup (message);
+        start_animation (plugin);
 }
 
 static void
@@ -630,29 +615,29 @@ show_password_prompt (ply_boot_splash_plugin_t *plugin,
                       const char               *prompt,
                       int                       bullets)
 {
-  ply_list_node_t *node;
-  int i;
-  char *entered_text;
+        ply_list_node_t *node;
+        int i;
+        char *entered_text;
 
-  entered_text = calloc (bullets + 1, sizeof (char));
+        entered_text = calloc (bullets + 1, sizeof(char));
 
-  for (i = 0; i < bullets; i++)
-    entered_text[i] = '*';
+        for (i = 0; i < bullets; i++) {
+                entered_text[i] = '*';
+        }
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, prompt, entered_text);
+                view_show_prompt (view, prompt, entered_text);
 
-      node = next_node;
-    }
-  free (entered_text);
+                node = next_node;
+        }
+        free (entered_text);
 }
 
 static void
@@ -660,21 +645,20 @@ show_prompt (ply_boot_splash_plugin_t *plugin,
              const char               *prompt,
              const char               *text)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, prompt, text);
+                view_show_prompt (view, prompt, text);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
@@ -682,18 +666,18 @@ display_password (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   int                       bullets)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin);
 
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
 
-  if (!prompt)
-    prompt = "Password";
+        if (!prompt)
+                prompt = "Password";
 
-  show_password_prompt (plugin, prompt, bullets);
+        show_password_prompt (plugin, prompt, bullets);
 
-  unpause_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
@@ -701,40 +685,40 @@ display_question (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   const char               *entry_text)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin);
 
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
 
-  if (!prompt)
-    prompt = "Password";
+        if (!prompt)
+                prompt = "Password";
 
-  show_prompt (plugin, prompt, entry_text);
+        show_prompt (plugin, prompt, entry_text);
 
-  unpause_views (plugin);
+        unpause_views (plugin);
 }
 
 ply_boot_splash_plugin_interface_t *
 ply_boot_splash_plugin_get_interface (void)
 {
-  static ply_boot_splash_plugin_interface_t plugin_interface =
-    {
-      .create_plugin = create_plugin,
-      .destroy_plugin = destroy_plugin,
-      .add_text_display = add_text_display,
-      .remove_text_display = remove_text_display,
-      .show_splash_screen = show_splash_screen,
-      .update_status = update_status,
-      .on_boot_progress = on_boot_progress,
-      .hide_splash_screen = hide_splash_screen,
-      .display_normal = display_normal,
-      .display_message = display_message,
-      .display_password = display_password,
-      .display_question = display_question,
-    };
-
-  return &plugin_interface;
+        static ply_boot_splash_plugin_interface_t plugin_interface =
+        {
+                .create_plugin       = create_plugin,
+                .destroy_plugin      = destroy_plugin,
+                .add_text_display    = add_text_display,
+                .remove_text_display = remove_text_display,
+                .show_splash_screen  = show_splash_screen,
+                .update_status       = update_status,
+                .on_boot_progress    = on_boot_progress,
+                .hide_splash_screen  = hide_splash_screen,
+                .display_normal      = display_normal,
+                .display_message     = display_message,
+                .display_password    = display_password,
+                .display_question    = display_question,
+        };
+
+        return &plugin_interface;
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/plugins/splash/two-step/plugin.c b/src/plugins/splash/two-step/plugin.c
index f48b41e..935d830 100644
--- a/src/plugins/splash/two-step/plugin.c
+++ b/src/plugins/splash/two-step/plugin.c
@@ -68,71 +68,73 @@
 #define SHOW_ANIMATION_PERCENT 0.9
 #endif
 
-typedef enum {
-   PLY_BOOT_SPLASH_DISPLAY_NORMAL,
-   PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
-   PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
+typedef enum
+{
+        PLY_BOOT_SPLASH_DISPLAY_NORMAL,
+        PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY,
+        PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY
 } ply_boot_splash_display_type_t;
 
-typedef enum {
-   PROGRESS_FUNCTION_TYPE_WWOODS,
-   PROGRESS_FUNCTION_TYPE_LINEAR,
+typedef enum
+{
+        PROGRESS_FUNCTION_TYPE_WWOODS,
+        PROGRESS_FUNCTION_TYPE_LINEAR,
 } progress_function_t;
 
 typedef struct
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_pixel_display_t *display;
-  ply_entry_t *entry;
-  ply_animation_t *end_animation;
-  ply_progress_animation_t *progress_animation;
-  ply_throbber_t *throbber;
-  ply_label_t *label;
-  ply_label_t *message_label;
-  ply_rectangle_t box_area, lock_area, watermark_area;
-  ply_trigger_t *end_trigger;
-  ply_image_t *background_image;
+        ply_boot_splash_plugin_t *plugin;
+        ply_pixel_display_t      *display;
+        ply_entry_t              *entry;
+        ply_animation_t          *end_animation;
+        ply_progress_animation_t *progress_animation;
+        ply_throbber_t           *throbber;
+        ply_label_t              *label;
+        ply_label_t              *message_label;
+        ply_rectangle_t           box_area, lock_area, watermark_area;
+        ply_trigger_t            *end_trigger;
+        ply_image_t              *background_image;
 } view_t;
 
 struct _ply_boot_splash_plugin
 {
-  ply_event_loop_t *loop;
-  ply_boot_splash_mode_t mode;
-  ply_image_t *lock_image;
-  ply_image_t *box_image;
-  ply_image_t *corner_image;
-  ply_image_t *header_image;
-  ply_image_t *background_tile_image;
-  ply_image_t *watermark_image;
-  ply_list_t *views;
+        ply_event_loop_t                   *loop;
+        ply_boot_splash_mode_t              mode;
+        ply_image_t                        *lock_image;
+        ply_image_t                        *box_image;
+        ply_image_t                        *corner_image;
+        ply_image_t                        *header_image;
+        ply_image_t                        *background_tile_image;
+        ply_image_t                        *watermark_image;
+        ply_list_t                         *views;
 
-  ply_boot_splash_display_type_t state;
+        ply_boot_splash_display_type_t      state;
 
-  double watermark_horizontal_alignment;
-  double watermark_vertical_alignment;
+        double                              watermark_horizontal_alignment;
+        double                              watermark_vertical_alignment;
 
-  double animation_horizontal_alignment;
-  double animation_vertical_alignment;
-  char *animation_dir;
+        double                              animation_horizontal_alignment;
+        double                              animation_vertical_alignment;
+        char                               *animation_dir;
 
-  ply_progress_animation_transition_t transition;
-  double transition_duration;
+        ply_progress_animation_transition_t transition;
+        double                              transition_duration;
 
-  uint32_t background_start_color;
-  uint32_t background_end_color;
+        uint32_t                            background_start_color;
+        uint32_t                            background_end_color;
 
-  progress_function_t progress_function;
+        progress_function_t                 progress_function;
 
-  ply_trigger_t *idle_trigger;
-  ply_trigger_t *stop_trigger;
+        ply_trigger_t                      *idle_trigger;
+        ply_trigger_t                      *stop_trigger;
 
-  uint32_t root_is_mounted : 1;
-  uint32_t is_visible : 1;
-  uint32_t is_animating : 1;
-  uint32_t is_idle : 1;
+        uint32_t                            root_is_mounted : 1;
+        uint32_t                            is_visible : 1;
+        uint32_t                            is_animating : 1;
+        uint32_t                            is_idle : 1;
 };
 
-ply_boot_splash_plugin_interface_t * ply_boot_splash_plugin_get_interface (void);
+ply_boot_splash_plugin_interface_t *ply_boot_splash_plugin_get_interface (void);
 
 static void stop_animation (ply_boot_splash_plugin_t *plugin,
                             ply_trigger_t            *idle_trigger);
@@ -147,704 +149,669 @@ static view_t *
 view_new (ply_boot_splash_plugin_t *plugin,
           ply_pixel_display_t      *display)
 {
-  view_t *view;
+        view_t *view;
 
-  view = calloc (1, sizeof (view_t));
-  view->plugin = plugin;
-  view->display = display;
+        view = calloc (1, sizeof(view_t));
+        view->plugin = plugin;
+        view->display = display;
 
-  view->entry = ply_entry_new (plugin->animation_dir);
-  view->end_animation = ply_animation_new (plugin->animation_dir,
-                                           "animation-");
-  view->progress_animation = ply_progress_animation_new (plugin->animation_dir,
-                                                         "progress-");
+        view->entry = ply_entry_new (plugin->animation_dir);
+        view->end_animation = ply_animation_new (plugin->animation_dir,
+                                                 "animation-");
+        view->progress_animation = ply_progress_animation_new (plugin->animation_dir,
+                                                               "progress-");
 
-  view->throbber = ply_throbber_new (plugin->animation_dir,
-                                     "throbber-");
-  ply_progress_animation_set_transition (view->progress_animation,
-                                         plugin->transition,
-                                         plugin->transition_duration);
+        view->throbber = ply_throbber_new (plugin->animation_dir,
+                                           "throbber-");
+        ply_progress_animation_set_transition (view->progress_animation,
+                                               plugin->transition,
+                                               plugin->transition_duration);
 
-  view->label = ply_label_new ();
-  view->message_label = ply_label_new ();
+        view->label = ply_label_new ();
+        view->message_label = ply_label_new ();
 
-  return view;
+        return view;
 }
 
 static void
 view_free (view_t *view)
 {
+        ply_entry_free (view->entry);
+        ply_animation_free (view->end_animation);
+        ply_progress_animation_free (view->progress_animation);
+        ply_throbber_free (view->throbber);
+        ply_label_free (view->label);
+        ply_label_free (view->message_label);
 
-  ply_entry_free (view->entry);
-  ply_animation_free (view->end_animation);
-  ply_progress_animation_free (view->progress_animation);
-  ply_throbber_free (view->throbber);
-  ply_label_free (view->label);
-  ply_label_free (view->message_label);
+        if (view->background_image != NULL)
+                ply_image_free (view->background_image);
 
-  if (view->background_image != NULL)
-    ply_image_free (view->background_image);
-
-  free (view);
+        free (view);
 }
 
 static bool
 view_load (view_t *view)
 {
-  unsigned long screen_width, screen_height;
-  ply_boot_splash_plugin_t *plugin;
-
-  plugin = view->plugin;
-
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
-
-  if (plugin->background_tile_image != NULL)
-    {
-      ply_trace ("tiling background to %lux%lu", screen_width, screen_height);
-      view->background_image = ply_image_tile (plugin->background_tile_image, screen_width, screen_height);
-    }
-
-  if (plugin->watermark_image != NULL)
-    {
-      view->watermark_area.width = ply_image_get_width (plugin->watermark_image);
-      view->watermark_area.height = ply_image_get_height (plugin->watermark_image);
-      view->watermark_area.x = screen_width * plugin->watermark_horizontal_alignment - ply_image_get_width (plugin->watermark_image) * plugin->watermark_horizontal_alignment;
-      view->watermark_area.y = screen_height * plugin->watermark_vertical_alignment - ply_image_get_height (plugin->watermark_image) * plugin->watermark_vertical_alignment;
-    }
-
-  ply_trace ("loading entry");
-  if (!ply_entry_load (view->entry))
-    return false;
-
-  ply_trace ("loading animation");
-  if (!ply_animation_load (view->end_animation))
-    {
-      ply_trace ("Default animation wouldn't load, "
-                 "falling back to old naming scheme");
-
-      /* fallback to throbber- for compatibility
-       */
-      ply_animation_free (view->end_animation);
-      view->end_animation = ply_animation_new (view->plugin->animation_dir,
-                                               "throbber-");
-      if (!ply_animation_load (view->end_animation))
-        {
-          ply_trace ("old naming scheme didn't work either");
-          return false;
+        unsigned long screen_width, screen_height;
+        ply_boot_splash_plugin_t *plugin;
+
+        plugin = view->plugin;
+
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
+
+        if (plugin->background_tile_image != NULL) {
+                ply_trace ("tiling background to %lux%lu", screen_width, screen_height);
+                view->background_image = ply_image_tile (plugin->background_tile_image, screen_width, screen_height);
         }
 
-      ply_throbber_free (view->throbber);
-      view->throbber = NULL;
-    }
-
-  ply_trace ("loading progress animation");
-  if (!ply_progress_animation_load (view->progress_animation))
-    {
-      ply_trace ("optional progress animation wouldn't load");
-      ply_progress_animation_free (view->progress_animation);
-      view->progress_animation = NULL;
-    }
-
-  if (view->throbber != NULL)
-    {
-      ply_trace ("loading throbber");
-      if (!ply_throbber_load (view->throbber))
-        {
-          ply_trace ("optional throbber was not loaded");
-          ply_throbber_free (view->throbber);
-          view->throbber = NULL;
+        if (plugin->watermark_image != NULL) {
+                view->watermark_area.width = ply_image_get_width (plugin->watermark_image);
+                view->watermark_area.height = ply_image_get_height (plugin->watermark_image);
+                view->watermark_area.x = screen_width * plugin->watermark_horizontal_alignment - ply_image_get_width (plugin->watermark_image) * plugin->watermark_horizontal_alignment;
+                view->watermark_area.y = screen_height * plugin->watermark_vertical_alignment - ply_image_get_height (plugin->watermark_image) * plugin->watermark_vertical_alignment;
+        }
+
+        ply_trace ("loading entry");
+        if (!ply_entry_load (view->entry))
+                return false;
+
+        ply_trace ("loading animation");
+        if (!ply_animation_load (view->end_animation)) {
+                ply_trace ("Default animation wouldn't load, "
+                           "falling back to old naming scheme");
+
+                /* fallback to throbber- for compatibility
+                 */
+                ply_animation_free (view->end_animation);
+                view->end_animation = ply_animation_new (view->plugin->animation_dir,
+                                                         "throbber-");
+                if (!ply_animation_load (view->end_animation)) {
+                        ply_trace ("old naming scheme didn't work either");
+                        return false;
+                }
+
+                ply_throbber_free (view->throbber);
+                view->throbber = NULL;
         }
-    }
-  else
-    {
-      ply_trace ("this theme has no throbber\n");
-    }
 
-  return true;
+        ply_trace ("loading progress animation");
+        if (!ply_progress_animation_load (view->progress_animation)) {
+                ply_trace ("optional progress animation wouldn't load");
+                ply_progress_animation_free (view->progress_animation);
+                view->progress_animation = NULL;
+        }
+
+        if (view->throbber != NULL) {
+                ply_trace ("loading throbber");
+                if (!ply_throbber_load (view->throbber)) {
+                        ply_trace ("optional throbber was not loaded");
+                        ply_throbber_free (view->throbber);
+                        view->throbber = NULL;
+                }
+        } else {
+                ply_trace ("this theme has no throbber\n");
+        }
+
+        return true;
 }
 
 static bool
 load_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
-  bool view_loaded;
+        ply_list_node_t *node;
+        bool view_loaded;
 
-  view_loaded = false;
-  node = ply_list_get_first_node (plugin->views);
+        view_loaded = false;
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view_load (view))
-        view_loaded = true;
+                if (view_load (view))
+                        view_loaded = true;
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  return view_loaded;
+        return view_loaded;
 }
 
 static void
 view_redraw (view_t *view)
 {
-  unsigned long screen_width, screen_height;
+        unsigned long screen_width, screen_height;
 
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
 
-  ply_pixel_display_draw_area (view->display, 0, 0,
-                               screen_width, screen_height);
+        ply_pixel_display_draw_area (view->display, 0, 0,
+                                     screen_width, screen_height);
 }
 
 static void
 redraw_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_redraw (view);
+                view_redraw (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 pause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("pausing views");
+        ply_trace ("pausing views");
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_pixel_display_pause_updates (view->display);
+                ply_pixel_display_pause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 unpause_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("unpausing views");
+        ply_trace ("unpausing views");
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      ply_pixel_display_unpause_updates (view->display);
+                ply_pixel_display_unpause_updates (view->display);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 view_start_end_animation (view_t        *view,
                           ply_trigger_t *trigger)
 {
-  ply_boot_splash_plugin_t *plugin;
+        ply_boot_splash_plugin_t *plugin;
 
-  long x, y;
-  long width, height;
-  unsigned long screen_width, screen_height;
+        long x, y;
+        long width, height;
+        unsigned long screen_width, screen_height;
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
-  width = ply_animation_get_width (view->end_animation);
-  height = ply_animation_get_height (view->end_animation);
-  x = plugin->animation_horizontal_alignment * screen_width - width / 2.0;
-  y = plugin->animation_vertical_alignment * screen_height - height / 2.0;
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
+        width = ply_animation_get_width (view->end_animation);
+        height = ply_animation_get_height (view->end_animation);
+        x = plugin->animation_horizontal_alignment * screen_width - width / 2.0;
+        y = plugin->animation_vertical_alignment * screen_height - height / 2.0;
 
-  ply_trace ("starting end sequence animation for %ldx%ld view", width, height);
-  ply_animation_start (view->end_animation,
-                       view->display,
-                       trigger, x, y);
+        ply_trace ("starting end sequence animation for %ldx%ld view", width, height);
+        ply_animation_start (view->end_animation,
+                             view->display,
+                             trigger, x, y);
 }
 
 static void
 on_view_throbber_stopped (view_t *view)
 {
-  ply_trace ("hiding progress animation");
-  if (view->progress_animation != NULL)
-      ply_progress_animation_hide (view->progress_animation);
-  view_start_end_animation (view, view->end_trigger);
-  view->end_trigger = NULL;
+        ply_trace ("hiding progress animation");
+        if (view->progress_animation != NULL)
+                ply_progress_animation_hide (view->progress_animation);
+        view_start_end_animation (view, view->end_trigger);
+        view->end_trigger = NULL;
 }
 
 static void
 view_start_progress_animation (view_t *view)
 {
-  ply_boot_splash_plugin_t *plugin;
-
-  long x, y;
-  long width, height;
-  unsigned long screen_width, screen_height;
-
-  assert (view != NULL);
-
-  plugin = view->plugin;
-
-  plugin->is_idle = false;
-
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
-
-  ply_pixel_display_draw_area (view->display, 0, 0,
-                               screen_width, screen_height);
-
-  if (view->throbber != NULL)
-    {
-      width = ply_throbber_get_width (view->throbber);
-      height = ply_throbber_get_height (view->throbber);
-      x = plugin->animation_horizontal_alignment * screen_width - width / 2.0;
-      y = plugin->animation_vertical_alignment * screen_height - height / 2.0;
-      ply_throbber_start (view->throbber,
-                          plugin->loop,
-                          view->display, x, y);
-      ply_pixel_display_draw_area (view->display, x, y, width, height);
-    }
-
-  /* We don't really know how long shutdown will so
-   * don't show the progress animation
-   */
-  if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
-    return;
-
-  if (view->progress_animation != NULL)
-    {
-      width = ply_progress_animation_get_width (view->progress_animation);
-      height = ply_progress_animation_get_height (view->progress_animation);
-      x = plugin->animation_horizontal_alignment * screen_width - width / 2.0;
-      y = plugin->animation_vertical_alignment * screen_height - height / 2.0;
-      ply_progress_animation_show (view->progress_animation,
-                                   view->display, x, y);
-
-      ply_pixel_display_draw_area (view->display, x, y, width, height);
-    }
+        ply_boot_splash_plugin_t *plugin;
+
+        long x, y;
+        long width, height;
+        unsigned long screen_width, screen_height;
+
+        assert (view != NULL);
+
+        plugin = view->plugin;
+
+        plugin->is_idle = false;
+
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
+
+        ply_pixel_display_draw_area (view->display, 0, 0,
+                                     screen_width, screen_height);
+
+        if (view->throbber != NULL) {
+                width = ply_throbber_get_width (view->throbber);
+                height = ply_throbber_get_height (view->throbber);
+                x = plugin->animation_horizontal_alignment * screen_width - width / 2.0;
+                y = plugin->animation_vertical_alignment * screen_height - height / 2.0;
+                ply_throbber_start (view->throbber,
+                                    plugin->loop,
+                                    view->display, x, y);
+                ply_pixel_display_draw_area (view->display, x, y, width, height);
+        }
+
+        /* We don't really know how long shutdown will so
+         * don't show the progress animation
+         */
+        if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
+                return;
+
+        if (view->progress_animation != NULL) {
+                width = ply_progress_animation_get_width (view->progress_animation);
+                height = ply_progress_animation_get_height (view->progress_animation);
+                x = plugin->animation_horizontal_alignment * screen_width - width / 2.0;
+                y = plugin->animation_vertical_alignment * screen_height - height / 2.0;
+                ply_progress_animation_show (view->progress_animation,
+                                             view->display, x, y);
+
+                ply_pixel_display_draw_area (view->display, x, y, width, height);
+        }
 }
 
 static void
 view_show_prompt (view_t     *view,
                   const char *prompt)
 {
-  ply_boot_splash_plugin_t *plugin;
-  int x, y;
-  int entry_width, entry_height;
-  unsigned long screen_width, screen_height;
+        ply_boot_splash_plugin_t *plugin;
+        int x, y;
+        int entry_width, entry_height;
+        unsigned long screen_width, screen_height;
 
-  assert (view != NULL);
+        assert (view != NULL);
 
-  plugin = view->plugin;
+        plugin = view->plugin;
 
-  screen_width = ply_pixel_display_get_width (view->display);
-  screen_height = ply_pixel_display_get_height (view->display);
+        screen_width = ply_pixel_display_get_width (view->display);
+        screen_height = ply_pixel_display_get_height (view->display);
 
-  if (ply_entry_is_hidden (view->entry))
-    {
-      view->box_area.width = ply_image_get_width (plugin->box_image);
-      view->box_area.height = ply_image_get_height (plugin->box_image);
-      view->box_area.x = screen_width / 2.0 - view->box_area.width / 2.0;
-      view->box_area.y = screen_height / 2.0 - view->box_area.height / 2.0;
+        if (ply_entry_is_hidden (view->entry)) {
+                view->box_area.width = ply_image_get_width (plugin->box_image);
+                view->box_area.height = ply_image_get_height (plugin->box_image);
+                view->box_area.x = screen_width / 2.0 - view->box_area.width / 2.0;
+                view->box_area.y = screen_height / 2.0 - view->box_area.height / 2.0;
 
-      view->lock_area.width = ply_image_get_width (plugin->lock_image);
-      view->lock_area.height = ply_image_get_height (plugin->lock_image);
+                view->lock_area.width = ply_image_get_width (plugin->lock_image);
+                view->lock_area.height = ply_image_get_height (plugin->lock_image);
 
-      entry_width = ply_entry_get_width (view->entry);
-      entry_height = ply_entry_get_height (view->entry);
+                entry_width = ply_entry_get_width (view->entry);
+                entry_height = ply_entry_get_height (view->entry);
 
-      x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0 + view->lock_area.width;
-      y = screen_height / 2.0 - entry_height / 2.0;
+                x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0 + view->lock_area.width;
+                y = screen_height / 2.0 - entry_height / 2.0;
 
-      view->lock_area.x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0;
-      view->lock_area.y = screen_height / 2.0 - view->lock_area.height / 2.0;
+                view->lock_area.x = screen_width / 2.0 - (view->lock_area.width + entry_width) / 2.0;
+                view->lock_area.y = screen_height / 2.0 - view->lock_area.height / 2.0;
 
-      ply_entry_show (view->entry, plugin->loop, view->display, x, y);
-    }
+                ply_entry_show (view->entry, plugin->loop, view->display, x, y);
+        }
 
-  if (prompt != NULL)
-    {
-      ply_label_set_text (view->label, prompt);
+        if (prompt != NULL) {
+                ply_label_set_text (view->label, prompt);
 
-      /* We center the prompt in the middle and use 80% of the horizontal space */
-      int label_width = screen_width * 100 / 80;
-      ply_label_set_alignment (view->label, PLY_LABEL_ALIGN_CENTER);
-      ply_label_set_width (view->label, label_width);
+                /* We center the prompt in the middle and use 80% of the horizontal space */
+                int label_width = screen_width * 100 / 80;
+                ply_label_set_alignment (view->label, PLY_LABEL_ALIGN_CENTER);
+                ply_label_set_width (view->label, label_width);
 
-      x = (screen_width - label_width) / 2;
-      y = view->box_area.y + view->box_area.height;
+                x = (screen_width - label_width) / 2;
+                y = view->box_area.y + view->box_area.height;
 
-      ply_label_show (view->label, view->display, x, y);
-    }
+                ply_label_show (view->label, view->display, x, y);
+        }
 }
 
 static void
 view_hide_prompt (view_t *view)
 {
-  assert (view != NULL);
+        assert (view != NULL);
 
-  ply_entry_hide (view->entry);
-  ply_label_hide (view->label);
+        ply_entry_hide (view->entry);
+        ply_label_hide (view->label);
 }
 
 static ply_boot_splash_plugin_t *
 create_plugin (ply_key_file_t *key_file)
 {
-  ply_boot_splash_plugin_t *plugin;
-  char *image_dir, *image_path;
-  char *alignment;
-  char *transition;
-  char *transition_duration;
-  char *color;
-  char *progress_function;
-
-  srand ((int) ply_get_timestamp ());
-  plugin = calloc (1, sizeof (ply_boot_splash_plugin_t));
-
-  image_dir = ply_key_file_get_value (key_file, "two-step", "ImageDir");
-
-  ply_trace ("Using '%s' as working directory", image_dir);
-
-  asprintf (&image_path, "%s/lock.png", image_dir);
-  plugin->lock_image = ply_image_new (image_path);
-  free (image_path);
-
-  asprintf (&image_path, "%s/box.png", image_dir);
-  plugin->box_image = ply_image_new (image_path);
-  free (image_path);
-
-  asprintf (&image_path, "%s/corner-image.png", image_dir);
-  plugin->corner_image = ply_image_new (image_path);
-  free (image_path);
-
-  asprintf (&image_path, "%s/header-image.png", image_dir);
-  plugin->header_image = ply_image_new (image_path);
-  free (image_path);
-
-  asprintf (&image_path, "%s/background-tile.png", image_dir);
-  plugin->background_tile_image = ply_image_new (image_path);
-  free (image_path);
-
-  asprintf (&image_path, "%s/watermark.png", image_dir);
-  plugin->watermark_image = ply_image_new (image_path);
-  free (image_path);
-
-  plugin->animation_dir = image_dir;
-
-  alignment = ply_key_file_get_value (key_file, "two-step", "HorizontalAlignment");
-  if (alignment != NULL)
-    plugin->animation_horizontal_alignment = strtod (alignment, NULL);
-  else
-    plugin->animation_horizontal_alignment = .5;
-  free (alignment);
-
-  alignment = ply_key_file_get_value (key_file, "two-step", "VerticalAlignment");
-  if (alignment != NULL)
-    plugin->animation_vertical_alignment = strtod (alignment, NULL);
-  else
-    plugin->animation_vertical_alignment = .5;
-  free (alignment);
-
-  alignment = ply_key_file_get_value (key_file, "two-step", "WatermarkHorizontalAlignment");
-  if (alignment != NULL)
-    plugin->watermark_horizontal_alignment = strtod (alignment, NULL);
-  else
-    plugin->watermark_horizontal_alignment = 1.0;
-  free (alignment);
-
-  alignment = ply_key_file_get_value (key_file, "two-step", "WatermarkVerticalAlignment");
-  if (alignment != NULL)
-    plugin->watermark_vertical_alignment = strtod (alignment, NULL);
-  else
-    plugin->watermark_vertical_alignment = .5;
-  free (alignment);
-
-  plugin->transition = PLY_PROGRESS_ANIMATION_TRANSITION_NONE;
-  transition = ply_key_file_get_value (key_file, "two-step", "Transition");
-  if (transition != NULL)
-    {
-      if (strcmp (transition, "fade-over") == 0)
-        plugin->transition = PLY_PROGRESS_ANIMATION_TRANSITION_FADE_OVER;
-      else if (strcmp (transition, "cross-fade") == 0)
-        plugin->transition = PLY_PROGRESS_ANIMATION_TRANSITION_CROSS_FADE;
-      else if (strcmp (transition, "merge-fade") == 0)
-        plugin->transition = PLY_PROGRESS_ANIMATION_TRANSITION_MERGE_FADE;
-    }
-  free (transition);
-
-  transition_duration = ply_key_file_get_value (key_file, "two-step", "TransitionDuration");
-  if (transition_duration != NULL)
-    plugin->transition_duration = strtod (transition_duration, NULL);
-  else
-    plugin->transition_duration = 0.0;
-  free (transition_duration);
-
-  color = ply_key_file_get_value (key_file, "two-step", "BackgroundStartColor");
-
-  if (color != NULL)
-    plugin->background_start_color = strtol (color, NULL, 0);
-  else
-    plugin->background_start_color = PLYMOUTH_BACKGROUND_START_COLOR;
-
-  free (color);
-
-  color = ply_key_file_get_value (key_file, "two-step", "BackgroundEndColor");
-
-  if (color != NULL)
-    plugin->background_end_color = strtol (color, NULL, 0);
-  else
-    plugin->background_end_color = PLYMOUTH_BACKGROUND_END_COLOR;
-
-  free (color);
-
-  progress_function = ply_key_file_get_value (key_file, "two-step", "ProgressFunction");
-
-  if (progress_function != NULL)
-    {
-      if (strcmp (progress_function, "wwoods") == 0)
-        {
-          ply_trace ("Using wwoods progress function");
-          plugin->progress_function = PROGRESS_FUNCTION_TYPE_WWOODS;
+        ply_boot_splash_plugin_t *plugin;
+        char *image_dir, *image_path;
+        char *alignment;
+        char *transition;
+        char *transition_duration;
+        char *color;
+        char *progress_function;
+
+        srand ((int) ply_get_timestamp ());
+        plugin = calloc (1, sizeof(ply_boot_splash_plugin_t));
+
+        image_dir = ply_key_file_get_value (key_file, "two-step", "ImageDir");
+
+        ply_trace ("Using '%s' as working directory", image_dir);
+
+        asprintf (&image_path, "%s/lock.png", image_dir);
+        plugin->lock_image = ply_image_new (image_path);
+        free (image_path);
+
+        asprintf (&image_path, "%s/box.png", image_dir);
+        plugin->box_image = ply_image_new (image_path);
+        free (image_path);
+
+        asprintf (&image_path, "%s/corner-image.png", image_dir);
+        plugin->corner_image = ply_image_new (image_path);
+        free (image_path);
+
+        asprintf (&image_path, "%s/header-image.png", image_dir);
+        plugin->header_image = ply_image_new (image_path);
+        free (image_path);
+
+        asprintf (&image_path, "%s/background-tile.png", image_dir);
+        plugin->background_tile_image = ply_image_new (image_path);
+        free (image_path);
+
+        asprintf (&image_path, "%s/watermark.png", image_dir);
+        plugin->watermark_image = ply_image_new (image_path);
+        free (image_path);
+
+        plugin->animation_dir = image_dir;
+
+        alignment = ply_key_file_get_value (key_file, "two-step", "HorizontalAlignment");
+        if (alignment != NULL)
+                plugin->animation_horizontal_alignment = strtod (alignment, NULL);
+        else
+                plugin->animation_horizontal_alignment = .5;
+        free (alignment);
+
+        alignment = ply_key_file_get_value (key_file, "two-step", "VerticalAlignment");
+        if (alignment != NULL)
+                plugin->animation_vertical_alignment = strtod (alignment, NULL);
+        else
+                plugin->animation_vertical_alignment = .5;
+        free (alignment);
+
+        alignment = ply_key_file_get_value (key_file, "two-step", "WatermarkHorizontalAlignment");
+        if (alignment != NULL)
+                plugin->watermark_horizontal_alignment = strtod (alignment, NULL);
+        else
+                plugin->watermark_horizontal_alignment = 1.0;
+        free (alignment);
+
+        alignment = ply_key_file_get_value (key_file, "two-step", "WatermarkVerticalAlignment");
+        if (alignment != NULL)
+                plugin->watermark_vertical_alignment = strtod (alignment, NULL);
+        else
+                plugin->watermark_vertical_alignment = .5;
+        free (alignment);
+
+        plugin->transition = PLY_PROGRESS_ANIMATION_TRANSITION_NONE;
+        transition = ply_key_file_get_value (key_file, "two-step", "Transition");
+        if (transition != NULL) {
+                if (strcmp (transition, "fade-over") == 0)
+                        plugin->transition = PLY_PROGRESS_ANIMATION_TRANSITION_FADE_OVER;
+                else if (strcmp (transition, "cross-fade") == 0)
+                        plugin->transition = PLY_PROGRESS_ANIMATION_TRANSITION_CROSS_FADE;
+                else if (strcmp (transition, "merge-fade") == 0)
+                        plugin->transition = PLY_PROGRESS_ANIMATION_TRANSITION_MERGE_FADE;
         }
-      else if (strcmp (progress_function, "linear") == 0)
-        {
-          ply_trace ("Using linear progress function");
-          plugin->progress_function = PROGRESS_FUNCTION_TYPE_LINEAR;
-        }
-      else
-        {
-          ply_trace ("unknown progress function %s, defaulting to linear", progress_function);
-          plugin->progress_function = PROGRESS_FUNCTION_TYPE_LINEAR;
+        free (transition);
+
+        transition_duration = ply_key_file_get_value (key_file, "two-step", "TransitionDuration");
+        if (transition_duration != NULL)
+                plugin->transition_duration = strtod (transition_duration, NULL);
+        else
+                plugin->transition_duration = 0.0;
+        free (transition_duration);
+
+        color = ply_key_file_get_value (key_file, "two-step", "BackgroundStartColor");
+
+        if (color != NULL)
+                plugin->background_start_color = strtol (color, NULL, 0);
+        else
+                plugin->background_start_color = PLYMOUTH_BACKGROUND_START_COLOR;
+
+        free (color);
+
+        color = ply_key_file_get_value (key_file, "two-step", "BackgroundEndColor");
+
+        if (color != NULL)
+                plugin->background_end_color = strtol (color, NULL, 0);
+        else
+                plugin->background_end_color = PLYMOUTH_BACKGROUND_END_COLOR;
+
+        free (color);
+
+        progress_function = ply_key_file_get_value (key_file, "two-step", "ProgressFunction");
+
+        if (progress_function != NULL) {
+                if (strcmp (progress_function, "wwoods") == 0) {
+                        ply_trace ("Using wwoods progress function");
+                        plugin->progress_function = PROGRESS_FUNCTION_TYPE_WWOODS;
+                } else if (strcmp (progress_function, "linear") == 0) {
+                        ply_trace ("Using linear progress function");
+                        plugin->progress_function = PROGRESS_FUNCTION_TYPE_LINEAR;
+                } else {
+                        ply_trace ("unknown progress function %s, defaulting to linear", progress_function);
+                        plugin->progress_function = PROGRESS_FUNCTION_TYPE_LINEAR;
+                }
         }
-    }
 
-  plugin->views = ply_list_new ();
+        plugin->views = ply_list_new ();
 
-  return plugin;
+        return plugin;
 }
 
 static void
 free_views (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("freeing views");
+        ply_trace ("freeing views");
 
-  node = ply_list_get_first_node (plugin->views);
+        node = ply_list_get_first_node (plugin->views);
 
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_free (view);
-      ply_list_remove_node (plugin->views, node);
+                view_free (view);
+                ply_list_remove_node (plugin->views, node);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  ply_list_free (plugin->views);
-  plugin->views = NULL;
+        ply_list_free (plugin->views);
+        plugin->views = NULL;
 }
 
 static void
 destroy_plugin (ply_boot_splash_plugin_t *plugin)
 {
-  if (plugin == NULL)
-    return;
+        if (plugin == NULL)
+                return;
 
-  ply_trace ("destroying plugin");
+        ply_trace ("destroying plugin");
 
-  if (plugin->loop != NULL)
-    {
-      stop_animation (plugin, NULL);
+        if (plugin->loop != NULL) {
+                stop_animation (plugin, NULL);
 
-      ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
+                ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
 
-  ply_image_free (plugin->box_image);
-  ply_image_free (plugin->lock_image);
+        ply_image_free (plugin->box_image);
+        ply_image_free (plugin->lock_image);
 
-  if (plugin->corner_image != NULL)
-    ply_image_free (plugin->corner_image);
+        if (plugin->corner_image != NULL)
+                ply_image_free (plugin->corner_image);
 
-  if (plugin->header_image != NULL)
-    ply_image_free (plugin->header_image);
+        if (plugin->header_image != NULL)
+                ply_image_free (plugin->header_image);
 
-  if (plugin->background_tile_image != NULL)
-    ply_image_free (plugin->background_tile_image);
+        if (plugin->background_tile_image != NULL)
+                ply_image_free (plugin->background_tile_image);
 
-  if (plugin->watermark_image != NULL)
-    ply_image_free (plugin->watermark_image);
+        if (plugin->watermark_image != NULL)
+                ply_image_free (plugin->watermark_image);
 
-  free (plugin->animation_dir);
-  free_views (plugin);
-  free (plugin);
+        free (plugin->animation_dir);
+        free_views (plugin);
+        free (plugin);
 }
 
 static void
 start_end_animation (ply_boot_splash_plugin_t *plugin,
                      ply_trigger_t            *trigger)
 {
-  ply_trace ("starting end animation");
-
-  ply_list_node_t *node;
-
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
-      ply_trigger_t *throbber_trigger;
-
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
-
-      ply_trigger_ignore_next_pull (trigger);
-
-      if (view->throbber != NULL)
-        {
-          ply_trace ("stopping throbber");
-          view->end_trigger = trigger;
-          throbber_trigger = ply_trigger_new (NULL);
-          ply_trigger_add_handler (throbber_trigger,
-                                   (ply_trigger_handler_t)
-                                   on_view_throbber_stopped,
-                                   view);
-          ply_throbber_stop (view->throbber, throbber_trigger);
-        }
-      else
-        {
-          if (view->progress_animation != NULL)
-            {
-              ply_trace ("hiding progress animation");
-              ply_progress_animation_hide (view->progress_animation);
-            }
-          view_start_end_animation (view, trigger);
+        ply_trace ("starting end animation");
+
+        ply_list_node_t *node;
+
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
+                ply_trigger_t *throbber_trigger;
+
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
+
+                ply_trigger_ignore_next_pull (trigger);
+
+                if (view->throbber != NULL) {
+                        ply_trace ("stopping throbber");
+                        view->end_trigger = trigger;
+                        throbber_trigger = ply_trigger_new (NULL);
+                        ply_trigger_add_handler (throbber_trigger,
+                                                 (ply_trigger_handler_t)
+                                                 on_view_throbber_stopped,
+                                                 view);
+                        ply_throbber_stop (view->throbber, throbber_trigger);
+                } else {
+                        if (view->progress_animation != NULL) {
+                                ply_trace ("hiding progress animation");
+                                ply_progress_animation_hide (view->progress_animation);
+                        }
+                        view_start_end_animation (view, trigger);
+                }
+
+                node = next_node;
         }
-
-      node = next_node;
-    }
-  ply_trigger_pull (trigger, NULL);
+        ply_trigger_pull (trigger, NULL);
 }
 
 static void
 start_progress_animation (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  if (plugin->is_animating)
-     return;
+        if (plugin->is_animating)
+                return;
 
-  ply_trace ("starting animation");
+        ply_trace ("starting animation");
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_start_progress_animation (view);
+                view_start_progress_animation (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  plugin->is_animating = true;
+        plugin->is_animating = true;
 
-  /* We don't really know how long shutdown will, take
-   * but it's normally really fast, so just jump to
-   * the end animation
-   */
-  if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
-    become_idle (plugin, NULL);
+        /* We don't really know how long shutdown will, take
+         * but it's normally really fast, so just jump to
+         * the end animation
+         */
+        if (plugin->mode == PLY_BOOT_SPLASH_MODE_SHUTDOWN)
+                become_idle (plugin, NULL);
 }
 
 static void
 stop_animation (ply_boot_splash_plugin_t *plugin,
                 ply_trigger_t            *trigger)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  assert (plugin != NULL);
-  assert (plugin->loop != NULL);
+        assert (plugin != NULL);
+        assert (plugin->loop != NULL);
 
-  if (!plugin->is_animating)
-     return;
+        if (!plugin->is_animating)
+                return;
 
-  ply_trace ("stopping animation%s",
-             trigger != NULL? " with trigger" : "");
+        ply_trace ("stopping animation%s",
+                   trigger != NULL ? " with trigger" : "");
 
-  plugin->is_animating = false;
+        plugin->is_animating = false;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view->progress_animation != NULL)
-        {
-          ply_trace ("hiding progress animation");
-          ply_progress_animation_hide (view->progress_animation);
-        }
-      if (trigger != NULL)
-        ply_trigger_ignore_next_pull (trigger);
-      if (view->throbber != NULL)
-        ply_throbber_stop (view->throbber, trigger);
-      ply_animation_stop (view->end_animation);
+                if (view->progress_animation != NULL) {
+                        ply_trace ("hiding progress animation");
+                        ply_progress_animation_hide (view->progress_animation);
+                }
+                if (trigger != NULL)
+                        ply_trigger_ignore_next_pull (trigger);
+                if (view->throbber != NULL)
+                        ply_throbber_stop (view->throbber, trigger);
+                ply_animation_stop (view->end_animation);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 
-  if (trigger != NULL)
-    ply_trigger_pull (trigger, NULL);
+        if (trigger != NULL)
+                ply_trigger_pull (trigger, NULL);
 }
 
 static void
 detach_from_event_loop (ply_boot_splash_plugin_t *plugin)
 {
-  plugin->loop = NULL;
+        plugin->loop = NULL;
 }
 
 static void
@@ -855,179 +822,165 @@ draw_background (view_t             *view,
                  int                 width,
                  int                 height)
 {
-  ply_boot_splash_plugin_t *plugin;
-  ply_rectangle_t area;
-
-  plugin = view->plugin;
-
-  area.x = x;
-  area.y = y;
-  area.width = width;
-  area.height = height;
-
-  if (plugin->background_start_color != plugin->background_end_color)
-    ply_pixel_buffer_fill_with_gradient (pixel_buffer, &area,
-                                         plugin->background_start_color,
-                                         plugin->background_end_color);
-  else
-    ply_pixel_buffer_fill_with_hex_color (pixel_buffer, &area,
-                                          plugin->background_start_color);
-
-  if (view->background_image != NULL)
-    {
-      uint32_t *data;
-      data = ply_image_get_data (view->background_image);
-      ply_pixel_buffer_fill_with_argb32_data (pixel_buffer, &area, data);
-    }
-
-  if (plugin->watermark_image != NULL)
-    {
-      uint32_t *data;
-
-      data = ply_image_get_data (plugin->watermark_image);
-      ply_pixel_buffer_fill_with_argb32_data (pixel_buffer, &view->watermark_area, data);
-    }
-}
-
-static void
-on_draw (view_t                   *view,
-         ply_pixel_buffer_t       *pixel_buffer,
-         int                       x,
-         int                       y,
-         int                       width,
-         int                       height)
-{
-  ply_boot_splash_plugin_t *plugin;
-  ply_rectangle_t screen_area;
-  ply_rectangle_t image_area;
-
-  plugin = view->plugin;
-
-  draw_background (view, pixel_buffer, x, y, width, height);
-
-  ply_pixel_buffer_get_size (pixel_buffer, &screen_area);
-
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY ||
-      plugin->state == PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY  )
-    {
-      uint32_t *box_data, *lock_data;
-
-      box_data = ply_image_get_data (plugin->box_image);
-      ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
-                                              &view->box_area,
-                                              box_data);
-
-      ply_entry_draw_area (view->entry,
-                           pixel_buffer,
-                           x, y, width, height);
-      ply_label_draw_area (view->label,
-                           pixel_buffer,
-                           x, y, width, height);
-
-      lock_data = ply_image_get_data (plugin->lock_image);
-      ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
-                                              &view->lock_area,
-                                              lock_data);
-    }
-  else
-    {
-      if (view->throbber != NULL &&
-          !ply_throbber_is_stopped (view->throbber))
-        {
-          ply_throbber_draw_area (view->throbber, pixel_buffer,
-                                  x, y, width, height);
-        }
-      if (view->progress_animation != NULL && !ply_progress_animation_is_hidden (view->progress_animation))
-        {
-          ply_progress_animation_draw_area (view->progress_animation,
-                                            pixel_buffer,
-                                            x, y, width, height);
+        ply_boot_splash_plugin_t *plugin;
+        ply_rectangle_t area;
+
+        plugin = view->plugin;
+
+        area.x = x;
+        area.y = y;
+        area.width = width;
+        area.height = height;
+
+        if (plugin->background_start_color != plugin->background_end_color)
+                ply_pixel_buffer_fill_with_gradient (pixel_buffer, &area,
+                                                     plugin->background_start_color,
+                                                     plugin->background_end_color);
+        else
+                ply_pixel_buffer_fill_with_hex_color (pixel_buffer, &area,
+                                                      plugin->background_start_color);
+
+        if (view->background_image != NULL) {
+                uint32_t *data;
+                data = ply_image_get_data (view->background_image);
+                ply_pixel_buffer_fill_with_argb32_data (pixel_buffer, &area, data);
         }
-      else if (!ply_animation_is_stopped (view->end_animation))
-        ply_animation_draw_area (view->end_animation,
-                                 pixel_buffer,
-                                 x, y, width, height);
 
-      if (plugin->corner_image != NULL)
-        {
-          image_area.width = ply_image_get_width (plugin->corner_image);
-          image_area.height = ply_image_get_height (plugin->corner_image);
-          image_area.x = screen_area.width - image_area.width - 20;
-          image_area.y = screen_area.height - image_area.height - 20;
-
-          ply_pixel_buffer_fill_with_argb32_data (pixel_buffer, &image_area, ply_image_get_data (plugin->corner_image));
+        if (plugin->watermark_image != NULL) {
+                uint32_t *data;
 
+                data = ply_image_get_data (plugin->watermark_image);
+                ply_pixel_buffer_fill_with_argb32_data (pixel_buffer, &view->watermark_area, data);
         }
+}
 
-      if (plugin->header_image != NULL)
-        {
-          long sprite_height;
-
-
-          if (view->progress_animation != NULL)
-            sprite_height = ply_progress_animation_get_height (view->progress_animation);
-          else
-            sprite_height = 0;
-
-          if (view->throbber != NULL)
-            sprite_height = MAX (ply_throbber_get_height (view->throbber),
-                                 sprite_height);
-
-          image_area.width = ply_image_get_width (plugin->header_image);
-          image_area.height = ply_image_get_height (plugin->header_image);
-          image_area.x = screen_area.width / 2.0 - image_area.width / 2.0;
-          image_area.y = plugin->animation_vertical_alignment * screen_area.height - sprite_height / 2.0 - image_area.height;
-
-          ply_pixel_buffer_fill_with_argb32_data (pixel_buffer, &image_area, ply_image_get_data (plugin->header_image));
+static void
+on_draw (view_t             *view,
+         ply_pixel_buffer_t *pixel_buffer,
+         int                 x,
+         int                 y,
+         int                 width,
+         int                 height)
+{
+        ply_boot_splash_plugin_t *plugin;
+        ply_rectangle_t screen_area;
+        ply_rectangle_t image_area;
+
+        plugin = view->plugin;
+
+        draw_background (view, pixel_buffer, x, y, width, height);
+
+        ply_pixel_buffer_get_size (pixel_buffer, &screen_area);
+
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY ||
+            plugin->state == PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY) {
+                uint32_t *box_data, *lock_data;
+
+                box_data = ply_image_get_data (plugin->box_image);
+                ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
+                                                        &view->box_area,
+                                                        box_data);
+
+                ply_entry_draw_area (view->entry,
+                                     pixel_buffer,
+                                     x, y, width, height);
+                ply_label_draw_area (view->label,
+                                     pixel_buffer,
+                                     x, y, width, height);
+
+                lock_data = ply_image_get_data (plugin->lock_image);
+                ply_pixel_buffer_fill_with_argb32_data (pixel_buffer,
+                                                        &view->lock_area,
+                                                        lock_data);
+        } else {
+                if (view->throbber != NULL &&
+                    !ply_throbber_is_stopped (view->throbber))
+                        ply_throbber_draw_area (view->throbber, pixel_buffer,
+                                                x, y, width, height);
+                if (view->progress_animation != NULL && !ply_progress_animation_is_hidden (view->progress_animation)) {
+                        ply_progress_animation_draw_area (view->progress_animation,
+                                                          pixel_buffer,
+                                                          x, y, width, height);
+                } else if (!ply_animation_is_stopped (view->end_animation)) {
+                        ply_animation_draw_area (view->end_animation,
+                                                 pixel_buffer,
+                                                 x, y, width, height);
+                }
+
+                if (plugin->corner_image != NULL) {
+                        image_area.width = ply_image_get_width (plugin->corner_image);
+                        image_area.height = ply_image_get_height (plugin->corner_image);
+                        image_area.x = screen_area.width - image_area.width - 20;
+                        image_area.y = screen_area.height - image_area.height - 20;
+
+                        ply_pixel_buffer_fill_with_argb32_data (pixel_buffer, &image_area, ply_image_get_data (plugin->corner_image));
+                }
+
+                if (plugin->header_image != NULL) {
+                        long sprite_height;
+
+
+                        if (view->progress_animation != NULL)
+                                sprite_height = ply_progress_animation_get_height (view->progress_animation);
+                        else
+                                sprite_height = 0;
+
+                        if (view->throbber != NULL)
+                                sprite_height = MAX (ply_throbber_get_height (view->throbber),
+                                                     sprite_height);
+
+                        image_area.width = ply_image_get_width (plugin->header_image);
+                        image_area.height = ply_image_get_height (plugin->header_image);
+                        image_area.x = screen_area.width / 2.0 - image_area.width / 2.0;
+                        image_area.y = plugin->animation_vertical_alignment * screen_area.height - sprite_height / 2.0 - image_area.height;
+
+                        ply_pixel_buffer_fill_with_argb32_data (pixel_buffer, &image_area, ply_image_get_data (plugin->header_image));
+                }
         }
-    }
-  ply_label_draw_area (view->message_label,
-                       pixel_buffer,
-                       x, y, width, height);
+        ply_label_draw_area (view->message_label,
+                             pixel_buffer,
+                             x, y, width, height);
 }
 
 static void
 add_pixel_display (ply_boot_splash_plugin_t *plugin,
                    ply_pixel_display_t      *display)
 {
-  view_t *view;
+        view_t *view;
 
-  ply_trace ("adding pixel display to plugin");
-  view = view_new (plugin, display);
+        ply_trace ("adding pixel display to plugin");
+        view = view_new (plugin, display);
 
-  ply_pixel_display_set_draw_handler (view->display,
-                                      (ply_pixel_display_draw_handler_t)
-                                      on_draw, view);
-  ply_list_append_data (plugin->views, view);
+        ply_pixel_display_set_draw_handler (view->display,
+                                            (ply_pixel_display_draw_handler_t)
+                                            on_draw, view);
+        ply_list_append_data (plugin->views, view);
 }
 
 static void
 remove_pixel_display (ply_boot_splash_plugin_t *plugin,
                       ply_pixel_display_t      *display)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("removing pixel display from plugin");
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      view_t *view;
-      ply_list_node_t *next_node;
+        ply_trace ("removing pixel display from plugin");
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                view_t *view;
+                ply_list_node_t *next_node;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view->display == display)
-        {
+                if (view->display == display) {
+                        ply_pixel_display_set_draw_handler (view->display, NULL, NULL);
+                        view_free (view);
+                        ply_list_remove_node (plugin->views, node);
+                        return;
+                }
 
-          ply_pixel_display_set_draw_handler (view->display, NULL, NULL);
-          view_free (view);
-          ply_list_remove_node (plugin->views, node);
-          return;
+                node = next_node;
         }
-
-      node = next_node;
-    }
 }
 
 static bool
@@ -1036,118 +989,107 @@ show_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_buffer_t             *boot_buffer,
                     ply_boot_splash_mode_t    mode)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  plugin->loop = loop;
-  plugin->mode = mode;
+        plugin->loop = loop;
+        plugin->mode = mode;
 
-  ply_trace ("loading lock image");
-  if (!ply_image_load (plugin->lock_image))
-    return false;
+        ply_trace ("loading lock image");
+        if (!ply_image_load (plugin->lock_image))
+                return false;
 
-  ply_trace ("loading box image");
-  if (!ply_image_load (plugin->box_image))
-    return false;
+        ply_trace ("loading box image");
+        if (!ply_image_load (plugin->box_image))
+                return false;
 
-  if (plugin->corner_image != NULL)
-    {
-      ply_trace ("loading corner image");
+        if (plugin->corner_image != NULL) {
+                ply_trace ("loading corner image");
 
-      if (!ply_image_load (plugin->corner_image))
-        {
-          ply_image_free (plugin->corner_image);
-          plugin->corner_image = NULL;
+                if (!ply_image_load (plugin->corner_image)) {
+                        ply_image_free (plugin->corner_image);
+                        plugin->corner_image = NULL;
+                }
         }
-    }
 
-  if (plugin->header_image != NULL)
-    {
-      ply_trace ("loading header image");
+        if (plugin->header_image != NULL) {
+                ply_trace ("loading header image");
 
-      if (!ply_image_load (plugin->header_image))
-        {
-          ply_image_free (plugin->header_image);
-          plugin->header_image = NULL;
+                if (!ply_image_load (plugin->header_image)) {
+                        ply_image_free (plugin->header_image);
+                        plugin->header_image = NULL;
+                }
         }
-    }
 
-  if (plugin->background_tile_image != NULL)
-    {
-      ply_trace ("loading background tile image");
-      if (!ply_image_load (plugin->background_tile_image))
-        {
-          ply_image_free (plugin->background_tile_image);
-          plugin->background_tile_image = NULL;
+        if (plugin->background_tile_image != NULL) {
+                ply_trace ("loading background tile image");
+                if (!ply_image_load (plugin->background_tile_image)) {
+                        ply_image_free (plugin->background_tile_image);
+                        plugin->background_tile_image = NULL;
+                }
         }
-    }
 
-  if (plugin->watermark_image != NULL)
-    {
-      ply_trace ("loading watermark image");
-      if (!ply_image_load (plugin->watermark_image))
-        {
-          ply_image_free (plugin->watermark_image);
-          plugin->watermark_image = NULL;
+        if (plugin->watermark_image != NULL) {
+                ply_trace ("loading watermark image");
+                if (!ply_image_load (plugin->watermark_image)) {
+                        ply_image_free (plugin->watermark_image);
+                        plugin->watermark_image = NULL;
+                }
         }
-    }
 
-  if (!load_views (plugin))
-    {
-      ply_trace ("couldn't load views");
-      return false;
-    }
+        if (!load_views (plugin)) {
+                ply_trace ("couldn't load views");
+                return false;
+        }
 
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
-                                 detach_from_event_loop,
-                                 plugin);
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       detach_from_event_loop,
+                                       plugin);
 
-  ply_trace ("starting boot animations");
-  start_progress_animation (plugin);
+        ply_trace ("starting boot animations");
+        start_progress_animation (plugin);
 
-  plugin->is_visible = true;
+        plugin->is_visible = true;
 
-  return true;
+        return true;
 }
 
 static void
 update_status (ply_boot_splash_plugin_t *plugin,
                const char               *status)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 }
 
 static void
 on_animation_stopped (ply_boot_splash_plugin_t *plugin)
 {
-  if (plugin->idle_trigger != NULL)
-    {
-      ply_trigger_pull (plugin->idle_trigger, NULL);
-      plugin->idle_trigger = NULL;
-    }
-  plugin->is_idle = true;
+        if (plugin->idle_trigger != NULL) {
+                ply_trigger_pull (plugin->idle_trigger, NULL);
+                plugin->idle_trigger = NULL;
+        }
+        plugin->is_idle = true;
 }
 
 static void
 update_progress_animation (ply_boot_splash_plugin_t *plugin,
                            double                    percent_done)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      if (view->progress_animation != NULL)
-        ply_progress_animation_set_percent_done (view->progress_animation,
-                                                 percent_done);
+                if (view->progress_animation != NULL)
+                        ply_progress_animation_set_percent_done (view->progress_animation,
+                                                                 percent_done);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
@@ -1155,70 +1097,64 @@ on_boot_progress (ply_boot_splash_plugin_t *plugin,
                   double                    duration,
                   double                    percent_done)
 {
-  if (plugin->mode == PLY_BOOT_SPLASH_MODE_UPDATES)
-    return;
-
-  if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    return;
-
-  if (plugin->is_idle)
-    return;
-
-  if (percent_done >= SHOW_ANIMATION_PERCENT)
-    {
-      if (plugin->stop_trigger == NULL)
-        {
-          ply_trace ("boot progressed to end");
-
-          plugin->stop_trigger = ply_trigger_new (&plugin->stop_trigger);
-          ply_trigger_add_handler (plugin->stop_trigger,
-                                   (ply_trigger_handler_t)
-                                   on_animation_stopped,
-                                   plugin);
-          start_end_animation (plugin, plugin->stop_trigger);
+        if (plugin->mode == PLY_BOOT_SPLASH_MODE_UPDATES)
+                return;
+
+        if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                return;
+
+        if (plugin->is_idle)
+                return;
+
+        if (percent_done >= SHOW_ANIMATION_PERCENT) {
+                if (plugin->stop_trigger == NULL) {
+                        ply_trace ("boot progressed to end");
+
+                        plugin->stop_trigger = ply_trigger_new (&plugin->stop_trigger);
+                        ply_trigger_add_handler (plugin->stop_trigger,
+                                                 (ply_trigger_handler_t)
+                                                 on_animation_stopped,
+                                                 plugin);
+                        start_end_animation (plugin, plugin->stop_trigger);
+                }
+        } else {
+                double total_duration;
+
+                percent_done *= (1 / SHOW_ANIMATION_PERCENT);
+
+                switch (plugin->progress_function) {
+                /* Fun made-up smoothing function to make the growth asymptotic:
+                 * fraction(time,estimate)=1-2^(-(time^1.45)/estimate) */
+                case PROGRESS_FUNCTION_TYPE_WWOODS:
+                        total_duration = duration / percent_done;
+                        percent_done = 1.0 - pow (2.0, -pow (duration, 1.45) / total_duration) * (1.0 - percent_done);
+                        break;
+
+                case PROGRESS_FUNCTION_TYPE_LINEAR:
+                        break;
+                }
+
+                update_progress_animation (plugin, percent_done);
         }
-    }
-  else
-    {
-      double total_duration;
-
-      percent_done *= (1 / SHOW_ANIMATION_PERCENT);
-
-      switch (plugin->progress_function)
-        {
-          /* Fun made-up smoothing function to make the growth asymptotic:
-           * fraction(time,estimate)=1-2^(-(time^1.45)/estimate) */
-          case PROGRESS_FUNCTION_TYPE_WWOODS:
-            total_duration = duration / percent_done;
-            percent_done = 1.0 - pow (2.0, -pow (duration, 1.45) / total_duration) * (1.0 - percent_done);
-            break;
-
-          case PROGRESS_FUNCTION_TYPE_LINEAR:
-            break;
-        }
-
-      update_progress_animation (plugin, percent_done);
-    }
 }
 
 static void
 hide_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_event_loop_t         *loop)
 {
-  assert (plugin != NULL);
+        assert (plugin != NULL);
 
-  ply_trace ("hiding splash");
-  if (plugin->loop != NULL)
-    {
-      stop_animation (plugin, NULL);
+        ply_trace ("hiding splash");
+        if (plugin->loop != NULL) {
+                stop_animation (plugin, NULL);
 
-      ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
-                                             detach_from_event_loop,
-                                             plugin);
-      detach_from_event_loop (plugin);
-    }
+                ply_event_loop_stop_watching_for_exit (plugin->loop, (ply_event_loop_exit_handler_t)
+                                                       detach_from_event_loop,
+                                                       plugin);
+                detach_from_event_loop (plugin);
+        }
 
-  plugin->is_visible = false;
+        plugin->is_visible = false;
 }
 
 static void
@@ -1226,23 +1162,22 @@ show_password_prompt (ply_boot_splash_plugin_t *plugin,
                       const char               *text,
                       int                       number_of_bullets)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("showing password prompt");
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        ply_trace ("showing password prompt");
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, text);
-      ply_entry_set_bullet_count (view->entry, number_of_bullets);
+                view_show_prompt (view, text);
+                ply_entry_set_bullet_count (view->entry, number_of_bullets);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
@@ -1250,81 +1185,75 @@ show_prompt (ply_boot_splash_plugin_t *plugin,
              const char               *prompt,
              const char               *entry_text)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("showing prompt");
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        ply_trace ("showing prompt");
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_show_prompt (view, prompt);
-      ply_entry_set_text (view->entry, entry_text);
+                view_show_prompt (view, prompt);
+                ply_entry_set_text (view->entry, entry_text);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 static void
 on_root_mounted (ply_boot_splash_plugin_t *plugin)
 {
-  ply_trace ("root filesystem mounted");
-  plugin->root_is_mounted = true;
+        ply_trace ("root filesystem mounted");
+        plugin->root_is_mounted = true;
 }
 
 static void
 become_idle (ply_boot_splash_plugin_t *plugin,
              ply_trigger_t            *idle_trigger)
 {
-  ply_trace ("deactivation requested");
-  if (plugin->is_idle)
-    {
-      ply_trace ("plugin is already idle");
-      ply_trigger_pull (idle_trigger, NULL);
-      return;
-    }
-
-  plugin->idle_trigger = idle_trigger;
-
-  if (plugin->stop_trigger == NULL)
-    {
-      ply_trace ("waiting for plugin to stop");
-      plugin->stop_trigger = ply_trigger_new (&plugin->stop_trigger);
-      ply_trigger_add_handler (plugin->stop_trigger,
-                               (ply_trigger_handler_t)
-                               on_animation_stopped,
-                               plugin);
-      start_end_animation (plugin, plugin->stop_trigger);
-    }
-  else
-    {
-      ply_trace ("already waiting for plugin to stop");
-    }
+        ply_trace ("deactivation requested");
+        if (plugin->is_idle) {
+                ply_trace ("plugin is already idle");
+                ply_trigger_pull (idle_trigger, NULL);
+                return;
+        }
+
+        plugin->idle_trigger = idle_trigger;
+
+        if (plugin->stop_trigger == NULL) {
+                ply_trace ("waiting for plugin to stop");
+                plugin->stop_trigger = ply_trigger_new (&plugin->stop_trigger);
+                ply_trigger_add_handler (plugin->stop_trigger,
+                                         (ply_trigger_handler_t)
+                                         on_animation_stopped,
+                                         plugin);
+                start_end_animation (plugin, plugin->stop_trigger);
+        } else {
+                ply_trace ("already waiting for plugin to stop");
+        }
 }
 
 static void
 hide_prompt (ply_boot_splash_plugin_t *plugin)
 {
-  ply_list_node_t *node;
+        ply_list_node_t *node;
 
-  ply_trace ("hiding prompt");
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
+        ply_trace ("hiding prompt");
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
 
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
 
-      view_hide_prompt (view);
+                view_hide_prompt (view);
 
-      node = next_node;
-    }
+                node = next_node;
+        }
 }
 
 
@@ -1332,61 +1261,59 @@ static void
 show_message (ply_boot_splash_plugin_t *plugin,
               const char               *message)
 {
-  ply_trace ("Showing message '%s'", message);
-  ply_list_node_t *node;
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
-
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
-      
-      ply_label_set_text (view->message_label, message);
-      ply_label_show (view->message_label, view->display, 10, 10);
-      
-      ply_pixel_display_draw_area (view->display, 10, 10,
-                                   ply_label_get_width (view->message_label),
-                                   ply_label_get_height(view->message_label));
-      node = next_node;
-    }
+        ply_trace ("Showing message '%s'", message);
+        ply_list_node_t *node;
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
+
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
+
+                ply_label_set_text (view->message_label, message);
+                ply_label_show (view->message_label, view->display, 10, 10);
+
+                ply_pixel_display_draw_area (view->display, 10, 10,
+                                             ply_label_get_width (view->message_label),
+                                             ply_label_get_height (view->message_label));
+                node = next_node;
+        }
 }
 
 static void
 system_update (ply_boot_splash_plugin_t *plugin,
                int                       progress)
 {
-  ply_list_node_t *node;
-
-  if (plugin->mode != PLY_BOOT_SPLASH_MODE_UPDATES)
-    return;
-
-  node = ply_list_get_first_node (plugin->views);
-  while (node != NULL)
-    {
-      ply_list_node_t *next_node;
-      view_t *view;
-
-      view = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (plugin->views, node);
-      ply_progress_animation_set_percent_done (view->progress_animation,
-                                               (double) progress / 100.f);
-      node = next_node;
-    }
+        ply_list_node_t *node;
+
+        if (plugin->mode != PLY_BOOT_SPLASH_MODE_UPDATES)
+                return;
+
+        node = ply_list_get_first_node (plugin->views);
+        while (node != NULL) {
+                ply_list_node_t *next_node;
+                view_t *view;
+
+                view = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (plugin->views, node);
+                ply_progress_animation_set_percent_done (view->progress_animation,
+                                                         (double) progress / 100.f);
+                node = next_node;
+        }
 }
 
 static void
 display_normal (ply_boot_splash_plugin_t *plugin)
 {
-  pause_views (plugin);
-  if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    hide_prompt (plugin);
-
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
-  start_progress_animation (plugin);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        pause_views (plugin);
+        if (plugin->state != PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                hide_prompt (plugin);
+
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_NORMAL;
+        start_progress_animation (plugin);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
@@ -1394,14 +1321,14 @@ display_password (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   int                       bullets)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin, NULL);
-
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
-  show_password_prompt (plugin, prompt, bullets);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin, NULL);
+
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_PASSWORD_ENTRY;
+        show_password_prompt (plugin, prompt, bullets);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
@@ -1409,46 +1336,46 @@ display_question (ply_boot_splash_plugin_t *plugin,
                   const char               *prompt,
                   const char               *entry_text)
 {
-  pause_views (plugin);
-  if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
-    stop_animation (plugin, NULL);
-
-  plugin->state = PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY;
-  show_prompt (plugin, prompt, entry_text);
-  redraw_views (plugin);
-  unpause_views (plugin);
+        pause_views (plugin);
+        if (plugin->state == PLY_BOOT_SPLASH_DISPLAY_NORMAL)
+                stop_animation (plugin, NULL);
+
+        plugin->state = PLY_BOOT_SPLASH_DISPLAY_QUESTION_ENTRY;
+        show_prompt (plugin, prompt, entry_text);
+        redraw_views (plugin);
+        unpause_views (plugin);
 }
 
 static void
 display_message (ply_boot_splash_plugin_t *plugin,
                  const char               *message)
 {
-  show_message (plugin, message);
+        show_message (plugin, message);
 }
 
 ply_boot_splash_plugin_interface_t *
 ply_boot_splash_plugin_get_interface (void)
 {
-  static ply_boot_splash_plugin_interface_t plugin_interface =
-    {
-      .create_plugin = create_plugin,
-      .destroy_plugin = destroy_plugin,
-      .add_pixel_display = add_pixel_display,
-      .remove_pixel_display = remove_pixel_display,
-      .show_splash_screen = show_splash_screen,
-      .update_status = update_status,
-      .on_boot_progress = on_boot_progress,
-      .hide_splash_screen = hide_splash_screen,
-      .on_root_mounted = on_root_mounted,
-      .become_idle = become_idle,
-      .display_normal = display_normal,
-      .display_password = display_password,
-      .display_question = display_question,
-      .display_message = display_message,
-      .system_update = system_update,
-    };
-
-  return &plugin_interface;
+        static ply_boot_splash_plugin_interface_t plugin_interface =
+        {
+                .create_plugin        = create_plugin,
+                .destroy_plugin       = destroy_plugin,
+                .add_pixel_display    = add_pixel_display,
+                .remove_pixel_display = remove_pixel_display,
+                .show_splash_screen   = show_splash_screen,
+                .update_status        = update_status,
+                .on_boot_progress     = on_boot_progress,
+                .hide_splash_screen   = hide_splash_screen,
+                .on_root_mounted      = on_root_mounted,
+                .become_idle          = become_idle,
+                .display_normal       = display_normal,
+                .display_password     = display_password,
+                .display_question     = display_question,
+                .display_message      = display_message,
+                .system_update        = system_update,
+        };
+
+        return &plugin_interface;
 }
 
 /* vim: set ts=4 sw=4 et ai ci cino={.5s,^-2,+.5s,t0,g0,e-2,n-2,p2s,(0,=.5s,:.5s */
diff --git a/src/ply-boot-server.c b/src/ply-boot-server.c
index c5a2f7f..3c1a268 100644
--- a/src/ply-boot-server.c
+++ b/src/ply-boot-server.c
@@ -41,100 +41,100 @@
 
 typedef struct
 {
-  int fd;
-  ply_fd_watch_t *watch;
-  ply_boot_server_t *server;
-  uid_t uid;
-  pid_t pid;
+        int                fd;
+        ply_fd_watch_t    *watch;
+        ply_boot_server_t *server;
+        uid_t              uid;
+        pid_t              pid;
 
-  uint32_t credentials_read : 1;
+        uint32_t           credentials_read : 1;
 } ply_boot_connection_t;
 
 struct _ply_boot_server
 {
-  ply_event_loop_t *loop;
-  ply_list_t *connections;
-  ply_list_t *cached_passwords;
-  int socket_fd;
-
-  ply_boot_server_update_handler_t update_handler;
-  ply_boot_server_change_mode_handler_t change_mode_handler;
-  ply_boot_server_system_update_handler_t system_update_handler;
-  ply_boot_server_newroot_handler_t newroot_handler;
-  ply_boot_server_system_initialized_handler_t system_initialized_handler;
-  ply_boot_server_error_handler_t error_handler;
-  ply_boot_server_show_splash_handler_t show_splash_handler;
-  ply_boot_server_hide_splash_handler_t hide_splash_handler;
-  ply_boot_server_ask_for_password_handler_t ask_for_password_handler;
-  ply_boot_server_ask_question_handler_t ask_question_handler;
-  ply_boot_server_display_message_handler_t display_message_handler;
-  ply_boot_server_hide_message_handler_t hide_message_handler;
-  ply_boot_server_watch_for_keystroke_handler_t watch_for_keystroke_handler;
-  ply_boot_server_ignore_keystroke_handler_t ignore_keystroke_handler;
-  ply_boot_server_progress_pause_handler_t progress_pause_handler;
-  ply_boot_server_progress_unpause_handler_t progress_unpause_handler;
-  ply_boot_server_deactivate_handler_t deactivate_handler;
-  ply_boot_server_reactivate_handler_t reactivate_handler;
-  ply_boot_server_quit_handler_t quit_handler;
-  ply_boot_server_has_active_vt_handler_t has_active_vt_handler;
-  void *user_data;
-
-  uint32_t is_listening : 1;
+        ply_event_loop_t                             *loop;
+        ply_list_t                                   *connections;
+        ply_list_t                                   *cached_passwords;
+        int                                           socket_fd;
+
+        ply_boot_server_update_handler_t              update_handler;
+        ply_boot_server_change_mode_handler_t         change_mode_handler;
+        ply_boot_server_system_update_handler_t       system_update_handler;
+        ply_boot_server_newroot_handler_t             newroot_handler;
+        ply_boot_server_system_initialized_handler_t  system_initialized_handler;
+        ply_boot_server_error_handler_t               error_handler;
+        ply_boot_server_show_splash_handler_t         show_splash_handler;
+        ply_boot_server_hide_splash_handler_t         hide_splash_handler;
+        ply_boot_server_ask_for_password_handler_t    ask_for_password_handler;
+        ply_boot_server_ask_question_handler_t        ask_question_handler;
+        ply_boot_server_display_message_handler_t     display_message_handler;
+        ply_boot_server_hide_message_handler_t        hide_message_handler;
+        ply_boot_server_watch_for_keystroke_handler_t watch_for_keystroke_handler;
+        ply_boot_server_ignore_keystroke_handler_t    ignore_keystroke_handler;
+        ply_boot_server_progress_pause_handler_t      progress_pause_handler;
+        ply_boot_server_progress_unpause_handler_t    progress_unpause_handler;
+        ply_boot_server_deactivate_handler_t          deactivate_handler;
+        ply_boot_server_reactivate_handler_t          reactivate_handler;
+        ply_boot_server_quit_handler_t                quit_handler;
+        ply_boot_server_has_active_vt_handler_t       has_active_vt_handler;
+        void                                         *user_data;
+
+        uint32_t                                      is_listening : 1;
 };
 
 ply_boot_server_t *
-ply_boot_server_new (ply_boot_server_update_handler_t  update_handler,
-                     ply_boot_server_change_mode_handler_t  change_mode_handler,
-                     ply_boot_server_system_update_handler_t  system_update_handler,
-                     ply_boot_server_ask_for_password_handler_t ask_for_password_handler,
-                     ply_boot_server_ask_question_handler_t ask_question_handler,
-                     ply_boot_server_display_message_handler_t display_message_handler,
-                     ply_boot_server_hide_message_handler_t hide_message_handler,
+ply_boot_server_new (ply_boot_server_update_handler_t              update_handler,
+                     ply_boot_server_change_mode_handler_t         change_mode_handler,
+                     ply_boot_server_system_update_handler_t       system_update_handler,
+                     ply_boot_server_ask_for_password_handler_t    ask_for_password_handler,
+                     ply_boot_server_ask_question_handler_t        ask_question_handler,
+                     ply_boot_server_display_message_handler_t     display_message_handler,
+                     ply_boot_server_hide_message_handler_t        hide_message_handler,
                      ply_boot_server_watch_for_keystroke_handler_t watch_for_keystroke_handler,
-                     ply_boot_server_ignore_keystroke_handler_t ignore_keystroke_handler,
-                     ply_boot_server_progress_pause_handler_t progress_pause_handler,
-                     ply_boot_server_progress_unpause_handler_t progress_unpause_handler,
-                     ply_boot_server_show_splash_handler_t show_splash_handler,
-                     ply_boot_server_hide_splash_handler_t hide_splash_handler,
-                     ply_boot_server_newroot_handler_t newroot_handler,
-                     ply_boot_server_system_initialized_handler_t initialized_handler,
-                     ply_boot_server_error_handler_t error_handler,
-                     ply_boot_server_deactivate_handler_t deactivate_handler,
-                     ply_boot_server_reactivate_handler_t reactivate_handler,
-                     ply_boot_server_quit_handler_t quit_handler,
-                     ply_boot_server_has_active_vt_handler_t has_active_vt_handler,
-                     void                             *user_data)
+                     ply_boot_server_ignore_keystroke_handler_t    ignore_keystroke_handler,
+                     ply_boot_server_progress_pause_handler_t      progress_pause_handler,
+                     ply_boot_server_progress_unpause_handler_t    progress_unpause_handler,
+                     ply_boot_server_show_splash_handler_t         show_splash_handler,
+                     ply_boot_server_hide_splash_handler_t         hide_splash_handler,
+                     ply_boot_server_newroot_handler_t             newroot_handler,
+                     ply_boot_server_system_initialized_handler_t  initialized_handler,
+                     ply_boot_server_error_handler_t               error_handler,
+                     ply_boot_server_deactivate_handler_t          deactivate_handler,
+                     ply_boot_server_reactivate_handler_t          reactivate_handler,
+                     ply_boot_server_quit_handler_t                quit_handler,
+                     ply_boot_server_has_active_vt_handler_t       has_active_vt_handler,
+                     void                                         *user_data)
 {
-  ply_boot_server_t *server;
-
-  server = calloc (1, sizeof (ply_boot_server_t));
-  server->connections = ply_list_new ();
-  server->cached_passwords = ply_list_new ();
-  server->loop = NULL;
-  server->is_listening = false;
-  server->update_handler = update_handler;
-  server->change_mode_handler = change_mode_handler;
-  server->system_update_handler = system_update_handler;
-  server->ask_for_password_handler = ask_for_password_handler;
-  server->ask_question_handler = ask_question_handler;
-  server->display_message_handler = display_message_handler;
-  server->hide_message_handler = hide_message_handler;
-  server->watch_for_keystroke_handler = watch_for_keystroke_handler;
-  server->ignore_keystroke_handler = ignore_keystroke_handler;
-  server->progress_pause_handler = progress_pause_handler;
-  server->progress_unpause_handler = progress_unpause_handler;
-  server->newroot_handler = newroot_handler;
-  server->error_handler = error_handler;
-  server->system_initialized_handler = initialized_handler;
-  server->show_splash_handler = show_splash_handler;
-  server->hide_splash_handler = hide_splash_handler;
-  server->deactivate_handler = deactivate_handler;
-  server->reactivate_handler = reactivate_handler;
-  server->quit_handler = quit_handler;
-  server->has_active_vt_handler = has_active_vt_handler;
-  server->user_data = user_data;
-
-  return server;
+        ply_boot_server_t *server;
+
+        server = calloc (1, sizeof(ply_boot_server_t));
+        server->connections = ply_list_new ();
+        server->cached_passwords = ply_list_new ();
+        server->loop = NULL;
+        server->is_listening = false;
+        server->update_handler = update_handler;
+        server->change_mode_handler = change_mode_handler;
+        server->system_update_handler = system_update_handler;
+        server->ask_for_password_handler = ask_for_password_handler;
+        server->ask_question_handler = ask_question_handler;
+        server->display_message_handler = display_message_handler;
+        server->hide_message_handler = hide_message_handler;
+        server->watch_for_keystroke_handler = watch_for_keystroke_handler;
+        server->ignore_keystroke_handler = ignore_keystroke_handler;
+        server->progress_pause_handler = progress_pause_handler;
+        server->progress_unpause_handler = progress_unpause_handler;
+        server->newroot_handler = newroot_handler;
+        server->error_handler = error_handler;
+        server->system_initialized_handler = initialized_handler;
+        server->show_splash_handler = show_splash_handler;
+        server->hide_splash_handler = hide_splash_handler;
+        server->deactivate_handler = deactivate_handler;
+        server->reactivate_handler = reactivate_handler;
+        server->quit_handler = quit_handler;
+        server->has_active_vt_handler = has_active_vt_handler;
+        server->user_data = user_data;
+
+        return server;
 }
 
 static void ply_boot_connection_on_hangup (ply_boot_connection_t *connection);
@@ -142,694 +142,625 @@ static void ply_boot_connection_on_hangup (ply_boot_connection_t *connection);
 void
 ply_boot_server_free (ply_boot_server_t *server)
 {
-  ply_list_node_t *node;
-  if (server == NULL)
-    return;
-  while ((node = ply_list_get_first_node(server->connections)))
-    {
-      ply_boot_connection_t *connection = ply_list_node_get_data (node);
-      ply_boot_connection_on_hangup (connection);
-    }
-  ply_list_free (server->connections);
-  ply_list_free (server->cached_passwords);
-  free (server);
+        ply_list_node_t *node;
+
+        if (server == NULL)
+                return;
+        while ((node = ply_list_get_first_node (server->connections))) {
+                ply_boot_connection_t *connection = ply_list_node_get_data (node);
+                ply_boot_connection_on_hangup (connection);
+        }
+        ply_list_free (server->connections);
+        ply_list_free (server->cached_passwords);
+        free (server);
 }
 
 static ply_boot_connection_t *
 ply_boot_connection_new (ply_boot_server_t *server,
                          int                fd)
 {
-  ply_boot_connection_t *connection;
+        ply_boot_connection_t *connection;
 
-  connection = calloc (1, sizeof (ply_boot_server_t));
-  connection->fd = fd;
-  connection->server = server;
-  connection->watch = NULL;
+        connection = calloc (1, sizeof(ply_boot_server_t));
+        connection->fd = fd;
+        connection->server = server;
+        connection->watch = NULL;
 
-  return connection;
+        return connection;
 }
 
 static void
 ply_boot_connection_free (ply_boot_connection_t *connection)
 {
-  if (connection == NULL)
-    return;
+        if (connection == NULL)
+                return;
 
-  close (connection->fd);
-  free (connection);
+        close (connection->fd);
+        free (connection);
 }
 
 bool
 ply_boot_server_listen (ply_boot_server_t *server)
 {
-  assert (server != NULL);
+        assert (server != NULL);
 
-  server->socket_fd =
-      ply_listen_to_unix_socket (PLY_BOOT_PROTOCOL_TRIMMED_ABSTRACT_SOCKET_PATH,
-                                 PLY_UNIX_SOCKET_TYPE_TRIMMED_ABSTRACT);
+        server->socket_fd =
+                ply_listen_to_unix_socket (PLY_BOOT_PROTOCOL_TRIMMED_ABSTRACT_SOCKET_PATH,
+                                           PLY_UNIX_SOCKET_TYPE_TRIMMED_ABSTRACT);
 
-  if (server->socket_fd < 0)
-    return false;
+        if (server->socket_fd < 0)
+                return false;
 
-  return true;
+        return true;
 }
 
 void
 ply_boot_server_stop_listening (ply_boot_server_t *server)
 {
-  assert (server != NULL);
+        assert (server != NULL);
 }
 
 static bool
-ply_boot_connection_read_request (ply_boot_connection_t  *connection,
-                                  char                  **command,
-                                  char                  **argument)
+ply_boot_connection_read_request (ply_boot_connection_t *connection,
+                                  char                 **command,
+                                  char                 **argument)
 {
-  uint8_t header[2];
+        uint8_t header[2];
 
-  assert (connection != NULL);
-  assert (connection->fd >= 0);
+        assert (connection != NULL);
+        assert (connection->fd >= 0);
 
-  connection->credentials_read = false;
+        connection->credentials_read = false;
 
-  if (!ply_read (connection->fd, header, sizeof (header)))
-    return false;
+        if (!ply_read (connection->fd, header, sizeof(header)))
+                return false;
 
-  *command = calloc (2, sizeof (char));
-  *command[0] = header[0];
+        *command = calloc (2, sizeof(char));
+        *command[0] = header[0];
 
-  *argument = NULL;
-  if (header[1] == '\002')
-    {
-      uint8_t argument_size;
+        *argument = NULL;
+        if (header[1] == '\002') {
+                uint8_t argument_size;
 
-      if (!ply_read (connection->fd, &argument_size, sizeof (uint8_t)))
-        {
-          free (*command);
-          return false;
-        }
+                if (!ply_read (connection->fd, &argument_size, sizeof(uint8_t))) {
+                        free (*command);
+                        return false;
+                }
 
-      *argument = calloc (argument_size, sizeof (char));
+                *argument = calloc (argument_size, sizeof(char));
+
+                if (!ply_read (connection->fd, *argument, argument_size)) {
+                        free (*argument);
+                        free (*command);
+                        return false;
+                }
+        }
 
-      if (!ply_read (connection->fd, *argument, argument_size))
-        {
-          free (*argument);
-          free (*command);
-          return false;
+        if (!ply_get_credentials_from_fd (connection->fd, &connection->pid, &connection->uid, NULL)) {
+                ply_trace ("couldn't read credentials from connection: %m");
+                free (*argument);
+                free (*command);
+                return false;
         }
-    }
-
-  if (!ply_get_credentials_from_fd (connection->fd, &connection->pid, &connection->uid, NULL))
-    {
-      ply_trace ("couldn't read credentials from connection: %m");
-      free (*argument);
-      free (*command);
-      return false;
-    }
-  connection->credentials_read = true;
-
-  return true;
+        connection->credentials_read = true;
+
+        return true;
 }
 
 static bool
 ply_boot_connection_is_from_root (ply_boot_connection_t *connection)
 {
-  if (!connection->credentials_read)
-    {
-      ply_trace ("Asked if connection is from root, but haven't checked credentials yet");
-      return false;
-    }
+        if (!connection->credentials_read) {
+                ply_trace ("Asked if connection is from root, but haven't checked credentials yet");
+                return false;
+        }
 
-  return connection->uid == 0;
+        return connection->uid == 0;
 }
 
 static void
 ply_boot_connection_send_answer (ply_boot_connection_t *connection,
                                  const char            *answer)
 {
-  uint32_t size;
-
-  /* splash plugin isn't able to ask for password,
-   * punt to client
-   */
-  if (answer == NULL)
-    {
-      if (!ply_write (connection->fd,
-                      PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NO_ANSWER,
-                      strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NO_ANSWER)))
-        ply_trace ("could not finish writing no answer reply: %m");
-    }
-  else
-    {
-      size = strlen (answer);
-
-      if (!ply_write (connection->fd,
-                      PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ANSWER,
-                      strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ANSWER)) ||
-          !ply_write_uint32 (connection->fd,
-                             size) ||
-          !ply_write (connection->fd,
-                      answer, size))
-          ply_trace ("could not finish writing answer: %m");
-
-    }
-
+        uint32_t size;
+
+        /* splash plugin isn't able to ask for password,
+         * punt to client
+         */
+        if (answer == NULL) {
+                if (!ply_write (connection->fd,
+                                PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NO_ANSWER,
+                                strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NO_ANSWER)))
+                        ply_trace ("could not finish writing no answer reply: %m");
+        } else {
+                size = strlen (answer);
+
+                if (!ply_write (connection->fd,
+                                PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ANSWER,
+                                strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ANSWER)) ||
+                    !ply_write_uint32 (connection->fd,
+                                       size) ||
+                    !ply_write (connection->fd,
+                                answer, size))
+                        ply_trace ("could not finish writing answer: %m");
+        }
 }
 
 static void
 ply_boot_connection_on_password_answer (ply_boot_connection_t *connection,
                                         const char            *password)
 {
-  ply_trace ("got password answer");
-
-  ply_boot_connection_send_answer (connection, password);
-  if (password != NULL)
-    ply_list_append_data (connection->server->cached_passwords,
-                          strdup (password));
+        ply_trace ("got password answer");
 
+        ply_boot_connection_send_answer (connection, password);
+        if (password != NULL)
+                ply_list_append_data (connection->server->cached_passwords,
+                                      strdup (password));
 }
 
 static void
 ply_boot_connection_on_deactivated (ply_boot_connection_t *connection)
 {
-  ply_trace ("deactivated");
-  if (!ply_write (connection->fd,
-                  PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
-                  strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)))
-    {
-      ply_trace ("could not finish writing deactivate reply: %m");
-    }
+        ply_trace ("deactivated");
+        if (!ply_write (connection->fd,
+                        PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
+                        strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)))
+                ply_trace ("could not finish writing deactivate reply: %m");
 }
 
 static void
 ply_boot_connection_on_quit_complete (ply_boot_connection_t *connection)
 {
-  ply_trace ("quit complete");
-  if (!ply_write (connection->fd,
-                  PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
-                  strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)))
-    {
-      ply_trace ("could not finish writing quit reply: %m");
-    }
+        ply_trace ("quit complete");
+        if (!ply_write (connection->fd,
+                        PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
+                        strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)))
+                ply_trace ("could not finish writing quit reply: %m");
 }
 
 static void
 ply_boot_connection_on_question_answer (ply_boot_connection_t *connection,
-                                        const char             *answer)
+                                        const char            *answer)
 {
-  ply_trace ("got question answer: %s", answer);
-  ply_boot_connection_send_answer (connection, answer);
+        ply_trace ("got question answer: %s", answer);
+        ply_boot_connection_send_answer (connection, answer);
 }
 
 static void
 ply_boot_connection_on_keystroke_answer (ply_boot_connection_t *connection,
-                                        const char            *key)
+                                         const char            *key)
 {
-  ply_trace ("got key: %s", key);
-  ply_boot_connection_send_answer (connection, key);
+        ply_trace ("got key: %s", key);
+        ply_boot_connection_send_answer (connection, key);
 }
 
 static void
 print_connection_process_identity (ply_boot_connection_t *connection)
 {
-  char *command_line, *parent_command_line;
-  pid_t parent_pid;
+        char *command_line, *parent_command_line;
+        pid_t parent_pid;
 
-  command_line = ply_get_process_command_line (connection->pid);
+        command_line = ply_get_process_command_line (connection->pid);
 
-  if (connection->pid == 1)
-    {
-      ply_trace ("connection is from toplevel init process (%s)", command_line);
-    }
-  else
-    {
-      parent_pid = ply_get_process_parent_pid (connection->pid); parent_command_line = ply_get_process_command_line (parent_pid);
+        if (connection->pid == 1) {
+                ply_trace ("connection is from toplevel init process (%s)", command_line);
+        } else {
+                parent_pid = ply_get_process_parent_pid (connection->pid); parent_command_line = ply_get_process_command_line (parent_pid);
 
-      ply_trace ("connection is from pid %ld (%s) with parent pid %ld (%s)",
-                 (long) connection->pid, command_line,
-                 (long) parent_pid, parent_command_line);
+                ply_trace ("connection is from pid %ld (%s) with parent pid %ld (%s)",
+                           (long) connection->pid, command_line,
+                           (long) parent_pid, parent_command_line);
 
-      free (parent_command_line);
-    }
+                free (parent_command_line);
+        }
 
-  free (command_line);
+        free (command_line);
 }
 
 static void
 ply_boot_connection_on_request (ply_boot_connection_t *connection)
 {
-  ply_boot_server_t *server;
-  char *command, *argument;
-
-  assert (connection != NULL);
-  assert (connection->fd >= 0);
-
-  server = connection->server;
-  assert (server != NULL);
-
-  if (!ply_boot_connection_read_request (connection,
-                                         &command, &argument))
-    {
-      ply_trace ("could not read connection request");
-      return;
-    }
-
-  if (ply_is_tracing ())
-    print_connection_process_identity (connection);
-
-  if (!ply_boot_connection_is_from_root (connection))
-    {
-      ply_error ("request came from non-root user");
-
-      if (!ply_write (connection->fd,
-                      PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK,
-                      strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK)))
-        ply_trace ("could not finish writing is-not-root nak: %m");
-
-      free (command);
-      return;
-    }
-
-  if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_UPDATE) == 0)
-    {
-
-      if (!ply_write (connection->fd,
-                      PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
-                      strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)) &&
-          errno != EPIPE)
-        ply_trace ("could not finish writing update reply: %m");
-
-      ply_trace ("got update request");
-      if (server->update_handler != NULL)
-        server->update_handler (server->user_data, argument, server);
-      free (argument);
-      free (command);
-      return;
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_CHANGE_MODE) == 0)
-    {
-      if (!ply_write (connection->fd,
-                      PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
-                      strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)))
-        ply_trace ("could not finish writing update reply: %m");
-
-      ply_trace ("got change mode notification");
-      if (server->change_mode_handler != NULL)
-        server->change_mode_handler (server->user_data, argument, server);
-      free (argument);
-      free (command);
-      return;
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SYSTEM_UPDATE) == 0)
-    {
-      long int value;
-      char *endptr = NULL;
-
-      value = strtol (argument, &endptr, 10);
-      if (endptr == NULL || *endptr != '\0' || value < 0 || value > 100)
-        {
-          ply_error ("failed to parse percentage %s", argument);
-          value = 0;
-        }
+        ply_boot_server_t *server;
+        char *command, *argument;
 
-      ply_trace ("got system-update notification %li%%", value);
-      if (!ply_write (connection->fd,
-                      PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
-                      strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)))
-        ply_trace ("could not finish writing update reply: %m");
-
-      if (server->system_update_handler != NULL)
-        server->system_update_handler (server->user_data, value, server);
-      free (argument);
-      free (command);
-      return;
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SYSTEM_INITIALIZED) == 0)
-    {
-      ply_trace ("got system initialized notification");
-      if (server->system_initialized_handler != NULL)
-        server->system_initialized_handler (server->user_data, server);
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_ERROR) == 0)
-    {
-      ply_trace ("got error notification");
-      if (server->error_handler != NULL)
-        server->error_handler (server->user_data, server);
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SHOW_SPLASH) == 0)
-    {
-      ply_trace ("got show splash request");
-      if (server->show_splash_handler != NULL)
-        server->show_splash_handler (server->user_data, server);
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HIDE_SPLASH) == 0)
-    {
-      ply_trace ("got hide splash request");
-      if (server->hide_splash_handler != NULL)
-        server->hide_splash_handler (server->user_data, server);
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_DEACTIVATE) == 0)
-    {
-      ply_trigger_t *deactivate_trigger;
-
-      ply_trace ("got deactivate request");
-
-      deactivate_trigger = ply_trigger_new (NULL);
-
-      ply_trigger_add_handler (deactivate_trigger,
-                               (ply_trigger_handler_t)
-                               ply_boot_connection_on_deactivated,
-                               connection);
-
-      if (server->deactivate_handler != NULL)
-        server->deactivate_handler (server->user_data, deactivate_trigger, server);
-
-      free (argument);
-      free (command);
-      return;
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_REACTIVATE) == 0)
-    {
-      ply_trace ("got reactivate request");
-      if (server->reactivate_handler != NULL)
-        server->reactivate_handler (server->user_data, server);
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_QUIT) == 0)
-    {
-      bool retain_splash;
-      ply_trigger_t *quit_trigger;
-
-      retain_splash = (bool) argument[0];
-
-      ply_trace ("got quit %srequest", retain_splash? "--retain-splash " : "");
-
-      quit_trigger = ply_trigger_new (NULL);
-
-      ply_trigger_add_handler (quit_trigger,
-                               (ply_trigger_handler_t)
-                               ply_boot_connection_on_quit_complete,
-                               connection);
-
-      if (server->quit_handler != NULL)
-        server->quit_handler (server->user_data, retain_splash, quit_trigger, server);
-
-      free(argument);
-      free(command);
-      return;
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PASSWORD) == 0)
-    {
-      ply_trigger_t *answer;
-
-      ply_trace ("got password request");
-
-      answer = ply_trigger_new (NULL);
-      ply_trigger_add_handler (answer,
-                               (ply_trigger_handler_t)
-                               ply_boot_connection_on_password_answer,
-                               connection);
-
-      if (server->ask_for_password_handler != NULL)
-        server->ask_for_password_handler (server->user_data,
-                                          argument,
-                                          answer,
-                                          server);
-      /* will reply later
-       */
-      free(command);
-      return;
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_CACHED_PASSWORD) == 0)
-    {
-      ply_list_node_t *node;
-      ply_buffer_t *buffer;
-      size_t buffer_size;
-      uint32_t size;
-
-      ply_trace ("got cached password request");
-
-      buffer = ply_buffer_new ();
-
-      node = ply_list_get_first_node (server->cached_passwords);
-
-      ply_trace ("There are %d cached passwords",
-                 ply_list_get_length (server->cached_passwords));
-
-      /* Add each answer separated by their NUL terminators into
-       * a buffer that we write out to the client
-       */
-      while (node != NULL)
-        {
-          ply_list_node_t *next_node;
-          const char *password;
-
-          next_node = ply_list_get_next_node (server->cached_passwords, node);
-          password = (const char *) ply_list_node_get_data (node);
-
-          ply_buffer_append_bytes (buffer,
-                                   password,
-                                   strlen (password) + 1);
-          node = next_node;
-        }
+        assert (connection != NULL);
+        assert (connection->fd >= 0);
 
-      buffer_size = ply_buffer_get_size (buffer);
-
-      /* splash plugin doesn't have any cached passwords
-      */
-      if (buffer_size == 0)
-        {
-          ply_trace ("Responding with 'no answer' reply since there are currently "
-                     "no cached answers");
-          if (!ply_write (connection->fd,
-                          PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NO_ANSWER,
-                          strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NO_ANSWER)))
-              ply_trace ("could not finish writing no answer reply: %m");
+        server = connection->server;
+        assert (server != NULL);
+
+        if (!ply_boot_connection_read_request (connection,
+                                               &command, &argument)) {
+                ply_trace ("could not read connection request");
+                return;
         }
-      else
-        {
-          size = buffer_size;
-
-          ply_trace ("writing %d cached answers",
-                     ply_list_get_length (server->cached_passwords));
-          if (!ply_write (connection->fd,
-                          PLY_BOOT_PROTOCOL_RESPONSE_TYPE_MULTIPLE_ANSWERS,
-                          strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_MULTIPLE_ANSWERS)) ||
-              !ply_write_uint32 (connection->fd,
-                                 size) ||
-              !ply_write (connection->fd,
-                          ply_buffer_get_bytes (buffer), size))
-              ply_trace ("could not finish writing cached answer reply: %m");
+
+        if (ply_is_tracing ())
+                print_connection_process_identity (connection);
+
+        if (!ply_boot_connection_is_from_root (connection)) {
+                ply_error ("request came from non-root user");
+
+                if (!ply_write (connection->fd,
+                                PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK,
+                                strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK)))
+                        ply_trace ("could not finish writing is-not-root nak: %m");
+
+                free (command);
+                return;
         }
 
-      ply_buffer_free (buffer);
-      free(command);
-      return;
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_QUESTION) == 0)
-    {
-      ply_trigger_t *answer;
-
-      ply_trace ("got question request");
-
-      answer = ply_trigger_new (NULL);
-      ply_trigger_add_handler (answer,
-                               (ply_trigger_handler_t)
-                               ply_boot_connection_on_question_answer,
-                               connection);
-
-      if (server->ask_question_handler != NULL)
-        server->ask_question_handler (server->user_data,
-                                          argument,
-                                          answer,
-                                          server);
-      /* will reply later
-       */
-      free(command);
-      return;
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SHOW_MESSAGE) == 0)
-    {
-      ply_trace ("got show message request");
-      if (server->display_message_handler != NULL)
-        server->display_message_handler(server->user_data, argument, server);
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HIDE_MESSAGE) == 0)
-    {
-      ply_trace ("got hide message request");
-      if (server->hide_message_handler != NULL)
-        server->hide_message_handler(server->user_data, argument, server);
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_KEYSTROKE) == 0)
-    {
-      ply_trigger_t *answer;
-
-      ply_trace ("got keystroke request");
-
-      answer = ply_trigger_new (NULL);
-      ply_trigger_add_handler (answer,
-                               (ply_trigger_handler_t)
-                               ply_boot_connection_on_keystroke_answer,
-                               connection);
-
-      if (server->watch_for_keystroke_handler != NULL)
-        server->watch_for_keystroke_handler (server->user_data,
-                                          argument,
-                                          answer,
-                                          server);
-      /* will reply later
-       */
-      free(command);
-      return;
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_KEYSTROKE_REMOVE) == 0)
-    {
-      ply_trace ("got keystroke remove request");
-      if (server->ignore_keystroke_handler != NULL)
-        server->ignore_keystroke_handler (server->user_data,
-                                          argument,
-                                          server);
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PROGRESS_PAUSE) == 0)
-    {
-      ply_trace ("got progress pause request");
-      if (server->progress_pause_handler != NULL)
-        server->progress_pause_handler (server->user_data,
-                                        server);
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PROGRESS_UNPAUSE) == 0)
-    {
-      ply_trace ("got progress unpause request");
-      if (server->progress_unpause_handler != NULL)
-        server->progress_unpause_handler (server->user_data,
-                                          server);
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_NEWROOT) == 0)
-    {
-      ply_trace ("got newroot request");
-      if (server->newroot_handler != NULL)
-        server->newroot_handler(server->user_data, argument, server);
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HAS_ACTIVE_VT) == 0)
-    {
-      bool answer = false;
-
-      ply_trace ("got has_active vt? request");
-      if (server->has_active_vt_handler != NULL)
-        answer = server->has_active_vt_handler(server->user_data, server);
-
-      if (!answer)
-        {
-          if (!ply_write (connection->fd,
-                          PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK,
-                          strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK)))
-            ply_trace ("could not finish writing nak: %m");
-
-          free(command);
-          return;
+        if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_UPDATE) == 0) {
+                if (!ply_write (connection->fd,
+                                PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
+                                strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)) &&
+                    errno != EPIPE)
+                        ply_trace ("could not finish writing update reply: %m");
+
+                ply_trace ("got update request");
+                if (server->update_handler != NULL)
+                        server->update_handler (server->user_data, argument, server);
+                free (argument);
+                free (command);
+                return;
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_CHANGE_MODE) == 0) {
+                if (!ply_write (connection->fd,
+                                PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
+                                strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)))
+                        ply_trace ("could not finish writing update reply: %m");
+
+                ply_trace ("got change mode notification");
+                if (server->change_mode_handler != NULL)
+                        server->change_mode_handler (server->user_data, argument, server);
+                free (argument);
+                free (command);
+                return;
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SYSTEM_UPDATE) == 0) {
+                long int value;
+                char *endptr = NULL;
+
+                value = strtol (argument, &endptr, 10);
+                if (endptr == NULL || *endptr != '\0' || value < 0 || value > 100) {
+                        ply_error ("failed to parse percentage %s", argument);
+                        value = 0;
+                }
+
+                ply_trace ("got system-update notification %li%%", value);
+                if (!ply_write (connection->fd,
+                                PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
+                                strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)))
+                        ply_trace ("could not finish writing update reply: %m");
+
+                if (server->system_update_handler != NULL)
+                        server->system_update_handler (server->user_data, value, server);
+                free (argument);
+                free (command);
+                return;
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SYSTEM_INITIALIZED) == 0) {
+                ply_trace ("got system initialized notification");
+                if (server->system_initialized_handler != NULL)
+                        server->system_initialized_handler (server->user_data, server);
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_ERROR) == 0) {
+                ply_trace ("got error notification");
+                if (server->error_handler != NULL)
+                        server->error_handler (server->user_data, server);
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SHOW_SPLASH) == 0) {
+                ply_trace ("got show splash request");
+                if (server->show_splash_handler != NULL)
+                        server->show_splash_handler (server->user_data, server);
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HIDE_SPLASH) == 0) {
+                ply_trace ("got hide splash request");
+                if (server->hide_splash_handler != NULL)
+                        server->hide_splash_handler (server->user_data, server);
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_DEACTIVATE) == 0) {
+                ply_trigger_t *deactivate_trigger;
+
+                ply_trace ("got deactivate request");
+
+                deactivate_trigger = ply_trigger_new (NULL);
+
+                ply_trigger_add_handler (deactivate_trigger,
+                                         (ply_trigger_handler_t)
+                                         ply_boot_connection_on_deactivated,
+                                         connection);
+
+                if (server->deactivate_handler != NULL)
+                        server->deactivate_handler (server->user_data, deactivate_trigger, server);
+
+                free (argument);
+                free (command);
+                return;
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_REACTIVATE) == 0) {
+                ply_trace ("got reactivate request");
+                if (server->reactivate_handler != NULL)
+                        server->reactivate_handler (server->user_data, server);
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_QUIT) == 0) {
+                bool retain_splash;
+                ply_trigger_t *quit_trigger;
+
+                retain_splash = (bool) argument[0];
+
+                ply_trace ("got quit %srequest", retain_splash ? "--retain-splash " : "");
+
+                quit_trigger = ply_trigger_new (NULL);
+
+                ply_trigger_add_handler (quit_trigger,
+                                         (ply_trigger_handler_t)
+                                         ply_boot_connection_on_quit_complete,
+                                         connection);
+
+                if (server->quit_handler != NULL)
+                        server->quit_handler (server->user_data, retain_splash, quit_trigger, server);
+
+                free (argument);
+                free (command);
+                return;
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PASSWORD) == 0) {
+                ply_trigger_t *answer;
+
+                ply_trace ("got password request");
+
+                answer = ply_trigger_new (NULL);
+                ply_trigger_add_handler (answer,
+                                         (ply_trigger_handler_t)
+                                         ply_boot_connection_on_password_answer,
+                                         connection);
+
+                if (server->ask_for_password_handler != NULL) {
+                        server->ask_for_password_handler (server->user_data,
+                                                          argument,
+                                                          answer,
+                                                          server);
+                }
+                /* will reply later
+                 */
+                free (command);
+                return;
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_CACHED_PASSWORD) == 0) {
+                ply_list_node_t *node;
+                ply_buffer_t *buffer;
+                size_t buffer_size;
+                uint32_t size;
+
+                ply_trace ("got cached password request");
+
+                buffer = ply_buffer_new ();
+
+                node = ply_list_get_first_node (server->cached_passwords);
+
+                ply_trace ("There are %d cached passwords",
+                           ply_list_get_length (server->cached_passwords));
+
+                /* Add each answer separated by their NUL terminators into
+                 * a buffer that we write out to the client
+                 */
+                while (node != NULL) {
+                        ply_list_node_t *next_node;
+                        const char *password;
+
+                        next_node = ply_list_get_next_node (server->cached_passwords, node);
+                        password = (const char *) ply_list_node_get_data (node);
+
+                        ply_buffer_append_bytes (buffer,
+                                                 password,
+                                                 strlen (password) + 1);
+                        node = next_node;
+                }
+
+                buffer_size = ply_buffer_get_size (buffer);
+
+                /* splash plugin doesn't have any cached passwords
+                 */
+                if (buffer_size == 0) {
+                        ply_trace ("Responding with 'no answer' reply since there are currently "
+                                   "no cached answers");
+                        if (!ply_write (connection->fd,
+                                        PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NO_ANSWER,
+                                        strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NO_ANSWER)))
+                                ply_trace ("could not finish writing no answer reply: %m");
+                } else {
+                        size = buffer_size;
+
+                        ply_trace ("writing %d cached answers",
+                                   ply_list_get_length (server->cached_passwords));
+                        if (!ply_write (connection->fd,
+                                        PLY_BOOT_PROTOCOL_RESPONSE_TYPE_MULTIPLE_ANSWERS,
+                                        strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_MULTIPLE_ANSWERS)) ||
+                            !ply_write_uint32 (connection->fd,
+                                               size) ||
+                            !ply_write (connection->fd,
+                                        ply_buffer_get_bytes (buffer), size))
+                                ply_trace ("could not finish writing cached answer reply: %m");
+                }
+
+                ply_buffer_free (buffer);
+                free (command);
+                return;
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_QUESTION) == 0) {
+                ply_trigger_t *answer;
+
+                ply_trace ("got question request");
+
+                answer = ply_trigger_new (NULL);
+                ply_trigger_add_handler (answer,
+                                         (ply_trigger_handler_t)
+                                         ply_boot_connection_on_question_answer,
+                                         connection);
+
+                if (server->ask_question_handler != NULL) {
+                        server->ask_question_handler (server->user_data,
+                                                      argument,
+                                                      answer,
+                                                      server);
+                }
+                /* will reply later
+                 */
+                free (command);
+                return;
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_SHOW_MESSAGE) == 0) {
+                ply_trace ("got show message request");
+                if (server->display_message_handler != NULL)
+                        server->display_message_handler (server->user_data, argument, server);
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HIDE_MESSAGE) == 0) {
+                ply_trace ("got hide message request");
+                if (server->hide_message_handler != NULL)
+                        server->hide_message_handler (server->user_data, argument, server);
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_KEYSTROKE) == 0) {
+                ply_trigger_t *answer;
+
+                ply_trace ("got keystroke request");
+
+                answer = ply_trigger_new (NULL);
+                ply_trigger_add_handler (answer,
+                                         (ply_trigger_handler_t)
+                                         ply_boot_connection_on_keystroke_answer,
+                                         connection);
+
+                if (server->watch_for_keystroke_handler != NULL) {
+                        server->watch_for_keystroke_handler (server->user_data,
+                                                             argument,
+                                                             answer,
+                                                             server);
+                }
+                /* will reply later
+                 */
+                free (command);
+                return;
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_KEYSTROKE_REMOVE) == 0) {
+                ply_trace ("got keystroke remove request");
+                if (server->ignore_keystroke_handler != NULL)
+                        server->ignore_keystroke_handler (server->user_data,
+                                                          argument,
+                                                          server);
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PROGRESS_PAUSE) == 0) {
+                ply_trace ("got progress pause request");
+                if (server->progress_pause_handler != NULL)
+                        server->progress_pause_handler (server->user_data,
+                                                        server);
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PROGRESS_UNPAUSE) == 0) {
+                ply_trace ("got progress unpause request");
+                if (server->progress_unpause_handler != NULL)
+                        server->progress_unpause_handler (server->user_data,
+                                                          server);
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_NEWROOT) == 0) {
+                ply_trace ("got newroot request");
+                if (server->newroot_handler != NULL)
+                        server->newroot_handler (server->user_data, argument, server);
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_HAS_ACTIVE_VT) == 0) {
+                bool answer = false;
+
+                ply_trace ("got has_active vt? request");
+                if (server->has_active_vt_handler != NULL)
+                        answer = server->has_active_vt_handler (server->user_data, server);
+
+                if (!answer) {
+                        if (!ply_write (connection->fd,
+                                        PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK,
+                                        strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK)))
+                                ply_trace ("could not finish writing nak: %m");
+
+                        free (command);
+                        return;
+                }
+        } else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PING) != 0) {
+                ply_error ("received unknown command '%s' from client", command);
+
+                if (!ply_write (connection->fd,
+                                PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK,
+                                strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK)))
+                        ply_trace ("could not finish writing ping reply: %m");
+
+                free (command);
+                return;
         }
-    }
-  else if (strcmp (command, PLY_BOOT_PROTOCOL_REQUEST_TYPE_PING) != 0)
-    {
-      ply_error ("received unknown command '%s' from client", command);
-
-      if (!ply_write (connection->fd,
-                      PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK,
-                      strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_NAK)))
-          ply_trace ("could not finish writing ping reply: %m");
-
-      free(command);
-      return;
-    }
-
-  if (!ply_write (connection->fd, 
-                  PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
-                  strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)))
-    {
-      ply_trace ("could not finish writing ack: %m");
-    }
-  free(command);
+
+        if (!ply_write (connection->fd,
+                        PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK,
+                        strlen (PLY_BOOT_PROTOCOL_RESPONSE_TYPE_ACK)))
+                ply_trace ("could not finish writing ack: %m");
+        free (command);
 }
 
 static void
 ply_boot_connection_on_hangup (ply_boot_connection_t *connection)
 {
-  ply_list_node_t *node;
-  ply_boot_server_t *server;
+        ply_list_node_t *node;
+        ply_boot_server_t *server;
 
-  assert (connection != NULL);
-  assert (connection->server != NULL);
+        assert (connection != NULL);
+        assert (connection->server != NULL);
 
-  server = connection->server;
+        server = connection->server;
 
-  node = ply_list_find_node (server->connections, connection);
+        node = ply_list_find_node (server->connections, connection);
 
-  assert (node != NULL);
+        assert (node != NULL);
 
-  ply_boot_connection_free (connection);
-  ply_list_remove_node (server->connections, node);
+        ply_boot_connection_free (connection);
+        ply_list_remove_node (server->connections, node);
 }
 
 static void
 ply_boot_server_on_new_connection (ply_boot_server_t *server)
 {
-  ply_boot_connection_t *connection;
-  int fd;
+        ply_boot_connection_t *connection;
+        int fd;
 
-  assert (server != NULL);
+        assert (server != NULL);
 
-  fd = accept4 (server->socket_fd, NULL, NULL, SOCK_CLOEXEC);
+        fd = accept4 (server->socket_fd, NULL, NULL, SOCK_CLOEXEC);
 
-  if (fd < 0)
-    return;
+        if (fd < 0)
+                return;
 
-  connection = ply_boot_connection_new (server, fd);
+        connection = ply_boot_connection_new (server, fd);
 
-  connection->watch = 
-      ply_event_loop_watch_fd (server->loop, fd,
-                               PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                               (ply_event_handler_t)
-                               ply_boot_connection_on_request,
-                               (ply_event_handler_t)
-                               ply_boot_connection_on_hangup,
-                               connection);
+        connection->watch =
+                ply_event_loop_watch_fd (server->loop, fd,
+                                         PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                         (ply_event_handler_t)
+                                         ply_boot_connection_on_request,
+                                         (ply_event_handler_t)
+                                         ply_boot_connection_on_hangup,
+                                         connection);
 
-  ply_list_append_data (server->connections, connection);
+        ply_list_append_data (server->connections, connection);
 }
 
 static void
 ply_boot_server_on_hangup (ply_boot_server_t *server)
 {
-  assert (server != NULL);
+        assert (server != NULL);
 }
 
 static void
 ply_boot_server_detach_from_event_loop (ply_boot_server_t *server)
 {
-  assert (server != NULL);
-  server->loop = NULL;
+        assert (server != NULL);
+        server->loop = NULL;
 }
 
 void
 ply_boot_server_attach_to_event_loop (ply_boot_server_t *server,
                                       ply_event_loop_t  *loop)
 {
-  assert (server != NULL);
-  assert (loop != NULL);
-  assert (server->loop == NULL);
-  assert (server->socket_fd >= 0);
-
-  server->loop = loop;
-
-  ply_event_loop_watch_fd (loop, server->socket_fd,
-                           PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                           (ply_event_handler_t)
-                           ply_boot_server_on_new_connection,
-                           (ply_event_handler_t)
-                           ply_boot_server_on_hangup,
-                           server);
-  ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t) 
-                                 ply_boot_server_detach_from_event_loop,
-                                 server); 
+        assert (server != NULL);
+        assert (loop != NULL);
+        assert (server->loop == NULL);
+        assert (server->socket_fd >= 0);
+
+        server->loop = loop;
+
+        ply_event_loop_watch_fd (loop, server->socket_fd,
+                                 PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                 (ply_event_handler_t)
+                                 ply_boot_server_on_new_connection,
+                                 (ply_event_handler_t)
+                                 ply_boot_server_on_hangup,
+                                 server);
+        ply_event_loop_watch_for_exit (loop, (ply_event_loop_exit_handler_t)
+                                       ply_boot_server_detach_from_event_loop,
+                                       server);
 }
 
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/ply-boot-server.h b/src/ply-boot-server.h
index b885a81..feb2bc4 100644
--- a/src/ply-boot-server.h
+++ b/src/ply-boot-server.h
@@ -32,99 +32,99 @@
 
 typedef struct _ply_boot_server ply_boot_server_t;
 
-typedef void (* ply_boot_server_update_handler_t) (void              *user_data,
-                                                   const char        *status,
-                                                   ply_boot_server_t *server);
+typedef void (*ply_boot_server_update_handler_t) (void              *user_data,
+                                                  const char        *status,
+                                                  ply_boot_server_t *server);
 
-typedef void (* ply_boot_server_change_mode_handler_t) (void              *user_data,
-                                                        const char        *mode,
-                                                        ply_boot_server_t *server);
+typedef void (*ply_boot_server_change_mode_handler_t) (void              *user_data,
+                                                       const char        *mode,
+                                                       ply_boot_server_t *server);
 
-typedef void (* ply_boot_server_system_update_handler_t) (void              *user_data,
-                                                          int                progress,
-                                                          ply_boot_server_t *server);
+typedef void (*ply_boot_server_system_update_handler_t) (void              *user_data,
+                                                         int                progress,
+                                                         ply_boot_server_t *server);
 
-typedef void (* ply_boot_server_newroot_handler_t) (void              *user_data,
-                                                    const char        *root_dir,
-                                                    ply_boot_server_t *server);
+typedef void (*ply_boot_server_newroot_handler_t) (void              *user_data,
+                                                   const char        *root_dir,
+                                                   ply_boot_server_t *server);
 
-typedef void (* ply_boot_server_show_splash_handler_t) (void              *user_data,
-                                                        ply_boot_server_t *server);
+typedef void (*ply_boot_server_show_splash_handler_t) (void              *user_data,
+                                                       ply_boot_server_t *server);
 
-typedef void (* ply_boot_server_hide_splash_handler_t) (void              *user_data,
-                                                        ply_boot_server_t *server);
+typedef void (*ply_boot_server_hide_splash_handler_t) (void              *user_data,
+                                                       ply_boot_server_t *server);
 
-typedef void (* ply_boot_server_password_answer_handler_t) (void              *answer_data,
-                                                            const char        *password,
+typedef void (*ply_boot_server_password_answer_handler_t) (void              *answer_data,
+                                                           const char        *password,
+                                                           ply_boot_server_t *server);
+typedef void (*ply_boot_server_ask_for_password_handler_t) (void              *user_data,
+                                                            const char        *prompt,
+                                                            ply_trigger_t     *answer,
                                                             ply_boot_server_t *server);
-typedef void (* ply_boot_server_ask_for_password_handler_t) (void              *user_data,
+typedef void (*ply_boot_server_question_answer_handler_t) (void              *answer_data,
+                                                           const char        *answer,
+                                                           ply_boot_server_t *server);
+typedef void (*ply_boot_server_ask_question_handler_t)      (void              *user_data,
                                                              const char        *prompt,
                                                              ply_trigger_t     *answer,
                                                              ply_boot_server_t *server);
-typedef void (* ply_boot_server_question_answer_handler_t) (void               *answer_data,
-                                                            const char         *answer,
-                                                            ply_boot_server_t  *server);
-typedef void (* ply_boot_server_ask_question_handler_t)      (void              *user_data,
-                                                              const char        *prompt,
-                                                              ply_trigger_t     *answer,
-                                                              ply_boot_server_t *server);
-typedef void (* ply_boot_server_display_message_handler_t)   (void              *user_data,
-                                                              const char        *message,
-                                                              ply_boot_server_t *server);
-typedef void (* ply_boot_server_hide_message_handler_t)   (void              *user_data,
-                                                           const char        *message,
-                                                           ply_boot_server_t *server);
-typedef void (* ply_boot_server_watch_for_keystroke_handler_t) (void              *user_data,
-                                                                const char        *keys,
-                                                                ply_trigger_t     *answer,
-                                                                ply_boot_server_t *server);
-typedef void (* ply_boot_server_ignore_keystroke_handler_t) (void              *user_data,
-                                                             const char        *keys,
-                                                             ply_boot_server_t *server);
-typedef void (* ply_boot_server_progress_pause_handler_t) (void              *user_data,
-                                                           ply_boot_server_t *server);
-typedef void (* ply_boot_server_progress_unpause_handler_t) (void              *user_data,
+typedef void (*ply_boot_server_display_message_handler_t)   (void              *user_data,
+                                                             const char        *message,
                                                              ply_boot_server_t *server);
+typedef void (*ply_boot_server_hide_message_handler_t)   (void              *user_data,
+                                                          const char        *message,
+                                                          ply_boot_server_t *server);
+typedef void (*ply_boot_server_watch_for_keystroke_handler_t) (void              *user_data,
+                                                               const char        *keys,
+                                                               ply_trigger_t     *answer,
+                                                               ply_boot_server_t *server);
+typedef void (*ply_boot_server_ignore_keystroke_handler_t) (void              *user_data,
+                                                            const char        *keys,
+                                                            ply_boot_server_t *server);
+typedef void (*ply_boot_server_progress_pause_handler_t) (void              *user_data,
+                                                          ply_boot_server_t *server);
+typedef void (*ply_boot_server_progress_unpause_handler_t) (void              *user_data,
+                                                            ply_boot_server_t *server);
 
-typedef void (* ply_boot_server_system_initialized_handler_t) (void              *user_data,
-                                                        ply_boot_server_t *server);
+typedef void (*ply_boot_server_system_initialized_handler_t) (void              *user_data,
+                                                              ply_boot_server_t *server);
 
-typedef void (* ply_boot_server_error_handler_t) (void              *user_data,
-                                                  ply_boot_server_t *server);
-typedef void (* ply_boot_server_deactivate_handler_t) (void              *user_data,
-                                                       ply_trigger_t     *deactivate_trigger,
-                                                       ply_boot_server_t *server);
-typedef void (* ply_boot_server_reactivate_handler_t) (void              *user_data,
-                                                       ply_boot_server_t *server);
-typedef void (* ply_boot_server_quit_handler_t) (void              *user_data,
-                                                 bool               retain_splash,
-                                                 ply_trigger_t     *quit_trigger,
+typedef void (*ply_boot_server_error_handler_t) (void              *user_data,
                                                  ply_boot_server_t *server);
-typedef bool (* ply_boot_server_has_active_vt_handler_t) (void              *user_data,
-                                                          ply_boot_server_t *server);
+typedef void (*ply_boot_server_deactivate_handler_t) (void              *user_data,
+                                                      ply_trigger_t     *deactivate_trigger,
+                                                      ply_boot_server_t *server);
+typedef void (*ply_boot_server_reactivate_handler_t) (void              *user_data,
+                                                      ply_boot_server_t *server);
+typedef void (*ply_boot_server_quit_handler_t) (void              *user_data,
+                                                bool               retain_splash,
+                                                ply_trigger_t     *quit_trigger,
+                                                ply_boot_server_t *server);
+typedef bool (*ply_boot_server_has_active_vt_handler_t) (void              *user_data,
+                                                         ply_boot_server_t *server);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
-ply_boot_server_t *ply_boot_server_new (ply_boot_server_update_handler_t update_handler,
-                                        ply_boot_server_change_mode_handler_t change_mode_handler,
-                                        ply_boot_server_system_update_handler_t system_update_handler,
-                                        ply_boot_server_ask_for_password_handler_t ask_for_password_handler,
-                                        ply_boot_server_ask_question_handler_t ask_question_handler,
-                                        ply_boot_server_display_message_handler_t display_message_handler,
-                                        ply_boot_server_hide_message_handler_t hide_message_handler,
+ply_boot_server_t *ply_boot_server_new (ply_boot_server_update_handler_t              update_handler,
+                                        ply_boot_server_change_mode_handler_t         change_mode_handler,
+                                        ply_boot_server_system_update_handler_t       system_update_handler,
+                                        ply_boot_server_ask_for_password_handler_t    ask_for_password_handler,
+                                        ply_boot_server_ask_question_handler_t        ask_question_handler,
+                                        ply_boot_server_display_message_handler_t     display_message_handler,
+                                        ply_boot_server_hide_message_handler_t        hide_message_handler,
                                         ply_boot_server_watch_for_keystroke_handler_t watch_for_keystroke_handler,
-                                        ply_boot_server_ignore_keystroke_handler_t ignore_keystroke_handler,
-                                        ply_boot_server_progress_pause_handler_t on_progress_pause,
-                                        ply_boot_server_progress_unpause_handler_t on_progress_unpause,
-                                        ply_boot_server_show_splash_handler_t show_splash_handler,
-                                        ply_boot_server_hide_splash_handler_t hide_splash_handler,
-                                        ply_boot_server_newroot_handler_t newroot_handler,
-                                        ply_boot_server_system_initialized_handler_t initialized_handler,
-                                        ply_boot_server_error_handler_t error_handler,
-                                        ply_boot_server_deactivate_handler_t deactivate_handler,
-                                        ply_boot_server_reactivate_handler_t reactivate_handler,
-                                        ply_boot_server_quit_handler_t quit_handler,
-                                        ply_boot_server_has_active_vt_handler_t has_active_vt_handler,
-                                        void                        *user_data);
+                                        ply_boot_server_ignore_keystroke_handler_t    ignore_keystroke_handler,
+                                        ply_boot_server_progress_pause_handler_t      on_progress_pause,
+                                        ply_boot_server_progress_unpause_handler_t    on_progress_unpause,
+                                        ply_boot_server_show_splash_handler_t         show_splash_handler,
+                                        ply_boot_server_hide_splash_handler_t         hide_splash_handler,
+                                        ply_boot_server_newroot_handler_t             newroot_handler,
+                                        ply_boot_server_system_initialized_handler_t  initialized_handler,
+                                        ply_boot_server_error_handler_t               error_handler,
+                                        ply_boot_server_deactivate_handler_t          deactivate_handler,
+                                        ply_boot_server_reactivate_handler_t          reactivate_handler,
+                                        ply_boot_server_quit_handler_t                quit_handler,
+                                        ply_boot_server_has_active_vt_handler_t       has_active_vt_handler,
+                                        void                                         *user_data);
 
 void ply_boot_server_free (ply_boot_server_t *server);
 bool ply_boot_server_listen (ply_boot_server_t *server);
diff --git a/src/upstart-bridge/ply-upstart-monitor.c b/src/upstart-bridge/ply-upstart-monitor.c
index 5784d6e..39940de 100644
--- a/src/upstart-bridge/ply-upstart-monitor.c
+++ b/src/upstart-bridge/ply-upstart-monitor.c
@@ -39,38 +39,38 @@
 
 typedef struct
 {
-  ply_upstart_monitor_t *monitor;
-  DBusTimeout           *timeout;
+        ply_upstart_monitor_t *monitor;
+        DBusTimeout           *timeout;
 } ply_upstart_monitor_timeout_t;
 
 struct _ply_upstart_monitor
 {
-  DBusConnection                              *connection;
-  ply_event_loop_t                            *loop;
-  ply_hashtable_t                             *jobs;
-  ply_hashtable_t                             *all_instances;
-  ply_upstart_monitor_state_changed_handler_t  state_changed_handler;
-  void                                        *state_changed_data;
-  ply_upstart_monitor_failed_handler_t         failed_handler;
-  void                                        *failed_data;
-  int                                          dispatch_fd;
+        DBusConnection                             *connection;
+        ply_event_loop_t                           *loop;
+        ply_hashtable_t                            *jobs;
+        ply_hashtable_t                            *all_instances;
+        ply_upstart_monitor_state_changed_handler_t state_changed_handler;
+        void                                       *state_changed_data;
+        ply_upstart_monitor_failed_handler_t        failed_handler;
+        void                                       *failed_data;
+        int                                         dispatch_fd;
 };
 
 typedef struct
 {
-  ply_upstart_monitor_t                *monitor;
-  ply_upstart_monitor_job_properties_t  properties;
-  ply_hashtable_t                      *instances;
-  ply_list_t                           *pending_calls;
+        ply_upstart_monitor_t               *monitor;
+        ply_upstart_monitor_job_properties_t properties;
+        ply_hashtable_t                     *instances;
+        ply_list_t                          *pending_calls;
 } ply_upstart_monitor_job_t;
 
 typedef struct
 {
-  ply_upstart_monitor_job_t                 *job;
-  ply_upstart_monitor_instance_properties_t  properties;
-  ply_list_t                                *pending_calls;
-  uint32_t                                   state_changed : 1;
-  uint32_t                                   call_failed : 1;
+        ply_upstart_monitor_job_t                *job;
+        ply_upstart_monitor_instance_properties_t properties;
+        ply_list_t                               *pending_calls;
+        uint32_t                                  state_changed : 1;
+        uint32_t                                  call_failed : 1;
 } ply_upstart_monitor_instance_t;
 
 #define UPSTART_SERVICE                 NULL
@@ -85,15 +85,15 @@ static void *
 hashtable_remove_and_free_key (ply_hashtable_t *hashtable,
                                const void      *key)
 {
-  void *reply_key, *reply_data;
+        void *reply_key, *reply_data;
 
-  if (!ply_hashtable_lookup_full (hashtable, (void *) key,
-                                  &reply_key, &reply_data))
-    return NULL;
-  ply_hashtable_remove (hashtable, (void *) key);
-  free (reply_key);
+        if (!ply_hashtable_lookup_full (hashtable, (void *) key,
+                                        &reply_key, &reply_data))
+                return NULL;
+        ply_hashtable_remove (hashtable, (void *) key);
+        free (reply_key);
 
-  return reply_data;
+        return reply_data;
 }
 
 /* We assume, in general, that Upstart responds to D-Bus messages in a
@@ -108,475 +108,455 @@ hashtable_remove_and_free_key (ply_hashtable_t *hashtable,
 static bool
 instance_is_initialized (ply_upstart_monitor_instance_t *instance)
 {
-  /* Note that the job may not have a description. */
-  if (instance->job->properties.name &&
-      instance->properties.name && instance->properties.goal &&
-      instance->properties.state)
-    return true;
-  else
-    return false;
+        /* Note that the job may not have a description. */
+        if (instance->job->properties.name &&
+            instance->properties.name && instance->properties.goal &&
+            instance->properties.state)
+                return true;
+        else
+                return false;
 }
 
 static void
 on_get_all_instance_properties_finished (DBusPendingCall                *call,
                                          ply_upstart_monitor_instance_t *instance)
 {
-  DBusMessage *reply;
-  DBusMessageIter iter, array_iter, dict_iter, variant_iter;
-  const char *key, *name, *goal, *state;
-  ply_upstart_monitor_t *monitor;
-
-  assert (call != NULL);
-  assert (instance != NULL);
-
-  reply = dbus_pending_call_steal_reply (call);
-  if (reply == NULL)
-    return;
-  if (dbus_message_get_type (reply) != DBUS_MESSAGE_TYPE_METHOD_RETURN)
-    goto out;
-
-  dbus_message_iter_init (reply, &iter);
-  if (dbus_message_iter_get_arg_type (&iter) != DBUS_TYPE_ARRAY)
-    goto out;
-  dbus_message_iter_recurse (&iter, &array_iter);
-
-  while (dbus_message_iter_get_arg_type (&array_iter) == DBUS_TYPE_DICT_ENTRY)
-    {
-      dbus_message_iter_recurse (&array_iter, &dict_iter);
-
-      if (dbus_message_iter_get_arg_type (&dict_iter) != DBUS_TYPE_STRING)
-        goto next_item;
-
-      dbus_message_iter_get_basic (&dict_iter, &key);
-      if (key == NULL)
-        goto next_item;
-
-      dbus_message_iter_next (&dict_iter);
-      if (dbus_message_iter_get_arg_type (&dict_iter) != DBUS_TYPE_VARIANT)
-        goto next_item;
-      dbus_message_iter_recurse (&dict_iter, &variant_iter);
-      if (dbus_message_iter_get_arg_type (&variant_iter) != DBUS_TYPE_STRING)
-        goto next_item;
-
-      if (strcmp (key, "name") == 0)
-        {
-          dbus_message_iter_get_basic (&variant_iter, &name);
-          if (name != NULL)
-            {
-              ply_trace ("%s: name = '%s'",
-                         instance->job->properties.name, name);
-              instance->properties.name = strdup (name);
-            }
-        }
-      else if (strcmp (key, "goal") == 0)
-        {
-          dbus_message_iter_get_basic (&variant_iter, &goal);
-          if (goal != NULL)
-            {
-              ply_trace ("%s: goal = '%s'",
-                         instance->job->properties.name, goal);
-              instance->properties.goal = strdup (goal);
-            }
-        }
-      else if (strcmp (key, "state") == 0)
-        {
-          dbus_message_iter_get_basic (&variant_iter, &state);
-          if (state != NULL)
-            {
-              ply_trace ("%s: state = '%s'",
-                         instance->job->properties.name, state);
-              instance->properties.state = strdup (state);
-            }
-        }
+        DBusMessage *reply;
+        DBusMessageIter iter, array_iter, dict_iter, variant_iter;
+        const char *key, *name, *goal, *state;
+        ply_upstart_monitor_t *monitor;
+
+        assert (call != NULL);
+        assert (instance != NULL);
+
+        reply = dbus_pending_call_steal_reply (call);
+        if (reply == NULL)
+                return;
+        if (dbus_message_get_type (reply) != DBUS_MESSAGE_TYPE_METHOD_RETURN)
+                goto out;
+
+        dbus_message_iter_init (reply, &iter);
+        if (dbus_message_iter_get_arg_type (&iter) != DBUS_TYPE_ARRAY)
+                goto out;
+        dbus_message_iter_recurse (&iter, &array_iter);
+
+        while (dbus_message_iter_get_arg_type (&array_iter) == DBUS_TYPE_DICT_ENTRY) {
+                dbus_message_iter_recurse (&array_iter, &dict_iter);
+
+                if (dbus_message_iter_get_arg_type (&dict_iter) != DBUS_TYPE_STRING)
+                        goto next_item;
+
+                dbus_message_iter_get_basic (&dict_iter, &key);
+                if (key == NULL)
+                        goto next_item;
+
+                dbus_message_iter_next (&dict_iter);
+                if (dbus_message_iter_get_arg_type (&dict_iter) != DBUS_TYPE_VARIANT)
+                        goto next_item;
+                dbus_message_iter_recurse (&dict_iter, &variant_iter);
+                if (dbus_message_iter_get_arg_type (&variant_iter) != DBUS_TYPE_STRING)
+                        goto next_item;
+
+                if (strcmp (key, "name") == 0) {
+                        dbus_message_iter_get_basic (&variant_iter, &name);
+                        if (name != NULL) {
+                                ply_trace ("%s: name = '%s'",
+                                           instance->job->properties.name, name);
+                                instance->properties.name = strdup (name);
+                        }
+                } else if (strcmp (key, "goal") == 0) {
+                        dbus_message_iter_get_basic (&variant_iter, &goal);
+                        if (goal != NULL) {
+                                ply_trace ("%s: goal = '%s'",
+                                           instance->job->properties.name, goal);
+                                instance->properties.goal = strdup (goal);
+                        }
+                } else if (strcmp (key, "state") == 0) {
+                        dbus_message_iter_get_basic (&variant_iter, &state);
+                        if (state != NULL) {
+                                ply_trace ("%s: state = '%s'",
+                                           instance->job->properties.name, state);
+                                instance->properties.state = strdup (state);
+                        }
+                }
 
 next_item:
-      dbus_message_iter_next (&array_iter);
-    }
+                dbus_message_iter_next (&array_iter);
+        }
 
 out:
-  dbus_message_unref (reply);
-
-  if (instance_is_initialized (instance))
-    {
-      /* Process any call events. */
-      monitor = instance->job->monitor;
-
-      if (instance->state_changed && monitor->state_changed_handler)
-        monitor->state_changed_handler (monitor->state_changed_data, NULL,
-                                        &instance->job->properties,
-                                        &instance->properties);
-      instance->state_changed = false;
-
-      if (instance->call_failed && monitor->failed_handler)
-        monitor->failed_handler (monitor->failed_data,
-                                 &instance->job->properties,
-                                 &instance->properties,
-                                 instance->properties.failed);
-      instance->call_failed = false;
-    }
+        dbus_message_unref (reply);
+
+        if (instance_is_initialized (instance)) {
+                /* Process any call events. */
+                monitor = instance->job->monitor;
+
+                if (instance->state_changed && monitor->state_changed_handler)
+                        monitor->state_changed_handler (monitor->state_changed_data, NULL,
+                                                        &instance->job->properties,
+                                                        &instance->properties);
+                instance->state_changed = false;
+
+                if (instance->call_failed && monitor->failed_handler) {
+                        monitor->failed_handler (monitor->failed_data,
+                                                 &instance->job->properties,
+                                                 &instance->properties,
+                                                 instance->properties.failed);
+                }
+                instance->call_failed = false;
+        }
 }
 
 static void
 on_get_all_job_properties_finished (DBusPendingCall           *call,
                                     ply_upstart_monitor_job_t *job)
 {
-  DBusMessage *reply;
-  DBusMessageIter iter, array_iter, dict_iter, variant_iter;
-  const char *key, *name, *description;
-  dbus_uint32_t task;
-
-  assert (call != NULL);
-  assert (job != NULL);
-
-  reply = dbus_pending_call_steal_reply (call);
-  if (reply == NULL)
-    return;
-  if (dbus_message_get_type (reply) != DBUS_MESSAGE_TYPE_METHOD_RETURN)
-    goto out;
-
-  dbus_message_iter_init (reply, &iter);
-  if (dbus_message_iter_get_arg_type (&iter) != DBUS_TYPE_ARRAY)
-    goto out;
-  dbus_message_iter_recurse (&iter, &array_iter);
-
-  while (dbus_message_iter_get_arg_type (&array_iter) == DBUS_TYPE_DICT_ENTRY)
-    {
-      dbus_message_iter_recurse (&array_iter, &dict_iter);
-
-      if (dbus_message_iter_get_arg_type (&dict_iter) != DBUS_TYPE_STRING)
-        goto next_item;
-
-      dbus_message_iter_get_basic (&dict_iter, &key);
-      if (key == NULL)
-        goto next_item;
-
-      dbus_message_iter_next (&dict_iter);
-      if (dbus_message_iter_get_arg_type (&dict_iter) != DBUS_TYPE_VARIANT)
-        goto next_item;
-      dbus_message_iter_recurse (&dict_iter, &variant_iter);
-
-      if (strcmp (key, "name") == 0)
-        {
-          if (dbus_message_iter_get_arg_type (&variant_iter) !=
-              DBUS_TYPE_STRING)
-            goto next_item;
-          dbus_message_iter_get_basic (&variant_iter, &name);
-          if (name != NULL)
-            {
-              ply_trace ("name = '%s'", name);
-              job->properties.name = strdup (name);
-            }
-        }
-      else if (strcmp (key, "description") == 0)
-        {
-          if (dbus_message_iter_get_arg_type (&variant_iter) !=
-              DBUS_TYPE_STRING)
-            goto next_item;
-          dbus_message_iter_get_basic (&variant_iter, &description);
-          if (description != NULL && description[0])
-            {
-              ply_trace ("description = '%s'", description);
-              job->properties.description = strdup (description);
-            }
-        }
-      else if (strcmp (key, "task") == 0)
-        {
-          if (dbus_message_iter_get_arg_type (&variant_iter) !=
-              DBUS_TYPE_BOOLEAN)
-            goto next_item;
-          dbus_message_iter_get_basic (&variant_iter, &task);
-          ply_trace ("task = %s", task ? "TRUE" : "FALSE");
-          job->properties.is_task = task ? true : false;
-        }
+        DBusMessage *reply;
+        DBusMessageIter iter, array_iter, dict_iter, variant_iter;
+        const char *key, *name, *description;
+        dbus_uint32_t task;
+
+        assert (call != NULL);
+        assert (job != NULL);
+
+        reply = dbus_pending_call_steal_reply (call);
+        if (reply == NULL)
+                return;
+        if (dbus_message_get_type (reply) != DBUS_MESSAGE_TYPE_METHOD_RETURN)
+                goto out;
+
+        dbus_message_iter_init (reply, &iter);
+        if (dbus_message_iter_get_arg_type (&iter) != DBUS_TYPE_ARRAY)
+                goto out;
+        dbus_message_iter_recurse (&iter, &array_iter);
+
+        while (dbus_message_iter_get_arg_type (&array_iter) == DBUS_TYPE_DICT_ENTRY) {
+                dbus_message_iter_recurse (&array_iter, &dict_iter);
+
+                if (dbus_message_iter_get_arg_type (&dict_iter) != DBUS_TYPE_STRING)
+                        goto next_item;
+
+                dbus_message_iter_get_basic (&dict_iter, &key);
+                if (key == NULL)
+                        goto next_item;
+
+                dbus_message_iter_next (&dict_iter);
+                if (dbus_message_iter_get_arg_type (&dict_iter) != DBUS_TYPE_VARIANT)
+                        goto next_item;
+                dbus_message_iter_recurse (&dict_iter, &variant_iter);
+
+                if (strcmp (key, "name") == 0) {
+                        if (dbus_message_iter_get_arg_type (&variant_iter) !=
+                            DBUS_TYPE_STRING)
+                                goto next_item;
+                        dbus_message_iter_get_basic (&variant_iter, &name);
+                        if (name != NULL) {
+                                ply_trace ("name = '%s'", name);
+                                job->properties.name = strdup (name);
+                        }
+                } else if (strcmp (key, "description") == 0) {
+                        if (dbus_message_iter_get_arg_type (&variant_iter) !=
+                            DBUS_TYPE_STRING)
+                                goto next_item;
+                        dbus_message_iter_get_basic (&variant_iter, &description);
+                        if (description != NULL && description[0]) {
+                                ply_trace ("description = '%s'", description);
+                                job->properties.description = strdup (description);
+                        }
+                } else if (strcmp (key, "task") == 0) {
+                        if (dbus_message_iter_get_arg_type (&variant_iter) !=
+                            DBUS_TYPE_BOOLEAN)
+                                goto next_item;
+                        dbus_message_iter_get_basic (&variant_iter, &task);
+                        ply_trace ("task = %s", task ? "TRUE" : "FALSE");
+                        job->properties.is_task = task ? true : false;
+                }
 
 next_item:
-      dbus_message_iter_next (&array_iter);
-    }
+                dbus_message_iter_next (&array_iter);
+        }
 
 out:
-  dbus_message_unref (reply);
+        dbus_message_unref (reply);
 }
 
 static void
 remove_instance_internal (ply_upstart_monitor_job_t *job, const char *path)
 {
-  ply_upstart_monitor_instance_t *instance;
-  ply_list_node_t *node;
-
-  instance = hashtable_remove_and_free_key (job->instances, path);
-  if (instance == NULL)
-    return;
-  hashtable_remove_and_free_key (job->monitor->all_instances, path);
-
-  node = ply_list_get_first_node (instance->pending_calls);
-  while (node != NULL)
-    {
-      DBusPendingCall *call;
-      ply_list_node_t *next_node;
-
-      call = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (instance->pending_calls, node);
-      dbus_pending_call_cancel (call);
-      dbus_pending_call_unref (call);
-      node = next_node;
-    }
-  ply_list_free (instance->pending_calls);
-
-  free (instance->properties.name);
-  free (instance->properties.goal);
-  free (instance->properties.state);
-  free (instance);
+        ply_upstart_monitor_instance_t *instance;
+        ply_list_node_t *node;
+
+        instance = hashtable_remove_and_free_key (job->instances, path);
+        if (instance == NULL)
+                return;
+        hashtable_remove_and_free_key (job->monitor->all_instances, path);
+
+        node = ply_list_get_first_node (instance->pending_calls);
+        while (node != NULL) {
+                DBusPendingCall *call;
+                ply_list_node_t *next_node;
+
+                call = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (instance->pending_calls, node);
+                dbus_pending_call_cancel (call);
+                dbus_pending_call_unref (call);
+                node = next_node;
+        }
+        ply_list_free (instance->pending_calls);
+
+        free (instance->properties.name);
+        free (instance->properties.goal);
+        free (instance->properties.state);
+        free (instance);
 }
 
 static void
 add_instance (ply_upstart_monitor_job_t *job,
               const char                *path)
 {
-  ply_upstart_monitor_instance_t *instance;
-  DBusMessage *message;
-  const char *interface = UPSTART_INTERFACE_0_6_INSTANCE;
-  DBusPendingCall *call;
-
-  ply_trace ("adding instance: %s", path);
-
-  remove_instance_internal (job, path);
-
-  instance = calloc (1, sizeof (ply_upstart_monitor_instance_t));
-  instance->job = job;
-  instance->properties.name = NULL;
-  instance->properties.goal = NULL;
-  instance->properties.state = NULL;
-  instance->properties.failed = false;
-  instance->pending_calls = ply_list_new ();
-  instance->state_changed = false;
-  instance->call_failed = false;
-
-  /* Keep a hash of instances per job, to make InstanceRemoved handling
-   * easy.
-   */
-  ply_hashtable_insert (job->instances, strdup (path), instance);
-  /* Keep a separate hash of all instances, to make StateChanged handling
-   * easy.
-   */
-  ply_hashtable_insert (job->monitor->all_instances, strdup (path), instance);
-
-  /* Ask Upstart for the name, goal, and state properties. */
-  ply_trace ("fetching properties of instance %s", path);
-  message = dbus_message_new_method_call (UPSTART_SERVICE, path,
-                                          DBUS_INTERFACE_PROPERTIES, "GetAll");
-  dbus_message_append_args (message,
-                            DBUS_TYPE_STRING, &interface,
-                            DBUS_TYPE_INVALID);
-  dbus_connection_send_with_reply (job->monitor->connection, message,
-                                   &call, -1);
-  dbus_message_unref (message);
-  if (call != NULL)
-    {
-      dbus_pending_call_set_notify (call,
-                                    (DBusPendingCallNotifyFunction)
-                                    on_get_all_instance_properties_finished,
-                                    instance, NULL);
-      ply_list_append_data (instance->pending_calls, call);
-    }
+        ply_upstart_monitor_instance_t *instance;
+        DBusMessage *message;
+        const char *interface = UPSTART_INTERFACE_0_6_INSTANCE;
+        DBusPendingCall *call;
+
+        ply_trace ("adding instance: %s", path);
+
+        remove_instance_internal (job, path);
+
+        instance = calloc (1, sizeof(ply_upstart_monitor_instance_t));
+        instance->job = job;
+        instance->properties.name = NULL;
+        instance->properties.goal = NULL;
+        instance->properties.state = NULL;
+        instance->properties.failed = false;
+        instance->pending_calls = ply_list_new ();
+        instance->state_changed = false;
+        instance->call_failed = false;
+
+        /* Keep a hash of instances per job, to make InstanceRemoved handling
+         * easy.
+         */
+        ply_hashtable_insert (job->instances, strdup (path), instance);
+        /* Keep a separate hash of all instances, to make StateChanged handling
+         * easy.
+         */
+        ply_hashtable_insert (job->monitor->all_instances, strdup (path), instance);
+
+        /* Ask Upstart for the name, goal, and state properties. */
+        ply_trace ("fetching properties of instance %s", path);
+        message = dbus_message_new_method_call (UPSTART_SERVICE, path,
+                                                DBUS_INTERFACE_PROPERTIES, "GetAll");
+        dbus_message_append_args (message,
+                                  DBUS_TYPE_STRING, &interface,
+                                  DBUS_TYPE_INVALID);
+        dbus_connection_send_with_reply (job->monitor->connection, message,
+                                         &call, -1);
+        dbus_message_unref (message);
+        if (call != NULL) {
+                dbus_pending_call_set_notify (call,
+                                              (DBusPendingCallNotifyFunction)
+                                              on_get_all_instance_properties_finished,
+                                              instance, NULL);
+                ply_list_append_data (instance->pending_calls, call);
+        }
 }
 
 static void
 remove_instance (ply_upstart_monitor_job_t *job,
                  const char                *path)
 {
-  ply_trace ("removing instance: %s", path);
+        ply_trace ("removing instance: %s", path);
 
-  remove_instance_internal (job, path);
+        remove_instance_internal (job, path);
 }
 
 static void
 on_get_all_instances_finished (DBusPendingCall           *call,
                                ply_upstart_monitor_job_t *job)
 {
-  DBusMessage *reply;
-  DBusError error;
-  char **instances;
-  int n_instances, i;
-
-  assert (call != NULL);
-  assert (job != NULL);
-
-  reply = dbus_pending_call_steal_reply (call);
-  if (reply == NULL)
-    return;
-  if (dbus_message_get_type (reply) != DBUS_MESSAGE_TYPE_METHOD_RETURN)
-    goto out;
-
-  dbus_error_init (&error);
-  dbus_message_get_args (reply, &error,
-                         DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
-                         &instances, &n_instances,
-                         DBUS_TYPE_INVALID);
-  if (dbus_error_is_set (&error))
-    goto out;
-  dbus_error_free (&error);
-
-  for (i = 0; i < n_instances; ++i)
-    add_instance (job, instances[i]);
-
-  dbus_free_string_array (instances);
+        DBusMessage *reply;
+        DBusError error;
+        char **instances;
+        int n_instances, i;
+
+        assert (call != NULL);
+        assert (job != NULL);
+
+        reply = dbus_pending_call_steal_reply (call);
+        if (reply == NULL)
+                return;
+        if (dbus_message_get_type (reply) != DBUS_MESSAGE_TYPE_METHOD_RETURN)
+                goto out;
+
+        dbus_error_init (&error);
+        dbus_message_get_args (reply, &error,
+                               DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
+                               &instances, &n_instances,
+                               DBUS_TYPE_INVALID);
+        if (dbus_error_is_set (&error))
+                goto out;
+        dbus_error_free (&error);
+
+        for (i = 0; i < n_instances; ++i) {
+                add_instance (job, instances[i]);
+        }
+
+        dbus_free_string_array (instances);
 
 out:
-  dbus_message_unref (reply);
+        dbus_message_unref (reply);
 }
 
 static void
 free_job_instance (void *key, void *data, void *user_data)
 {
-  const char *path = key;
-  ply_upstart_monitor_instance_t *instance = data;
-  ply_upstart_monitor_t *monitor = user_data;
+        const char *path = key;
+        ply_upstart_monitor_instance_t *instance = data;
+        ply_upstart_monitor_t *monitor = user_data;
 
-  assert (monitor != NULL);
+        assert (monitor != NULL);
 
-  if (instance == NULL)
-    return;
+        if (instance == NULL)
+                return;
 
-  hashtable_remove_and_free_key (monitor->all_instances, path);
-  free (instance->properties.name);
-  free (instance->properties.goal);
-  free (instance->properties.state);
-  free (instance);
+        hashtable_remove_and_free_key (monitor->all_instances, path);
+        free (instance->properties.name);
+        free (instance->properties.goal);
+        free (instance->properties.state);
+        free (instance);
 }
 
 static void
 remove_job_internal (ply_upstart_monitor_t *monitor, const char *path)
 {
-  ply_upstart_monitor_job_t *job;
-  ply_list_node_t *node;
-
-  job = hashtable_remove_and_free_key (monitor->jobs, path);
-  if (job == NULL)
-    return;
-
-  node = ply_list_get_first_node (job->pending_calls);
-  while (node != NULL)
-    {
-      DBusPendingCall *call;
-      ply_list_node_t *next_node;
-
-      call = ply_list_node_get_data (node);
-      next_node = ply_list_get_next_node (job->pending_calls, node);
-      dbus_pending_call_cancel (call);
-      dbus_pending_call_unref (call);
-      node = next_node;
-    }
-  ply_list_free (job->pending_calls);
-
-  free (job->properties.name);
-  free (job->properties.description);
-  ply_hashtable_foreach (job->instances, free_job_instance, monitor);
-  ply_hashtable_free (job->instances);
-  free (job);
+        ply_upstart_monitor_job_t *job;
+        ply_list_node_t *node;
+
+        job = hashtable_remove_and_free_key (monitor->jobs, path);
+        if (job == NULL)
+                return;
+
+        node = ply_list_get_first_node (job->pending_calls);
+        while (node != NULL) {
+                DBusPendingCall *call;
+                ply_list_node_t *next_node;
+
+                call = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (job->pending_calls, node);
+                dbus_pending_call_cancel (call);
+                dbus_pending_call_unref (call);
+                node = next_node;
+        }
+        ply_list_free (job->pending_calls);
+
+        free (job->properties.name);
+        free (job->properties.description);
+        ply_hashtable_foreach (job->instances, free_job_instance, monitor);
+        ply_hashtable_free (job->instances);
+        free (job);
 }
 
 static void
 add_job (ply_upstart_monitor_t *monitor, const char *path)
 {
-  ply_upstart_monitor_job_t *job;
-  DBusMessage *message;
-  const char *interface = UPSTART_INTERFACE_0_6_JOB;
-  DBusPendingCall *call;
-
-  ply_trace ("adding job: %s", path);
-
-  remove_job_internal (monitor, path);
-
-  job = calloc (1, sizeof (ply_upstart_monitor_job_t));
-  job->monitor = monitor;
-  job->properties.name = NULL;
-  job->properties.description = NULL;
-  job->properties.is_task = false;
-  job->instances = ply_hashtable_new (ply_hashtable_string_hash,
-                                      ply_hashtable_string_compare);
-  job->pending_calls = ply_list_new ();
-
-  ply_hashtable_insert (monitor->jobs, strdup (path), job);
-
-  /* Ask Upstart for the name and description properties. */
-  ply_trace ("fetching properties of job %s", path);
-  message = dbus_message_new_method_call (UPSTART_SERVICE, path,
-                                          DBUS_INTERFACE_PROPERTIES, "GetAll");
-  dbus_message_append_args (message,
-                            DBUS_TYPE_STRING, &interface,
-                            DBUS_TYPE_INVALID);
-  dbus_connection_send_with_reply (monitor->connection, message, &call, -1);
-  dbus_message_unref (message);
-  if (call != NULL)
-    {
-      dbus_pending_call_set_notify (call,
-                                    (DBusPendingCallNotifyFunction)
-                                    on_get_all_job_properties_finished,
-                                    job,
-                                    NULL);
-      ply_list_append_data (job->pending_calls, call);
-    }
-
-  /* Ask Upstart for a list of all instances of this job. */
-  ply_trace ("calling GetAllInstances on job %s", path);
-  message = dbus_message_new_method_call (UPSTART_SERVICE, path,
-                                          UPSTART_INTERFACE_0_6_JOB,
-                                          "GetAllInstances");
-  dbus_connection_send_with_reply (monitor->connection, message, &call, -1);
-  dbus_message_unref (message);
-  if (call != NULL)
-    {
-      dbus_pending_call_set_notify (call,
-                                    (DBusPendingCallNotifyFunction)
-                                    on_get_all_instances_finished,
-                                    job,
-                                    NULL);
-      ply_list_append_data (job->pending_calls, call);
-    }
+        ply_upstart_monitor_job_t *job;
+        DBusMessage *message;
+        const char *interface = UPSTART_INTERFACE_0_6_JOB;
+        DBusPendingCall *call;
+
+        ply_trace ("adding job: %s", path);
+
+        remove_job_internal (monitor, path);
+
+        job = calloc (1, sizeof(ply_upstart_monitor_job_t));
+        job->monitor = monitor;
+        job->properties.name = NULL;
+        job->properties.description = NULL;
+        job->properties.is_task = false;
+        job->instances = ply_hashtable_new (ply_hashtable_string_hash,
+                                            ply_hashtable_string_compare);
+        job->pending_calls = ply_list_new ();
+
+        ply_hashtable_insert (monitor->jobs, strdup (path), job);
+
+        /* Ask Upstart for the name and description properties. */
+        ply_trace ("fetching properties of job %s", path);
+        message = dbus_message_new_method_call (UPSTART_SERVICE, path,
+                                                DBUS_INTERFACE_PROPERTIES, "GetAll");
+        dbus_message_append_args (message,
+                                  DBUS_TYPE_STRING, &interface,
+                                  DBUS_TYPE_INVALID);
+        dbus_connection_send_with_reply (monitor->connection, message, &call, -1);
+        dbus_message_unref (message);
+        if (call != NULL) {
+                dbus_pending_call_set_notify (call,
+                                              (DBusPendingCallNotifyFunction)
+                                              on_get_all_job_properties_finished,
+                                              job,
+                                              NULL);
+                ply_list_append_data (job->pending_calls, call);
+        }
+
+        /* Ask Upstart for a list of all instances of this job. */
+        ply_trace ("calling GetAllInstances on job %s", path);
+        message = dbus_message_new_method_call (UPSTART_SERVICE, path,
+                                                UPSTART_INTERFACE_0_6_JOB,
+                                                "GetAllInstances");
+        dbus_connection_send_with_reply (monitor->connection, message, &call, -1);
+        dbus_message_unref (message);
+        if (call != NULL) {
+                dbus_pending_call_set_notify (call,
+                                              (DBusPendingCallNotifyFunction)
+                                              on_get_all_instances_finished,
+                                              job,
+                                              NULL);
+                ply_list_append_data (job->pending_calls, call);
+        }
 }
 
 static void
 remove_job (ply_upstart_monitor_t *monitor, const char *path)
 {
-  ply_trace ("removing job: %s", path);
+        ply_trace ("removing job: %s", path);
 
-  remove_job_internal (monitor, path);
+        remove_job_internal (monitor, path);
 }
 
 static void
 on_get_all_jobs_finished (DBusPendingCall       *call,
                           ply_upstart_monitor_t *monitor)
 {
-  DBusMessage *reply;
-  DBusError error;
-  char **jobs;
-  int n_jobs, i;
-
-  assert (call != NULL);
-  assert (monitor != NULL);
-
-  reply = dbus_pending_call_steal_reply (call);
-  if (reply == NULL)
-    return;
-  if (dbus_message_get_type (reply) != DBUS_MESSAGE_TYPE_METHOD_RETURN)
-    goto out;
-
-  dbus_error_init (&error);
-  dbus_message_get_args (reply, &error,
-                         DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
-                         &jobs, &n_jobs,
-                         DBUS_TYPE_INVALID);
-  if (dbus_error_is_set (&error))
-    goto out;
-  dbus_error_free (&error);
-
-  for (i = 0; i < n_jobs; ++i)
-    add_job (monitor, jobs[i]);
-
-  dbus_free_string_array (jobs);
+        DBusMessage *reply;
+        DBusError error;
+        char **jobs;
+        int n_jobs, i;
+
+        assert (call != NULL);
+        assert (monitor != NULL);
+
+        reply = dbus_pending_call_steal_reply (call);
+        if (reply == NULL)
+                return;
+        if (dbus_message_get_type (reply) != DBUS_MESSAGE_TYPE_METHOD_RETURN)
+                goto out;
+
+        dbus_error_init (&error);
+        dbus_message_get_args (reply, &error,
+                               DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH,
+                               &jobs, &n_jobs,
+                               DBUS_TYPE_INVALID);
+        if (dbus_error_is_set (&error))
+                goto out;
+        dbus_error_free (&error);
+
+        for (i = 0; i < n_jobs; ++i) {
+                add_job (monitor, jobs[i]);
+        }
+
+        dbus_free_string_array (jobs);
 
 out:
-  dbus_message_unref (reply);
+        dbus_message_unref (reply);
 }
 
 
@@ -585,17 +565,17 @@ job_added_handler (DBusConnection        *connection,
                    DBusMessage           *message,
                    ply_upstart_monitor_t *monitor)
 {
-  DBusError error;
-  const char *signal_path;
-
-  ply_trace ("got JobAdded");
-  dbus_error_init (&error);
-  if (dbus_message_get_args (message, &error,
-                             DBUS_TYPE_OBJECT_PATH, &signal_path,
-                             DBUS_TYPE_INVALID))
-    add_job (monitor, signal_path);
-  dbus_error_free (&error);
-  return DBUS_HANDLER_RESULT_HANDLED;
+        DBusError error;
+        const char *signal_path;
+
+        ply_trace ("got JobAdded");
+        dbus_error_init (&error);
+        if (dbus_message_get_args (message, &error,
+                                   DBUS_TYPE_OBJECT_PATH, &signal_path,
+                                   DBUS_TYPE_INVALID))
+                add_job (monitor, signal_path);
+        dbus_error_free (&error);
+        return DBUS_HANDLER_RESULT_HANDLED;
 }
 
 static DBusHandlerResult
@@ -603,580 +583,566 @@ job_removed_handler (DBusConnection        *connection,
                      DBusMessage           *message,
                      ply_upstart_monitor_t *monitor)
 {
-  DBusError error;
-  const char *signal_path;
-
-  ply_trace ("got JobRemoved");
-  dbus_error_init (&error);
-  if (dbus_message_get_args (message, &error,
-                             DBUS_TYPE_OBJECT_PATH, &signal_path,
-                             DBUS_TYPE_INVALID))
-    remove_job (monitor, signal_path);
-  dbus_error_free (&error);
-  return DBUS_HANDLER_RESULT_HANDLED;
+        DBusError error;
+        const char *signal_path;
+
+        ply_trace ("got JobRemoved");
+        dbus_error_init (&error);
+        if (dbus_message_get_args (message, &error,
+                                   DBUS_TYPE_OBJECT_PATH, &signal_path,
+                                   DBUS_TYPE_INVALID))
+                remove_job (monitor, signal_path);
+        dbus_error_free (&error);
+        return DBUS_HANDLER_RESULT_HANDLED;
 }
 
 static DBusHandlerResult
 instance_added_handler (DBusConnection *connection, DBusMessage *message,
                         ply_upstart_monitor_t *monitor, const char *path)
 {
-  DBusError error;
-  const char *signal_path;
-  ply_upstart_monitor_job_t *job;
-
-  ply_trace ("got %s InstanceAdded", path);
-  job = ply_hashtable_lookup (monitor->jobs, (void *) path);
-  if (job != NULL)
-    {
-      dbus_error_init (&error);
-      if (dbus_message_get_args (message, &error,
-                                 DBUS_TYPE_OBJECT_PATH, &signal_path,
-                                 DBUS_TYPE_INVALID))
-        add_instance (job, signal_path);
-      dbus_error_free (&error);
-    }
-  return DBUS_HANDLER_RESULT_HANDLED;
+        DBusError error;
+        const char *signal_path;
+        ply_upstart_monitor_job_t *job;
+
+        ply_trace ("got %s InstanceAdded", path);
+        job = ply_hashtable_lookup (monitor->jobs, (void *) path);
+        if (job != NULL) {
+                dbus_error_init (&error);
+                if (dbus_message_get_args (message, &error,
+                                           DBUS_TYPE_OBJECT_PATH, &signal_path,
+                                           DBUS_TYPE_INVALID))
+                        add_instance (job, signal_path);
+                dbus_error_free (&error);
+        }
+        return DBUS_HANDLER_RESULT_HANDLED;
 }
 
 static DBusHandlerResult
 instance_removed_handler (DBusConnection *connection, DBusMessage *message,
                           ply_upstart_monitor_t *monitor, const char *path)
 {
-  DBusError error;
-  const char *signal_path;
-  ply_upstart_monitor_job_t *job;
-
-  ply_trace ("got %s InstanceRemoved", path);
-  job = ply_hashtable_lookup (monitor->jobs, (void *) path);
-  if (job != NULL)
-    {
-      dbus_error_init (&error);
-      if (dbus_message_get_args (message, &error,
-                                 DBUS_TYPE_OBJECT_PATH, &signal_path,
-                                 DBUS_TYPE_INVALID))
-        remove_instance (job, signal_path);
-      dbus_error_free (&error);
-    }
-  return DBUS_HANDLER_RESULT_HANDLED;
+        DBusError error;
+        const char *signal_path;
+        ply_upstart_monitor_job_t *job;
+
+        ply_trace ("got %s InstanceRemoved", path);
+        job = ply_hashtable_lookup (monitor->jobs, (void *) path);
+        if (job != NULL) {
+                dbus_error_init (&error);
+                if (dbus_message_get_args (message, &error,
+                                           DBUS_TYPE_OBJECT_PATH, &signal_path,
+                                           DBUS_TYPE_INVALID))
+                        remove_instance (job, signal_path);
+                dbus_error_free (&error);
+        }
+        return DBUS_HANDLER_RESULT_HANDLED;
 }
 
 static DBusHandlerResult
 goal_changed_handler (DBusConnection *connection, DBusMessage *message,
                       ply_upstart_monitor_t *monitor, const char *path)
 {
-  DBusError error;
-  const char *goal;
-  ply_upstart_monitor_instance_t *instance;
-  char *old_goal;
-
-  ply_trace ("got %s GoalChanged", path);
-  instance = ply_hashtable_lookup (monitor->all_instances, (void *) path);
-  if (instance != NULL)
-    {
-      dbus_error_init (&error);
-      if (dbus_message_get_args (message, &error,
-                                 DBUS_TYPE_STRING, &goal,
-                                 DBUS_TYPE_INVALID))
-        {
-          old_goal = instance->properties.goal;
-          instance->properties.goal = strdup (goal);
-          ply_trace ("goal changed from '%s' to '%s'", old_goal, goal);
-          free (old_goal);
+        DBusError error;
+        const char *goal;
+        ply_upstart_monitor_instance_t *instance;
+        char *old_goal;
+
+        ply_trace ("got %s GoalChanged", path);
+        instance = ply_hashtable_lookup (monitor->all_instances, (void *) path);
+        if (instance != NULL) {
+                dbus_error_init (&error);
+                if (dbus_message_get_args (message, &error,
+                                           DBUS_TYPE_STRING, &goal,
+                                           DBUS_TYPE_INVALID)) {
+                        old_goal = instance->properties.goal;
+                        instance->properties.goal = strdup (goal);
+                        ply_trace ("goal changed from '%s' to '%s'", old_goal, goal);
+                        free (old_goal);
+                }
+                dbus_error_free (&error);
         }
-      dbus_error_free (&error);
-    }
-  return DBUS_HANDLER_RESULT_HANDLED;
+        return DBUS_HANDLER_RESULT_HANDLED;
 }
 
 static DBusHandlerResult
 state_changed_handler (DBusConnection *connection, DBusMessage *message,
                        ply_upstart_monitor_t *monitor, const char *path)
 {
-  DBusError error;
-  const char *state;
-  ply_upstart_monitor_instance_t *instance;
-  char *old_state;
-
-  ply_trace ("got %s StateChanged", path);
-  instance = ply_hashtable_lookup (monitor->all_instances, (void *) path);
-  if (instance != NULL)
-    {
-      dbus_error_init (&error);
-      if (dbus_message_get_args (message, &error,
-                                 DBUS_TYPE_STRING, &state,
-                                 DBUS_TYPE_INVALID))
-        {
-          old_state = instance->properties.state;
-          instance->properties.state = strdup (state);
-          ply_trace ("state changed from '%s' to '%s'", old_state, state);
-          if (strcmp (state, "starting") == 0)
-            {
-              /* Clear any old failed information. */
-              instance->properties.failed = 0;
-              instance->call_failed = false;
-            }
-          if (instance_is_initialized (instance))
-            {
-              if (monitor->state_changed_handler)
-                monitor->state_changed_handler (monitor->state_changed_data,
-                                                old_state,
-                                                &instance->job->properties,
-                                                &instance->properties);
-            }
-          else
-            instance->state_changed = true;
-          free (old_state);
+        DBusError error;
+        const char *state;
+        ply_upstart_monitor_instance_t *instance;
+        char *old_state;
+
+        ply_trace ("got %s StateChanged", path);
+        instance = ply_hashtable_lookup (monitor->all_instances, (void *) path);
+        if (instance != NULL) {
+                dbus_error_init (&error);
+                if (dbus_message_get_args (message, &error,
+                                           DBUS_TYPE_STRING, &state,
+                                           DBUS_TYPE_INVALID)) {
+                        old_state = instance->properties.state;
+                        instance->properties.state = strdup (state);
+                        ply_trace ("state changed from '%s' to '%s'", old_state, state);
+                        if (strcmp (state, "starting") == 0) {
+                                /* Clear any old failed information. */
+                                instance->properties.failed = 0;
+                                instance->call_failed = false;
+                        }
+                        if (instance_is_initialized (instance)) {
+                                if (monitor->state_changed_handler) {
+                                        monitor->state_changed_handler (monitor->state_changed_data,
+                                                                        old_state,
+                                                                        &instance->job->properties,
+                                                                        &instance->properties);
+                                }
+                        } else {
+                                instance->state_changed = true;
+                        }
+                        free (old_state);
+                }
+                dbus_error_free (&error);
         }
-      dbus_error_free (&error);
-    }
-  return DBUS_HANDLER_RESULT_HANDLED;
+        return DBUS_HANDLER_RESULT_HANDLED;
 }
 
 static DBusHandlerResult
 failed_handler (DBusConnection *connection, DBusMessage *message,
                 ply_upstart_monitor_t *monitor, const char *path)
 {
-  DBusError error;
-  ply_upstart_monitor_instance_t *instance;
-  dbus_int32_t failed_status;
-
-  ply_trace ("got %s Failed", path);
-  instance = ply_hashtable_lookup (monitor->all_instances, (void *) path);
-  if (instance != NULL)
-    {
-      dbus_error_init (&error);
-      if (dbus_message_get_args (message, &error,
-                                 DBUS_TYPE_INT32, &failed_status,
-                                 DBUS_TYPE_INVALID))
-        {
-          instance->properties.failed = failed_status;
-          if (instance_is_initialized (instance))
-            {
-              if (monitor->failed_handler)
-                monitor->failed_handler (monitor->failed_data,
-                                         &instance->job->properties,
-                                         &instance->properties,
-                                         (int) failed_status);
-            }
-          else
-            instance->call_failed = true;
+        DBusError error;
+        ply_upstart_monitor_instance_t *instance;
+        dbus_int32_t failed_status;
+
+        ply_trace ("got %s Failed", path);
+        instance = ply_hashtable_lookup (monitor->all_instances, (void *) path);
+        if (instance != NULL) {
+                dbus_error_init (&error);
+                if (dbus_message_get_args (message, &error,
+                                           DBUS_TYPE_INT32, &failed_status,
+                                           DBUS_TYPE_INVALID)) {
+                        instance->properties.failed = failed_status;
+                        if (instance_is_initialized (instance)) {
+                                if (monitor->failed_handler) {
+                                        monitor->failed_handler (monitor->failed_data,
+                                                                 &instance->job->properties,
+                                                                 &instance->properties,
+                                                                 (int) failed_status);
+                                }
+                        } else {
+                                instance->call_failed = true;
+                        }
+                }
+                dbus_error_free (&error);
         }
-      dbus_error_free (&error);
-    }
-  return DBUS_HANDLER_RESULT_HANDLED;
+        return DBUS_HANDLER_RESULT_HANDLED;
 }
 
 static DBusHandlerResult
 message_handler (DBusConnection *connection, DBusMessage *message, void *data)
 {
-  ply_upstart_monitor_t *monitor = data;
-  const char *path;
+        ply_upstart_monitor_t *monitor = data;
+        const char *path;
 
-  assert (connection != NULL);
-  assert (message != NULL);
-  assert (monitor != NULL);
+        assert (connection != NULL);
+        assert (message != NULL);
+        assert (monitor != NULL);
 
-  path = dbus_message_get_path (message);
-  if (path == NULL)
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        path = dbus_message_get_path (message);
+        if (path == NULL)
+                return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
-  if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6,
-                              "JobAdded"))
-    return job_added_handler (connection, message, monitor);
+        if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6,
+                                    "JobAdded"))
+                return job_added_handler (connection, message, monitor);
 
-  if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6,
-                              "JobRemoved"))
-    return job_removed_handler (connection, message, monitor);
+        if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6,
+                                    "JobRemoved"))
+                return job_removed_handler (connection, message, monitor);
 
-  if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6_JOB,
-                              "InstanceAdded"))
-    return instance_added_handler (connection, message, monitor, path);
+        if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6_JOB,
+                                    "InstanceAdded"))
+                return instance_added_handler (connection, message, monitor, path);
 
-  if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6_JOB,
-                              "InstanceRemoved"))
-    return instance_removed_handler (connection, message, monitor, path);
+        if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6_JOB,
+                                    "InstanceRemoved"))
+                return instance_removed_handler (connection, message, monitor, path);
 
-  if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6_INSTANCE,
-                              "GoalChanged"))
-    return goal_changed_handler (connection, message, monitor, path);
+        if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6_INSTANCE,
+                                    "GoalChanged"))
+                return goal_changed_handler (connection, message, monitor, path);
 
-  if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6_INSTANCE,
-                              "StateChanged"))
-    return state_changed_handler (connection, message, monitor, path);
+        if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6_INSTANCE,
+                                    "StateChanged"))
+                return state_changed_handler (connection, message, monitor, path);
 
-  if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6_INSTANCE,
-                              "Failed"))
-    return failed_handler (connection, message, monitor, path);
+        if (dbus_message_is_signal (message, UPSTART_INTERFACE_0_6_INSTANCE,
+                                    "Failed"))
+                return failed_handler (connection, message, monitor, path);
 
-  return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
 ply_upstart_monitor_t *
 ply_upstart_monitor_new (ply_event_loop_t *loop)
 {
-  DBusError error;
-  DBusConnection *connection;
-  ply_upstart_monitor_t *monitor;
-  DBusMessage *message;
-  DBusPendingCall *call;
-
-  dbus_error_init (&error);
-
-  /* Get a connection to the system bus and set it up to listen for messages
-   * from Upstart.
-   */
-  connection = dbus_connection_open (DBUS_ADDRESS_UPSTART, &error);
-  if (connection == NULL)
-    {
-      ply_error ("unable to connect to system bus: %s", error.message);
-      dbus_error_free (&error);
-      return NULL;
-    }
-  dbus_error_free (&error);
-
-  monitor = calloc (1, sizeof (ply_upstart_monitor_t));
-  monitor->connection = connection;
-  monitor->loop = NULL;
-  monitor->jobs = ply_hashtable_new (ply_hashtable_string_hash,
-                                     ply_hashtable_string_compare);
-  monitor->all_instances = ply_hashtable_new (ply_hashtable_string_hash,
-                                              ply_hashtable_string_compare);
-  monitor->state_changed_handler = NULL;
-  monitor->state_changed_data = NULL;
-  monitor->failed_handler = NULL;
-  monitor->failed_data = NULL;
-  monitor->dispatch_fd = -1;
-
-  if (!dbus_connection_add_filter (connection, message_handler, monitor, NULL))
-    {
-      ply_error ("unable to add filter to system bus connection");
-      ply_upstart_monitor_free (monitor);
-      return NULL;
-    }
-
-  ply_trace ("calling GetAllJobs");
-  message = dbus_message_new_method_call (UPSTART_SERVICE, UPSTART_PATH,
-                                          UPSTART_INTERFACE_0_6,
-                                          "GetAllJobs");
-  dbus_connection_send_with_reply (monitor->connection, message, &call, -1);
-  dbus_message_unref (message);
-  if (call != NULL)
-    dbus_pending_call_set_notify (call,
-                                  (DBusPendingCallNotifyFunction)
-                                  on_get_all_jobs_finished,
-                                  monitor, NULL);
-
-  if (loop != NULL)
-    ply_upstart_monitor_connect_to_event_loop (monitor, loop);
-
-  return monitor;
+        DBusError error;
+        DBusConnection *connection;
+        ply_upstart_monitor_t *monitor;
+        DBusMessage *message;
+        DBusPendingCall *call;
+
+        dbus_error_init (&error);
+
+        /* Get a connection to the system bus and set it up to listen for messages
+         * from Upstart.
+         */
+        connection = dbus_connection_open (DBUS_ADDRESS_UPSTART, &error);
+        if (connection == NULL) {
+                ply_error ("unable to connect to system bus: %s", error.message);
+                dbus_error_free (&error);
+                return NULL;
+        }
+        dbus_error_free (&error);
+
+        monitor = calloc (1, sizeof(ply_upstart_monitor_t));
+        monitor->connection = connection;
+        monitor->loop = NULL;
+        monitor->jobs = ply_hashtable_new (ply_hashtable_string_hash,
+                                           ply_hashtable_string_compare);
+        monitor->all_instances = ply_hashtable_new (ply_hashtable_string_hash,
+                                                    ply_hashtable_string_compare);
+        monitor->state_changed_handler = NULL;
+        monitor->state_changed_data = NULL;
+        monitor->failed_handler = NULL;
+        monitor->failed_data = NULL;
+        monitor->dispatch_fd = -1;
+
+        if (!dbus_connection_add_filter (connection, message_handler, monitor, NULL)) {
+                ply_error ("unable to add filter to system bus connection");
+                ply_upstart_monitor_free (monitor);
+                return NULL;
+        }
+
+        ply_trace ("calling GetAllJobs");
+        message = dbus_message_new_method_call (UPSTART_SERVICE, UPSTART_PATH,
+                                                UPSTART_INTERFACE_0_6,
+                                                "GetAllJobs");
+        dbus_connection_send_with_reply (monitor->connection, message, &call, -1);
+        dbus_message_unref (message);
+        if (call != NULL) {
+                dbus_pending_call_set_notify (call,
+                                              (DBusPendingCallNotifyFunction)
+                                              on_get_all_jobs_finished,
+                                              monitor, NULL);
+        }
+
+        if (loop != NULL)
+                ply_upstart_monitor_connect_to_event_loop (monitor, loop);
+
+        return monitor;
 }
 
 void
 ply_upstart_monitor_free (ply_upstart_monitor_t *monitor)
 {
-  if (monitor == NULL)
-    return;
-
-  ply_hashtable_free (monitor->all_instances);
-  ply_hashtable_free (monitor->jobs);
-  dbus_connection_unref (monitor->connection);
-  if (monitor->dispatch_fd >= 0)
-    close (monitor->dispatch_fd);
-  free (monitor);
+        if (monitor == NULL)
+                return;
+
+        ply_hashtable_free (monitor->all_instances);
+        ply_hashtable_free (monitor->jobs);
+        dbus_connection_unref (monitor->connection);
+        if (monitor->dispatch_fd >= 0)
+                close (monitor->dispatch_fd);
+        free (monitor);
 }
 
 static void
 read_watch_handler (void *data, int fd)
 {
-  DBusWatch *watch = data;
+        DBusWatch *watch = data;
 
-  assert (watch != NULL);
+        assert (watch != NULL);
 
-  dbus_watch_handle (watch, DBUS_WATCH_READABLE);
+        dbus_watch_handle (watch, DBUS_WATCH_READABLE);
 }
 
 static void
 write_watch_handler (void *data, int fd)
 {
-  DBusWatch *watch = data;
+        DBusWatch *watch = data;
 
-  assert (watch != NULL);
+        assert (watch != NULL);
 
-  dbus_watch_handle (watch, DBUS_WATCH_WRITABLE);
+        dbus_watch_handle (watch, DBUS_WATCH_WRITABLE);
 }
 
 static dbus_bool_t
 add_watch (DBusWatch *watch, void *data)
 {
-  ply_upstart_monitor_t *monitor = data;
-  unsigned int flags;
-  int fd;
-  ply_event_loop_fd_status_t status;
-  ply_fd_watch_t *read_watch_event = NULL, *write_watch_event = NULL;
-
-  assert (monitor != NULL);
-  assert (watch != NULL);
-
-  if (!dbus_watch_get_enabled (watch))
-    return TRUE;
-
-  assert (dbus_watch_get_data (watch) == NULL);
-
-  flags = dbus_watch_get_flags (watch);
-  fd = dbus_watch_get_unix_fd (watch);
-
-  if (flags & DBUS_WATCH_READABLE)
-    {
-      status = PLY_EVENT_LOOP_FD_STATUS_HAS_DATA;
-      read_watch_event = ply_event_loop_watch_fd (monitor->loop, fd, status,
-                                                  read_watch_handler, NULL,
-                                                  watch);
-      if (read_watch_event == NULL)
-        return FALSE;
-      dbus_watch_set_data (watch, read_watch_event, NULL);
-    }
-
-  if (flags & DBUS_WATCH_WRITABLE)
-    {
-      status = PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA;
-      write_watch_event = ply_event_loop_watch_fd (monitor->loop, fd, status,
-                                                   write_watch_handler, NULL,
-                                                   watch);
-      if (write_watch_event == NULL)
-        {
-          if (read_watch_event != NULL)
-            ply_event_loop_stop_watching_fd (monitor->loop, read_watch_event);
-          return FALSE;
+        ply_upstart_monitor_t *monitor = data;
+        unsigned int flags;
+        int fd;
+        ply_event_loop_fd_status_t status;
+        ply_fd_watch_t *read_watch_event = NULL, *write_watch_event = NULL;
+
+        assert (monitor != NULL);
+        assert (watch != NULL);
+
+        if (!dbus_watch_get_enabled (watch))
+                return TRUE;
+
+        assert (dbus_watch_get_data (watch) == NULL);
+
+        flags = dbus_watch_get_flags (watch);
+        fd = dbus_watch_get_unix_fd (watch);
+
+        if (flags & DBUS_WATCH_READABLE) {
+                status = PLY_EVENT_LOOP_FD_STATUS_HAS_DATA;
+                read_watch_event = ply_event_loop_watch_fd (monitor->loop, fd, status,
+                                                            read_watch_handler, NULL,
+                                                            watch);
+                if (read_watch_event == NULL)
+                        return FALSE;
+                dbus_watch_set_data (watch, read_watch_event, NULL);
         }
-      dbus_watch_set_data (watch, write_watch_event, NULL);
-    }
 
-  return TRUE;
+        if (flags & DBUS_WATCH_WRITABLE) {
+                status = PLY_EVENT_LOOP_FD_STATUS_CAN_TAKE_DATA;
+                write_watch_event = ply_event_loop_watch_fd (monitor->loop, fd, status,
+                                                             write_watch_handler, NULL,
+                                                             watch);
+                if (write_watch_event == NULL) {
+                        if (read_watch_event != NULL)
+                                ply_event_loop_stop_watching_fd (monitor->loop, read_watch_event);
+                        return FALSE;
+                }
+                dbus_watch_set_data (watch, write_watch_event, NULL);
+        }
+
+        return TRUE;
 }
 
 static void
 remove_watch (DBusWatch *watch, void *data)
 {
-  ply_upstart_monitor_t *monitor = data;
-  ply_fd_watch_t *watch_event;
+        ply_upstart_monitor_t *monitor = data;
+        ply_fd_watch_t *watch_event;
 
-  assert (monitor != NULL);
-  assert (watch != NULL);
+        assert (monitor != NULL);
+        assert (watch != NULL);
 
-  watch_event = dbus_watch_get_data (watch);
-  if (watch_event == NULL)
-    return;
+        watch_event = dbus_watch_get_data (watch);
+        if (watch_event == NULL)
+                return;
 
-  ply_event_loop_stop_watching_fd (monitor->loop, watch_event);
+        ply_event_loop_stop_watching_fd (monitor->loop, watch_event);
 
-  dbus_watch_set_data (watch, NULL, NULL);
+        dbus_watch_set_data (watch, NULL, NULL);
 }
 
 static void
 toggled_watch (DBusWatch *watch, void *data)
 {
-  if (dbus_watch_get_enabled (watch))
-    add_watch (watch, data);
-  else
-    remove_watch (watch, data);
+        if (dbus_watch_get_enabled (watch))
+                add_watch (watch, data);
+        else
+                remove_watch (watch, data);
 }
 
 static ply_upstart_monitor_timeout_t *
 timeout_user_data_new (ply_upstart_monitor_t *monitor, DBusTimeout *timeout)
 {
-  ply_upstart_monitor_timeout_t *monitor_timeout;
+        ply_upstart_monitor_timeout_t *monitor_timeout;
 
-  monitor_timeout = calloc (1, sizeof (ply_upstart_monitor_timeout_t));
-  monitor_timeout->monitor = monitor;
-  monitor_timeout->timeout = timeout;
+        monitor_timeout = calloc (1, sizeof(ply_upstart_monitor_timeout_t));
+        monitor_timeout->monitor = monitor;
+        monitor_timeout->timeout = timeout;
 
-  return monitor_timeout;
+        return monitor_timeout;
 }
 
 static void
 timeout_user_data_free (void *data)
 {
-  ply_upstart_monitor_timeout_t *monitor_timeout = data;
+        ply_upstart_monitor_timeout_t *monitor_timeout = data;
 
-  free (monitor_timeout);
+        free (monitor_timeout);
 }
 
 static void
 timeout_handler (void *data, ply_event_loop_t *loop)
 {
-  ply_upstart_monitor_timeout_t *monitor_timeout = data;
+        ply_upstart_monitor_timeout_t *monitor_timeout = data;
 
-  assert (monitor_timeout != NULL);
+        assert (monitor_timeout != NULL);
 
-  dbus_timeout_handle (monitor_timeout->timeout);
+        dbus_timeout_handle (monitor_timeout->timeout);
 }
 
 static dbus_bool_t
 add_timeout (DBusTimeout *timeout, void *data)
 {
-  ply_upstart_monitor_t *monitor = data;
-  int interval;
-  ply_upstart_monitor_timeout_t *monitor_timeout;
+        ply_upstart_monitor_t *monitor = data;
+        int interval;
+        ply_upstart_monitor_timeout_t *monitor_timeout;
 
-  assert (monitor != NULL);
-  assert (timeout != NULL);
+        assert (monitor != NULL);
+        assert (timeout != NULL);
 
-  if (!dbus_timeout_get_enabled (timeout))
-    return TRUE;
+        if (!dbus_timeout_get_enabled (timeout))
+                return TRUE;
 
-  interval = dbus_timeout_get_interval (timeout) * 1000;
+        interval = dbus_timeout_get_interval (timeout) * 1000;
 
-  monitor_timeout = timeout_user_data_new (monitor, timeout);
+        monitor_timeout = timeout_user_data_new (monitor, timeout);
 
-  ply_event_loop_watch_for_timeout (monitor->loop, (double) interval,
-                                    timeout_handler, monitor_timeout);
+        ply_event_loop_watch_for_timeout (monitor->loop, (double) interval,
+                                          timeout_handler, monitor_timeout);
 
-  dbus_timeout_set_data (timeout, monitor_timeout, timeout_user_data_free);
+        dbus_timeout_set_data (timeout, monitor_timeout, timeout_user_data_free);
 
-  return TRUE;
+        return TRUE;
 }
 
 static void
 remove_timeout (DBusTimeout *timeout, void *data)
 {
-  ply_upstart_monitor_t *monitor = data;
-  ply_upstart_monitor_timeout_t *monitor_timeout;
+        ply_upstart_monitor_t *monitor = data;
+        ply_upstart_monitor_timeout_t *monitor_timeout;
 
-  assert (monitor != NULL);
-  assert (timeout != NULL);
+        assert (monitor != NULL);
+        assert (timeout != NULL);
 
-  monitor_timeout = dbus_timeout_get_data (timeout);
-  if (monitor_timeout == NULL)
-    return;
+        monitor_timeout = dbus_timeout_get_data (timeout);
+        if (monitor_timeout == NULL)
+                return;
 
-  ply_event_loop_stop_watching_for_timeout (monitor->loop,
-                                            timeout_handler, monitor_timeout);
+        ply_event_loop_stop_watching_for_timeout (monitor->loop,
+                                                  timeout_handler, monitor_timeout);
 
-  dbus_timeout_set_data (timeout, NULL, NULL);
+        dbus_timeout_set_data (timeout, NULL, NULL);
 }
 
 static void
 toggled_timeout (DBusTimeout *timeout, void *data)
 {
-  if (dbus_timeout_get_enabled (timeout))
-    add_timeout (timeout, data);
-  else
-    remove_timeout (timeout, data);
+        if (dbus_timeout_get_enabled (timeout))
+                add_timeout (timeout, data);
+        else
+                remove_timeout (timeout, data);
 }
 
 static void
 dispatch_status (DBusConnection *connection, DBusDispatchStatus new_status,
                  void *data)
 {
-  ply_upstart_monitor_t *monitor = data;
-  uint64_t event_payload;
+        ply_upstart_monitor_t *monitor = data;
+        uint64_t event_payload;
 
-  assert (monitor != NULL);
+        assert (monitor != NULL);
 
-  if (new_status != DBUS_DISPATCH_DATA_REMAINS)
-    return;
+        if (new_status != DBUS_DISPATCH_DATA_REMAINS)
+                return;
 
-  /* wake up event loop */
-  event_payload = 1;
-  ply_write (monitor->dispatch_fd, &event_payload, sizeof (event_payload));
+        /* wake up event loop */
+        event_payload = 1;
+        ply_write (monitor->dispatch_fd, &event_payload, sizeof(event_payload));
 }
 
 static void
 dispatch (void *data, int fd)
 {
-  ply_upstart_monitor_t *monitor = data;
-  uint64_t event_payload;
+        ply_upstart_monitor_t *monitor = data;
+        uint64_t event_payload;
 
-  assert (monitor != NULL);
+        assert (monitor != NULL);
 
-  /* reset eventfd to zero */
-  ply_read (fd, &event_payload, sizeof (event_payload));
+        /* reset eventfd to zero */
+        ply_read (fd, &event_payload, sizeof(event_payload));
 
-  while (dbus_connection_dispatch (monitor->connection) ==
-         DBUS_DISPATCH_DATA_REMAINS)
-    ;
+        while (dbus_connection_dispatch (monitor->connection) ==
+               DBUS_DISPATCH_DATA_REMAINS) {
+        }
 }
 
 bool
-ply_upstart_monitor_connect_to_event_loop (ply_upstart_monitor_t    *monitor,
-                                           ply_event_loop_t         *loop)
+ply_upstart_monitor_connect_to_event_loop (ply_upstart_monitor_t *monitor,
+                                           ply_event_loop_t      *loop)
 {
-  ply_fd_watch_t *dispatch_event = NULL;
-  uint64_t event_payload;
-
-  assert (monitor != NULL);
-
-  monitor->loop = loop;
-  monitor->dispatch_fd = -1;
-
-  if (!dbus_connection_set_watch_functions (monitor->connection,
-                                            add_watch,
-                                            remove_watch,
-                                            toggled_watch,
-                                            monitor, NULL))
-    goto err;
-
-  if (!dbus_connection_set_timeout_functions (monitor->connection,
-                                              add_timeout,
-                                              remove_timeout,
-                                              toggled_timeout,
-                                              monitor, NULL))
-    goto err;
-
-  monitor->dispatch_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);
-  if (monitor->dispatch_fd < 0)
-    goto err;
-  /* make sure we wake up to dispatch the first time through */
-  event_payload = 1;
-  ply_write (monitor->dispatch_fd, &event_payload, sizeof (event_payload));
-
-  dispatch_event = ply_event_loop_watch_fd (monitor->loop,
-                                            monitor->dispatch_fd,
-                                            PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
-                                            dispatch, NULL, monitor);
-  if (dispatch_event == NULL)
-    goto err;
-
-  dbus_connection_set_dispatch_status_function (monitor->connection,
-                                                dispatch_status,
-                                                monitor, NULL);
-
-  return true;
+        ply_fd_watch_t *dispatch_event = NULL;
+        uint64_t event_payload;
+
+        assert (monitor != NULL);
+
+        monitor->loop = loop;
+        monitor->dispatch_fd = -1;
+
+        if (!dbus_connection_set_watch_functions (monitor->connection,
+                                                  add_watch,
+                                                  remove_watch,
+                                                  toggled_watch,
+                                                  monitor, NULL))
+                goto err;
+
+        if (!dbus_connection_set_timeout_functions (monitor->connection,
+                                                    add_timeout,
+                                                    remove_timeout,
+                                                    toggled_timeout,
+                                                    monitor, NULL))
+                goto err;
+
+        monitor->dispatch_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);
+        if (monitor->dispatch_fd < 0)
+                goto err;
+        /* make sure we wake up to dispatch the first time through */
+        event_payload = 1;
+        ply_write (monitor->dispatch_fd, &event_payload, sizeof(event_payload));
+
+        dispatch_event = ply_event_loop_watch_fd (monitor->loop,
+                                                  monitor->dispatch_fd,
+                                                  PLY_EVENT_LOOP_FD_STATUS_HAS_DATA,
+                                                  dispatch, NULL, monitor);
+        if (dispatch_event == NULL)
+                goto err;
+
+        dbus_connection_set_dispatch_status_function (monitor->connection,
+                                                      dispatch_status,
+                                                      monitor, NULL);
+
+        return true;
 
 err:
-  dbus_connection_set_watch_functions (monitor->connection,
-                                       NULL, NULL, NULL, NULL, NULL);
-  dbus_connection_set_timeout_functions (monitor->connection,
-                                         NULL, NULL, NULL, NULL, NULL);
-  dbus_connection_set_dispatch_status_function (monitor->connection,
-                                                NULL, NULL, NULL);
-  if (dispatch_event != NULL)
-    ply_event_loop_stop_watching_fd (monitor->loop, dispatch_event);
-  if (monitor->dispatch_fd >= 0)
-    {
-      close (monitor->dispatch_fd);
-      monitor->dispatch_fd = -1;
-    }
-  monitor->loop = NULL;
-  return false;
+        dbus_connection_set_watch_functions (monitor->connection,
+                                             NULL, NULL, NULL, NULL, NULL);
+        dbus_connection_set_timeout_functions (monitor->connection,
+                                               NULL, NULL, NULL, NULL, NULL);
+        dbus_connection_set_dispatch_status_function (monitor->connection,
+                                                      NULL, NULL, NULL);
+        if (dispatch_event != NULL)
+                ply_event_loop_stop_watching_fd (monitor->loop, dispatch_event);
+        if (monitor->dispatch_fd >= 0) {
+                close (monitor->dispatch_fd);
+                monitor->dispatch_fd = -1;
+        }
+        monitor->loop = NULL;
+        return false;
 }
 
 void
-ply_upstart_monitor_add_state_changed_handler (ply_upstart_monitor_t                       *monitor,
-                                               ply_upstart_monitor_state_changed_handler_t  handler,
-                                               void                                        *user_data)
+ply_upstart_monitor_add_state_changed_handler (ply_upstart_monitor_t                      *monitor,
+                                               ply_upstart_monitor_state_changed_handler_t handler,
+                                               void                                       *user_data)
 {
-  monitor->state_changed_handler = handler;
-  monitor->state_changed_data = user_data;
+        monitor->state_changed_handler = handler;
+        monitor->state_changed_data = user_data;
 }
 
 void
-ply_upstart_monitor_add_failed_handler (ply_upstart_monitor_t                *monitor,
-                                        ply_upstart_monitor_failed_handler_t  handler,
-                                        void                                 *user_data)
+ply_upstart_monitor_add_failed_handler (ply_upstart_monitor_t               *monitor,
+                                        ply_upstart_monitor_failed_handler_t handler,
+                                        void                                *user_data)
 {
-  monitor->failed_handler = handler;
-  monitor->failed_data = user_data;
+        monitor->failed_handler = handler;
+        monitor->failed_data = user_data;
 }
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/upstart-bridge/ply-upstart-monitor.h b/src/upstart-bridge/ply-upstart-monitor.h
index 810e57a..be899a3 100644
--- a/src/upstart-bridge/ply-upstart-monitor.h
+++ b/src/upstart-bridge/ply-upstart-monitor.h
@@ -28,40 +28,42 @@
 
 typedef struct _ply_upstart_monitor ply_upstart_monitor_t;
 
-typedef struct {
-  char *name;
-  char *description;
-  bool  is_task;
+typedef struct
+{
+        char *name;
+        char *description;
+        bool  is_task;
 } ply_upstart_monitor_job_properties_t;
 
-typedef struct {
-  char     *name;
-  char     *goal;
-  char     *state;
-  uint32_t  failed : 1;
+typedef struct
+{
+        char    *name;
+        char    *goal;
+        char    *state;
+        uint32_t failed : 1;
 } ply_upstart_monitor_instance_properties_t;
 
-typedef void (* ply_upstart_monitor_state_changed_handler_t) (void                                      *user_data,
-                                                              const char                                *old_state,
-                                                              ply_upstart_monitor_job_properties_t      *job,
-                                                              ply_upstart_monitor_instance_properties_t *instance);
+typedef void (*ply_upstart_monitor_state_changed_handler_t) (void                                      *user_data,
+                                                             const char                                *old_state,
+                                                             ply_upstart_monitor_job_properties_t      *job,
+                                                             ply_upstart_monitor_instance_properties_t *instance);
 
-typedef void (* ply_upstart_monitor_failed_handler_t) (void                                      *user_data,
-                                                       ply_upstart_monitor_job_properties_t      *job,
-                                                       ply_upstart_monitor_instance_properties_t *instance,
-                                                       int                                        status);
+typedef void (*ply_upstart_monitor_failed_handler_t) (void                                      *user_data,
+                                                      ply_upstart_monitor_job_properties_t      *job,
+                                                      ply_upstart_monitor_instance_properties_t *instance,
+                                                      int                                        status);
 
 #ifndef PLY_HIDE_FUNCTION_DECLARATIONS
 ply_upstart_monitor_t *ply_upstart_monitor_new (ply_event_loop_t *loop);
 void ply_upstart_monitor_free (ply_upstart_monitor_t *upstart);
-bool ply_upstart_monitor_connect_to_event_loop (ply_upstart_monitor_t    *upstart,
-                                                ply_event_loop_t         *loop);
-void ply_upstart_monitor_add_state_changed_handler (ply_upstart_monitor_t                       *upstart,
-                                                    ply_upstart_monitor_state_changed_handler_t  handler,
-                                                    void                                        *user_data);
-void ply_upstart_monitor_add_failed_handler (ply_upstart_monitor_t                *upstart,
-                                             ply_upstart_monitor_failed_handler_t  handler,
-                                             void                                 *user_data);
+bool ply_upstart_monitor_connect_to_event_loop (ply_upstart_monitor_t *upstart,
+                                                ply_event_loop_t      *loop);
+void ply_upstart_monitor_add_state_changed_handler (ply_upstart_monitor_t                      *upstart,
+                                                    ply_upstart_monitor_state_changed_handler_t handler,
+                                                    void                                       *user_data);
+void ply_upstart_monitor_add_failed_handler (ply_upstart_monitor_t               *upstart,
+                                             ply_upstart_monitor_failed_handler_t handler,
+                                             void                                *user_data);
 #endif
 
 #endif
diff --git a/src/upstart-bridge/plymouth-upstart-bridge.c b/src/upstart-bridge/plymouth-upstart-bridge.c
index 1f86caa..c3733de 100644
--- a/src/upstart-bridge/plymouth-upstart-bridge.c
+++ b/src/upstart-bridge/plymouth-upstart-bridge.c
@@ -44,10 +44,10 @@
 
 typedef struct
 {
-  ply_event_loop_t      *loop;
-  ply_boot_client_t     *client;
-  ply_upstart_monitor_t *upstart;
-  ply_command_parser_t  *command_parser;
+        ply_event_loop_t      *loop;
+        ply_boot_client_t     *client;
+        ply_upstart_monitor_t *upstart;
+        ply_command_parser_t  *command_parser;
 } state_t;
 
 #ifndef TERMINAL_COLOR_RED
@@ -60,84 +60,84 @@ typedef struct
 static const char *
 get_string_capability (const char *name)
 {
-  const char *value;
+        const char *value;
 
-  value = tigetstr ((char *) name);
-  if (value == (const char *) -1)
-    value = NULL;
+        value = tigetstr ((char *) name);
+        if (value == (const char *) -1)
+                value = NULL;
 
-  return value;
+        return value;
 }
 
 static bool
 terminal_ignores_new_line_after_80_chars (void)
 {
-  return tigetflag ((char *) "xenl") != 0;
+        return tigetflag ((char *) "xenl") != 0;
 }
 
 static int
 get_number_of_columns (void)
 {
-  int number_of_columns;
+        int number_of_columns;
 
-  number_of_columns = tigetnum ((char *) "cols");
+        number_of_columns = tigetnum ((char *) "cols");
 
-  return number_of_columns;
+        return number_of_columns;
 }
 
 static bool
 can_set_cursor_column (void)
 {
-  const char *capability;
+        const char *capability;
 
-  capability = get_string_capability ("hpa");
+        capability = get_string_capability ("hpa");
 
-  return capability != NULL;
+        return capability != NULL;
 }
 
 static void
 set_cursor_column (int column)
 {
-  const char *capability;
-  const char *terminal_string;
+        const char *capability;
+        const char *terminal_string;
 
-  capability = get_string_capability ("hpa");
-  terminal_string = tiparm (capability, column);
-  fputs (terminal_string, stdout);
+        capability = get_string_capability ("hpa");
+        terminal_string = tiparm (capability, column);
+        fputs (terminal_string, stdout);
 }
 
 static bool
 can_set_fg_color (void)
 {
-  const char *capability;
+        const char *capability;
 
-  capability = get_string_capability ("setaf");
+        capability = get_string_capability ("setaf");
 
-  return capability != NULL;
+        return capability != NULL;
 }
 
 static void
 set_fg_color (int color)
 {
-  const char *capability;
-  const char *terminal_string;
+        const char *capability;
+        const char *terminal_string;
 
-  capability = get_string_capability ("setaf");
-  terminal_string = tiparm (capability, color);
-  fputs (terminal_string, stdout);
+        capability = get_string_capability ("setaf");
+        terminal_string = tiparm (capability, color);
+        fputs (terminal_string, stdout);
 }
 
 static void
 unset_fg_color (void)
 {
-  const char *terminal_string;
+        const char *terminal_string;
 
-  terminal_string = get_string_capability ("op");
+        terminal_string = get_string_capability ("op");
 
-  if (terminal_string == NULL)
-    return;
+        if (terminal_string == NULL)
+                return;
 
-  fputs (terminal_string, stdout);
+        fputs (terminal_string, stdout);
 }
 
 static void
@@ -147,53 +147,49 @@ update_status (state_t                                   *state,
                const char                                *action,
                bool                                       is_okay)
 {
-  if (job->description == NULL)
-    return;
+        if (job->description == NULL)
+                return;
 
-  printf (" * %s%s%s",
-          action ? action : "", action ? " " : "", job->description);
+        printf (" * %s%s%s",
+                action ? action : "", action ? " " : "", job->description);
 
-  if (terminal_ignores_new_line_after_80_chars () && can_set_cursor_column ())
-    {
-      int number_of_columns, column;
+        if (terminal_ignores_new_line_after_80_chars () && can_set_cursor_column ()) {
+                int number_of_columns, column;
 
-      number_of_columns = get_number_of_columns ();
+                number_of_columns = get_number_of_columns ();
 
-      if (number_of_columns < (int) strlen("[fail]"))
-        number_of_columns = 80;
+                if (number_of_columns < (int) strlen ("[fail]"))
+                        number_of_columns = 80;
 
-      column = number_of_columns - strlen ("[fail]") - 1;
+                column = number_of_columns - strlen ("[fail]") - 1;
 
-      set_cursor_column (column);
+                set_cursor_column (column);
 
-      if (is_okay)
-        puts ("[ OK ]");
-      else
-        {
-          bool supports_color;
+                if (is_okay) {
+                        puts ("[ OK ]");
+                } else {
+                        bool supports_color;
 
-          supports_color = can_set_fg_color ();
+                        supports_color = can_set_fg_color ();
 
-          fputs ("[", stdout);
+                        fputs ("[", stdout);
 
-          if (supports_color)
-            set_fg_color (TERMINAL_COLOR_RED);
+                        if (supports_color)
+                                set_fg_color (TERMINAL_COLOR_RED);
 
-          fputs ("fail", stdout);
+                        fputs ("fail", stdout);
 
-          if (supports_color)
-            unset_fg_color ();
+                        if (supports_color)
+                                unset_fg_color ();
 
-          puts ("]");
+                        puts ("]");
+                }
+        } else {
+                if (is_okay)
+                        puts ("   ...done.");
+                else
+                        puts ("   ...fail!");
         }
-    }
-  else
-    {
-      if (is_okay)
-        puts ("   ...done.");
-      else
-        puts ("   ...fail!");
-    }
 }
 
 static void
@@ -202,17 +198,16 @@ on_failed (void                                      *data,
            ply_upstart_monitor_instance_properties_t *instance,
            int                                        status)
 {
-  state_t *state = data;
-
-  if (job->is_task)
-    update_status (state, job, instance, NULL, false);
-  else
-    {
-      if (strcmp (instance->goal, "start") == 0)
-        update_status (state, job, instance, "Starting", false);
-      else if (strcmp (instance->goal, "stop") == 0)
-        update_status (state, job, instance, "Stopping", false);
-    }
+        state_t *state = data;
+
+        if (job->is_task) {
+                update_status (state, job, instance, NULL, false);
+        } else {
+                if (strcmp (instance->goal, "start") == 0)
+                        update_status (state, job, instance, "Starting", false);
+                else if (strcmp (instance->goal, "stop") == 0)
+                        update_status (state, job, instance, "Stopping", false);
+        }
 }
 
 static void
@@ -221,119 +216,110 @@ on_state_changed (state_t                                   *state,
                   ply_upstart_monitor_job_properties_t      *job,
                   ply_upstart_monitor_instance_properties_t *instance)
 {
-  if (instance->failed)
-    return;
-
-  if (job->is_task)
-    {
-      if (strcmp (instance->state, "waiting") == 0)
-        update_status (state, job, instance, NULL, true);
-    }
-  else
-    {
-      if (strcmp (instance->goal, "start") == 0)
-        {
-          if (strcmp (instance->state, "running") == 0)
-            update_status (state, job, instance, "Starting", true);
-        }
-      else if (strcmp (instance->goal, "stop") == 0)
-        {
-          if (strcmp (instance->state, "waiting") == 0)
-            update_status (state, job, instance, "Stopping", true);
+        if (instance->failed)
+                return;
+
+        if (job->is_task) {
+                if (strcmp (instance->state, "waiting") == 0)
+                        update_status (state, job, instance, NULL, true);
+        } else {
+                if (strcmp (instance->goal, "start") == 0) {
+                        if (strcmp (instance->state, "running") == 0)
+                                update_status (state, job, instance, "Starting", true);
+                } else if (strcmp (instance->goal, "stop") == 0) {
+                        if (strcmp (instance->state, "waiting") == 0)
+                                update_status (state, job, instance, "Stopping", true);
+                }
         }
-    }
 }
 
 static void
 on_disconnect (state_t *state)
 {
-  ply_trace ("disconnected from boot status daemon");
-  ply_event_loop_exit (state->loop, 0);
+        ply_trace ("disconnected from boot status daemon");
+        ply_event_loop_exit (state->loop, 0);
 }
 
 int
 main (int    argc,
       char **argv)
 {
-  state_t state = { 0 };
-  bool should_help, should_be_verbose;
-  bool is_connected;
-  int exit_code;
+        state_t state = { 0 };
+        bool should_help, should_be_verbose;
+        bool is_connected;
+        int exit_code;
 
-  exit_code = 0;
+        exit_code = 0;
 
-  signal (SIGPIPE, SIG_IGN);
+        signal (SIGPIPE, SIG_IGN);
 
-  state.loop = ply_event_loop_new ();
-  state.client = ply_boot_client_new ();
-  state.command_parser = ply_command_parser_new ("plymouth-upstart-bridge", "Upstart job state bridge");
+        state.loop = ply_event_loop_new ();
+        state.client = ply_boot_client_new ();
+        state.command_parser = ply_command_parser_new ("plymouth-upstart-bridge", "Upstart job state bridge");
 
-  ply_command_parser_add_options (state.command_parser,
-                                  "help", "This help message", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  "debug", "Enable verbose debug logging", PLY_COMMAND_OPTION_TYPE_FLAG,
-                                  NULL);
+        ply_command_parser_add_options (state.command_parser,
+                                        "help", "This help message", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        "debug", "Enable verbose debug logging", PLY_COMMAND_OPTION_TYPE_FLAG,
+                                        NULL);
 
-  if (!ply_command_parser_parse_arguments (state.command_parser, state.loop, argv, argc))
-    {
-      char *help_string;
+        if (!ply_command_parser_parse_arguments (state.command_parser, state.loop, argv, argc)) {
+                char *help_string;
 
-      help_string = ply_command_parser_get_help_string (state.command_parser);
+                help_string = ply_command_parser_get_help_string (state.command_parser);
 
-      ply_error ("%s", help_string);
+                ply_error ("%s", help_string);
 
-      free (help_string);
-      return 1;
-    }
+                free (help_string);
+                return 1;
+        }
 
-  ply_command_parser_get_options (state.command_parser,
-                                  "help", &should_help,
-                                  "debug", &should_be_verbose,
-                                  NULL);
+        ply_command_parser_get_options (state.command_parser,
+                                        "help", &should_help,
+                                        "debug", &should_be_verbose,
+                                        NULL);
 
-  if (should_help)
-    {
-      char *help_string;
+        if (should_help) {
+                char *help_string;
 
-      help_string = ply_command_parser_get_help_string (state.command_parser);
+                help_string = ply_command_parser_get_help_string (state.command_parser);
 
-      puts (help_string);
+                puts (help_string);
 
-      free (help_string);
-      return 0;
-    }
+                free (help_string);
+                return 0;
+        }
 
-  if (should_be_verbose && !ply_is_tracing ())
-    ply_toggle_tracing ();
+        if (should_be_verbose && !ply_is_tracing ())
+                ply_toggle_tracing ();
 
-  /* Don't bail on dummy/hardcopy terminals */
-  int errret=0;
-  setupterm (NULL, STDOUT_FILENO, &errret);
+        /* Don't bail on dummy/hardcopy terminals */
+        int errret = 0;
+        setupterm (NULL, STDOUT_FILENO, &errret);
 
-  is_connected = ply_boot_client_connect (state.client,
-                                          (ply_boot_client_disconnect_handler_t)
-                                          on_disconnect, &state);
-  if (!is_connected)
-    {
-      ply_trace ("daemon not running");
-      return 1;
-    }
+        is_connected = ply_boot_client_connect (state.client,
+                                                (ply_boot_client_disconnect_handler_t)
+                                                on_disconnect, &state);
+        if (!is_connected) {
+                ply_trace ("daemon not running");
+                return 1;
+        }
 
-  ply_boot_client_attach_to_event_loop (state.client, state.loop);
-  state.upstart = ply_upstart_monitor_new (state.loop);
-  if (!state.upstart)
-    return 1;
-  ply_upstart_monitor_add_state_changed_handler (state.upstart,
-                                                 (ply_upstart_monitor_state_changed_handler_t)
-                                                 on_state_changed, &state);
-  ply_upstart_monitor_add_failed_handler (state.upstart, on_failed, &state);
+        ply_boot_client_attach_to_event_loop (state.client, state.loop);
+        state.upstart = ply_upstart_monitor_new (state.loop);
+        if (!state.upstart)
+                return 1;
+        ply_upstart_monitor_add_state_changed_handler (state.upstart,
+                                                       (ply_upstart_monitor_state_changed_handler_t)
+                                                       on_state_changed, &state);
+        ply_upstart_monitor_add_failed_handler (state.upstart, on_failed, &state);
 
-  exit_code = ply_event_loop_run (state.loop);
+        exit_code = ply_event_loop_run (state.loop);
 
-  ply_upstart_monitor_free (state.upstart);
-  ply_boot_client_free (state.client);
+        ply_upstart_monitor_free (state.upstart);
+        ply_boot_client_free (state.client);
 
-  ply_event_loop_free (state.loop);
+        ply_event_loop_free (state.loop);
 
-  return exit_code;
+        return exit_code;
 }
 /* vim: set ts=4 sw=4 expandtab autoindent cindent cino={.5s,(0: */
diff --git a/src/viewer/plymouth-log-viewer.c b/src/viewer/plymouth-log-viewer.c
index ca54e0f..ea40774 100644
--- a/src/viewer/plymouth-log-viewer.c
+++ b/src/viewer/plymouth-log-viewer.c
@@ -50,302 +50,285 @@
 static gboolean show_icon = FALSE;
 static gboolean force = FALSE;
 
-static GOptionEntry entries[] = 
+static GOptionEntry entries[] =
 {
-  { "icon", 0, 0, G_OPTION_ARG_NONE, &show_icon, N_("Show a status icon if there are errors"), NULL },
-  { "force", 0, 0, G_OPTION_ARG_NONE, &force, N_("Show the icon even without errors"), NULL },
-  { NULL }
+        { "icon",  0, 0, G_OPTION_ARG_NONE, &show_icon, N_ ("Show a status icon if there are errors"), NULL },
+        { "force", 0, 0, G_OPTION_ARG_NONE, &force,     N_ ("Show the icon even without errors"),      NULL },
+        { NULL }
 };
 
 static void
-popup_menu (GtkStatusIcon *icon, 
+popup_menu (GtkStatusIcon *icon,
             guint          button,
             guint          activate_time,
             gpointer       user_data)
 {
-  GtkWidget *menu = user_data;
-  
-  gtk_menu_popup (GTK_MENU (menu), NULL, NULL, 
-                  gtk_status_icon_position_menu, icon, 
-                  button, activate_time);
+        GtkWidget *menu = user_data;
+
+        gtk_menu_popup (GTK_MENU (menu), NULL, NULL,
+                        gtk_status_icon_position_menu, icon,
+                        button, activate_time);
 }
 
 static void
-activate_icon (GtkStatusIcon *icon, 
+activate_icon (GtkStatusIcon *icon,
                gpointer       user_data)
 {
-  GtkWidget *window = user_data;
+        GtkWidget *window = user_data;
 
-  gtk_window_present (GTK_WINDOW (window));
+        gtk_window_present (GTK_WINDOW (window));
 }
 
 static gboolean
 check_for_errors (const char *file)
 {
-  struct stat log_info, spool_file_info;
+        struct stat log_info, spool_file_info;
 
-  if (stat (file, &log_info) < 0)
-    return FALSE;
+        if (stat (file, &log_info) < 0)
+                return FALSE;
 
-  if (stat (DEFAULT_SPOOL_FILE, &spool_file_info) < 0)
-    return FALSE;
+        if (stat (DEFAULT_SPOOL_FILE, &spool_file_info) < 0)
+                return FALSE;
 
-  return spool_file_info.st_dev == log_info.st_dev &&
-         spool_file_info.st_ino == log_info.st_ino;
+        return spool_file_info.st_dev == log_info.st_dev &&
+               spool_file_info.st_ino == log_info.st_ino;
 }
 
 static GtkTextBuffer *
-read_boot_log (const char  *file, 
-               int         *seen_errors, 
-               GError     **error)
+read_boot_log (const char *file,
+               int        *seen_errors,
+               GError    **error)
 {
-  char *content;
-  char *content_utf8;
-  gsize length;
-  char *p, *q;
-  GtkTextBuffer *buffer;
-  GtkTextIter iter;
-  GString *partial;
-
-  if (!g_file_get_contents (file, &content, &length, error))
-    return NULL;
-
-  content_utf8 = g_locale_to_utf8 (content, length, NULL, NULL, NULL);
-  if (content_utf8)
-    {
-      g_free (content);
-      content = content_utf8;   
-    }
-  
-  if (check_for_errors (file))
-    *seen_errors = 2;
-  else
-    *seen_errors = 0;
-
-  buffer = gtk_text_buffer_new (NULL);
-  gtk_text_buffer_create_tag (buffer, "blue", "foreground", "blue", NULL);
-  gtk_text_buffer_create_tag (buffer, "green", "foreground", "green", NULL);
-  gtk_text_buffer_create_tag (buffer, "red", "foreground", "red", NULL);
-  gtk_text_buffer_create_tag (buffer, "yellow", "foreground", "yellow", NULL);
-
-  partial = g_string_new ("");
-
-  p = content;
-  while (*p) 
-    {
-      switch (*p) 
-        {
-          case '\r': 
-            /* keep isolated \r */
-            if (p[1] != '\r' && p[-1] != '\r' &&
-                p[1] != '\n' && p[-1] != '\n')
-              {
-                gtk_text_buffer_get_end_iter (buffer, &iter);
-                gtk_text_buffer_insert (buffer, &iter, p, 1);
-              }
-            p++;
-            break;
-          case '\t':
-            gtk_text_buffer_get_end_iter (buffer, &iter);
-            gtk_text_buffer_insert (buffer, &iter, "        ", 8); 
-            p++;
-            break;
-          case '\033':
-            if (strncmp (p, "\033[0;34m", 7) == 0 && (q = strstr (p, "\033[0;39m")))
-              {
-                p += 7;
-                gtk_text_buffer_get_end_iter (buffer, &iter);
-                gtk_text_buffer_insert_with_tags_by_name (buffer, &iter, p, q - p, "blue", NULL); 
-                p = q + 7; 
-              }
-            else if (strncmp (p, "\033[60G", 5) == 0) 
-              {
-                gtk_text_buffer_get_end_iter (buffer, &iter);
-                gtk_text_buffer_insert (buffer, &iter, "\t", 1);
-                p += 5;
-              }
-            else if (strncmp (p, "\033[0;31m", 7) == 0 && (q = strstr (p, "\033[0;39m")))
-              {
-                p += 7;
-                gtk_text_buffer_get_end_iter (buffer, &iter);
-                gtk_text_buffer_insert_with_tags_by_name (buffer, &iter, p, q - p, "red", NULL); 
-                p = q + 7; 
-              }
-            else if (strncmp (p, "\033[0;32m", 7) == 0 && (q = strstr (p, "\033[0;39m")))
-              {
-                p += 7;
-                gtk_text_buffer_get_end_iter (buffer, &iter);
-                gtk_text_buffer_insert_with_tags_by_name (buffer, &iter, p, q - p, "green", NULL); 
-                p = q + 7; 
-              }
-            else if (strncmp (p, "\033[0;33m", 7) == 0 && (q = strstr (p, "\033[0;39m")))
-              {
-                p += 7;
-                gtk_text_buffer_get_end_iter (buffer, &iter);
-                gtk_text_buffer_insert_with_tags_by_name (buffer, &iter, p, q - p, "yellow", NULL); 
-                p = q + 7; 
-              }
-            else if (strncmp (p, "\033%G", 3) == 0) 
-              p += 3;
-            else
-              p++;
-            break;
-          default:
-            /* GtkTextBuffer doesn't let us insert partial utf-8 characters */
-            g_string_append_c (partial, *p);
-            if (g_utf8_get_char_validated (partial->str, partial->len) != (gunichar)-2)
-              {
-                gtk_text_buffer_get_end_iter (buffer, &iter);
-                gtk_text_buffer_insert (buffer, &iter, partial->str, partial->len);
-                g_string_truncate (partial, 0);
-              }
-            p++;
-            break;
+        char *content;
+        char *content_utf8;
+        gsize length;
+        char *p, *q;
+        GtkTextBuffer *buffer;
+        GtkTextIter iter;
+        GString *partial;
+
+        if (!g_file_get_contents (file, &content, &length, error))
+                return NULL;
+
+        content_utf8 = g_locale_to_utf8 (content, length, NULL, NULL, NULL);
+        if (content_utf8) {
+                g_free (content);
+                content = content_utf8;
+        }
+
+        if (check_for_errors (file))
+                *seen_errors = 2;
+        else
+                *seen_errors = 0;
+
+        buffer = gtk_text_buffer_new (NULL);
+        gtk_text_buffer_create_tag (buffer, "blue", "foreground", "blue", NULL);
+        gtk_text_buffer_create_tag (buffer, "green", "foreground", "green", NULL);
+        gtk_text_buffer_create_tag (buffer, "red", "foreground", "red", NULL);
+        gtk_text_buffer_create_tag (buffer, "yellow", "foreground", "yellow", NULL);
+
+        partial = g_string_new ("");
+
+        p = content;
+        while (*p) {
+                switch (*p) {
+                case '\r':
+                        /* keep isolated \r */
+                        if (p[1] != '\r' && p[-1] != '\r' &&
+                            p[1] != '\n' && p[-1] != '\n') {
+                                gtk_text_buffer_get_end_iter (buffer, &iter);
+                                gtk_text_buffer_insert (buffer, &iter, p, 1);
+                        }
+                        p++;
+                        break;
+                case '\t':
+                        gtk_text_buffer_get_end_iter (buffer, &iter);
+                        gtk_text_buffer_insert (buffer, &iter, "        ", 8);
+                        p++;
+                        break;
+                case '\033':
+                        if (strncmp (p, "\033[0;34m", 7) == 0 && (q = strstr (p, "\033[0;39m"))) {
+                                p += 7;
+                                gtk_text_buffer_get_end_iter (buffer, &iter);
+                                gtk_text_buffer_insert_with_tags_by_name (buffer, &iter, p, q - p, "blue", NULL);
+                                p = q + 7;
+                        } else if (strncmp (p, "\033[60G", 5) == 0) {
+                                gtk_text_buffer_get_end_iter (buffer, &iter);
+                                gtk_text_buffer_insert (buffer, &iter, "\t", 1);
+                                p += 5;
+                        } else if (strncmp (p, "\033[0;31m", 7) == 0 && (q = strstr (p, "\033[0;39m"))) {
+                                p += 7;
+                                gtk_text_buffer_get_end_iter (buffer, &iter);
+                                gtk_text_buffer_insert_with_tags_by_name (buffer, &iter, p, q - p, "red", NULL);
+                                p = q + 7;
+                        } else if (strncmp (p, "\033[0;32m", 7) == 0 && (q = strstr (p, "\033[0;39m"))) {
+                                p += 7;
+                                gtk_text_buffer_get_end_iter (buffer, &iter);
+                                gtk_text_buffer_insert_with_tags_by_name (buffer, &iter, p, q - p, "green", NULL);
+                                p = q + 7;
+                        } else if (strncmp (p, "\033[0;33m", 7) == 0 && (q = strstr (p, "\033[0;39m"))) {
+                                p += 7;
+                                gtk_text_buffer_get_end_iter (buffer, &iter);
+                                gtk_text_buffer_insert_with_tags_by_name (buffer, &iter, p, q - p, "yellow", NULL);
+                                p = q + 7;
+                        } else if (strncmp (p, "\033%G", 3) == 0) {
+                                p += 3;
+                        } else {
+                                p++;
+                        }
+                        break;
+                default:
+                        /* GtkTextBuffer doesn't let us insert partial utf-8 characters */
+                        g_string_append_c (partial, *p);
+                        if (g_utf8_get_char_validated (partial->str, partial->len) != (gunichar) - 2) {
+                                gtk_text_buffer_get_end_iter (buffer, &iter);
+                                gtk_text_buffer_insert (buffer, &iter, partial->str, partial->len);
+                                g_string_truncate (partial, 0);
+                        }
+                        p++;
+                        break;
+                }
         }
-    }
 
-  g_string_free (partial, TRUE);
-  g_free (content);
+        g_string_free (partial, TRUE);
+        g_free (content);
 
-  return buffer;
+        return buffer;
 }
 
 static void
 close_window (GtkWidget *window)
 {
-  if (show_icon)
-    gtk_widget_hide (window);
-  else
-    gtk_main_quit ();
+        if (show_icon)
+                gtk_widget_hide (window);
+        else
+                gtk_main_quit ();
 }
 
 static GtkWidget *
 create_window (GtkTextBuffer *buffer)
 {
-  GtkWidget *window;
-  GtkWidget *scrolledwin;
-  GtkWidget *box;
-  GtkWidget *terminal;
-  GtkWidget *bbox;
-  GtkWidget *close_button;
-  PangoFontDescription *description;
-  PangoTabArray *tabs;
-  int width, height;
-
-  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
-  gtk_window_set_position (GTK_WINDOW (window), GTK_WIN_POS_CENTER);
-  gtk_window_set_title (GTK_WINDOW (window), _("Boot messages"));
-  gtk_container_set_border_width (GTK_CONTAINER (window), 12);
-
-  width = MIN (800, 0.75 * gdk_screen_get_width (gdk_screen_get_default ()));
-  height = MIN (600, 0.75 * gdk_screen_get_height (gdk_screen_get_default ()));
-  gtk_window_set_default_size (GTK_WINDOW (window), width, height);
-
-  box = gtk_vbox_new (FALSE, 0);
-  scrolledwin = gtk_scrolled_window_new (NULL, NULL);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwin), 
-                                  GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
-  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolledwin), 
-                                       GTK_SHADOW_IN);
-  terminal = gtk_text_view_new_with_buffer (buffer);
-  gtk_text_view_set_editable (GTK_TEXT_VIEW (terminal), FALSE);
-
-  description = pango_font_description_from_string ("monospace");
-  gtk_widget_modify_font (terminal, description);
-  pango_font_description_free (description);
-
-  tabs = pango_tab_array_new_with_positions (1, TRUE, PANGO_TAB_LEFT, width - 130);
-  gtk_text_view_set_tabs (GTK_TEXT_VIEW (terminal), tabs);
-  gtk_text_view_set_left_margin (GTK_TEXT_VIEW (terminal), 12);
-  gtk_text_view_set_right_margin (GTK_TEXT_VIEW (terminal), 12);
-
-  bbox = gtk_hbutton_box_new ();
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (bbox), GTK_BUTTONBOX_END);
-  close_button = gtk_button_new_from_stock (GTK_STOCK_CLOSE);
-
-  gtk_container_add (GTK_CONTAINER (window), box);
-  gtk_box_pack_start (GTK_BOX (box), scrolledwin, TRUE, TRUE, 6);
-  gtk_container_add (GTK_CONTAINER (scrolledwin), terminal);
-  gtk_box_pack_start (GTK_BOX (box), bbox, FALSE, TRUE, 6);
-  gtk_box_pack_start (GTK_BOX (bbox), close_button, FALSE, TRUE, 6);
-
-  g_signal_connect (window, "delete-event",
-                    G_CALLBACK (close_window), NULL);
-  g_signal_connect_swapped (close_button, "clicked", 
-                            G_CALLBACK (close_window), window);
-
-  gtk_widget_show_all (box);
-
-  return window;
+        GtkWidget *window;
+        GtkWidget *scrolledwin;
+        GtkWidget *box;
+        GtkWidget *terminal;
+        GtkWidget *bbox;
+        GtkWidget *close_button;
+        PangoFontDescription *description;
+        PangoTabArray *tabs;
+        int width, height;
+
+        window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+        gtk_window_set_position (GTK_WINDOW (window), GTK_WIN_POS_CENTER);
+        gtk_window_set_title (GTK_WINDOW (window), _ ("Boot messages"));
+        gtk_container_set_border_width (GTK_CONTAINER (window), 12);
+
+        width = MIN (800, 0.75 * gdk_screen_get_width (gdk_screen_get_default ()));
+        height = MIN (600, 0.75 * gdk_screen_get_height (gdk_screen_get_default ()));
+        gtk_window_set_default_size (GTK_WINDOW (window), width, height);
+
+        box = gtk_vbox_new (FALSE, 0);
+        scrolledwin = gtk_scrolled_window_new (NULL, NULL);
+        gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwin),
+                                        GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
+        gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolledwin),
+                                             GTK_SHADOW_IN);
+        terminal = gtk_text_view_new_with_buffer (buffer);
+        gtk_text_view_set_editable (GTK_TEXT_VIEW (terminal), FALSE);
+
+        description = pango_font_description_from_string ("monospace");
+        gtk_widget_modify_font (terminal, description);
+        pango_font_description_free (description);
+
+        tabs = pango_tab_array_new_with_positions (1, TRUE, PANGO_TAB_LEFT, width - 130);
+        gtk_text_view_set_tabs (GTK_TEXT_VIEW (terminal), tabs);
+        gtk_text_view_set_left_margin (GTK_TEXT_VIEW (terminal), 12);
+        gtk_text_view_set_right_margin (GTK_TEXT_VIEW (terminal), 12);
+
+        bbox = gtk_hbutton_box_new ();
+        gtk_button_box_set_layout (GTK_BUTTON_BOX (bbox), GTK_BUTTONBOX_END);
+        close_button = gtk_button_new_from_stock (GTK_STOCK_CLOSE);
+
+        gtk_container_add (GTK_CONTAINER (window), box);
+        gtk_box_pack_start (GTK_BOX (box), scrolledwin, TRUE, TRUE, 6);
+        gtk_container_add (GTK_CONTAINER (scrolledwin), terminal);
+        gtk_box_pack_start (GTK_BOX (box), bbox, FALSE, TRUE, 6);
+        gtk_box_pack_start (GTK_BOX (bbox), close_button, FALSE, TRUE, 6);
+
+        g_signal_connect (window, "delete-event",
+                          G_CALLBACK (close_window), NULL);
+        g_signal_connect_swapped (close_button, "clicked",
+                                  G_CALLBACK (close_window), window);
+
+        gtk_widget_show_all (box);
+
+        return window;
 }
 
 int
 main (int argc, char *argv[])
 {
-  GtkStatusIcon *icon;
-  GtkWidget *menu;
-  GtkWidget *quit_item;
-  GtkWidget *window;
-  GtkTextBuffer *buffer;
-  GError *error = NULL;
-  int seen_errors;
-  gchar *file;
-
-  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-  textdomain (GETTEXT_PACKAGE);
-
-  if (!gtk_init_with_args (&argc, &argv, 
-                           _("[FILE]"), entries, GETTEXT_PACKAGE, &error))
-    {
-      g_print ("%s\n", error ? error->message : "Beep");
-      exit (1);
-    }
-
-  if (argc > 1)
-    file = argv[1];
-  else
-    file = DEFAULT_LOG;
-
-  buffer = read_boot_log (file, &seen_errors, &error);
-  if (buffer == NULL)
-    {
-      g_print ("%s\n", error ? error->message : "Blop");
-      exit (1);
-    }
-
-  window = create_window (buffer);
-
-  if (seen_errors == 2)
-    gtk_window_set_icon_name (GTK_WINDOW (window), GTK_STOCK_DIALOG_WARNING);
-  else
-    gtk_window_set_icon_name (GTK_WINDOW (window), GTK_STOCK_INFO);
-
-  if (show_icon)
-    {
-      menu = gtk_menu_new ();
-      quit_item = gtk_image_menu_item_new_from_stock (GTK_STOCK_QUIT, NULL);
-      gtk_menu_append (GTK_MENU (menu), quit_item);
-      gtk_widget_show_all (menu);
-      g_signal_connect (quit_item, "activate", G_CALLBACK (gtk_main_quit), NULL);
-  
-      icon = gtk_status_icon_new ();
-      if (seen_errors == 2)
-        gtk_status_icon_set_from_stock (icon, GTK_STOCK_DIALOG_WARNING);
-      else if (seen_errors == 1 || force)
-        gtk_status_icon_set_from_stock (icon, GTK_STOCK_INFO);
-      else
-        exit (0);
-
-      gtk_status_icon_set_tooltip (icon, _("Console output from services during system startup"));
-      gtk_status_icon_set_title (icon, _("Boot messages"));
-
-      g_signal_connect (icon, "activate", G_CALLBACK (activate_icon), window);
-      g_signal_connect (icon, "popup-menu", G_CALLBACK (popup_menu), menu);
-    }
-  else
-    gtk_window_present (GTK_WINDOW (window));
-
-  gtk_main ();
-
-  return 0;
+        GtkStatusIcon *icon;
+        GtkWidget *menu;
+        GtkWidget *quit_item;
+        GtkWidget *window;
+        GtkTextBuffer *buffer;
+        GError *error = NULL;
+        int seen_errors;
+        gchar *file;
+
+        bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+        textdomain (GETTEXT_PACKAGE);
+
+        if (!gtk_init_with_args (&argc, &argv,
+                                 _ ("[FILE]"), entries, GETTEXT_PACKAGE, &error)) {
+                g_print ("%s\n", error ? error->message : "Beep");
+                exit (1);
+        }
+
+        if (argc > 1)
+                file = argv[1];
+        else
+                file = DEFAULT_LOG;
+
+        buffer = read_boot_log (file, &seen_errors, &error);
+        if (buffer == NULL) {
+                g_print ("%s\n", error ? error->message : "Blop");
+                exit (1);
+        }
+
+        window = create_window (buffer);
+
+        if (seen_errors == 2)
+                gtk_window_set_icon_name (GTK_WINDOW (window), GTK_STOCK_DIALOG_WARNING);
+        else
+                gtk_window_set_icon_name (GTK_WINDOW (window), GTK_STOCK_INFO);
+
+        if (show_icon) {
+                menu = gtk_menu_new ();
+                quit_item = gtk_image_menu_item_new_from_stock (GTK_STOCK_QUIT, NULL);
+                gtk_menu_append (GTK_MENU (menu), quit_item);
+                gtk_widget_show_all (menu);
+                g_signal_connect (quit_item, "activate", G_CALLBACK (gtk_main_quit), NULL);
+
+                icon = gtk_status_icon_new ();
+                if (seen_errors == 2)
+                        gtk_status_icon_set_from_stock (icon, GTK_STOCK_DIALOG_WARNING);
+                else if (seen_errors == 1 || force)
+                        gtk_status_icon_set_from_stock (icon, GTK_STOCK_INFO);
+                else
+                        exit (0);
+
+                gtk_status_icon_set_tooltip (icon, _ ("Console output from services during system startup"));
+                gtk_status_icon_set_title (icon, _ ("Boot messages"));
+
+                g_signal_connect (icon, "activate", G_CALLBACK (activate_icon), window);
+                g_signal_connect (icon, "popup-menu", G_CALLBACK (popup_menu), menu);
+        } else {
+                gtk_window_present (GTK_WINDOW (window));
+        }
+
+        gtk_main ();
+
+        return 0;
 }
-- 
1.9.0

