From d8278c93ad78a5cbeb89b6b825fc37454798164a Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Wed, 7 Jan 2015 16:24:57 -0500
Subject: device-manager: try fb device if drm device failed

If the drm device failed to work, then fall back to the fb device.

Right now, we ignore fb devices that have associated drm devices.

This may fix vmwgfx.

diff --git a/src/libply-splash-core/ply-device-manager.c b/src/libply-splash-core/ply-device-manager.c
index 75f41c8..67eba32 100644
--- a/src/libply-splash-core/ply-device-manager.c
+++ b/src/libply-splash-core/ply-device-manager.c
@@ -115,6 +115,39 @@ device_is_for_local_console (ply_device_manager_t *manager,
 }
 
 static bool
+drm_device_in_use (ply_device_manager_t *manager,
+                   const char           *device_path)
+{
+        ply_list_node_t *node;
+
+        node = ply_list_get_first_node (manager->seats);
+        while (node != NULL) {
+                ply_seat_t *seat;
+                ply_renderer_t *renderer;
+                ply_list_node_t *next_node;
+                const char *renderer_device_path;
+
+                seat = ply_list_node_get_data (node);
+                next_node = ply_list_get_next_node (manager->seats, node);
+                renderer = ply_seat_get_renderer (seat);
+
+                if (renderer != NULL) {
+                        renderer_device_path = ply_renderer_get_device_name (renderer);
+
+                        if (renderer_device_path != NULL) {
+                                if (strcmp (device_path, renderer_device_path) == 0) {
+                                        return true;
+                                }
+                        }
+                }
+
+                node = next_node;
+        }
+
+        return false;
+}
+
+static bool
 fb_device_has_drm_device (ply_device_manager_t *manager,
                           struct udev_device   *fb_device)
 {
@@ -148,7 +181,7 @@ fb_device_has_drm_device (ply_device_manager_t *manager,
                 card_path = udev_list_entry_get_name (card_entry);
                 card_device = udev_device_new_from_syspath (manager->udev_context, card_path);
                 card_node = udev_device_get_devnode (card_device);
-                if (card_node != NULL)
+                if (card_node != NULL && drm_device_in_use (manager, card_node))
                         has_drm_device = true;
                 else
                         ply_trace ("no card node!");
-- 
cgit v0.10.2

